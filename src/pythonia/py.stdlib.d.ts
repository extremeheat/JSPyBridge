declare type asyncio_default = typeof asyncio.base_events & typeof asyncio.coroutines & typeof asyncio.events & typeof asyncio.exceptions & typeof asyncio.futures & typeof asyncio.locks & typeof asyncio.protocols & typeof asyncio.runners & typeof asyncio.queues & typeof asyncio.streams & typeof asyncio.subprocess & typeof asyncio.tasks & typeof asyncio.threads & typeof asyncio.transports & typeof asyncio.windows_events & typeof asyncio.unix_events
declare type ctypes_default = typeof ctypes._endian.BigEndianStructure & typeof ctypes._endian.LittleEndianStructure
declare type dbm_default = typeof dbm.ndbm
declare type ensurepip_default = typeof importlib.resources
declare type json_default = typeof json.decoder & typeof json.encoder
declare type logging_default = typeof string.Template
declare type sqlite3_default = typeof sqlite3.dbapi2
declare type tkinter_default = typeof tkinter.constants
declare module abc {
	var _

	/**
	 * A decorator indicating abstract methods.
	 * 
	 *     Requires that the metaclass is ABCMeta or derived from it.  A
	 *     class that has a metaclass derived from ABCMeta cannot be
	 *     instantiated unless all of its abstract methods are overridden.
	 *     The abstract methods can be called using any of the normal
	 *     'super' call mechanisms.  abstractmethod() may be used to declare
	 *     abstract methods for properties and descriptors.
	 * 
	 *     Usage:
	 * 
	 *         class C(metaclass=ABCMeta):
	 *             @abstractmethod
	 *             def my_abstract_method(self, ...):
	 *                 ...
	 *     
	 */
	function abstractmethod(funcobj): Promise<any>
	function abstractmethod$({ funcobj }): Promise<any>

	/**
	 * Recalculate the set of abstract methods of an abstract class.
	 * 
	 *     If a class has had one of its abstract methods implemented after the
	 *     class was created, the method will not be considered implemented until
	 *     this function is called. Alternatively, if a new abstract method has been
	 *     added to the class, it will only be considered an abstract method of the
	 *     class after this function is called.
	 * 
	 *     This function should be called before any use is made of the class,
	 *     usually in class decorators that add methods to the subject class.
	 * 
	 *     Returns cls, to allow usage as a class decorator.
	 * 
	 *     If cls is not an instance of ABCMeta, does nothing.
	 *     
	 */
	function update_abstractmethods(cls): Promise<any>
	function update_abstractmethods$({ cls }): Promise<any>

	/**
	 * A decorator indicating abstract classmethods.
	 * 
	 *     Deprecated, use 'classmethod' with 'abstractmethod' instead.
	 *     
	 */
	function abstractclassmethod(callable): Promise<Iabstractclassmethod>
	function abstractclassmethod$({ callable }): Promise<Iabstractclassmethod>
	interface Iabstractclassmethod {
	}

	/**
	 * A decorator indicating abstract staticmethods.
	 * 
	 *     Deprecated, use 'staticmethod' with 'abstractmethod' instead.
	 *     
	 */
	function abstractstaticmethod(callable): Promise<Iabstractstaticmethod>
	function abstractstaticmethod$({ callable }): Promise<Iabstractstaticmethod>
	interface Iabstractstaticmethod {
	}

	/**
	 * A decorator indicating abstract properties.
	 * 
	 *     Deprecated, use 'property' with 'abstractmethod' instead.
	 *     
	 */
	interface Iabstractproperty {
	}

	/**
	 * Metaclass for defining Abstract Base Classes (ABCs).
	 * 
	 *         Use this metaclass to create an ABC.  An ABC can be subclassed
	 *         directly, and then acts as a mix-in class.  You can also register
	 *         unrelated concrete classes (even built-in classes) and unrelated
	 *         ABCs as 'virtual subclasses' -- these and their descendants will
	 *         be considered subclasses of the registering ABC by the built-in
	 *         issubclass() function, but the registering ABC won't show up in
	 *         their MRO (Method Resolution Order) nor will method
	 *         implementations defined by the registering ABC be callable (not
	 *         even via super()).
	 *         
	 */
	interface IABCMeta {

		/**
		 * Register a virtual subclass of an ABC.
		 * 
		 *             Returns the subclass, to allow usage as a class decorator.
		 *             
		 */
		register(subclass): Promise<any>
		register$({ subclass }): Promise<any>
	}

	/**
	 * Helper class that provides a standard way to create an ABC using
	 *     inheritance.
	 *     
	 */
	interface IABC {
	}
}
declare module aifc {
	var _
	function open(f, mode?): Promise<any>
	function open$({ f, mode }: { f, mode?}): Promise<any>
	interface IError {
	}
	function Aifc_read(f): Promise<IAifc_read>
	function Aifc_read$({ f }): Promise<IAifc_read>
	interface IAifc_read {
		initfp(file): Promise<any>
		initfp$({ file }): Promise<any>
		getfp(): Promise<any>
		getfp$($: {}): Promise<any>
		rewind(): Promise<any>
		rewind$($: {}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
		tell(): Promise<any>
		tell$($: {}): Promise<any>
		getnchannels(): Promise<any>
		getnchannels$($: {}): Promise<any>
		getnframes(): Promise<any>
		getnframes$($: {}): Promise<any>
		getsampwidth(): Promise<any>
		getsampwidth$($: {}): Promise<any>
		getframerate(): Promise<any>
		getframerate$($: {}): Promise<any>
		getcomptype(): Promise<any>
		getcomptype$($: {}): Promise<any>
		getcompname(): Promise<any>
		getcompname$($: {}): Promise<any>
		getparams(): Promise<any>
		getparams$($: {}): Promise<any>
		getmarkers(): Promise<any>
		getmarkers$($: {}): Promise<any>
		getmark(id): Promise<any>
		getmark$({ id }): Promise<any>
		setpos(pos): Promise<any>
		setpos$({ pos }): Promise<any>
		readframes(nframes): Promise<any>
		readframes$({ nframes }): Promise<any>
	}
	function Aifc_write(f): Promise<IAifc_write>
	function Aifc_write$({ f }): Promise<IAifc_write>
	interface IAifc_write {
		initfp(file): Promise<any>
		initfp$({ file }): Promise<any>
		aiff(): Promise<any>
		aiff$($: {}): Promise<any>
		aifc(): Promise<any>
		aifc$($: {}): Promise<any>
		setnchannels(nchannels): Promise<any>
		setnchannels$({ nchannels }): Promise<any>
		getnchannels(): Promise<any>
		getnchannels$($: {}): Promise<any>
		setsampwidth(sampwidth): Promise<any>
		setsampwidth$({ sampwidth }): Promise<any>
		getsampwidth(): Promise<any>
		getsampwidth$($: {}): Promise<any>
		setframerate(framerate): Promise<any>
		setframerate$({ framerate }): Promise<any>
		getframerate(): Promise<any>
		getframerate$($: {}): Promise<any>
		setnframes(nframes): Promise<any>
		setnframes$({ nframes }): Promise<any>
		getnframes(): Promise<any>
		getnframes$($: {}): Promise<any>
		setcomptype(comptype, compname): Promise<any>
		setcomptype$({ comptype, compname }): Promise<any>
		getcomptype(): Promise<any>
		getcomptype$($: {}): Promise<any>
		getcompname(): Promise<any>
		getcompname$($: {}): Promise<any>
		setparams(params): Promise<any>
		setparams$({ params }): Promise<any>
		getparams(): Promise<any>
		getparams$($: {}): Promise<any>
		setmark(id, pos, name): Promise<any>
		setmark$({ id, pos, name }): Promise<any>
		getmark(id): Promise<any>
		getmark$({ id }): Promise<any>
		getmarkers(): Promise<any>
		getmarkers$($: {}): Promise<any>
		tell(): Promise<any>
		tell$($: {}): Promise<any>
		writeframesraw(data): Promise<any>
		writeframesraw$({ data }): Promise<any>
		writeframes(data): Promise<any>
		writeframes$({ data }): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}
	let fn: Promise<any>
	let gn: Promise<any>
	let data: Promise<any>
}
declare module antigravity {
	var _

	/**
	 * Compute geohash() using the Munroe algorithm.
	 * 
	 *     >>> geohash(37.421542, -122.085589, b'2005-05-26-10458.68')
	 *     37.857713 -122.544543
	 * 
	 *     
	 */
	function geohash(latitude, longitude, datedow): Promise<any>
	function geohash$({ latitude, longitude, datedow }): Promise<any>
}
declare module argparse {
	var _

	/**
	 * Abstract base class that provides __repr__.
	 * 
	 *     The __repr__ method returns a string in the format::
	 *         ClassName(attr=name, attr=name, ...)
	 *     The attributes are determined either by a class-level attribute,
	 *     '_kwarg_names', or by inspecting the instance __dict__.
	 *     
	 */
	interface I_AttributeHolder {
	}

	/**
	 * Formatter for generating usage messages and argument help strings.
	 * 
	 *     Only the name of this class is considered a public API. All the methods
	 *     provided by the class are considered an implementation detail.
	 *     
	 */
	function HelpFormatter(prog, indent_increment?, max_help_position?, width?): Promise<IHelpFormatter>
	function HelpFormatter$({ prog, indent_increment, max_help_position, width }: { prog, indent_increment?, max_help_position?, width?}): Promise<IHelpFormatter>
	interface IHelpFormatter {
		start_section(heading): Promise<any>
		start_section$({ heading }): Promise<any>
		end_section(): Promise<any>
		end_section$($: {}): Promise<any>
		add_text(text): Promise<any>
		add_text$({ text }): Promise<any>
		add_usage(usage, actions, groups, prefix?): Promise<any>
		add_usage$({ usage, actions, groups, prefix }: { usage, actions, groups, prefix?}): Promise<any>
		add_argument(action): Promise<any>
		add_argument$({ action }): Promise<any>
		add_arguments(actions): Promise<any>
		add_arguments$({ actions }): Promise<any>
		format_help(): Promise<any>
		format_help$($: {}): Promise<any>
	}

	/**
	 * Help message formatter which retains any formatting in descriptions.
	 * 
	 *     Only the name of this class is considered a public API. All the methods
	 *     provided by the class are considered an implementation detail.
	 *     
	 */
	interface IRawDescriptionHelpFormatter extends IHelpFormatter {
	}

	/**
	 * Help message formatter which retains formatting of all help text.
	 * 
	 *     Only the name of this class is considered a public API. All the methods
	 *     provided by the class are considered an implementation detail.
	 *     
	 */
	interface IRawTextHelpFormatter extends IRawDescriptionHelpFormatter {
	}

	/**
	 * Help message formatter which adds default values to argument help.
	 * 
	 *     Only the name of this class is considered a public API. All the methods
	 *     provided by the class are considered an implementation detail.
	 *     
	 */
	interface IArgumentDefaultsHelpFormatter extends IHelpFormatter {
	}

	/**
	 * Help message formatter which uses the argument 'type' as the default
	 *     metavar value (instead of the argument 'dest')
	 * 
	 *     Only the name of this class is considered a public API. All the methods
	 *     provided by the class are considered an implementation detail.
	 *     
	 */
	interface IMetavarTypeHelpFormatter extends IHelpFormatter {
	}

	/**
	 * An error from creating or using an argument (optional or positional).
	 * 
	 *     The string value of this exception is the message, augmented with
	 *     information about the argument that caused it.
	 *     
	 */
	function ArgumentError(argument, message): Promise<IArgumentError>
	function ArgumentError$({ argument, message }): Promise<IArgumentError>
	interface IArgumentError {
	}

	/**
	 * An error from trying to convert a command line string to a type.
	 */
	interface IArgumentTypeError {
	}

	/**
	 * Information about how to convert command line strings to Python objects.
	 * 
	 *     Action objects are used by an ArgumentParser to represent the information
	 *     needed to parse a single argument from one or more strings from the
	 *     command line. The keyword arguments to the Action constructor are also
	 *     all attributes of Action instances.
	 * 
	 *     Keyword Arguments:
	 * 
	 *         - option_strings -- A list of command-line option strings which
	 *             should be associated with this action.
	 * 
	 *         - dest -- The name of the attribute to hold the created object(s)
	 * 
	 *         - nargs -- The number of command-line arguments that should be
	 *             consumed. By default, one argument will be consumed and a single
	 *             value will be produced.  Other values include:
	 *                 - N (an integer) consumes N arguments (and produces a list)
	 *                 - '?' consumes zero or one arguments
	 *                 - '*' consumes zero or more arguments (and produces a list)
	 *                 - '+' consumes one or more arguments (and produces a list)
	 *             Note that the difference between the default and nargs=1 is that
	 *             with the default, a single value will be produced, while with
	 *             nargs=1, a list containing a single value will be produced.
	 * 
	 *         - const -- The value to be produced if the option is specified and the
	 *             option uses an action that takes no values.
	 * 
	 *         - default -- The value to be produced if the option is not specified.
	 * 
	 *         - type -- A callable that accepts a single string argument, and
	 *             returns the converted value.  The standard Python types str, int,
	 *             float, and complex are useful examples of such callables.  If None,
	 *             str is used.
	 * 
	 *         - choices -- A container of values that should be allowed. If not None,
	 *             after a command-line argument has been converted to the appropriate
	 *             type, an exception will be raised if it is not a member of this
	 *             collection.
	 * 
	 *         - required -- True if the action must always be specified at the
	 *             command line. This is only meaningful for optional command-line
	 *             arguments.
	 * 
	 *         - help -- The help string describing the argument.
	 * 
	 *         - metavar -- The name to be used for the option's argument with the
	 *             help string. If None, the 'dest' value will be used as the name.
	 *     
	 */
	function Action(option_strings, dest, nargs?, constant?, def?, type?, choices?, required?: boolean, help?, metavar?): Promise<IAction>
	function Action$({ option_strings, dest, nargs, constant, def, type, choices, required, help, metavar }: { option_strings, dest, nargs?, constant?, def?, type?, choices?, required?, help?, metavar?}): Promise<IAction>
	interface IAction extends I_AttributeHolder {
		format_usage(): Promise<any>
		format_usage$($: {}): Promise<any>
	}
	function BooleanOptionalAction(option_strings, dest, def?, type?, choices?, required?: boolean, help?, metavar?): Promise<IBooleanOptionalAction>
	function BooleanOptionalAction$({ option_strings, dest, def, type, choices, required, help, metavar }: { option_strings, dest, def?, type?, choices?, required?, help?, metavar?}): Promise<IBooleanOptionalAction>
	interface IBooleanOptionalAction extends IAction {
		format_usage(): Promise<any>
		format_usage$($: {}): Promise<any>
	}
	interface I_StoreAction extends IAction {
	}
	interface I_StoreConstAction extends IAction {
	}
	interface I_StoreTrueAction extends I_StoreConstAction {
	}
	interface I_StoreFalseAction extends I_StoreConstAction {
	}
	interface I_AppendAction extends IAction {
	}
	interface I_AppendConstAction extends IAction {
	}
	interface I_CountAction extends IAction {
	}
	interface I_HelpAction extends IAction {
	}
	interface I_VersionAction extends IAction {
	}
	interface I_SubParsersAction extends IAction {
		add_parser(name): Promise<any>
		add_parser$({ name }): Promise<any>
	}
	interface I_ExtendAction extends I_AppendAction {
	}

	/**
	 * Factory for creating file object types
	 * 
	 *     Instances of FileType are typically passed as type= arguments to the
	 *     ArgumentParser add_argument() method.
	 * 
	 *     Keyword Arguments:
	 *         - mode -- A string indicating how the file is to be opened. Accepts the
	 *             same values as the builtin open() function.
	 *         - bufsize -- The file's desired buffer size. Accepts the same values as
	 *             the builtin open() function.
	 *         - encoding -- The file's encoding. Accepts the same values as the
	 *             builtin open() function.
	 *         - errors -- A string indicating how encoding and decoding errors are to
	 *             be handled. Accepts the same value as the builtin open() function.
	 *     
	 */
	function FileType(mode?, bufsize?, encoding?, errors?): Promise<IFileType>
	function FileType$({ mode, bufsize, encoding, errors }: { mode?, bufsize?, encoding?, errors?}): Promise<IFileType>
	interface IFileType {
	}

	/**
	 * Simple object for storing attributes.
	 * 
	 *     Implements equality by attribute names and values, and provides a simple
	 *     string representation.
	 *     
	 */
	function Namespace(): Promise<INamespace>
	function Namespace$({ }): Promise<INamespace>
	interface INamespace extends I_AttributeHolder {
	}
	interface I_ActionsContainer {
		register(registry_name, value, object): Promise<any>
		register$({ registry_name, value, object }): Promise<any>
		set_defaults(): Promise<any>
		set_defaults$($: {}): Promise<any>
		get_default(dest): Promise<any>
		get_default$({ dest }): Promise<any>

		/**
		 * 
		 *         add_argument(dest, ..., name=value, ...)
		 *         add_argument(option_string, option_string, ..., name=value, ...)
		 *         
		 */
		add_argument(): Promise<any>
		add_argument$($: {}): Promise<any>
		add_argument_group(): Promise<any>
		add_argument_group$($: {}): Promise<any>
		add_mutually_exclusive_group(): Promise<any>
		add_mutually_exclusive_group$($: {}): Promise<any>
	}
	interface I_ArgumentGroup extends I_ActionsContainer {
	}
	interface I_MutuallyExclusiveGroup extends I_ArgumentGroup {
	}

	/**
	 * Object for parsing command line strings into Python objects.
	 * 
	 *     Keyword Arguments:
	 *         - prog -- The name of the program (default: sys.argv[0])
	 *         - usage -- A usage message (default: auto-generated from arguments)
	 *         - description -- A description of what the program does
	 *         - epilog -- Text following the argument descriptions
	 *         - parents -- Parsers whose arguments should be copied into this one
	 *         - formatter_class -- HelpFormatter class for printing help messages
	 *         - prefix_chars -- Characters that prefix optional arguments
	 *         - fromfile_prefix_chars -- Characters that prefix files containing
	 *             additional arguments
	 *         - argument_default -- The default value for all arguments
	 *         - conflict_handler -- String indicating how to handle conflicts
	 *         - add_help -- Add a -h/-help option
	 *         - allow_abbrev -- Allow long options to be abbreviated unambiguously
	 *         - exit_on_error -- Determines whether or not ArgumentParser exits with
	 *             error info when an error occurs
	 *     
	 */
	function ArgumentParser(prog?, usage?, description?, epilog?, parents?, formatter_class?, prefix_chars?, fromfile_prefix_chars?, argument_default?, conflict_handler?, add_help?: boolean, allow_abbrev?: boolean, exit_on_error?: boolean): Promise<IArgumentParser>
	function ArgumentParser$({ prog, usage, description, epilog, parents, formatter_class, prefix_chars, fromfile_prefix_chars, argument_default, conflict_handler, add_help, allow_abbrev, exit_on_error }: { prog?, usage?, description?, epilog?, parents?, formatter_class?, prefix_chars?, fromfile_prefix_chars?, argument_default?, conflict_handler?, add_help?, allow_abbrev?, exit_on_error?}): Promise<IArgumentParser>
	interface IArgumentParser extends I_AttributeHolder, I_ActionsContainer {
		add_subparsers(): Promise<any>
		add_subparsers$($: {}): Promise<any>
		parse_args(args?, namespace?): Promise<any>
		parse_args$({ args, namespace }: { args?, namespace?}): Promise<any>
		parse_known_args(args?, namespace?): Promise<any>
		parse_known_args$({ args, namespace }: { args?, namespace?}): Promise<any>
		convert_arg_line_to_args(arg_line): Promise<any>
		convert_arg_line_to_args$({ arg_line }): Promise<any>
		parse_intermixed_args(args?, namespace?): Promise<any>
		parse_intermixed_args$({ args, namespace }: { args?, namespace?}): Promise<any>
		parse_known_intermixed_args(args?, namespace?): Promise<any>
		parse_known_intermixed_args$({ args, namespace }: { args?, namespace?}): Promise<any>
		format_usage(): Promise<any>
		format_usage$($: {}): Promise<any>
		format_help(): Promise<any>
		format_help$($: {}): Promise<any>
		print_usage(file?): Promise<any>
		print_usage$({ file }: { file?}): Promise<any>
		print_help(file?): Promise<any>
		print_help$({ file }: { file?}): Promise<any>
		exit(status?, message?): Promise<any>
		exit$({ status, message }: { status?, message?}): Promise<any>

		/**
		 * error(message: string)
		 * 
		 *         Prints a usage message incorporating the message to stderr and
		 *         exits.
		 * 
		 *         If you override this in a subclass, it should not return -- it
		 *         should either exit or raise an exception.
		 *         
		 */
		error(message): Promise<any>
		error$({ message }): Promise<any>
	}
	let SUPPRESS: Promise<any>
	let OPTIONAL: Promise<any>
	let ZERO_OR_MORE: Promise<any>
	let ONE_OR_MORE: Promise<any>
	let PARSER: Promise<any>
	let REMAINDER: Promise<any>
}
declare module ast {
	var _

	/**
	 * 
	 *     Parse the source into an AST node.
	 *     Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
	 *     Pass type_comments=True to get back type comments where the syntax allows.
	 *     
	 */
	function parse(source, filename?, mode?): Promise<any>
	function parse$({ source, filename, mode }: { source, filename?, mode?}): Promise<any>

	/**
	 * 
	 *     Safely evaluate an expression node or a string containing a Python
	 *     expression.  The string or node provided may only consist of the following
	 *     Python literal structures: strings, bytes, numbers, tuples, lists, dicts,
	 *     sets, booleans, and None.
	 *     
	 */
	function literal_eval(node_or_string): Promise<any>
	function literal_eval$({ node_or_string }): Promise<any>

	/**
	 * 
	 *     Return a formatted dump of the tree in node.  This is mainly useful for
	 *     debugging purposes.  If annotate_fields is true (by default),
	 *     the returned string will show the names and the values for fields.
	 *     If annotate_fields is false, the result string will be more compact by
	 *     omitting unambiguous field names.  Attributes such as line
	 *     numbers and column offsets are not dumped by default.  If this is wanted,
	 *     include_attributes can be set to true.  If indent is a non-negative
	 *     integer or string, then the tree will be pretty-printed with that indent
	 *     level. None (the default) selects the single line representation.
	 *     
	 */
	function dump(node, annotate_fields?: boolean, include_attributes?: boolean): Promise<any>
	function dump$({ node, annotate_fields, include_attributes }: { node, annotate_fields?, include_attributes?}): Promise<any>

	/**
	 * 
	 *     Copy source location (`lineno`, `col_offset`, `end_lineno`, and `end_col_offset`
	 *     attributes) from *old_node* to *new_node* if possible, and return *new_node*.
	 *     
	 */
	function copy_location(new_node, old_node): Promise<any>
	function copy_location$({ new_node, old_node }): Promise<any>

	/**
	 * 
	 *     When you compile a node tree with compile(), the compiler expects lineno and
	 *     col_offset attributes for every node that supports them.  This is rather
	 *     tedious to fill in for generated nodes, so this helper adds these attributes
	 *     recursively where not already set, by setting them to the values of the
	 *     parent node.  It works recursively starting at *node*.
	 *     
	 */
	function fix_missing_locations(node): Promise<any>
	function fix_missing_locations$({ node }): Promise<any>

	/**
	 * 
	 *     Increment the line number and end line number of each node in the tree
	 *     starting at *node* by *n*. This is useful to "move code" to a different
	 *     location in a file.
	 *     
	 */
	function increment_lineno(node, n?): Promise<any>
	function increment_lineno$({ node, n }: { node, n?}): Promise<any>

	/**
	 * 
	 *     Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``
	 *     that is present on *node*.
	 *     
	 */
	function iter_fields(node): Promise<any>
	function iter_fields$({ node }): Promise<any>

	/**
	 * 
	 *     Yield all direct child nodes of *node*, that is, all fields that are nodes
	 *     and all items of fields that are lists of nodes.
	 *     
	 */
	function iter_child_nodes(node): Promise<any>
	function iter_child_nodes$({ node }): Promise<any>

	/**
	 * 
	 *     Return the docstring for the given node or None if no docstring can
	 *     be found.  If the node provided does not have docstrings a TypeError
	 *     will be raised.
	 * 
	 *     If *clean* is `True`, all tabs are expanded to spaces and any whitespace
	 *     that can be uniformly removed from the second line onwards is removed.
	 *     
	 */
	function get_docstring(node, clean?: boolean): Promise<any>
	function get_docstring$({ node, clean }: { node, clean?}): Promise<any>

	/**
	 * Get source code segment of the *source* that generated *node*.
	 * 
	 *     If some location information (`lineno`, `end_lineno`, `col_offset`,
	 *     or `end_col_offset`) is missing, return None.
	 * 
	 *     If *padded* is `True`, the first line of a multi-line statement will
	 *     be padded with spaces to match its original position.
	 *     
	 */
	function get_source_segment(source, node): Promise<any>
	function get_source_segment$({ source, node }): Promise<any>

	/**
	 * 
	 *     Recursively yield all descendant nodes in the tree starting at *node*
	 *     (including *node* itself), in no specified order.  This is useful if you
	 *     only want to modify nodes in place and don't care about the context.
	 *     
	 */
	function walk(node): Promise<any>
	function walk$({ node }): Promise<any>
	function unparse(ast_obj): Promise<any>
	function unparse$({ ast_obj }): Promise<any>
	function main(): Promise<any>
	function main$($: {}): Promise<any>

	/**
	 * 
	 *     A node visitor base class that walks the abstract syntax tree and calls a
	 *     visitor function for every node found.  This function may return a value
	 *     which is forwarded by the `visit` method.
	 * 
	 *     This class is meant to be subclassed, with the subclass adding visitor
	 *     methods.
	 * 
	 *     Per default the visitor functions for the nodes are ``'visit_'`` +
	 *     class name of the node.  So a `TryFinally` node visit function would
	 *     be `visit_TryFinally`.  This behavior can be changed by overriding
	 *     the `visit` method.  If no visitor function exists for a node
	 *     (return value `None`) the `generic_visit` visitor is used instead.
	 * 
	 *     Don't use the `NodeVisitor` if you want to apply changes to nodes during
	 *     traversing.  For this a special visitor exists (`NodeTransformer`) that
	 *     allows modifications.
	 *     
	 */
	interface INodeVisitor {

		/**
		 * Visit a node.
		 */
		visit(node): Promise<any>
		visit$({ node }): Promise<any>

		/**
		 * Called if no explicit visitor function exists for a node.
		 */
		generic_visit(node): Promise<any>
		generic_visit$({ node }): Promise<any>
		visit_Constant(node): Promise<any>
		visit_Constant$({ node }): Promise<any>
	}

	/**
	 * 
	 *     A :class:`NodeVisitor` subclass that walks the abstract syntax tree and
	 *     allows modification of nodes.
	 * 
	 *     The `NodeTransformer` will walk the AST and use the return value of the
	 *     visitor methods to replace or remove the old node.  If the return value of
	 *     the visitor method is ``None``, the node will be removed from its location,
	 *     otherwise it is replaced with the return value.  The return value may be the
	 *     original node in which case no replacement takes place.
	 * 
	 *     Here is an example transformer that rewrites all occurrences of name lookups
	 *     (``foo``) to ``data['foo']``::
	 * 
	 *        class RewriteName(NodeTransformer):
	 * 
	 *            def visit_Name(self, node):
	 *                return Subscript(
	 *                    value=Name(id='data', ctx=Load()),
	 *                    slice=Constant(value=node.id),
	 *                    ctx=node.ctx
	 *                )
	 * 
	 *     Keep in mind that if the node you're operating on has child nodes you must
	 *     either transform the child nodes yourself or call the :meth:`generic_visit`
	 *     method for the node first.
	 * 
	 *     For nodes that were part of a collection of statements (that applies to all
	 *     statement nodes), the visitor may also return a list of nodes rather than
	 *     just a single node.
	 * 
	 *     Usually you use the transformer like this::
	 * 
	 *        node = YourTransformer().visit(node)
	 *     
	 */
	interface INodeTransformer extends INodeVisitor {
		generic_visit(node): Promise<any>
		generic_visit$({ node }): Promise<any>
	}
	interface I_ABC {
	}
	interface INum {
	}
	interface IStr {
	}
	interface IBytes {
	}
	interface INameConstant {
	}
	interface IEllipsis {
	}

	/**
	 * Deprecated AST node class.
	 */
	interface Islice {
	}

	/**
	 * Deprecated AST node class. Use the index value directly instead.
	 */
	interface IIndex extends Islice {
	}

	/**
	 * Deprecated AST node class. Use ast.Tuple instead.
	 */
	interface IExtSlice extends Islice {
	}

	/**
	 * Deprecated AST node class.  Unused in Python 3.
	 */
	interface ISuite {
	}

	/**
	 * Deprecated AST node class.  Unused in Python 3.
	 */
	interface IAugLoad {
	}

	/**
	 * Deprecated AST node class.  Unused in Python 3.
	 */
	interface IAugStore {
	}

	/**
	 * Deprecated AST node class.  Unused in Python 3.
	 */
	interface IParam {
	}

	/**
	 * Precedence table that originated from python grammar.
	 */
	interface I_Precedence {
		next(): Promise<any>
		next$($: {}): Promise<any>
		NAMED_EXPR
		TUPLE
		YIELD
		TEST
		OR
		AND
		NOT
		CMP
		EXPR
		BOR
		BXOR
		BAND
		SHIFT
		ARITH
		TERM
		FACTOR
		POWER
		AWAIT
		ATOM
	}

	/**
	 * Methods in this class recursively traverse an AST and
	 *     output source code for the abstract syntax; original formatting
	 *     is disregarded.
	 */
	interface I_Unparser extends INodeVisitor {

		/**
		 * Call f on each item in seq, calling inter() in between.
		 */
		interleave(inter, f, seq): Promise<any>
		interleave$({ inter, f, seq }): Promise<any>

		/**
		 * Traverse and separate the given *items* with a comma and append it to
		 *         the buffer. If *items* is a single item sequence, a trailing comma
		 *         will be added.
		 */
		items_view(traverser, items): Promise<any>
		items_view$({ traverser, items }): Promise<any>

		/**
		 * Adds a newline if it isn't the start of generated source
		 */
		maybe_newline(): Promise<any>
		maybe_newline$($: {}): Promise<any>

		/**
		 * Indent a piece of text and append it, according to the current
		 *         indentation level
		 */
		fill(text?): Promise<any>
		fill$({ text }: { text?}): Promise<any>

		/**
		 * Add new source parts
		 */
		write(): Promise<any>
		write$($: {}): Promise<any>
		buffered(buffer?): Promise<any>
		buffered$({ buffer }: { buffer?}): Promise<any>

		/**
		 * A context manager for preparing the source for blocks. It adds
		 *         the character':', increases the indentation on enter and decreases
		 *         the indentation on exit. If *extra* is given, it will be directly
		 *         appended after the colon character.
		 *         
		 */
		block(): Promise<any>
		block$($: {}): Promise<any>

		/**
		 * A context manager for preparing the source for expressions. It adds
		 *         *start* to the buffer and enters, after exit it adds *end*.
		 */
		delimit(start, end): Promise<any>
		delimit$({ start, end }): Promise<any>
		delimit_if(start, end, condition): Promise<any>
		delimit_if$({ start, end, condition }): Promise<any>

		/**
		 * Shortcut to adding precedence related parens
		 */
		require_parens(precedence, node): Promise<any>
		require_parens$({ precedence, node }): Promise<any>
		get_precedence(node): Promise<any>
		get_precedence$({ node }): Promise<any>
		set_precedence(precedence): Promise<any>
		set_precedence$({ precedence }): Promise<any>

		/**
		 * If a docstring node is found in the body of the *node* parameter,
		 *         return that docstring node, None otherwise.
		 * 
		 *         Logic mirrored from ``_PyAST_GetDocString``.
		 */
		get_raw_docstring(node): Promise<any>
		get_raw_docstring$({ node }): Promise<any>
		get_type_comment(node): Promise<any>
		get_type_comment$({ node }): Promise<any>
		traverse(node): Promise<any>
		traverse$({ node }): Promise<any>

		/**
		 * Outputs a source code string that, if converted back to an ast
		 *         (using ast.parse) will generate an AST equivalent to *node*
		 */
		visit(node): Promise<any>
		visit$({ node }): Promise<any>
		visit_Module(node): Promise<any>
		visit_Module$({ node }): Promise<any>
		visit_FunctionType(node): Promise<any>
		visit_FunctionType$({ node }): Promise<any>
		visit_Expr(node): Promise<any>
		visit_Expr$({ node }): Promise<any>
		visit_NamedExpr(node): Promise<any>
		visit_NamedExpr$({ node }): Promise<any>
		visit_Import(node): Promise<any>
		visit_Import$({ node }): Promise<any>
		visit_ImportFrom(node): Promise<any>
		visit_ImportFrom$({ node }): Promise<any>
		visit_Assign(node): Promise<any>
		visit_Assign$({ node }): Promise<any>
		visit_AugAssign(node): Promise<any>
		visit_AugAssign$({ node }): Promise<any>
		visit_AnnAssign(node): Promise<any>
		visit_AnnAssign$({ node }): Promise<any>
		visit_Return(node): Promise<any>
		visit_Return$({ node }): Promise<any>
		visit_Pass(node): Promise<any>
		visit_Pass$({ node }): Promise<any>
		visit_Break(node): Promise<any>
		visit_Break$({ node }): Promise<any>
		visit_Continue(node): Promise<any>
		visit_Continue$({ node }): Promise<any>
		visit_Delete(node): Promise<any>
		visit_Delete$({ node }): Promise<any>
		visit_Assert(node): Promise<any>
		visit_Assert$({ node }): Promise<any>
		visit_Global(node): Promise<any>
		visit_Global$({ node }): Promise<any>
		visit_Nonlocal(node): Promise<any>
		visit_Nonlocal$({ node }): Promise<any>
		visit_Await(node): Promise<any>
		visit_Await$({ node }): Promise<any>
		visit_Yield(node): Promise<any>
		visit_Yield$({ node }): Promise<any>
		visit_YieldFrom(node): Promise<any>
		visit_YieldFrom$({ node }): Promise<any>
		visit_Raise(node): Promise<any>
		visit_Raise$({ node }): Promise<any>
		visit_Try(node): Promise<any>
		visit_Try$({ node }): Promise<any>
		visit_ExceptHandler(node): Promise<any>
		visit_ExceptHandler$({ node }): Promise<any>
		visit_ClassDef(node): Promise<any>
		visit_ClassDef$({ node }): Promise<any>
		visit_FunctionDef(node): Promise<any>
		visit_FunctionDef$({ node }): Promise<any>
		visit_AsyncFunctionDef(node): Promise<any>
		visit_AsyncFunctionDef$({ node }): Promise<any>
		visit_For(node): Promise<any>
		visit_For$({ node }): Promise<any>
		visit_AsyncFor(node): Promise<any>
		visit_AsyncFor$({ node }): Promise<any>
		visit_If(node): Promise<any>
		visit_If$({ node }): Promise<any>
		visit_While(node): Promise<any>
		visit_While$({ node }): Promise<any>
		visit_With(node): Promise<any>
		visit_With$({ node }): Promise<any>
		visit_AsyncWith(node): Promise<any>
		visit_AsyncWith$({ node }): Promise<any>
		visit_JoinedStr(node): Promise<any>
		visit_JoinedStr$({ node }): Promise<any>
		visit_FormattedValue(node): Promise<any>
		visit_FormattedValue$({ node }): Promise<any>
		visit_Name(node): Promise<any>
		visit_Name$({ node }): Promise<any>
		visit_Constant(node): Promise<any>
		visit_Constant$({ node }): Promise<any>
		visit_List(node): Promise<any>
		visit_List$({ node }): Promise<any>
		visit_ListComp(node): Promise<any>
		visit_ListComp$({ node }): Promise<any>
		visit_GeneratorExp(node): Promise<any>
		visit_GeneratorExp$({ node }): Promise<any>
		visit_SetComp(node): Promise<any>
		visit_SetComp$({ node }): Promise<any>
		visit_DictComp(node): Promise<any>
		visit_DictComp$({ node }): Promise<any>
		visit_comprehension(node): Promise<any>
		visit_comprehension$({ node }): Promise<any>
		visit_IfExp(node): Promise<any>
		visit_IfExp$({ node }): Promise<any>
		visit_Set(node): Promise<any>
		visit_Set$({ node }): Promise<any>
		visit_Dict(node): Promise<any>
		visit_Dict$({ node }): Promise<any>
		visit_Tuple(node): Promise<any>
		visit_Tuple$({ node }): Promise<any>
		visit_UnaryOp(node): Promise<any>
		visit_UnaryOp$({ node }): Promise<any>
		visit_BinOp(node): Promise<any>
		visit_BinOp$({ node }): Promise<any>
		visit_Compare(node): Promise<any>
		visit_Compare$({ node }): Promise<any>
		visit_BoolOp(node): Promise<any>
		visit_BoolOp$({ node }): Promise<any>
		visit_Attribute(node): Promise<any>
		visit_Attribute$({ node }): Promise<any>
		visit_Call(node): Promise<any>
		visit_Call$({ node }): Promise<any>
		visit_Subscript(node): Promise<any>
		visit_Subscript$({ node }): Promise<any>
		visit_Starred(node): Promise<any>
		visit_Starred$({ node }): Promise<any>
		visit_Ellipsis(node): Promise<any>
		visit_Ellipsis$({ node }): Promise<any>
		visit_Slice(node): Promise<any>
		visit_Slice$({ node }): Promise<any>
		visit_Match(node): Promise<any>
		visit_Match$({ node }): Promise<any>
		visit_arg(node): Promise<any>
		visit_arg$({ node }): Promise<any>
		visit_arguments(node): Promise<any>
		visit_arguments$({ node }): Promise<any>
		visit_keyword(node): Promise<any>
		visit_keyword$({ node }): Promise<any>
		visit_Lambda(node): Promise<any>
		visit_Lambda$({ node }): Promise<any>
		visit_alias(node): Promise<any>
		visit_alias$({ node }): Promise<any>
		visit_withitem(node): Promise<any>
		visit_withitem$({ node }): Promise<any>
		visit_match_case(node): Promise<any>
		visit_match_case$({ node }): Promise<any>
		visit_MatchValue(node): Promise<any>
		visit_MatchValue$({ node }): Promise<any>
		visit_MatchSingleton(node): Promise<any>
		visit_MatchSingleton$({ node }): Promise<any>
		visit_MatchSequence(node): Promise<any>
		visit_MatchSequence$({ node }): Promise<any>
		visit_MatchStar(node): Promise<any>
		visit_MatchStar$({ node }): Promise<any>
		visit_MatchMapping(node): Promise<any>
		visit_MatchMapping$({ node }): Promise<any>
		visit_MatchClass(node): Promise<any>
		visit_MatchClass$({ node }): Promise<any>
		visit_MatchAs(node): Promise<any>
		visit_MatchAs$({ node }): Promise<any>
		visit_MatchOr(node): Promise<any>
		visit_MatchOr$({ node }): Promise<any>
		unop
		unop_precedence
		binop
		binop_precedence
		binop_rassoc
		cmpops
		boolops
		boolop_precedence
	}
}
declare module asynchat {
	var _
	function find_prefix_at_end(haystack, needle): Promise<any>
	function find_prefix_at_end$({ haystack, needle }): Promise<any>

	/**
	 * This is an abstract class.  You must derive from this class, and add
	 *     the two methods collect_incoming_data() and found_terminator()
	 */
	function async_chat(sock?, map?): Promise<Iasync_chat>
	function async_chat$({ sock, map }: { sock?, map?}): Promise<Iasync_chat>
	interface Iasync_chat {
		collect_incoming_data(data): Promise<any>
		collect_incoming_data$({ data }): Promise<any>
		found_terminator(): Promise<any>
		found_terminator$($: {}): Promise<any>

		/**
		 * Set the input delimiter.
		 * 
		 *         Can be a fixed string of any length, an integer, or None.
		 *         
		 */
		set_terminator(term): Promise<any>
		set_terminator$({ term }): Promise<any>
		get_terminator(): Promise<any>
		get_terminator$($: {}): Promise<any>
		handle_read(): Promise<any>
		handle_read$($: {}): Promise<any>
		handle_write(): Promise<any>
		handle_write$($: {}): Promise<any>
		handle_close(): Promise<any>
		handle_close$($: {}): Promise<any>
		push(data): Promise<any>
		push$({ data }): Promise<any>
		push_with_producer(producer): Promise<any>
		push_with_producer$({ producer }): Promise<any>

		/**
		 * predicate for inclusion in the readable for select()
		 */
		readable(): Promise<any>
		readable$($: {}): Promise<any>

		/**
		 * predicate for inclusion in the writable for select()
		 */
		writable(): Promise<any>
		writable$($: {}): Promise<any>

		/**
		 * automatically close this channel once the outgoing queue is empty
		 */
		close_when_done(): Promise<any>
		close_when_done$($: {}): Promise<any>
		initiate_send(): Promise<any>
		initiate_send$($: {}): Promise<any>
		discard_buffers(): Promise<any>
		discard_buffers$($: {}): Promise<any>
		ac_in_buffer_size
		ac_out_buffer_size
		use_encoding
		encoding
	}
	function simple_producer(data, buffer_size?): Promise<Isimple_producer>
	function simple_producer$({ data, buffer_size }: { data, buffer_size?}): Promise<Isimple_producer>
	interface Isimple_producer {
		more(): Promise<any>
		more$($: {}): Promise<any>
	}
}
declare module asyncio {
	var _
	module __main__ {
		var _
		function AsyncIOInteractiveConsole(locals, loop): Promise<IAsyncIOInteractiveConsole>
		function AsyncIOInteractiveConsole$({ locals, loop }): Promise<IAsyncIOInteractiveConsole>
		interface IAsyncIOInteractiveConsole {
			runcode(code): Promise<any>
			runcode$({ code }): Promise<any>
		}
		interface IREPLThread {
			run(): Promise<any>
			run$($: {}): Promise<any>
		}
		let loop: Promise<any>
		let repl_locals: Promise<any>
		let console: Promise<any>
		let repl_future: Promise<any>
		let repl_future_interrupted: Promise<any>
		let repl_thread: Promise<any>
	}
	module base_events {
		var _
		interface I_SendfileFallbackProtocol {
			connection_made(transport): Promise<any>
			connection_made$({ transport }): Promise<any>
			connection_lost(exc): Promise<any>
			connection_lost$({ exc }): Promise<any>
			pause_writing(): Promise<any>
			pause_writing$($: {}): Promise<any>
			resume_writing(): Promise<any>
			resume_writing$($: {}): Promise<any>
			data_received(data): Promise<any>
			data_received$({ data }): Promise<any>
			eof_received(): Promise<any>
			eof_received$($: {}): Promise<any>
		}
		function Server(loop, sockets, protocol_factory, ssl_context, backlog, ssl_handshake_timeout): Promise<IServer>
		function Server$({ loop, sockets, protocol_factory, ssl_context, backlog, ssl_handshake_timeout }): Promise<IServer>
		interface IServer {
			get_loop(): Promise<any>
			get_loop$($: {}): Promise<any>
			is_serving(): Promise<any>
			is_serving$($: {}): Promise<any>
			sockets(): Promise<any>
			sockets$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
		}
		function BaseEventLoop(): Promise<IBaseEventLoop>
		function BaseEventLoop$({ }): Promise<IBaseEventLoop>
		interface IBaseEventLoop {

			/**
			 * Create a Future object attached to the loop.
			 */
			create_future(): Promise<any>
			create_future$($: {}): Promise<any>

			/**
			 * Schedule a coroutine object.
			 * 
			 *         Return a task object.
			 *         
			 */
			create_task(coro): Promise<any>
			create_task$({ coro }): Promise<any>

			/**
			 * Set a task factory that will be used by loop.create_task().
			 * 
			 *         If factory is None the default task factory will be set.
			 * 
			 *         If factory is a callable, it should have a signature matching
			 *         '(loop, coro)', where 'loop' will be a reference to the active
			 *         event loop, 'coro' will be a coroutine object.  The callable
			 *         must return a Future.
			 *         
			 */
			set_task_factory(factory): Promise<any>
			set_task_factory$({ factory }): Promise<any>

			/**
			 * Return a task factory, or None if the default one is in use.
			 */
			get_task_factory(): Promise<any>
			get_task_factory$($: {}): Promise<any>

			/**
			 * Run until stop() is called.
			 */
			run_forever(): Promise<any>
			run_forever$($: {}): Promise<any>

			/**
			 * Run until the Future is done.
			 * 
			 *         If the argument is a coroutine, it is wrapped in a Task.
			 * 
			 *         WARNING: It would be disastrous to call run_until_complete()
			 *         with the same coroutine twice -- it would wrap it in two
			 *         different Tasks and that can't be good.
			 * 
			 *         Return the Future's result, or raise its exception.
			 *         
			 */
			run_until_complete(future): Promise<any>
			run_until_complete$({ future }): Promise<any>

			/**
			 * Stop running the event loop.
			 * 
			 *         Every callback already scheduled will still run.  This simply informs
			 *         run_forever to stop looping after a complete iteration.
			 *         
			 */
			stop(): Promise<any>
			stop$($: {}): Promise<any>

			/**
			 * Close the event loop.
			 * 
			 *         This clears the queues and shuts down the executor,
			 *         but does not wait for the executor to finish.
			 * 
			 *         The event loop must not be running.
			 *         
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Returns True if the event loop was closed.
			 */
			is_closed(): Promise<any>
			is_closed$($: {}): Promise<any>

			/**
			 * Returns True if the event loop is running.
			 */
			is_running(): Promise<any>
			is_running$($: {}): Promise<any>

			/**
			 * Return the time according to the event loop's clock.
			 * 
			 *         This is a float expressed in seconds since an epoch, but the
			 *         epoch, precision, accuracy and drift are unspecified and may
			 *         differ per event loop.
			 *         
			 */
			time(): Promise<any>
			time$($: {}): Promise<any>

			/**
			 * Arrange for a callback to be called at a given time.
			 * 
			 *         Return a Handle: an opaque object with a cancel() method that
			 *         can be used to cancel the call.
			 * 
			 *         The delay can be an int or float, expressed in seconds.  It is
			 *         always relative to the current time.
			 * 
			 *         Each callback will be called exactly once.  If two callbacks
			 *         are scheduled for exactly the same time, it undefined which
			 *         will be called first.
			 * 
			 *         Any positional arguments after the callback will be passed to
			 *         the callback when it is called.
			 *         
			 */
			call_later(delay, callback): Promise<any>
			call_later$({ delay, callback }): Promise<any>

			/**
			 * Like call_later(), but uses an absolute time.
			 * 
			 *         Absolute time corresponds to the event loop's time() method.
			 *         
			 */
			call_at(when, callback): Promise<any>
			call_at$({ when, callback }): Promise<any>

			/**
			 * Arrange for a callback to be called as soon as possible.
			 * 
			 *         This operates as a FIFO queue: callbacks are called in the
			 *         order in which they are registered.  Each callback will be
			 *         called exactly once.
			 * 
			 *         Any positional arguments after the callback will be passed to
			 *         the callback when it is called.
			 *         
			 */
			call_soon(callback): Promise<any>
			call_soon$({ callback }): Promise<any>

			/**
			 * Like call_soon(), but thread-safe.
			 */
			call_soon_threadsafe(callback): Promise<any>
			call_soon_threadsafe$({ callback }): Promise<any>
			run_in_executor(executor, func): Promise<any>
			run_in_executor$({ executor, func }): Promise<any>
			set_default_executor(executor): Promise<any>
			set_default_executor$({ executor }): Promise<any>

			/**
			 * Return an exception handler, or None if the default one is in use.
			 *         
			 */
			get_exception_handler(): Promise<any>
			get_exception_handler$($: {}): Promise<any>

			/**
			 * Set handler as the new event loop exception handler.
			 * 
			 *         If handler is None, the default exception handler will
			 *         be set.
			 * 
			 *         If handler is a callable object, it should have a
			 *         signature matching '(loop, context)', where 'loop'
			 *         will be a reference to the active event loop, 'context'
			 *         will be a dict object (see `call_exception_handler()`
			 *         documentation for details about context).
			 *         
			 */
			set_exception_handler(handler): Promise<any>
			set_exception_handler$({ handler }): Promise<any>

			/**
			 * Default exception handler.
			 * 
			 *         This is called when an exception occurs and no exception
			 *         handler is set, and can be called by a custom exception
			 *         handler that wants to defer to the default behavior.
			 * 
			 *         This default handler logs the error message and other
			 *         context-dependent information.  In debug mode, a truncated
			 *         stack trace is also appended showing where the given object
			 *         (e.g. a handle or future or task) was created, if any.
			 * 
			 *         The context parameter has the same meaning as in
			 *         `call_exception_handler()`.
			 *         
			 */
			default_exception_handler(context): Promise<any>
			default_exception_handler$({ context }): Promise<any>

			/**
			 * Call the current event loop's exception handler.
			 * 
			 *         The context argument is a dict containing the following keys:
			 * 
			 *         - 'message': Error message;
			 *         - 'exception' (optional): Exception object;
			 *         - 'future' (optional): Future instance;
			 *         - 'task' (optional): Task instance;
			 *         - 'handle' (optional): Handle instance;
			 *         - 'protocol' (optional): Protocol instance;
			 *         - 'transport' (optional): Transport instance;
			 *         - 'socket' (optional): Socket instance;
			 *         - 'asyncgen' (optional): Asynchronous generator that caused
			 *                                  the exception.
			 * 
			 *         New keys maybe introduced in the future.
			 * 
			 *         Note: do not overload this method in an event loop subclass.
			 *         For custom exception handling, use the
			 *         `set_exception_handler()` method.
			 *         
			 */
			call_exception_handler(context): Promise<any>
			call_exception_handler$({ context }): Promise<any>
			get_debug(): Promise<any>
			get_debug$($: {}): Promise<any>
			set_debug(enabled): Promise<any>
			set_debug$({ enabled }): Promise<any>
		}
		let MAXIMUM_SELECT_TIMEOUT: Promise<any>
	}
	module base_futures {
		var _

		/**
		 * Check for a Future.
		 * 
		 *     This returns True when obj is a Future instance or is advertising
		 *     itself as duck-type compatible by setting _asyncio_future_blocking.
		 *     See comment in Future for more details.
		 *     
		 */
		function isfuture(obj): Promise<any>
		function isfuture$({ obj }): Promise<any>
	}
	module base_subprocess {
		var _
		function BaseSubprocessTransport(loop, protocol, args, shell, stdin, stdout, stderr, bufsize, waiter?, extra?): Promise<IBaseSubprocessTransport>
		function BaseSubprocessTransport$({ loop, protocol, args, shell, stdin, stdout, stderr, bufsize, waiter, extra }: { loop, protocol, args, shell, stdin, stdout, stderr, bufsize, waiter?, extra?}): Promise<IBaseSubprocessTransport>
		interface IBaseSubprocessTransport {
			set_protocol(protocol): Promise<any>
			set_protocol$({ protocol }): Promise<any>
			get_protocol(): Promise<any>
			get_protocol$($: {}): Promise<any>
			is_closing(): Promise<any>
			is_closing$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			get_pid(): Promise<any>
			get_pid$($: {}): Promise<any>
			get_returncode(): Promise<any>
			get_returncode$($: {}): Promise<any>
			get_pipe_transport(fd): Promise<any>
			get_pipe_transport$({ fd }): Promise<any>
			send_signal(signal): Promise<any>
			send_signal$({ signal }): Promise<any>
			terminate(): Promise<any>
			terminate$($: {}): Promise<any>
			kill(): Promise<any>
			kill$($: {}): Promise<any>
		}
		function WriteSubprocessPipeProto(proc, fd): Promise<IWriteSubprocessPipeProto>
		function WriteSubprocessPipeProto$({ proc, fd }): Promise<IWriteSubprocessPipeProto>
		interface IWriteSubprocessPipeProto {
			connection_made(transport): Promise<any>
			connection_made$({ transport }): Promise<any>
			connection_lost(exc): Promise<any>
			connection_lost$({ exc }): Promise<any>
			pause_writing(): Promise<any>
			pause_writing$($: {}): Promise<any>
			resume_writing(): Promise<any>
			resume_writing$($: {}): Promise<any>
		}
		interface IReadSubprocessPipeProto extends IWriteSubprocessPipeProto {
			data_received(data): Promise<any>
			data_received$({ data }): Promise<any>
		}
	}
	module base_tasks {
		var _
	}
	module constants {
		var _
		interface I_SendfileMode {
			UNSUPPORTED
			TRY_NATIVE
			FALLBACK
		}
		let LOG_THRESHOLD_FOR_CONNLOST_WRITES: Promise<any>
		let ACCEPT_RETRY_DELAY: Promise<any>
		let DEBUG_STACK_DEPTH: Promise<any>
		let SSL_HANDSHAKE_TIMEOUT: Promise<any>
		let SENDFILE_FALLBACK_READBUFFER_SIZE: Promise<any>
	}
	module coroutines {
		var _

		/**
		 * Decorator to mark coroutines.
		 * 
		 *     If the coroutine is not yielded from before it is destroyed,
		 *     an error message is logged.
		 *     
		 */
		function coroutine(func): Promise<any>
		function coroutine$({ func }): Promise<any>

		/**
		 * Return True if func is a decorated coroutine function.
		 */
		function iscoroutinefunction(func): Promise<any>
		function iscoroutinefunction$({ func }): Promise<any>

		/**
		 * Return True if obj is a coroutine object.
		 */
		function iscoroutine(obj): Promise<any>
		function iscoroutine$({ obj }): Promise<any>
		function CoroWrapper(gen, func?): Promise<ICoroWrapper>
		function CoroWrapper$({ gen, func }: { gen, func?}): Promise<ICoroWrapper>
		interface ICoroWrapper {
			send(value): Promise<any>
			send$({ value }): Promise<any>
			throw(type, value?, traceback?): Promise<any>
			throw$({ type, value, traceback }: { type, value?, traceback?}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			gi_frame(): Promise<any>
			gi_frame$($: {}): Promise<any>
			gi_running(): Promise<any>
			gi_running$($: {}): Promise<any>
			gi_code(): Promise<any>
			gi_code$($: {}): Promise<any>
			gi_yieldfrom(): Promise<any>
			gi_yieldfrom$($: {}): Promise<any>
		}
	}
	module events {
		var _

		/**
		 * Return the running event loop.  Raise a RuntimeError if there is none.
		 * 
		 *     This function is thread-specific.
		 *     
		 */
		function get_running_loop(): Promise<any>
		function get_running_loop$($: {}): Promise<any>

		/**
		 * Get the current event loop policy.
		 */
		function get_event_loop_policy(): Promise<any>
		function get_event_loop_policy$($: {}): Promise<any>

		/**
		 * Set the current event loop policy.
		 * 
		 *     If policy is None, the default policy is restored.
		 */
		function set_event_loop_policy(policy): Promise<any>
		function set_event_loop_policy$({ policy }): Promise<any>

		/**
		 * Return an asyncio event loop.
		 * 
		 *     When called from a coroutine or a callback (e.g. scheduled with call_soon
		 *     or similar API), this function will always return the running event loop.
		 * 
		 *     If there is no running event loop set, the function will return
		 *     the result of `get_event_loop_policy().get_event_loop()` call.
		 *     
		 */
		function get_event_loop(): Promise<any>
		function get_event_loop$($: {}): Promise<any>

		/**
		 * Equivalent to calling get_event_loop_policy().set_event_loop(loop).
		 */
		function set_event_loop(loop): Promise<any>
		function set_event_loop$({ loop }): Promise<any>

		/**
		 * Equivalent to calling get_event_loop_policy().new_event_loop().
		 */
		function new_event_loop(): Promise<any>
		function new_event_loop$($: {}): Promise<any>

		/**
		 * Equivalent to calling get_event_loop_policy().get_child_watcher().
		 */
		function get_child_watcher(): Promise<any>
		function get_child_watcher$($: {}): Promise<any>

		/**
		 * Equivalent to calling
		 *     get_event_loop_policy().set_child_watcher(watcher).
		 */
		function set_child_watcher(watcher): Promise<any>
		function set_child_watcher$({ watcher }): Promise<any>

		/**
		 * Object returned by callback registration methods.
		 */
		function Handle(callback, args, loop, context?): Promise<IHandle>
		function Handle$({ callback, args, loop, context }: { callback, args, loop, context?}): Promise<IHandle>
		interface IHandle {
			cancel(): Promise<any>
			cancel$($: {}): Promise<any>
			cancelled(): Promise<any>
			cancelled$($: {}): Promise<any>
		}

		/**
		 * Object returned by timed callback registration methods.
		 */
		function TimerHandle(when, callback, args, loop, context?): Promise<ITimerHandle>
		function TimerHandle$({ when, callback, args, loop, context }: { when, callback, args, loop, context?}): Promise<ITimerHandle>
		interface ITimerHandle extends IHandle {
			cancel(): Promise<any>
			cancel$($: {}): Promise<any>

			/**
			 * Return a scheduled callback time.
			 * 
			 *         The time is an absolute timestamp, using the same time
			 *         reference as loop.time().
			 *         
			 */
			when(): Promise<any>
			when$($: {}): Promise<any>
		}

		/**
		 * Abstract server returned by create_server().
		 */
		interface IAbstractServer {

			/**
			 * Stop serving.  This leaves existing connections open.
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Get the event loop the Server object is attached to.
			 */
			get_loop(): Promise<any>
			get_loop$($: {}): Promise<any>

			/**
			 * Return True if the server is accepting connections.
			 */
			is_serving(): Promise<any>
			is_serving$($: {}): Promise<any>
		}

		/**
		 * Abstract event loop.
		 */
		interface IAbstractEventLoop {

			/**
			 * Run the event loop until stop() is called.
			 */
			run_forever(): Promise<any>
			run_forever$($: {}): Promise<any>

			/**
			 * Run the event loop until a Future is done.
			 * 
			 *         Return the Future's result, or raise its exception.
			 *         
			 */
			run_until_complete(future): Promise<any>
			run_until_complete$({ future }): Promise<any>

			/**
			 * Stop the event loop as soon as reasonable.
			 * 
			 *         Exactly how soon that is may depend on the implementation, but
			 *         no more I/O callbacks should be scheduled.
			 *         
			 */
			stop(): Promise<any>
			stop$($: {}): Promise<any>

			/**
			 * Return whether the event loop is currently running.
			 */
			is_running(): Promise<any>
			is_running$($: {}): Promise<any>

			/**
			 * Returns True if the event loop was closed.
			 */
			is_closed(): Promise<any>
			is_closed$($: {}): Promise<any>

			/**
			 * Close the loop.
			 * 
			 *         The loop should not be running.
			 * 
			 *         This is idempotent and irreversible.
			 * 
			 *         No other methods should be called after this one.
			 *         
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>
			call_soon(callback): Promise<any>
			call_soon$({ callback }): Promise<any>
			call_later(delay, callback): Promise<any>
			call_later$({ delay, callback }): Promise<any>
			call_at(when, callback): Promise<any>
			call_at$({ when, callback }): Promise<any>
			time(): Promise<any>
			time$($: {}): Promise<any>
			create_future(): Promise<any>
			create_future$($: {}): Promise<any>
			create_task(coro): Promise<any>
			create_task$({ coro }): Promise<any>
			call_soon_threadsafe(callback): Promise<any>
			call_soon_threadsafe$({ callback }): Promise<any>
			run_in_executor(executor, func): Promise<any>
			run_in_executor$({ executor, func }): Promise<any>
			set_default_executor(executor): Promise<any>
			set_default_executor$({ executor }): Promise<any>
			add_reader(fd, callback): Promise<any>
			add_reader$({ fd, callback }): Promise<any>
			remove_reader(fd): Promise<any>
			remove_reader$({ fd }): Promise<any>
			add_writer(fd, callback): Promise<any>
			add_writer$({ fd, callback }): Promise<any>
			remove_writer(fd): Promise<any>
			remove_writer$({ fd }): Promise<any>
			add_signal_handler(sig, callback): Promise<any>
			add_signal_handler$({ sig, callback }): Promise<any>
			remove_signal_handler(sig): Promise<any>
			remove_signal_handler$({ sig }): Promise<any>
			set_task_factory(factory): Promise<any>
			set_task_factory$({ factory }): Promise<any>
			get_task_factory(): Promise<any>
			get_task_factory$($: {}): Promise<any>
			get_exception_handler(): Promise<any>
			get_exception_handler$($: {}): Promise<any>
			set_exception_handler(handler): Promise<any>
			set_exception_handler$({ handler }): Promise<any>
			default_exception_handler(context): Promise<any>
			default_exception_handler$({ context }): Promise<any>
			call_exception_handler(context): Promise<any>
			call_exception_handler$({ context }): Promise<any>
			get_debug(): Promise<any>
			get_debug$($: {}): Promise<any>
			set_debug(enabled): Promise<any>
			set_debug$({ enabled }): Promise<any>
		}

		/**
		 * Abstract policy for accessing the event loop.
		 */
		interface IAbstractEventLoopPolicy {

			/**
			 * Get the event loop for the current context.
			 * 
			 *         Returns an event loop object implementing the BaseEventLoop interface,
			 *         or raises an exception in case no event loop has been set for the
			 *         current context and the current policy does not specify to create one.
			 * 
			 *         It should never return None.
			 */
			get_event_loop(): Promise<any>
			get_event_loop$($: {}): Promise<any>

			/**
			 * Set the event loop for the current context to loop.
			 */
			set_event_loop(loop): Promise<any>
			set_event_loop$({ loop }): Promise<any>

			/**
			 * Create and return a new event loop object according to this
			 *         policy's rules. If there's need to set this loop as the event loop for
			 *         the current context, set_event_loop must be called explicitly.
			 */
			new_event_loop(): Promise<any>
			new_event_loop$($: {}): Promise<any>

			/**
			 * Get the watcher for child processes.
			 */
			get_child_watcher(): Promise<any>
			get_child_watcher$($: {}): Promise<any>

			/**
			 * Set the watcher for child processes.
			 */
			set_child_watcher(watcher): Promise<any>
			set_child_watcher$({ watcher }): Promise<any>
		}

		/**
		 * Default policy implementation for accessing the event loop.
		 * 
		 *     In this policy, each thread has its own event loop.  However, we
		 *     only automatically create an event loop by default for the main
		 *     thread; other threads by default have no event loop.
		 * 
		 *     Other policies may have different rules (e.g. a single global
		 *     event loop, or automatically creating an event loop per thread, or
		 *     using some other notion of context to which an event loop is
		 *     associated).
		 *     
		 */
		function BaseDefaultEventLoopPolicy(): Promise<IBaseDefaultEventLoopPolicy>
		function BaseDefaultEventLoopPolicy$({ }): Promise<IBaseDefaultEventLoopPolicy>
		interface IBaseDefaultEventLoopPolicy extends IAbstractEventLoopPolicy {

			/**
			 * Get the event loop for the current context.
			 * 
			 *         Returns an instance of EventLoop or raises an exception.
			 *         
			 */
			get_event_loop(): Promise<any>
			get_event_loop$($: {}): Promise<any>

			/**
			 * Set the event loop.
			 */
			set_event_loop(loop): Promise<any>
			set_event_loop$({ loop }): Promise<any>

			/**
			 * Create a new event loop.
			 * 
			 *         You must call set_event_loop() to make this the current event
			 *         loop.
			 *         
			 */
			new_event_loop(): Promise<any>
			new_event_loop$($: {}): Promise<any>
		}
		interface I_RunningLoop {
			loop_pid
		}
	}
	module exceptions {
		var _

		/**
		 * The Future or Task was cancelled.
		 */
		interface ICancelledError {
		}

		/**
		 * The operation exceeded the given deadline.
		 */
		interface ITimeoutError {
		}

		/**
		 * The operation is not allowed in this state.
		 */
		interface IInvalidStateError {
		}

		/**
		 * Sendfile syscall is not available.
		 * 
		 *     Raised if OS does not support sendfile syscall for given socket or
		 *     file type.
		 *     
		 */
		interface ISendfileNotAvailableError {
		}

		/**
		 * 
		 *     Incomplete read error. Attributes:
		 * 
		 *     - partial: read bytes string before the end of stream was reached
		 *     - expected: total number of expected bytes (or None if unknown)
		 *     
		 */
		function IncompleteReadError(partial, expected): Promise<IIncompleteReadError>
		function IncompleteReadError$({ partial, expected }): Promise<IIncompleteReadError>
		interface IIncompleteReadError {
		}

		/**
		 * Reached the buffer limit while looking for a separator.
		 * 
		 *     Attributes:
		 *     - consumed: total number of to be consumed bytes.
		 *     
		 */
		function LimitOverrunError(message, consumed): Promise<ILimitOverrunError>
		function LimitOverrunError$({ message, consumed }): Promise<ILimitOverrunError>
		interface ILimitOverrunError {
		}
	}
	module format_helpers {
		var _

		/**
		 * Replacement for traceback.extract_stack() that only does the
		 *     necessary work for asyncio debug mode.
		 *     
		 */
		function extract_stack(f?, limit?): Promise<any>
		function extract_stack$({ f, limit }: { f?, limit?}): Promise<any>
	}
	module futures {
		var _

		/**
		 * Wrap concurrent.futures.Future object.
		 */
		function wrap_future(future): Promise<any>
		function wrap_future$({ future }): Promise<any>

		/**
		 * This class is *almost* compatible with concurrent.futures.Future.
		 * 
		 *     Differences:
		 * 
		 *     - This class is not thread-safe.
		 * 
		 *     - result() and exception() do not take a timeout argument and
		 *       raise an exception when the future isn't done yet.
		 * 
		 *     - Callbacks registered with add_done_callback() are always called
		 *       via the event loop's call_soon().
		 * 
		 *     - This class is not compatible with the wait() and as_completed()
		 *       methods in the concurrent.futures package.
		 * 
		 *     (In Python 3.4 or later we may be able to unify the implementations.)
		 *     
		 */

		/**
		 * Initialize the future.
		 * 
		 *         The optional event_loop argument allows explicitly setting the event
		 *         loop object used by the future. If it's not provided, the future uses
		 *         the default event loop.
		 *         
		 */
		function Future(): Promise<IFuture>
		function Future$({ }): Promise<IFuture>
		interface IFuture {

			/**
			 * Return the event loop the Future is bound to.
			 */
			get_loop(): Promise<any>
			get_loop$($: {}): Promise<any>

			/**
			 * Cancel the future and schedule callbacks.
			 * 
			 *         If the future is already done or cancelled, return False.  Otherwise,
			 *         change the future's state to cancelled, schedule the callbacks and
			 *         return True.
			 *         
			 */
			cancel(msg?): Promise<any>
			cancel$({ msg }: { msg?}): Promise<any>

			/**
			 * Return True if the future was cancelled.
			 */
			cancelled(): Promise<any>
			cancelled$($: {}): Promise<any>

			/**
			 * Return True if the future is done.
			 * 
			 *         Done means either that a result / exception are available, or that the
			 *         future was cancelled.
			 *         
			 */
			done(): Promise<any>
			done$($: {}): Promise<any>

			/**
			 * Return the result this future represents.
			 * 
			 *         If the future has been cancelled, raises CancelledError.  If the
			 *         future's result isn't yet available, raises InvalidStateError.  If
			 *         the future is done and has an exception set, this exception is raised.
			 *         
			 */
			result(): Promise<any>
			result$($: {}): Promise<any>

			/**
			 * Return the exception that was set on this future.
			 * 
			 *         The exception (or None if no exception was set) is returned only if
			 *         the future is done.  If the future has been cancelled, raises
			 *         CancelledError.  If the future isn't done yet, raises
			 *         InvalidStateError.
			 *         
			 */
			exception(): Promise<any>
			exception$($: {}): Promise<any>

			/**
			 * Add a callback to be run when the future becomes done.
			 * 
			 *         The callback is called with a single argument - the future object. If
			 *         the future is already done when this is called, the callback is
			 *         scheduled with call_soon.
			 *         
			 */
			add_done_callback(fn): Promise<any>
			add_done_callback$({ fn }): Promise<any>

			/**
			 * Remove all instances of a callback from the "call when done" list.
			 * 
			 *         Returns the number of callbacks removed.
			 *         
			 */
			remove_done_callback(fn): Promise<any>
			remove_done_callback$({ fn }): Promise<any>

			/**
			 * Mark the future done and set its result.
			 * 
			 *         If the future is already done when this method is called, raises
			 *         InvalidStateError.
			 *         
			 */
			set_result(result): Promise<any>
			set_result$({ result }): Promise<any>

			/**
			 * Mark the future done and set an exception.
			 * 
			 *         If the future is already done when this method is called, raises
			 *         InvalidStateError.
			 *         
			 */
			set_exception(exception): Promise<any>
			set_exception$({ exception }): Promise<any>
		}
		let isfuture: Promise<any>
		let STACK_DEBUG: Promise<any>
	}
	module locks {
		var _
		interface I_ContextManagerMixin {
		}

		/**
		 * Primitive lock objects.
		 * 
		 *     A primitive lock is a synchronization primitive that is not owned
		 *     by a particular coroutine when locked.  A primitive lock is in one
		 *     of two states, 'locked' or 'unlocked'.
		 * 
		 *     It is created in the unlocked state.  It has two basic methods,
		 *     acquire() and release().  When the state is unlocked, acquire()
		 *     changes the state to locked and returns immediately.  When the
		 *     state is locked, acquire() blocks until a call to release() in
		 *     another coroutine changes it to unlocked, then the acquire() call
		 *     resets it to locked and returns.  The release() method should only
		 *     be called in the locked state; it changes the state to unlocked
		 *     and returns immediately.  If an attempt is made to release an
		 *     unlocked lock, a RuntimeError will be raised.
		 * 
		 *     When more than one coroutine is blocked in acquire() waiting for
		 *     the state to turn to unlocked, only one coroutine proceeds when a
		 *     release() call resets the state to unlocked; first coroutine which
		 *     is blocked in acquire() is being processed.
		 * 
		 *     acquire() is a coroutine and should be called with 'await'.
		 * 
		 *     Locks also support the asynchronous context management protocol.
		 *     'async with lock' statement should be used.
		 * 
		 *     Usage:
		 * 
		 *         lock = Lock()
		 *         ...
		 *         await lock.acquire()
		 *         try:
		 *             ...
		 *         finally:
		 *             lock.release()
		 * 
		 *     Context manager usage:
		 * 
		 *         lock = Lock()
		 *         ...
		 *         async with lock:
		 *              ...
		 * 
		 *     Lock objects can be tested for locking state:
		 * 
		 *         if not lock.locked():
		 *            await lock.acquire()
		 *         else:
		 *            # lock is acquired
		 *            ...
		 * 
		 *     
		 */
		function Lock(): Promise<ILock>
		function Lock$({ }): Promise<ILock>
		interface ILock extends I_ContextManagerMixin {

			/**
			 * Return True if lock is acquired.
			 */
			locked(): Promise<any>
			locked$($: {}): Promise<any>

			/**
			 * Release a lock.
			 * 
			 *         When the lock is locked, reset it to unlocked, and return.
			 *         If any other coroutines are blocked waiting for the lock to become
			 *         unlocked, allow exactly one of them to proceed.
			 * 
			 *         When invoked on an unlocked lock, a RuntimeError is raised.
			 * 
			 *         There is no return value.
			 *         
			 */
			release(): Promise<any>
			release$($: {}): Promise<any>
		}

		/**
		 * Asynchronous equivalent to threading.Event.
		 * 
		 *     Class implementing event objects. An event manages a flag that can be set
		 *     to true with the set() method and reset to false with the clear() method.
		 *     The wait() method blocks until the flag is true. The flag is initially
		 *     false.
		 *     
		 */
		function Event(): Promise<IEvent>
		function Event$({ }): Promise<IEvent>
		interface IEvent {

			/**
			 * Return True if and only if the internal flag is true.
			 */
			is_set(): Promise<any>
			is_set$($: {}): Promise<any>

			/**
			 * Set the internal flag to true. All coroutines waiting for it to
			 *         become true are awakened. Coroutine that call wait() once the flag is
			 *         true will not block at all.
			 *         
			 */
			set(): Promise<any>
			set$($: {}): Promise<any>

			/**
			 * Reset the internal flag to false. Subsequently, coroutines calling
			 *         wait() will block until set() is called to set the internal flag
			 *         to true again.
			 */
			clear(): Promise<any>
			clear$($: {}): Promise<any>
		}

		/**
		 * Asynchronous equivalent to threading.Condition.
		 * 
		 *     This class implements condition variable objects. A condition variable
		 *     allows one or more coroutines to wait until they are notified by another
		 *     coroutine.
		 * 
		 *     A new Lock object is created and used as the underlying lock.
		 *     
		 */
		function Condition(lock?): Promise<ICondition>
		function Condition$({ lock }: { lock?}): Promise<ICondition>
		interface ICondition extends I_ContextManagerMixin {

			/**
			 * By default, wake up one coroutine waiting on this condition, if any.
			 *         If the calling coroutine has not acquired the lock when this method
			 *         is called, a RuntimeError is raised.
			 * 
			 *         This method wakes up at most n of the coroutines waiting for the
			 *         condition variable; it is a no-op if no coroutines are waiting.
			 * 
			 *         Note: an awakened coroutine does not actually return from its
			 *         wait() call until it can reacquire the lock. Since notify() does
			 *         not release the lock, its caller should.
			 *         
			 */
			notify(n?): Promise<any>
			notify$({ n }: { n?}): Promise<any>

			/**
			 * Wake up all threads waiting on this condition. This method acts
			 *         like notify(), but wakes up all waiting threads instead of one. If the
			 *         calling thread has not acquired the lock when this method is called,
			 *         a RuntimeError is raised.
			 *         
			 */
			notify_all(): Promise<any>
			notify_all$($: {}): Promise<any>
		}

		/**
		 * A Semaphore implementation.
		 * 
		 *     A semaphore manages an internal counter which is decremented by each
		 *     acquire() call and incremented by each release() call. The counter
		 *     can never go below zero; when acquire() finds that it is zero, it blocks,
		 *     waiting until some other thread calls release().
		 * 
		 *     Semaphores also support the context management protocol.
		 * 
		 *     The optional argument gives the initial value for the internal
		 *     counter; it defaults to 1. If the value given is less than 0,
		 *     ValueError is raised.
		 *     
		 */
		function Semaphore(value?): Promise<ISemaphore>
		function Semaphore$({ value }: { value?}): Promise<ISemaphore>
		interface ISemaphore extends I_ContextManagerMixin {

			/**
			 * Returns True if semaphore can not be acquired immediately.
			 */
			locked(): Promise<any>
			locked$($: {}): Promise<any>

			/**
			 * Release a semaphore, incrementing the internal counter by one.
			 *         When it was zero on entry and another coroutine is waiting for it to
			 *         become larger than zero again, wake up that coroutine.
			 *         
			 */
			release(): Promise<any>
			release$($: {}): Promise<any>
		}

		/**
		 * A bounded semaphore implementation.
		 * 
		 *     This raises ValueError in release() if it would increase the value
		 *     above the initial value.
		 *     
		 */
		function BoundedSemaphore(value?): Promise<IBoundedSemaphore>
		function BoundedSemaphore$({ value }: { value?}): Promise<IBoundedSemaphore>
		interface IBoundedSemaphore extends ISemaphore {
			release(): Promise<any>
			release$($: {}): Promise<any>
		}
	}
	module log {
		var _
		let logger: Promise<any>
	}
	module mixins {
		var _
		interface I_LoopBoundMixin {
		}
	}
	module proactor_events {
		var _

		/**
		 * Base class for pipe and socket transports.
		 */
		interface I_ProactorBasePipeTransport {
			set_protocol(protocol): Promise<any>
			set_protocol$({ protocol }): Promise<any>
			get_protocol(): Promise<any>
			get_protocol$($: {}): Promise<any>
			is_closing(): Promise<any>
			is_closing$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			get_write_buffer_size(): Promise<any>
			get_write_buffer_size$($: {}): Promise<any>
		}

		/**
		 * Transport for read pipes.
		 */
		interface I_ProactorReadPipeTransport extends I_ProactorBasePipeTransport {
			is_reading(): Promise<any>
			is_reading$($: {}): Promise<any>
			pause_reading(): Promise<any>
			pause_reading$($: {}): Promise<any>
			resume_reading(): Promise<any>
			resume_reading$($: {}): Promise<any>
		}

		/**
		 * Transport for write pipes.
		 */
		interface I_ProactorBaseWritePipeTransport extends I_ProactorBasePipeTransport {
			write(data): Promise<any>
			write$({ data }): Promise<any>
			can_write_eof(): Promise<any>
			can_write_eof$($: {}): Promise<any>
			write_eof(): Promise<any>
			write_eof$($: {}): Promise<any>
			abort(): Promise<any>
			abort$($: {}): Promise<any>
		}
		interface I_ProactorWritePipeTransport extends I_ProactorBaseWritePipeTransport {
		}
		interface I_ProactorDatagramTransport extends I_ProactorBasePipeTransport {
			get_write_buffer_size(): Promise<any>
			get_write_buffer_size$($: {}): Promise<any>
			abort(): Promise<any>
			abort$($: {}): Promise<any>
			sendto(data, addr?): Promise<any>
			sendto$({ data, addr }: { data, addr?}): Promise<any>
			max_size
		}

		/**
		 * Transport for duplex pipes.
		 */
		interface I_ProactorDuplexPipeTransport extends I_ProactorReadPipeTransport, I_ProactorBaseWritePipeTransport {
			can_write_eof(): Promise<any>
			can_write_eof$($: {}): Promise<any>
			write_eof(): Promise<any>
			write_eof$($: {}): Promise<any>
		}

		/**
		 * Transport for connected sockets.
		 */
		interface I_ProactorSocketTransport extends I_ProactorReadPipeTransport, I_ProactorBaseWritePipeTransport {
			can_write_eof(): Promise<any>
			can_write_eof$($: {}): Promise<any>
			write_eof(): Promise<any>
			write_eof$($: {}): Promise<any>
		}
		function BaseProactorEventLoop(proactor): Promise<IBaseProactorEventLoop>
		function BaseProactorEventLoop$({ proactor }): Promise<IBaseProactorEventLoop>
		interface IBaseProactorEventLoop {
			close(): Promise<any>
			close$($: {}): Promise<any>
		}
	}
	module protocols {
		var _

		/**
		 * Common base class for protocol interfaces.
		 * 
		 *     Usually user implements protocols that derived from BaseProtocol
		 *     like Protocol or ProcessProtocol.
		 * 
		 *     The only case when BaseProtocol should be implemented directly is
		 *     write-only transport like write pipe
		 *     
		 */
		interface IBaseProtocol {

			/**
			 * Called when a connection is made.
			 * 
			 *         The argument is the transport representing the pipe connection.
			 *         To receive data, wait for data_received() calls.
			 *         When the connection is closed, connection_lost() is called.
			 *         
			 */
			connection_made(transport): Promise<any>
			connection_made$({ transport }): Promise<any>

			/**
			 * Called when the connection is lost or closed.
			 * 
			 *         The argument is an exception object or None (the latter
			 *         meaning a regular EOF is received or the connection was
			 *         aborted or closed).
			 *         
			 */
			connection_lost(exc): Promise<any>
			connection_lost$({ exc }): Promise<any>

			/**
			 * Called when the transport's buffer goes over the high-water mark.
			 * 
			 *         Pause and resume calls are paired -- pause_writing() is called
			 *         once when the buffer goes strictly over the high-water mark
			 *         (even if subsequent writes increases the buffer size even
			 *         more), and eventually resume_writing() is called once when the
			 *         buffer size reaches the low-water mark.
			 * 
			 *         Note that if the buffer size equals the high-water mark,
			 *         pause_writing() is not called -- it must go strictly over.
			 *         Conversely, resume_writing() is called when the buffer size is
			 *         equal or lower than the low-water mark.  These end conditions
			 *         are important to ensure that things go as expected when either
			 *         mark is zero.
			 * 
			 *         NOTE: This is the only Protocol callback that is not called
			 *         through EventLoop.call_soon() -- if it were, it would have no
			 *         effect when it's most needed (when the app keeps writing
			 *         without yielding until pause_writing() is called).
			 *         
			 */
			pause_writing(): Promise<any>
			pause_writing$($: {}): Promise<any>

			/**
			 * Called when the transport's buffer drains below the low-water mark.
			 * 
			 *         See pause_writing() for details.
			 *         
			 */
			resume_writing(): Promise<any>
			resume_writing$($: {}): Promise<any>
		}

		/**
		 * Interface for stream protocol.
		 * 
		 *     The user should implement this interface.  They can inherit from
		 *     this class but don't need to.  The implementations here do
		 *     nothing (they don't raise exceptions).
		 * 
		 *     When the user wants to requests a transport, they pass a protocol
		 *     factory to a utility function (e.g., EventLoop.create_connection()).
		 * 
		 *     When the connection is made successfully, connection_made() is
		 *     called with a suitable transport object.  Then data_received()
		 *     will be called 0 or more times with data (bytes) received from the
		 *     transport; finally, connection_lost() will be called exactly once
		 *     with either an exception object or None as an argument.
		 * 
		 *     State machine of calls:
		 * 
		 *       start -> CM [-> DR*] [-> ER?] -> CL -> end
		 * 
		 *     * CM: connection_made()
		 *     * DR: data_received()
		 *     * ER: eof_received()
		 *     * CL: connection_lost()
		 *     
		 */
		interface IProtocol extends IBaseProtocol {

			/**
			 * Called when some data is received.
			 * 
			 *         The argument is a bytes object.
			 *         
			 */
			data_received(data): Promise<any>
			data_received$({ data }): Promise<any>

			/**
			 * Called when the other end calls write_eof() or equivalent.
			 * 
			 *         If this returns a false value (including None), the transport
			 *         will close itself.  If it returns a true value, closing the
			 *         transport is up to the protocol.
			 *         
			 */
			eof_received(): Promise<any>
			eof_received$($: {}): Promise<any>
		}

		/**
		 * Interface for stream protocol with manual buffer control.
		 * 
		 *     Important: this has been added to asyncio in Python 3.7
		 *     *on a provisional basis*!  Consider it as an experimental API that
		 *     might be changed or removed in Python 3.8.
		 * 
		 *     Event methods, such as `create_server` and `create_connection`,
		 *     accept factories that return protocols that implement this interface.
		 * 
		 *     The idea of BufferedProtocol is that it allows to manually allocate
		 *     and control the receive buffer.  Event loops can then use the buffer
		 *     provided by the protocol to avoid unnecessary data copies.  This
		 *     can result in noticeable performance improvement for protocols that
		 *     receive big amounts of data.  Sophisticated protocols can allocate
		 *     the buffer only once at creation time.
		 * 
		 *     State machine of calls:
		 * 
		 *       start -> CM [-> GB [-> BU?]]* [-> ER?] -> CL -> end
		 * 
		 *     * CM: connection_made()
		 *     * GB: get_buffer()
		 *     * BU: buffer_updated()
		 *     * ER: eof_received()
		 *     * CL: connection_lost()
		 *     
		 */
		interface IBufferedProtocol extends IBaseProtocol {

			/**
			 * Called to allocate a new receive buffer.
			 * 
			 *         *sizehint* is a recommended minimal size for the returned
			 *         buffer.  When set to -1, the buffer size can be arbitrary.
			 * 
			 *         Must return an object that implements the
			 *         :ref:`buffer protocol <bufferobjects>`.
			 *         It is an error to return a zero-sized buffer.
			 *         
			 */
			get_buffer(sizehint): Promise<any>
			get_buffer$({ sizehint }): Promise<any>

			/**
			 * Called when the buffer was updated with the received data.
			 * 
			 *         *nbytes* is the total number of bytes that were written to
			 *         the buffer.
			 *         
			 */
			buffer_updated(nbytes): Promise<any>
			buffer_updated$({ nbytes }): Promise<any>

			/**
			 * Called when the other end calls write_eof() or equivalent.
			 * 
			 *         If this returns a false value (including None), the transport
			 *         will close itself.  If it returns a true value, closing the
			 *         transport is up to the protocol.
			 *         
			 */
			eof_received(): Promise<any>
			eof_received$($: {}): Promise<any>
		}

		/**
		 * Interface for datagram protocol.
		 */
		interface IDatagramProtocol extends IBaseProtocol {

			/**
			 * Called when some datagram is received.
			 */
			datagram_received(data, addr): Promise<any>
			datagram_received$({ data, addr }): Promise<any>

			/**
			 * Called when a send or receive operation raises an OSError.
			 * 
			 *         (Other than BlockingIOError or InterruptedError.)
			 *         
			 */
			error_received(exc): Promise<any>
			error_received$({ exc }): Promise<any>
		}

		/**
		 * Interface for protocol for subprocess calls.
		 */
		interface ISubprocessProtocol extends IBaseProtocol {

			/**
			 * Called when the subprocess writes data into stdout/stderr pipe.
			 * 
			 *         fd is int file descriptor.
			 *         data is bytes object.
			 *         
			 */
			pipe_data_received(fd, data): Promise<any>
			pipe_data_received$({ fd, data }): Promise<any>

			/**
			 * Called when a file descriptor associated with the child process is
			 *         closed.
			 * 
			 *         fd is the int file descriptor that was closed.
			 *         
			 */
			pipe_connection_lost(fd, exc): Promise<any>
			pipe_connection_lost$({ fd, exc }): Promise<any>

			/**
			 * Called when subprocess has exited.
			 */
			process_exited(): Promise<any>
			process_exited$($: {}): Promise<any>
		}
	}
	module queues {
		var _

		/**
		 * Raised when Queue.get_nowait() is called on an empty Queue.
		 */
		interface IQueueEmpty {
		}

		/**
		 * Raised when the Queue.put_nowait() method is called on a full Queue.
		 */
		interface IQueueFull {
		}

		/**
		 * A queue, useful for coordinating producer and consumer coroutines.
		 * 
		 *     If maxsize is less than or equal to zero, the queue size is infinite. If it
		 *     is an integer greater than 0, then "await put()" will block when the
		 *     queue reaches maxsize, until an item is removed by get().
		 * 
		 *     Unlike the standard library Queue, you can reliably know this Queue's size
		 *     with qsize(), since your single-threaded asyncio application won't be
		 *     interrupted between calling qsize() and doing an operation on the Queue.
		 *     
		 */
		function Queue(maxsize?): Promise<IQueue>
		function Queue$({ maxsize }: { maxsize?}): Promise<IQueue>
		interface IQueue {

			/**
			 * Number of items in the queue.
			 */
			qsize(): Promise<any>
			qsize$($: {}): Promise<any>

			/**
			 * Number of items allowed in the queue.
			 */
			maxsize(): Promise<any>
			maxsize$($: {}): Promise<any>

			/**
			 * Return True if the queue is empty, False otherwise.
			 */
			empty(): Promise<any>
			empty$($: {}): Promise<any>

			/**
			 * Return True if there are maxsize items in the queue.
			 * 
			 *         Note: if the Queue was initialized with maxsize=0 (the default),
			 *         then full() is never True.
			 *         
			 */
			full(): Promise<any>
			full$($: {}): Promise<any>

			/**
			 * Put an item into the queue without blocking.
			 * 
			 *         If no free slot is immediately available, raise QueueFull.
			 *         
			 */
			put_nowait(item): Promise<any>
			put_nowait$({ item }): Promise<any>

			/**
			 * Remove and return an item from the queue.
			 * 
			 *         Return an item if one is immediately available, else raise QueueEmpty.
			 *         
			 */
			get_nowait(): Promise<any>
			get_nowait$($: {}): Promise<any>

			/**
			 * Indicate that a formerly enqueued task is complete.
			 * 
			 *         Used by queue consumers. For each get() used to fetch a task,
			 *         a subsequent call to task_done() tells the queue that the processing
			 *         on the task is complete.
			 * 
			 *         If a join() is currently blocking, it will resume when all items have
			 *         been processed (meaning that a task_done() call was received for every
			 *         item that had been put() into the queue).
			 * 
			 *         Raises ValueError if called more times than there were items placed in
			 *         the queue.
			 *         
			 */
			task_done(): Promise<any>
			task_done$($: {}): Promise<any>
		}

		/**
		 * A subclass of Queue; retrieves entries in priority order (lowest first).
		 * 
		 *     Entries are typically tuples of the form: (priority number, data).
		 *     
		 */
		interface IPriorityQueue extends IQueue {
		}

		/**
		 * A subclass of Queue that retrieves most recently added entries first.
		 */
		interface ILifoQueue extends IQueue {
		}
	}
	module runners {
		var _

		/**
		 * Execute the coroutine and return the result.
		 * 
		 *     This function runs the passed coroutine, taking care of
		 *     managing the asyncio event loop and finalizing asynchronous
		 *     generators.
		 * 
		 *     This function cannot be called when another asyncio event loop is
		 *     running in the same thread.
		 * 
		 *     If debug is True, the event loop will be run in debug mode.
		 * 
		 *     This function always creates a new event loop and closes it at the end.
		 *     It should be used as a main entry point for asyncio programs, and should
		 *     ideally only be called once.
		 * 
		 *     Example:
		 * 
		 *         async def main():
		 *             await asyncio.sleep(1)
		 *             print('hello')
		 * 
		 *         asyncio.run(main())
		 *     
		 */
		function run(main): Promise<any>
		function run$({ main }): Promise<any>
	}
	module selector_events {
		var _

		/**
		 * Selector event loop.
		 * 
		 *     See events.EventLoop for API specification.
		 *     
		 */
		function BaseSelectorEventLoop(selector?): Promise<IBaseSelectorEventLoop>
		function BaseSelectorEventLoop$({ selector }: { selector?}): Promise<IBaseSelectorEventLoop>
		interface IBaseSelectorEventLoop {
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Add a reader callback.
			 */
			add_reader(fd, callback): Promise<any>
			add_reader$({ fd, callback }): Promise<any>

			/**
			 * Remove a reader callback.
			 */
			remove_reader(fd): Promise<any>
			remove_reader$({ fd }): Promise<any>

			/**
			 * Add a writer callback..
			 */
			add_writer(fd, callback): Promise<any>
			add_writer$({ fd, callback }): Promise<any>

			/**
			 * Remove a writer callback.
			 */
			remove_writer(fd): Promise<any>
			remove_writer$({ fd }): Promise<any>
		}
		interface I_SelectorTransport {
			abort(): Promise<any>
			abort$($: {}): Promise<any>
			set_protocol(protocol): Promise<any>
			set_protocol$({ protocol }): Promise<any>
			get_protocol(): Promise<any>
			get_protocol$($: {}): Promise<any>
			is_closing(): Promise<any>
			is_closing$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			get_write_buffer_size(): Promise<any>
			get_write_buffer_size$($: {}): Promise<any>
			max_size
		}
		interface I_SelectorSocketTransport extends I_SelectorTransport {
			set_protocol(protocol): Promise<any>
			set_protocol$({ protocol }): Promise<any>
			is_reading(): Promise<any>
			is_reading$($: {}): Promise<any>
			pause_reading(): Promise<any>
			pause_reading$($: {}): Promise<any>
			resume_reading(): Promise<any>
			resume_reading$($: {}): Promise<any>
			write(data): Promise<any>
			write$({ data }): Promise<any>
			write_eof(): Promise<any>
			write_eof$($: {}): Promise<any>
			can_write_eof(): Promise<any>
			can_write_eof$($: {}): Promise<any>
		}
		interface I_SelectorDatagramTransport extends I_SelectorTransport {
			get_write_buffer_size(): Promise<any>
			get_write_buffer_size$($: {}): Promise<any>
			sendto(data, addr?): Promise<any>
			sendto$({ data, addr }: { data, addr?}): Promise<any>
		}
	}
	module sslproto {
		var _

		/**
		 * An SSL "Pipe".
		 * 
		 *     An SSL pipe allows you to communicate with an SSL/TLS protocol instance
		 *     through memory buffers. It can be used to implement a security layer for an
		 *     existing connection where you don't have access to the connection's file
		 *     descriptor, or for some reason you don't want to use it.
		 * 
		 *     An SSL pipe can be in "wrapped" and "unwrapped" mode. In unwrapped mode,
		 *     data is passed through untransformed. In wrapped mode, application level
		 *     data is encrypted to SSL record level data and vice versa. The SSL record
		 *     level is the lowest level in the SSL protocol suite and is what travels
		 *     as-is over the wire.
		 * 
		 *     An SslPipe initially is in "unwrapped" mode. To start SSL, call
		 *     do_handshake(). To shutdown SSL again, call unwrap().
		 *     
		 */
		interface I_SSLPipe {

			/**
			 * The SSL context passed to the constructor.
			 */
			context(): Promise<any>
			context$($: {}): Promise<any>

			/**
			 * The internal ssl.SSLObject instance.
			 * 
			 *         Return None if the pipe is not wrapped.
			 *         
			 */
			ssl_object(): Promise<any>
			ssl_object$($: {}): Promise<any>

			/**
			 * Whether more record level data is needed to complete a handshake
			 *         that is currently in progress.
			 */
			need_ssldata(): Promise<any>
			need_ssldata$($: {}): Promise<any>

			/**
			 * 
			 *         Whether a security layer is currently in effect.
			 * 
			 *         Return False during handshake.
			 *         
			 */
			wrapped(): Promise<any>
			wrapped$($: {}): Promise<any>

			/**
			 * Start the SSL handshake.
			 * 
			 *         Return a list of ssldata. A ssldata element is a list of buffers
			 * 
			 *         The optional *callback* argument can be used to install a callback that
			 *         will be called when the handshake is complete. The callback will be
			 *         called with None if successful, else an exception instance.
			 *         
			 */
			do_handshake(callback?): Promise<any>
			do_handshake$({ callback }: { callback?}): Promise<any>

			/**
			 * Start the SSL shutdown sequence.
			 * 
			 *         Return a list of ssldata. A ssldata element is a list of buffers
			 * 
			 *         The optional *callback* argument can be used to install a callback that
			 *         will be called when the shutdown is complete. The callback will be
			 *         called without arguments.
			 *         
			 */
			shutdown(callback?): Promise<any>
			shutdown$({ callback }: { callback?}): Promise<any>

			/**
			 * Send a potentially "ragged" EOF.
			 * 
			 *         This method will raise an SSL_ERROR_EOF exception if the EOF is
			 *         unexpected.
			 *         
			 */
			feed_eof(): Promise<any>
			feed_eof$($: {}): Promise<any>

			/**
			 * Feed SSL record level data into the pipe.
			 * 
			 *         The data must be a bytes instance. It is OK to send an empty bytes
			 *         instance. This can be used to get ssldata for a handshake initiated by
			 *         this endpoint.
			 * 
			 *         Return a (ssldata, appdata) tuple. The ssldata element is a list of
			 *         buffers containing SSL data that needs to be sent to the remote SSL.
			 * 
			 *         The appdata element is a list of buffers containing plaintext data that
			 *         needs to be forwarded to the application. The appdata list may contain
			 *         an empty buffer indicating an SSL "close_notify" alert. This alert must
			 *         be acknowledged by calling shutdown().
			 *         
			 */
			feed_ssldata(data, only_handshake?: boolean): Promise<any>
			feed_ssldata$({ data, only_handshake }: { data, only_handshake?}): Promise<any>

			/**
			 * Feed plaintext data into the pipe.
			 * 
			 *         Return an (ssldata, offset) tuple. The ssldata element is a list of
			 *         buffers containing record level data that needs to be sent to the
			 *         remote SSL instance. The offset is the number of plaintext bytes that
			 *         were processed, which may be less than the length of data.
			 * 
			 *         NOTE: In case of short writes, this call MUST be retried with the SAME
			 *         buffer passed into the *data* argument (i.e. the id() must be the
			 *         same). This is an OpenSSL requirement. A further particularity is that
			 *         a short write will always have offset == 0, because the _ssl module
			 *         does not enable partial writes. And even though the offset is zero,
			 *         there will still be encrypted data in ssldata.
			 *         
			 */
			feed_appdata(data, offset?): Promise<any>
			feed_appdata$({ data, offset }: { data, offset?}): Promise<any>
			max_size
		}
		interface I_SSLProtocolTransport {

			/**
			 * Get optional transport information.
			 */
			get_extra_info(name, def?): Promise<any>
			get_extra_info$({ name, def }: { name, def?}): Promise<any>
			set_protocol(protocol): Promise<any>
			set_protocol$({ protocol }): Promise<any>
			get_protocol(): Promise<any>
			get_protocol$($: {}): Promise<any>
			is_closing(): Promise<any>
			is_closing$($: {}): Promise<any>

			/**
			 * Close the transport.
			 * 
			 *         Buffered data will be flushed asynchronously.  No more data
			 *         will be received.  After all buffered data is flushed, the
			 *         protocol's connection_lost() method will (eventually) called
			 *         with None as its argument.
			 *         
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>
			is_reading(): Promise<any>
			is_reading$($: {}): Promise<any>

			/**
			 * Pause the receiving end.
			 * 
			 *         No data will be passed to the protocol's data_received()
			 *         method until resume_reading() is called.
			 *         
			 */
			pause_reading(): Promise<any>
			pause_reading$($: {}): Promise<any>

			/**
			 * Resume the receiving end.
			 * 
			 *         Data received will once again be passed to the protocol's
			 *         data_received() method.
			 *         
			 */
			resume_reading(): Promise<any>
			resume_reading$($: {}): Promise<any>

			/**
			 * Set the high- and low-water limits for write flow control.
			 * 
			 *         These two values control when to call the protocol's
			 *         pause_writing() and resume_writing() methods.  If specified,
			 *         the low-water limit must be less than or equal to the
			 *         high-water limit.  Neither value can be negative.
			 * 
			 *         The defaults are implementation-specific.  If only the
			 *         high-water limit is given, the low-water limit defaults to an
			 *         implementation-specific value less than or equal to the
			 *         high-water limit.  Setting high to zero forces low to zero as
			 *         well, and causes pause_writing() to be called whenever the
			 *         buffer becomes non-empty.  Setting low to zero causes
			 *         resume_writing() to be called only once the buffer is empty.
			 *         Use of zero for either limit is generally sub-optimal as it
			 *         reduces opportunities for doing I/O and computation
			 *         concurrently.
			 *         
			 */
			set_write_buffer_limits(high?, low?): Promise<any>
			set_write_buffer_limits$({ high, low }: { high?, low?}): Promise<any>

			/**
			 * Return the current size of the write buffer.
			 */
			get_write_buffer_size(): Promise<any>
			get_write_buffer_size$($: {}): Promise<any>

			/**
			 * Write some data bytes to the transport.
			 * 
			 *         This does not block; it buffers the data and arranges for it
			 *         to be sent out asynchronously.
			 *         
			 */
			write(data): Promise<any>
			write$({ data }): Promise<any>

			/**
			 * Return True if this transport supports write_eof(), False if not.
			 */
			can_write_eof(): Promise<any>
			can_write_eof$($: {}): Promise<any>

			/**
			 * Close the transport immediately.
			 * 
			 *         Buffered data will be lost.  No more data will be received.
			 *         The protocol's connection_lost() method will (eventually) be
			 *         called with None as its argument.
			 *         
			 */
			abort(): Promise<any>
			abort$($: {}): Promise<any>
		}

		/**
		 * SSL protocol.
		 * 
		 *     Implementation of SSL on top of a socket using incoming and outgoing
		 *     buffers which are ssl.MemoryBIO objects.
		 *     
		 */
		function SSLProtocol(loop, app_protocol, sslcontext, waiter, server_side?: boolean, server_hostname?, call_connection_made?: boolean, ssl_handshake_timeout?): Promise<ISSLProtocol>
		function SSLProtocol$({ loop, app_protocol, sslcontext, waiter, server_side, server_hostname, call_connection_made, ssl_handshake_timeout }: { loop, app_protocol, sslcontext, waiter, server_side?, server_hostname?, call_connection_made?, ssl_handshake_timeout?}): Promise<ISSLProtocol>
		interface ISSLProtocol {

			/**
			 * Called when the low-level connection is made.
			 * 
			 *         Start the SSL handshake.
			 *         
			 */
			connection_made(transport): Promise<any>
			connection_made$({ transport }): Promise<any>

			/**
			 * Called when the low-level connection is lost or closed.
			 * 
			 *         The argument is an exception object or None (the latter
			 *         meaning a regular EOF is received or the connection was
			 *         aborted or closed).
			 *         
			 */
			connection_lost(exc): Promise<any>
			connection_lost$({ exc }): Promise<any>

			/**
			 * Called when the low-level transport's buffer goes over
			 *         the high-water mark.
			 *         
			 */
			pause_writing(): Promise<any>
			pause_writing$($: {}): Promise<any>

			/**
			 * Called when the low-level transport's buffer drains below
			 *         the low-water mark.
			 *         
			 */
			resume_writing(): Promise<any>
			resume_writing$($: {}): Promise<any>

			/**
			 * Called when some SSL data is received.
			 * 
			 *         The argument is a bytes object.
			 *         
			 */
			data_received(data): Promise<any>
			data_received$({ data }): Promise<any>

			/**
			 * Called when the other end of the low-level stream
			 *         is half-closed.
			 * 
			 *         If this returns a false value (including None), the transport
			 *         will close itself.  If it returns a true value, closing the
			 *         transport is up to the protocol.
			 *         
			 */
			eof_received(): Promise<any>
			eof_received$($: {}): Promise<any>
		}
	}
	module staggered {
		var _
		let loop: Promise<any>
		let enum_coro_fns: Promise<any>
		let winner_result: Promise<any>
		let winner_index: Promise<any>
		let exceptions: Promise<any>
		let running_tasks: Promise<any>
		let this_failed: Promise<any>
		let next_task: Promise<any>
		let result: Promise<any>
		let first_task: Promise<any>
		let done_count: Promise<any>
	}
	module streams {
		var _
		function factory(): Promise<any>
		function factory$($: {}): Promise<any>
		function factory(): Promise<any>
		function factory$($: {}): Promise<any>

		/**
		 * Reusable flow control logic for StreamWriter.drain().
		 * 
		 *     This implements the protocol methods pause_writing(),
		 *     resume_writing() and connection_lost().  If the subclass overrides
		 *     these it must call the super methods.
		 * 
		 *     StreamWriter.drain() must wait for _drain_helper() coroutine.
		 *     
		 */
		function FlowControlMixin(loop?): Promise<IFlowControlMixin>
		function FlowControlMixin$({ loop }: { loop?}): Promise<IFlowControlMixin>
		interface IFlowControlMixin {
			pause_writing(): Promise<any>
			pause_writing$($: {}): Promise<any>
			resume_writing(): Promise<any>
			resume_writing$($: {}): Promise<any>
			connection_lost(exc): Promise<any>
			connection_lost$({ exc }): Promise<any>
		}

		/**
		 * Helper class to adapt between Protocol and StreamReader.
		 * 
		 *     (This is a helper class instead of making StreamReader itself a
		 *     Protocol subclass, because the StreamReader has other potential
		 *     uses, and to prevent the user of the StreamReader to accidentally
		 *     call inappropriate methods of the protocol.)
		 *     
		 */
		function StreamReaderProtocol(stream_reader, client_connected_cb?, loop?): Promise<IStreamReaderProtocol>
		function StreamReaderProtocol$({ stream_reader, client_connected_cb, loop }: { stream_reader, client_connected_cb?, loop?}): Promise<IStreamReaderProtocol>
		interface IStreamReaderProtocol extends IFlowControlMixin {
			connection_made(transport): Promise<any>
			connection_made$({ transport }): Promise<any>
			connection_lost(exc): Promise<any>
			connection_lost$({ exc }): Promise<any>
			data_received(data): Promise<any>
			data_received$({ data }): Promise<any>
			eof_received(): Promise<any>
			eof_received$($: {}): Promise<any>
		}

		/**
		 * Wraps a Transport.
		 * 
		 *     This exposes write(), writelines(), [can_]write_eof(),
		 *     get_extra_info() and close().  It adds drain() which returns an
		 *     optional Future on which you can wait for flow control.  It also
		 *     adds a transport property which references the Transport
		 *     directly.
		 *     
		 */
		function StreamWriter(transport, protocol, reader, loop): Promise<IStreamWriter>
		function StreamWriter$({ transport, protocol, reader, loop }): Promise<IStreamWriter>
		interface IStreamWriter {
			transport(): Promise<any>
			transport$($: {}): Promise<any>
			write(data): Promise<any>
			write$({ data }): Promise<any>
			writelines(data): Promise<any>
			writelines$({ data }): Promise<any>
			write_eof(): Promise<any>
			write_eof$($: {}): Promise<any>
			can_write_eof(): Promise<any>
			can_write_eof$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			is_closing(): Promise<any>
			is_closing$($: {}): Promise<any>
			get_extra_info(name, def?): Promise<any>
			get_extra_info$({ name, def }: { name, def?}): Promise<any>
		}
		function StreamReader(limit?, loop?): Promise<IStreamReader>
		function StreamReader$({ limit, loop }: { limit?, loop?}): Promise<IStreamReader>
		interface IStreamReader {
			exception(): Promise<any>
			exception$($: {}): Promise<any>
			set_exception(exc): Promise<any>
			set_exception$({ exc }): Promise<any>
			set_transport(transport): Promise<any>
			set_transport$({ transport }): Promise<any>
			feed_eof(): Promise<any>
			feed_eof$($: {}): Promise<any>

			/**
			 * Return True if the buffer is empty and 'feed_eof' was called.
			 */
			at_eof(): Promise<any>
			at_eof$($: {}): Promise<any>
			feed_data(data): Promise<any>
			feed_data$({ data }): Promise<any>
		}
		let loop: Promise<any>
		let reader: Promise<any>
		let protocol: Promise<any>
		let writer: Promise<any>
	}
	module subprocess {
		var _

		/**
		 * Like StreamReaderProtocol, but for a subprocess.
		 */
		function SubprocessStreamProtocol(limit, loop): Promise<ISubprocessStreamProtocol>
		function SubprocessStreamProtocol$({ limit, loop }): Promise<ISubprocessStreamProtocol>
		interface ISubprocessStreamProtocol {
			connection_made(transport): Promise<any>
			connection_made$({ transport }): Promise<any>
			pipe_data_received(fd, data): Promise<any>
			pipe_data_received$({ fd, data }): Promise<any>
			pipe_connection_lost(fd, exc): Promise<any>
			pipe_connection_lost$({ fd, exc }): Promise<any>
			process_exited(): Promise<any>
			process_exited$($: {}): Promise<any>
		}
		function Process(transport, protocol, loop): Promise<IProcess>
		function Process$({ transport, protocol, loop }): Promise<IProcess>
		interface IProcess {
			returncode(): Promise<any>
			returncode$($: {}): Promise<any>
			send_signal(signal): Promise<any>
			send_signal$({ signal }): Promise<any>
			terminate(): Promise<any>
			terminate$($: {}): Promise<any>
			kill(): Promise<any>
			kill$($: {}): Promise<any>
		}
		let PIPE: Promise<any>
		let STDOUT: Promise<any>
		let DEVNULL: Promise<any>
		let loop: Promise<any>
		let protocol_factory: Promise<any>
	}
	module tasks {
		var _

		/**
		 * Return a currently executed task.
		 */
		function current_task(loop?): Promise<any>
		function current_task$({ loop }: { loop?}): Promise<any>

		/**
		 * Return a set of all tasks for the loop.
		 */
		function all_tasks(loop?): Promise<any>
		function all_tasks$({ loop }: { loop?}): Promise<any>

		/**
		 * Schedule the execution of a coroutine object in a spawn task.
		 * 
		 *     Return a Task object.
		 *     
		 */
		function create_task(coro): Promise<any>
		function create_task$({ coro }): Promise<any>

		/**
		 * Return an iterator whose values are coroutines.
		 * 
		 *     When waiting for the yielded coroutines you'll get the results (or
		 *     exceptions!) of the original Futures (or coroutines), in the order
		 *     in which and as soon as they complete.
		 * 
		 *     This differs from PEP 3148; the proper way to use this is:
		 * 
		 *         for f in as_completed(fs):
		 *             result = await f  # The 'await' may raise.
		 *             # Use result.
		 * 
		 *     If a timeout is specified, the 'await' will raise
		 *     TimeoutError when the timeout occurs before all Futures are done.
		 * 
		 *     Note: The futures 'f' are not necessarily members of fs.
		 *     
		 */
		function as_completed(fs): Promise<any>
		function as_completed$({ fs }): Promise<any>

		/**
		 * Wrap a coroutine or an awaitable in a future.
		 * 
		 *     If the argument is a Future, it is returned directly.
		 *     
		 */
		function ensure_future(coro_or_future): Promise<any>
		function ensure_future$({ coro_or_future }): Promise<any>

		/**
		 * Return a future aggregating results from the given coroutines/futures.
		 * 
		 *     Coroutines will be wrapped in a future and scheduled in the event
		 *     loop. They will not necessarily be scheduled in the same order as
		 *     passed in.
		 * 
		 *     All futures must share the same event loop.  If all the tasks are
		 *     done successfully, the returned future's result is the list of
		 *     results (in the order of the original sequence, not necessarily
		 *     the order of results arrival).  If *return_exceptions* is True,
		 *     exceptions in the tasks are treated the same as successful
		 *     results, and gathered in the result list; otherwise, the first
		 *     raised exception will be immediately propagated to the returned
		 *     future.
		 * 
		 *     Cancellation: if the outer Future is cancelled, all children (that
		 *     have not completed yet) are also cancelled.  If any child is
		 *     cancelled, this is treated as if it raised CancelledError --
		 *     the outer Future is *not* cancelled in this case.  (This is to
		 *     prevent the cancellation of one child to cause other children to
		 *     be cancelled.)
		 * 
		 *     If *return_exceptions* is False, cancelling gather() after it
		 *     has been marked done won't cancel any submitted awaitables.
		 *     For instance, gather can be marked done after propagating an
		 *     exception to the caller, therefore, calling ``gather.cancel()``
		 *     after catching an exception (raised by one of the awaitables) from
		 *     gather won't cancel any other awaitables.
		 *     
		 */
		function gather(): Promise<any>
		function gather$($: {}): Promise<any>

		/**
		 * Wait for a future, shielding it from cancellation.
		 * 
		 *     The statement
		 * 
		 *         res = await shield(something())
		 * 
		 *     is exactly equivalent to the statement
		 * 
		 *         res = await something()
		 * 
		 *     *except* that if the coroutine containing it is cancelled, the
		 *     task running in something() is not cancelled.  From the POV of
		 *     something(), the cancellation did not happen.  But its caller is
		 *     still cancelled, so the yield-from expression still raises
		 *     CancelledError.  Note: If something() is cancelled by other means
		 *     this will still cancel shield().
		 * 
		 *     If you want to completely ignore cancellation (not recommended)
		 *     you can combine shield() with a try/except clause, as follows:
		 * 
		 *         try:
		 *             res = await shield(something())
		 *         except CancelledError:
		 *             res = None
		 *     
		 */
		function shield(arg): Promise<any>
		function shield$({ arg }): Promise<any>

		/**
		 * Submit a coroutine object to a given event loop.
		 * 
		 *     Return a concurrent.futures.Future to access the result.
		 *     
		 */
		function run_coroutine_threadsafe(coro, loop): Promise<any>
		function run_coroutine_threadsafe$({ coro, loop }): Promise<any>

		/**
		 * A coroutine wrapped in a Future.
		 */
		function Task(coro): Promise<ITask>
		function Task$({ coro }): Promise<ITask>
		interface ITask {
			get_coro(): Promise<any>
			get_coro$($: {}): Promise<any>
			get_name(): Promise<any>
			get_name$($: {}): Promise<any>
			set_name(value): Promise<any>
			set_name$({ value }): Promise<any>
			set_result(result): Promise<any>
			set_result$({ result }): Promise<any>
			set_exception(exception): Promise<any>
			set_exception$({ exception }): Promise<any>

			/**
			 * Return the list of stack frames for this task's coroutine.
			 * 
			 *         If the coroutine is not done, this returns the stack where it is
			 *         suspended.  If the coroutine has completed successfully or was
			 *         cancelled, this returns an empty list.  If the coroutine was
			 *         terminated by an exception, this returns the list of traceback
			 *         frames.
			 * 
			 *         The frames are always ordered from oldest to newest.
			 * 
			 *         The optional limit gives the maximum number of frames to
			 *         return; by default all available frames are returned.  Its
			 *         meaning differs depending on whether a stack or a traceback is
			 *         returned: the newest frames of a stack are returned, but the
			 *         oldest frames of a traceback are returned.  (This matches the
			 *         behavior of the traceback module.)
			 * 
			 *         For reasons beyond our control, only one stack frame is
			 *         returned for a suspended coroutine.
			 *         
			 */
			get_stack(): Promise<any>
			get_stack$($: {}): Promise<any>

			/**
			 * Print the stack or traceback for this task's coroutine.
			 * 
			 *         This produces output similar to that of the traceback module,
			 *         for the frames retrieved by get_stack().  The limit argument
			 *         is passed to get_stack().  The file argument is an I/O stream
			 *         to which the output is written; by default output is written
			 *         to sys.stderr.
			 *         
			 */
			print_stack(): Promise<any>
			print_stack$($: {}): Promise<any>

			/**
			 * Request that this task cancel itself.
			 * 
			 *         This arranges for a CancelledError to be thrown into the
			 *         wrapped coroutine on the next cycle through the event loop.
			 *         The coroutine then has a chance to clean up or even deny
			 *         the request using try/except/finally.
			 * 
			 *         Unlike Future.cancel, this does not guarantee that the
			 *         task will be cancelled: the exception might be caught and
			 *         acted upon, delaying cancellation of the task or preventing
			 *         cancellation completely.  The task may also return a value or
			 *         raise a different exception.
			 * 
			 *         Immediately after this method is called, Task.cancelled() will
			 *         not return True (unless the task was already cancelled).  A
			 *         task will be marked as cancelled when the wrapped coroutine
			 *         terminates with a CancelledError exception (even if cancel()
			 *         was not called).
			 *         
			 */
			cancel(msg?): Promise<any>
			cancel$({ msg }: { msg?}): Promise<any>
		}

		/**
		 * Helper for gather().
		 * 
		 *     This overrides cancel() to cancel all the children and act more
		 *     like Task.cancel(), which doesn't immediately mark itself as
		 *     cancelled.
		 *     
		 */
		interface I_GatheringFuture {
			cancel(msg?): Promise<any>
			cancel$({ msg }: { msg?}): Promise<any>
		}
		let FIRST_COMPLETED: Promise<any>
		let FIRST_EXCEPTION: Promise<any>
		let ALL_COMPLETED: Promise<any>
		let loop: Promise<any>
		let fs: Promise<any>
		let fut: Promise<any>
		let waiter: Promise<any>
		let timeout_handle: Promise<any>
		let cb: Promise<any>
		let counter: Promise<any>
		let future: Promise<any>
		let h: Promise<any>
	}
	module threads {
		var _
		let loop: Promise<any>
		let ctx: Promise<any>
		let func_call: Promise<any>
	}
	module transports {
		var _

		/**
		 * Base class for transports.
		 */
		function BaseTransport(extra?): Promise<IBaseTransport>
		function BaseTransport$({ extra }: { extra?}): Promise<IBaseTransport>
		interface IBaseTransport {

			/**
			 * Get optional transport information.
			 */
			get_extra_info(name, def?): Promise<any>
			get_extra_info$({ name, def }: { name, def?}): Promise<any>

			/**
			 * Return True if the transport is closing or closed.
			 */
			is_closing(): Promise<any>
			is_closing$($: {}): Promise<any>

			/**
			 * Close the transport.
			 * 
			 *         Buffered data will be flushed asynchronously.  No more data
			 *         will be received.  After all buffered data is flushed, the
			 *         protocol's connection_lost() method will (eventually) be
			 *         called with None as its argument.
			 *         
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Set a new protocol.
			 */
			set_protocol(protocol): Promise<any>
			set_protocol$({ protocol }): Promise<any>

			/**
			 * Return the current protocol.
			 */
			get_protocol(): Promise<any>
			get_protocol$($: {}): Promise<any>
		}

		/**
		 * Interface for read-only transports.
		 */
		interface IReadTransport extends IBaseTransport {

			/**
			 * Return True if the transport is receiving.
			 */
			is_reading(): Promise<any>
			is_reading$($: {}): Promise<any>

			/**
			 * Pause the receiving end.
			 * 
			 *         No data will be passed to the protocol's data_received()
			 *         method until resume_reading() is called.
			 *         
			 */
			pause_reading(): Promise<any>
			pause_reading$($: {}): Promise<any>

			/**
			 * Resume the receiving end.
			 * 
			 *         Data received will once again be passed to the protocol's
			 *         data_received() method.
			 *         
			 */
			resume_reading(): Promise<any>
			resume_reading$($: {}): Promise<any>
		}

		/**
		 * Interface for write-only transports.
		 */
		interface IWriteTransport extends IBaseTransport {

			/**
			 * Set the high- and low-water limits for write flow control.
			 * 
			 *         These two values control when to call the protocol's
			 *         pause_writing() and resume_writing() methods.  If specified,
			 *         the low-water limit must be less than or equal to the
			 *         high-water limit.  Neither value can be negative.
			 * 
			 *         The defaults are implementation-specific.  If only the
			 *         high-water limit is given, the low-water limit defaults to an
			 *         implementation-specific value less than or equal to the
			 *         high-water limit.  Setting high to zero forces low to zero as
			 *         well, and causes pause_writing() to be called whenever the
			 *         buffer becomes non-empty.  Setting low to zero causes
			 *         resume_writing() to be called only once the buffer is empty.
			 *         Use of zero for either limit is generally sub-optimal as it
			 *         reduces opportunities for doing I/O and computation
			 *         concurrently.
			 *         
			 */
			set_write_buffer_limits(high?, low?): Promise<any>
			set_write_buffer_limits$({ high, low }: { high?, low?}): Promise<any>

			/**
			 * Return the current size of the write buffer.
			 */
			get_write_buffer_size(): Promise<any>
			get_write_buffer_size$($: {}): Promise<any>

			/**
			 * Write some data bytes to the transport.
			 * 
			 *         This does not block; it buffers the data and arranges for it
			 *         to be sent out asynchronously.
			 *         
			 */
			write(data): Promise<any>
			write$({ data }): Promise<any>

			/**
			 * Write a list (or any iterable) of data bytes to the transport.
			 * 
			 *         The default implementation concatenates the arguments and
			 *         calls write() on the result.
			 *         
			 */
			writelines(list_of_data): Promise<any>
			writelines$({ list_of_data }): Promise<any>

			/**
			 * Close the write end after flushing buffered data.
			 * 
			 *         (This is like typing ^D into a UNIX program reading from stdin.)
			 * 
			 *         Data may still be received.
			 *         
			 */
			write_eof(): Promise<any>
			write_eof$($: {}): Promise<any>

			/**
			 * Return True if this transport supports write_eof(), False if not.
			 */
			can_write_eof(): Promise<any>
			can_write_eof$($: {}): Promise<any>

			/**
			 * Close the transport immediately.
			 * 
			 *         Buffered data will be lost.  No more data will be received.
			 *         The protocol's connection_lost() method will (eventually) be
			 *         called with None as its argument.
			 *         
			 */
			abort(): Promise<any>
			abort$($: {}): Promise<any>
		}

		/**
		 * Interface representing a bidirectional transport.
		 * 
		 *     There may be several implementations, but typically, the user does
		 *     not implement new transports; rather, the platform provides some
		 *     useful transports that are implemented using the platform's best
		 *     practices.
		 * 
		 *     The user never instantiates a transport directly; they call a
		 *     utility function, passing it a protocol factory and other
		 *     information necessary to create the transport and protocol.  (E.g.
		 *     EventLoop.create_connection() or EventLoop.create_server().)
		 * 
		 *     The utility function will asynchronously create a transport and a
		 *     protocol and hook them up by calling the protocol's
		 *     connection_made() method, passing it the transport.
		 * 
		 *     The implementation here raises NotImplemented for every method
		 *     except writelines(), which calls write() in a loop.
		 *     
		 */
		interface ITransport extends IReadTransport, IWriteTransport {
		}

		/**
		 * Interface for datagram (UDP) transports.
		 */
		interface IDatagramTransport extends IBaseTransport {

			/**
			 * Send data to the transport.
			 * 
			 *         This does not block; it buffers the data and arranges for it
			 *         to be sent out asynchronously.
			 *         addr is target socket address.
			 *         If addr is None use target address pointed on transport creation.
			 *         
			 */
			sendto(data, addr?): Promise<any>
			sendto$({ data, addr }: { data, addr?}): Promise<any>

			/**
			 * Close the transport immediately.
			 * 
			 *         Buffered data will be lost.  No more data will be received.
			 *         The protocol's connection_lost() method will (eventually) be
			 *         called with None as its argument.
			 *         
			 */
			abort(): Promise<any>
			abort$($: {}): Promise<any>
		}
		interface ISubprocessTransport extends IBaseTransport {

			/**
			 * Get subprocess id.
			 */
			get_pid(): Promise<any>
			get_pid$($: {}): Promise<any>

			/**
			 * Get subprocess returncode.
			 * 
			 *         See also
			 *         http://docs.python.org/3/library/subprocess#subprocess.Popen.returncode
			 *         
			 */
			get_returncode(): Promise<any>
			get_returncode$($: {}): Promise<any>

			/**
			 * Get transport for pipe with number fd.
			 */
			get_pipe_transport(fd): Promise<any>
			get_pipe_transport$({ fd }): Promise<any>

			/**
			 * Send signal to subprocess.
			 * 
			 *         See also:
			 *         docs.python.org/3/library/subprocess#subprocess.Popen.send_signal
			 *         
			 */
			send_signal(signal): Promise<any>
			send_signal$({ signal }): Promise<any>

			/**
			 * Stop the subprocess.
			 * 
			 *         Alias for close() method.
			 * 
			 *         On Posix OSs the method sends SIGTERM to the subprocess.
			 *         On Windows the Win32 API function TerminateProcess()
			 *          is called to stop the subprocess.
			 * 
			 *         See also:
			 *         http://docs.python.org/3/library/subprocess#subprocess.Popen.terminate
			 *         
			 */
			terminate(): Promise<any>
			terminate$($: {}): Promise<any>

			/**
			 * Kill the subprocess.
			 * 
			 *         On Posix OSs the function sends SIGKILL to the subprocess.
			 *         On Windows kill() is an alias for terminate().
			 * 
			 *         See also:
			 *         http://docs.python.org/3/library/subprocess#subprocess.Popen.kill
			 *         
			 */
			kill(): Promise<any>
			kill$($: {}): Promise<any>
		}

		/**
		 * All the logic for (write) flow control in a mix-in base class.
		 * 
		 *     The subclass must implement get_write_buffer_size().  It must call
		 *     _maybe_pause_protocol() whenever the write buffer size increases,
		 *     and _maybe_resume_protocol() whenever it decreases.  It may also
		 *     override set_write_buffer_limits() (e.g. to specify different
		 *     defaults).
		 * 
		 *     The subclass constructor must call super().__init__(extra).  This
		 *     will call set_write_buffer_limits().
		 * 
		 *     The user may call set_write_buffer_limits() and
		 *     get_write_buffer_size(), and their protocol's pause_writing() and
		 *     resume_writing() may be called.
		 *     
		 */
		interface I_FlowControlMixin extends ITransport {
			get_write_buffer_limits(): Promise<any>
			get_write_buffer_limits$($: {}): Promise<any>
			set_write_buffer_limits(high?, low?): Promise<any>
			set_write_buffer_limits$({ high, low }: { high?, low?}): Promise<any>
			get_write_buffer_size(): Promise<any>
			get_write_buffer_size$($: {}): Promise<any>
		}
	}
	module trsock {
		var _

		/**
		 * A socket-like wrapper for exposing real transport sockets.
		 * 
		 *     These objects can be safely returned by APIs like
		 *     `transport.get_extra_info('socket')`.  All potentially disruptive
		 *     operations (like "socket.close()") are banned.
		 *     
		 */
		function TransportSocket(sock): Promise<ITransportSocket>
		function TransportSocket$({ sock }): Promise<ITransportSocket>
		interface ITransportSocket {
			family(): Promise<any>
			family$($: {}): Promise<any>
			type(): Promise<any>
			type$($: {}): Promise<any>
			proto(): Promise<any>
			proto$($: {}): Promise<any>
			fileno(): Promise<any>
			fileno$($: {}): Promise<any>
			dup(): Promise<any>
			dup$($: {}): Promise<any>
			get_inheritable(): Promise<any>
			get_inheritable$($: {}): Promise<any>
			shutdown(how): Promise<any>
			shutdown$({ how }): Promise<any>
			getsockopt(): Promise<any>
			getsockopt$($: {}): Promise<any>
			setsockopt(): Promise<any>
			setsockopt$($: {}): Promise<any>
			getpeername(): Promise<any>
			getpeername$($: {}): Promise<any>
			getsockname(): Promise<any>
			getsockname$($: {}): Promise<any>
			getsockbyname(): Promise<any>
			getsockbyname$($: {}): Promise<any>
			accept(): Promise<any>
			accept$($: {}): Promise<any>
			connect(): Promise<any>
			connect$($: {}): Promise<any>
			connect_ex(): Promise<any>
			connect_ex$($: {}): Promise<any>
			bind(): Promise<any>
			bind$($: {}): Promise<any>
			ioctl(): Promise<any>
			ioctl$($: {}): Promise<any>
			listen(): Promise<any>
			listen$($: {}): Promise<any>
			makefile(): Promise<any>
			makefile$($: {}): Promise<any>
			sendfile(): Promise<any>
			sendfile$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			detach(): Promise<any>
			detach$($: {}): Promise<any>
			sendmsg_afalg(): Promise<any>
			sendmsg_afalg$($: {}): Promise<any>
			sendmsg(): Promise<any>
			sendmsg$($: {}): Promise<any>
			sendto(): Promise<any>
			sendto$($: {}): Promise<any>
			send(): Promise<any>
			send$($: {}): Promise<any>
			sendall(): Promise<any>
			sendall$($: {}): Promise<any>
			set_inheritable(): Promise<any>
			set_inheritable$($: {}): Promise<any>
			share(process_id): Promise<any>
			share$({ process_id }): Promise<any>
			recv_into(): Promise<any>
			recv_into$($: {}): Promise<any>
			recvfrom_into(): Promise<any>
			recvfrom_into$($: {}): Promise<any>
			recvmsg_into(): Promise<any>
			recvmsg_into$($: {}): Promise<any>
			recvmsg(): Promise<any>
			recvmsg$($: {}): Promise<any>
			recvfrom(): Promise<any>
			recvfrom$($: {}): Promise<any>
			recv(): Promise<any>
			recv$($: {}): Promise<any>
			settimeout(value): Promise<any>
			settimeout$({ value }): Promise<any>
			gettimeout(): Promise<any>
			gettimeout$($: {}): Promise<any>
			setblocking(flag): Promise<any>
			setblocking$({ flag }): Promise<any>
		}
	}
	module unix_events {
		var _
		function waitstatus_to_exitcode(status): Promise<any>
		function waitstatus_to_exitcode$({ status }): Promise<any>

		/**
		 * Unix event loop.
		 * 
		 *     Adds signal handling and UNIX Domain Socket support to SelectorEventLoop.
		 *     
		 */
		interface I_UnixSelectorEventLoop {
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Add a handler for a signal.  UNIX only.
			 * 
			 *         Raise ValueError if the signal number is invalid or uncatchable.
			 *         Raise RuntimeError if there is a problem setting up the handler.
			 *         
			 */
			add_signal_handler(sig, callback): Promise<any>
			add_signal_handler$({ sig, callback }): Promise<any>

			/**
			 * Remove a handler for a signal.  UNIX only.
			 * 
			 *         Return True if a signal handler was removed, False if not.
			 *         
			 */
			remove_signal_handler(sig): Promise<any>
			remove_signal_handler$({ sig }): Promise<any>
		}
		interface I_UnixReadPipeTransport {
			pause_reading(): Promise<any>
			pause_reading$($: {}): Promise<any>
			resume_reading(): Promise<any>
			resume_reading$($: {}): Promise<any>
			set_protocol(protocol): Promise<any>
			set_protocol$({ protocol }): Promise<any>
			get_protocol(): Promise<any>
			get_protocol$($: {}): Promise<any>
			is_closing(): Promise<any>
			is_closing$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			max_size
		}
		interface I_UnixWritePipeTransport {
			get_write_buffer_size(): Promise<any>
			get_write_buffer_size$($: {}): Promise<any>
			write(data): Promise<any>
			write$({ data }): Promise<any>
			can_write_eof(): Promise<any>
			can_write_eof$($: {}): Promise<any>
			write_eof(): Promise<any>
			write_eof$($: {}): Promise<any>
			set_protocol(protocol): Promise<any>
			set_protocol$({ protocol }): Promise<any>
			get_protocol(): Promise<any>
			get_protocol$($: {}): Promise<any>
			is_closing(): Promise<any>
			is_closing$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			abort(): Promise<any>
			abort$($: {}): Promise<any>
		}
		interface I_UnixSubprocessTransport {
		}

		/**
		 * Abstract base class for monitoring child processes.
		 * 
		 *     Objects derived from this class monitor a collection of subprocesses and
		 *     report their termination or interruption by a signal.
		 * 
		 *     New callbacks are registered with .add_child_handler(). Starting a new
		 *     process must be done within a 'with' block to allow the watcher to suspend
		 *     its activity until the new process if fully registered (this is needed to
		 *     prevent a race condition in some implementations).
		 * 
		 *     Example:
		 *         with watcher:
		 *             proc = subprocess.Popen("sleep 1")
		 *             watcher.add_child_handler(proc.pid, callback)
		 * 
		 *     Notes:
		 *         Implementations of this class must be thread-safe.
		 * 
		 *         Since child watcher objects may catch the SIGCHLD signal and call
		 *         waitpid(-1), there should be only one active object per process.
		 *     
		 */
		interface IAbstractChildWatcher {

			/**
			 * Register a new child handler.
			 * 
			 *         Arrange for callback(pid, returncode, *args) to be called when
			 *         process 'pid' terminates. Specifying another callback for the same
			 *         process replaces the previous handler.
			 * 
			 *         Note: callback() must be thread-safe.
			 *         
			 */
			add_child_handler(pid, callback): Promise<any>
			add_child_handler$({ pid, callback }): Promise<any>

			/**
			 * Removes the handler for process 'pid'.
			 * 
			 *         The function returns True if the handler was successfully removed,
			 *         False if there was nothing to remove.
			 */
			remove_child_handler(pid): Promise<any>
			remove_child_handler$({ pid }): Promise<any>

			/**
			 * Attach the watcher to an event loop.
			 * 
			 *         If the watcher was previously attached to an event loop, then it is
			 *         first detached before attaching to the new loop.
			 * 
			 *         Note: loop may be None.
			 *         
			 */
			attach_loop(loop): Promise<any>
			attach_loop$({ loop }): Promise<any>

			/**
			 * Close the watcher.
			 * 
			 *         This must be called to make sure that any underlying resource is freed.
			 *         
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Return ``True`` if the watcher is active and is used by the event loop.
			 * 
			 *         Return True if the watcher is installed and ready to handle process exit
			 *         notifications.
			 * 
			 *         
			 */
			is_active(): Promise<any>
			is_active$($: {}): Promise<any>
		}

		/**
		 * Child watcher implementation using Linux's pid file descriptors.
		 * 
		 *     This child watcher polls process file descriptors (pidfds) to await child
		 *     process termination. In some respects, PidfdChildWatcher is a "Goldilocks"
		 *     child watcher implementation. It doesn't require signals or threads, doesn't
		 *     interfere with any processes launched outside the event loop, and scales
		 *     linearly with the number of subprocesses launched by the event loop. The
		 *     main disadvantage is that pidfds are specific to Linux, and only work on
		 *     recent (5.3+) kernels.
		 *     
		 */
		function PidfdChildWatcher(): Promise<IPidfdChildWatcher>
		function PidfdChildWatcher$({ }): Promise<IPidfdChildWatcher>
		interface IPidfdChildWatcher extends IAbstractChildWatcher {
			is_active(): Promise<any>
			is_active$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			attach_loop(loop): Promise<any>
			attach_loop$({ loop }): Promise<any>
			add_child_handler(pid, callback): Promise<any>
			add_child_handler$({ pid, callback }): Promise<any>
			remove_child_handler(pid): Promise<any>
			remove_child_handler$({ pid }): Promise<any>
		}
		function BaseChildWatcher(): Promise<IBaseChildWatcher>
		function BaseChildWatcher$({ }): Promise<IBaseChildWatcher>
		interface IBaseChildWatcher extends IAbstractChildWatcher {
			close(): Promise<any>
			close$($: {}): Promise<any>
			is_active(): Promise<any>
			is_active$($: {}): Promise<any>
			attach_loop(loop): Promise<any>
			attach_loop$({ loop }): Promise<any>
		}

		/**
		 * 'Safe' child watcher implementation.
		 * 
		 *     This implementation avoids disrupting other code spawning processes by
		 *     polling explicitly each process in the SIGCHLD handler instead of calling
		 *     os.waitpid(-1).
		 * 
		 *     This is a safe solution but it has a significant overhead when handling a
		 *     big number of children (O(n) each time SIGCHLD is raised)
		 *     
		 */
		interface ISafeChildWatcher extends IBaseChildWatcher {
			close(): Promise<any>
			close$($: {}): Promise<any>
			add_child_handler(pid, callback): Promise<any>
			add_child_handler$({ pid, callback }): Promise<any>
			remove_child_handler(pid): Promise<any>
			remove_child_handler$({ pid }): Promise<any>
		}

		/**
		 * 'Fast' child watcher implementation.
		 * 
		 *     This implementation reaps every terminated processes by calling
		 *     os.waitpid(-1) directly, possibly breaking other code spawning processes
		 *     and waiting for their termination.
		 * 
		 *     There is no noticeable overhead when handling a big number of children
		 *     (O(1) each time a child terminates).
		 *     
		 */
		function FastChildWatcher(): Promise<IFastChildWatcher>
		function FastChildWatcher$({ }): Promise<IFastChildWatcher>
		interface IFastChildWatcher extends IBaseChildWatcher {
			close(): Promise<any>
			close$($: {}): Promise<any>
			add_child_handler(pid, callback): Promise<any>
			add_child_handler$({ pid, callback }): Promise<any>
			remove_child_handler(pid): Promise<any>
			remove_child_handler$({ pid }): Promise<any>
		}

		/**
		 * A watcher that doesn't require running loop in the main thread.
		 * 
		 *     This implementation registers a SIGCHLD signal handler on
		 *     instantiation (which may conflict with other code that
		 *     install own handler for this signal).
		 * 
		 *     The solution is safe but it has a significant overhead when
		 *     handling a big number of processes (*O(n)* each time a
		 *     SIGCHLD is received).
		 *     
		 */
		function MultiLoopChildWatcher(): Promise<IMultiLoopChildWatcher>
		function MultiLoopChildWatcher$({ }): Promise<IMultiLoopChildWatcher>
		interface IMultiLoopChildWatcher extends IAbstractChildWatcher {
			is_active(): Promise<any>
			is_active$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			add_child_handler(pid, callback): Promise<any>
			add_child_handler$({ pid, callback }): Promise<any>
			remove_child_handler(pid): Promise<any>
			remove_child_handler$({ pid }): Promise<any>
			attach_loop(loop): Promise<any>
			attach_loop$({ loop }): Promise<any>
		}

		/**
		 * Threaded child watcher implementation.
		 * 
		 *     The watcher uses a thread per process
		 *     for waiting for the process finish.
		 * 
		 *     It doesn't require subscription on POSIX signal
		 *     but a thread creation is not free.
		 * 
		 *     The watcher has O(1) complexity, its performance doesn't depend
		 *     on amount of spawn processes.
		 *     
		 */
		function ThreadedChildWatcher(): Promise<IThreadedChildWatcher>
		function ThreadedChildWatcher$({ }): Promise<IThreadedChildWatcher>
		interface IThreadedChildWatcher extends IAbstractChildWatcher {
			is_active(): Promise<any>
			is_active$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			add_child_handler(pid, callback): Promise<any>
			add_child_handler$({ pid, callback }): Promise<any>
			remove_child_handler(pid): Promise<any>
			remove_child_handler$({ pid }): Promise<any>
			attach_loop(loop): Promise<any>
			attach_loop$({ loop }): Promise<any>
		}

		/**
		 * UNIX event loop policy with a watcher for child processes.
		 */
		interface I_UnixDefaultEventLoopPolicy {

			/**
			 * Set the event loop.
			 * 
			 *         As a side effect, if a child watcher was set before, then calling
			 *         .set_event_loop() from the main thread will call .attach_loop(loop) on
			 *         the child watcher.
			 *         
			 */
			set_event_loop(loop): Promise<any>
			set_event_loop$({ loop }): Promise<any>

			/**
			 * Get the watcher for child processes.
			 * 
			 *         If not yet set, a ThreadedChildWatcher object is automatically created.
			 *         
			 */
			get_child_watcher(): Promise<any>
			get_child_watcher$($: {}): Promise<any>

			/**
			 * Set the watcher for child processes.
			 */
			set_child_watcher(watcher): Promise<any>
			set_child_watcher$({ watcher }): Promise<any>
		}
		let SelectorEventLoop: Promise<any>
		let DefaultEventLoopPolicy: Promise<any>
	}
	module windows_events {
		var _

		/**
		 * Subclass of Future which represents an overlapped operation.
		 * 
		 *     Cancelling it will immediately cancel the overlapped operation.
		 *     
		 */
		interface I_OverlappedFuture {
			cancel(msg?): Promise<any>
			cancel$({ msg }: { msg?}): Promise<any>
			set_exception(exception): Promise<any>
			set_exception$({ exception }): Promise<any>
			set_result(result): Promise<any>
			set_result$({ result }): Promise<any>
		}

		/**
		 * Subclass of Future which represents a wait handle.
		 */
		interface I_BaseWaitHandleFuture {
			cancel(msg?): Promise<any>
			cancel$({ msg }: { msg?}): Promise<any>
			set_exception(exception): Promise<any>
			set_exception$({ exception }): Promise<any>
			set_result(result): Promise<any>
			set_result$({ result }): Promise<any>
		}

		/**
		 * Subclass of Future which represents a wait for the cancellation of a
		 *     _WaitHandleFuture using an event.
		 *     
		 */
		interface I_WaitCancelFuture extends I_BaseWaitHandleFuture {
			cancel(): Promise<any>
			cancel$($: {}): Promise<any>
			set_result(result): Promise<any>
			set_result$({ result }): Promise<any>
			set_exception(exception): Promise<any>
			set_exception$({ exception }): Promise<any>
		}
		interface I_WaitHandleFuture extends I_BaseWaitHandleFuture {
		}

		/**
		 * Class representing a pipe server.
		 * 
		 *     This is much like a bound, listening socket.
		 *     
		 */
		function PipeServer(address): Promise<IPipeServer>
		function PipeServer$({ address }): Promise<IPipeServer>
		interface IPipeServer {
			closed(): Promise<any>
			closed$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
		}

		/**
		 * Windows version of selector event loop.
		 */
		interface I_WindowsSelectorEventLoop {
		}

		/**
		 * Windows version of proactor event loop using IOCP.
		 */
		function ProactorEventLoop(proactor?): Promise<IProactorEventLoop>
		function ProactorEventLoop$({ proactor }: { proactor?}): Promise<IProactorEventLoop>
		interface IProactorEventLoop {
			run_forever(): Promise<any>
			run_forever$($: {}): Promise<any>
		}

		/**
		 * Proactor implementation using IOCP.
		 */
		function IocpProactor(concurrency?): Promise<IIocpProactor>
		function IocpProactor$({ concurrency }: { concurrency?}): Promise<IIocpProactor>
		interface IIocpProactor {
			set_loop(loop): Promise<any>
			set_loop$({ loop }): Promise<any>
			select(timeout?): Promise<any>
			select$({ timeout }: { timeout?}): Promise<any>
			recv(conn, nbytes, flags?): Promise<any>
			recv$({ conn, nbytes, flags }: { conn, nbytes, flags?}): Promise<any>
			recv_into(conn, buf, flags?): Promise<any>
			recv_into$({ conn, buf, flags }: { conn, buf, flags?}): Promise<any>
			recvfrom(conn, nbytes, flags?): Promise<any>
			recvfrom$({ conn, nbytes, flags }: { conn, nbytes, flags?}): Promise<any>
			sendto(conn, buf, flags?, addr?): Promise<any>
			sendto$({ conn, buf, flags, addr }: { conn, buf, flags?, addr?}): Promise<any>
			send(conn, buf, flags?): Promise<any>
			send$({ conn, buf, flags }: { conn, buf, flags?}): Promise<any>
			accept(listener): Promise<any>
			accept$({ listener }): Promise<any>
			connect(conn, address): Promise<any>
			connect$({ conn, address }): Promise<any>
			sendfile(sock, file, offset, count): Promise<any>
			sendfile$({ sock, file, offset, count }): Promise<any>
			accept_pipe(pipe): Promise<any>
			accept_pipe$({ pipe }): Promise<any>

			/**
			 * Wait for a handle.
			 * 
			 *         Return a Future object. The result of the future is True if the wait
			 *         completed, or False if the wait did not complete (on timeout).
			 *         
			 */
			wait_for_handle(handle, timeout?): Promise<any>
			wait_for_handle$({ handle, timeout }: { handle, timeout?}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
		}
		interface I_WindowsSubprocessTransport {
		}
		interface IWindowsSelectorEventLoopPolicy {
		}
		interface IWindowsProactorEventLoopPolicy {
		}
		let NULL: Promise<any>
		let INFINITE: Promise<any>
		let ERROR_CONNECTION_REFUSED: Promise<any>
		let ERROR_CONNECTION_ABORTED: Promise<any>
		let CONNECT_PIPE_INIT_DELAY: Promise<any>
		let CONNECT_PIPE_MAX_DELAY: Promise<any>
		let SelectorEventLoop: Promise<any>
		let DefaultEventLoopPolicy: Promise<any>
	}
	module windows_utils {
		var _

		/**
		 * Like os.pipe() but with overlapped support and using handles not fds.
		 */
		function pipe(): Promise<any>
		function pipe$($: {}): Promise<any>

		/**
		 * Wrapper for an overlapped pipe handle which is vaguely file-object like.
		 * 
		 *     The IOCP event loop can use these instead of socket objects.
		 *     
		 */
		function PipeHandle(handle): Promise<IPipeHandle>
		function PipeHandle$({ handle }): Promise<IPipeHandle>
		interface IPipeHandle {
			handle(): Promise<any>
			handle$($: {}): Promise<any>
			fileno(): Promise<any>
			fileno$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
		}

		/**
		 * Replacement for subprocess.Popen using overlapped pipe handles.
		 * 
		 *     The stdin, stdout, stderr are None or instances of PipeHandle.
		 *     
		 */
		function Popen(args, stdin?, stdout?, stderr?): Promise<IPopen>
		function Popen$({ args, stdin, stdout, stderr }: { args, stdin?, stdout?, stderr?}): Promise<IPopen>
		interface IPopen {
		}
		let BUFSIZE: Promise<any>
		let PIPE: Promise<any>
		let STDOUT: Promise<any>
	}
}
declare module asyncore {
	var _
	function read(obj): Promise<any>
	function read$({ obj }): Promise<any>
	function write(obj): Promise<any>
	function write$({ obj }): Promise<any>
	function readwrite(obj, flags): Promise<any>
	function readwrite$({ obj, flags }): Promise<any>
	function poll(timeout?, map?): Promise<any>
	function poll$({ timeout, map }: { timeout?, map?}): Promise<any>
	function poll2(timeout?, map?): Promise<any>
	function poll2$({ timeout, map }: { timeout?, map?}): Promise<any>
	function loop(timeout?, use_poll?: boolean, map?, count?): Promise<any>
	function loop$({ timeout, use_poll, map, count }: { timeout?, use_poll?, map?, count?}): Promise<any>
	function compact_traceback(): Promise<any>
	function compact_traceback$($: {}): Promise<any>
	function close_all(map?, ignore_all?: boolean): Promise<any>
	function close_all$({ map, ignore_all }: { map?, ignore_all?}): Promise<any>
	interface IExitNow {
	}
	function dispatcher(sock?, map?): Promise<Idispatcher>
	function dispatcher$({ sock, map }: { sock?, map?}): Promise<Idispatcher>
	interface Idispatcher {
		add_channel(map?): Promise<any>
		add_channel$({ map }: { map?}): Promise<any>
		del_channel(map?): Promise<any>
		del_channel$({ map }: { map?}): Promise<any>
		create_socket(family?, type?): Promise<any>
		create_socket$({ family, type }: { family?, type?}): Promise<any>
		set_socket(sock, map?): Promise<any>
		set_socket$({ sock, map }: { sock, map?}): Promise<any>
		set_reuse_addr(): Promise<any>
		set_reuse_addr$($: {}): Promise<any>
		readable(): Promise<any>
		readable$($: {}): Promise<any>
		writable(): Promise<any>
		writable$($: {}): Promise<any>
		listen(num): Promise<any>
		listen$({ num }): Promise<any>
		bind(addr): Promise<any>
		bind$({ addr }): Promise<any>
		connect(address): Promise<any>
		connect$({ address }): Promise<any>
		accept(): Promise<any>
		accept$($: {}): Promise<any>
		send(data): Promise<any>
		send$({ data }): Promise<any>
		recv(buffer_size): Promise<any>
		recv$({ buffer_size }): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
		log(message): Promise<any>
		log$({ message }): Promise<any>
		log_info(message, type?): Promise<any>
		log_info$({ message, type }: { message, type?}): Promise<any>
		handle_read_event(): Promise<any>
		handle_read_event$($: {}): Promise<any>
		handle_connect_event(): Promise<any>
		handle_connect_event$($: {}): Promise<any>
		handle_write_event(): Promise<any>
		handle_write_event$($: {}): Promise<any>
		handle_expt_event(): Promise<any>
		handle_expt_event$($: {}): Promise<any>
		handle_error(): Promise<any>
		handle_error$($: {}): Promise<any>
		handle_expt(): Promise<any>
		handle_expt$($: {}): Promise<any>
		handle_read(): Promise<any>
		handle_read$($: {}): Promise<any>
		handle_write(): Promise<any>
		handle_write$($: {}): Promise<any>
		handle_connect(): Promise<any>
		handle_connect$($: {}): Promise<any>
		handle_accept(): Promise<any>
		handle_accept$($: {}): Promise<any>
		handle_accepted(sock, addr): Promise<any>
		handle_accepted$({ sock, addr }): Promise<any>
		handle_close(): Promise<any>
		handle_close$($: {}): Promise<any>
		debug
		connected
		accepting
		connecting
		closing
		addr
		ignore_log_types
	}
	function dispatcher_with_send(sock?, map?): Promise<Idispatcher_with_send>
	function dispatcher_with_send$({ sock, map }: { sock?, map?}): Promise<Idispatcher_with_send>
	interface Idispatcher_with_send extends Idispatcher {
		initiate_send(): Promise<any>
		initiate_send$($: {}): Promise<any>
		handle_write(): Promise<any>
		handle_write$($: {}): Promise<any>
		writable(): Promise<any>
		writable$($: {}): Promise<any>
		send(data): Promise<any>
		send$({ data }): Promise<any>
	}
	function file_wrapper(fd): Promise<Ifile_wrapper>
	function file_wrapper$({ fd }): Promise<Ifile_wrapper>
	interface Ifile_wrapper {
		recv(): Promise<any>
		recv$($: {}): Promise<any>
		send(): Promise<any>
		send$($: {}): Promise<any>
		getsockopt(level, optname, buflen?): Promise<any>
		getsockopt$({ level, optname, buflen }: { level, optname, buflen?}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
		fileno(): Promise<any>
		fileno$($: {}): Promise<any>
	}
	function file_dispatcher(fd, map?): Promise<Ifile_dispatcher>
	function file_dispatcher$({ fd, map }: { fd, map?}): Promise<Ifile_dispatcher>
	interface Ifile_dispatcher extends Idispatcher {
		set_file(fd): Promise<any>
		set_file$({ fd }): Promise<any>
	}
	let poll3: Promise<any>
}
declare module base64 {
	var _

	/**
	 * Encode the bytes-like object s using Base64 and return a bytes object.
	 * 
	 *     Optional altchars should be a byte string of length 2 which specifies an
	 *     alternative alphabet for the '+' and '/' characters.  This allows an
	 *     application to e.g. generate url or filesystem safe Base64 strings.
	 *     
	 */
	function b64encode(s, altchars?): Promise<any>
	function b64encode$({ s, altchars }: { s, altchars?}): Promise<any>

	/**
	 * Decode the Base64 encoded bytes-like object or ASCII string s.
	 * 
	 *     Optional altchars must be a bytes-like object or ASCII string of length 2
	 *     which specifies the alternative alphabet used instead of the '+' and '/'
	 *     characters.
	 * 
	 *     The result is returned as a bytes object.  A binascii.Error is raised if
	 *     s is incorrectly padded.
	 * 
	 *     If validate is False (the default), characters that are neither in the
	 *     normal base-64 alphabet nor the alternative alphabet are discarded prior
	 *     to the padding check.  If validate is True, these non-alphabet characters
	 *     in the input result in a binascii.Error.
	 *     
	 */
	function b64decode(s, altchars?, validate?: boolean): Promise<any>
	function b64decode$({ s, altchars, validate }: { s, altchars?, validate?}): Promise<any>

	/**
	 * Encode bytes-like object s using the standard Base64 alphabet.
	 * 
	 *     The result is returned as a bytes object.
	 *     
	 */
	function standard_b64encode(s): Promise<any>
	function standard_b64encode$({ s }): Promise<any>

	/**
	 * Decode bytes encoded with the standard Base64 alphabet.
	 * 
	 *     Argument s is a bytes-like object or ASCII string to decode.  The result
	 *     is returned as a bytes object.  A binascii.Error is raised if the input
	 *     is incorrectly padded.  Characters that are not in the standard alphabet
	 *     are discarded prior to the padding check.
	 *     
	 */
	function standard_b64decode(s): Promise<any>
	function standard_b64decode$({ s }): Promise<any>

	/**
	 * Encode bytes using the URL- and filesystem-safe Base64 alphabet.
	 * 
	 *     Argument s is a bytes-like object to encode.  The result is returned as a
	 *     bytes object.  The alphabet uses '-' instead of '+' and '_' instead of
	 *     '/'.
	 *     
	 */
	function urlsafe_b64encode(s): Promise<any>
	function urlsafe_b64encode$({ s }): Promise<any>

	/**
	 * Decode bytes using the URL- and filesystem-safe Base64 alphabet.
	 * 
	 *     Argument s is a bytes-like object or ASCII string to decode.  The result
	 *     is returned as a bytes object.  A binascii.Error is raised if the input
	 *     is incorrectly padded.  Characters that are not in the URL-safe base-64
	 *     alphabet, and are not a plus '+' or slash '/', are discarded prior to the
	 *     padding check.
	 * 
	 *     The alphabet uses '-' instead of '+' and '_' instead of '/'.
	 *     
	 */
	function urlsafe_b64decode(s): Promise<any>
	function urlsafe_b64decode$({ s }): Promise<any>
	function b32encode(s): Promise<any>
	function b32encode$({ s }): Promise<any>
	function b32decode(s, casefold?: boolean, map01?): Promise<any>
	function b32decode$({ s, casefold, map01 }: { s, casefold?, map01?}): Promise<any>
	function b32hexencode(s): Promise<any>
	function b32hexencode$({ s }): Promise<any>
	function b32hexdecode(s, casefold?: boolean): Promise<any>
	function b32hexdecode$({ s, casefold }: { s, casefold?}): Promise<any>

	/**
	 * Encode the bytes-like object s using Base16 and return a bytes object.
	 *     
	 */
	function b16encode(s): Promise<any>
	function b16encode$({ s }): Promise<any>

	/**
	 * Decode the Base16 encoded bytes-like object or ASCII string s.
	 * 
	 *     Optional casefold is a flag specifying whether a lowercase alphabet is
	 *     acceptable as input.  For security purposes, the default is False.
	 * 
	 *     The result is returned as a bytes object.  A binascii.Error is raised if
	 *     s is incorrectly padded or if there are non-alphabet characters present
	 *     in the input.
	 *     
	 */
	function b16decode(s, casefold?: boolean): Promise<any>
	function b16decode$({ s, casefold }: { s, casefold?}): Promise<any>

	/**
	 * Encode bytes-like object b using Ascii85 and return a bytes object.
	 * 
	 *     foldspaces is an optional flag that uses the special short sequence 'y'
	 *     instead of 4 consecutive spaces (ASCII 0x20) as supported by 'btoa'. This
	 *     feature is not supported by the "standard" Adobe encoding.
	 * 
	 *     wrapcol controls whether the output should have newline (b'\n') characters
	 *     added to it. If this is non-zero, each output line will be at most this
	 *     many characters long.
	 * 
	 *     pad controls whether the input is padded to a multiple of 4 before
	 *     encoding. Note that the btoa implementation always pads.
	 * 
	 *     adobe controls whether the encoded byte sequence is framed with <~ and ~>,
	 *     which is used by the Adobe implementation.
	 *     
	 */
	function a85encode(b): Promise<any>
	function a85encode$({ b }): Promise<any>

	/**
	 * Decode the Ascii85 encoded bytes-like object or ASCII string b.
	 * 
	 *     foldspaces is a flag that specifies whether the 'y' short sequence should be
	 *     accepted as shorthand for 4 consecutive spaces (ASCII 0x20). This feature is
	 *     not supported by the "standard" Adobe encoding.
	 * 
	 *     adobe controls whether the input sequence is in Adobe Ascii85 format (i.e.
	 *     is framed with <~ and ~>).
	 * 
	 *     ignorechars should be a byte string containing characters to ignore from the
	 *     input. This should only contain whitespace characters, and by default
	 *     contains all whitespace characters in ASCII.
	 * 
	 *     The result is returned as a bytes object.
	 *     
	 */
	function a85decode(b): Promise<any>
	function a85decode$({ b }): Promise<any>

	/**
	 * Encode bytes-like object b in base85 format and return a bytes object.
	 * 
	 *     If pad is true, the input is padded with b'\0' so its length is a multiple of
	 *     4 bytes before encoding.
	 *     
	 */
	function b85encode(b, pad?: boolean): Promise<any>
	function b85encode$({ b, pad }: { b, pad?}): Promise<any>

	/**
	 * Decode the base85-encoded bytes-like object or ASCII string b
	 * 
	 *     The result is returned as a bytes object.
	 *     
	 */
	function b85decode(b): Promise<any>
	function b85decode$({ b }): Promise<any>

	/**
	 * Encode a file; input and output are binary files.
	 */
	function encode(input, output): Promise<any>
	function encode$({ input, output }): Promise<any>

	/**
	 * Decode a file; input and output are binary files.
	 */
	function decode(input, output): Promise<any>
	function decode$({ input, output }): Promise<any>

	/**
	 * Encode a bytestring into a bytes object containing multiple lines
	 *     of base-64 data.
	 */
	function encodebytes(s): Promise<any>
	function encodebytes$({ s }): Promise<any>

	/**
	 * Decode a bytestring of base-64 data into a bytes object.
	 */
	function decodebytes(s): Promise<any>
	function decodebytes$({ s }): Promise<any>

	/**
	 * Small main program
	 */
	function main(): Promise<any>
	function main$($: {}): Promise<any>
	function test(): Promise<any>
	function test$($: {}): Promise<any>
	let bytes_types: Promise<any>
	let MAXLINESIZE: Promise<any>
	let MAXBINSIZE: Promise<any>
}
declare module bdb {
	var _

	/**
	 * Start debugging with a Bdb instance from the caller's frame.
	 */
	function set_trace(): Promise<any>
	function set_trace$($: {}): Promise<any>

	/**
	 * Return True if break should happen here.
	 * 
	 *     Whether a break should happen depends on the way that b (the breakpoint)
	 *     was set.  If it was set via line number, check if b.line is the same as
	 *     the one in the frame.  If it was set via function name, check if this is
	 *     the right function and if it is on the first executable line.
	 *     
	 */
	function checkfuncname(b, frame): Promise<any>
	function checkfuncname$({ b, frame }): Promise<any>

	/**
	 * Determine which breakpoint for this file:line is to be acted upon.
	 * 
	 *     Called only if we know there is a breakpoint at this location.  Return
	 *     the breakpoint that was triggered and a boolean that indicates if it is
	 *     ok to delete a temporary breakpoint.  Return (None, None) if there is no
	 *     matching breakpoint.
	 *     
	 */
	function effective(file, line, frame): Promise<any>
	function effective$({ file, line, frame }): Promise<any>
	function foo(n): Promise<any>
	function foo$({ n }): Promise<any>
	function bar(a): Promise<any>
	function bar$({ a }): Promise<any>
	function test(): Promise<any>
	function test$($: {}): Promise<any>

	/**
	 * Exception to give up completely.
	 */
	interface IBdbQuit {
	}

	/**
	 * Generic Python debugger base class.
	 * 
	 *     This class takes care of details of the trace facility;
	 *     a derived class should implement user interaction.
	 *     The standard debugger class (pdb.Pdb) is an example.
	 * 
	 *     The optional skip argument must be an iterable of glob-style
	 *     module name patterns.  The debugger will not step into frames
	 *     that originate in a module that matches one of these patterns.
	 *     Whether a frame is considered to originate in a certain module
	 *     is determined by the __name__ in the frame globals.
	 *     
	 */
	function Bdb(skip?): Promise<IBdb>
	function Bdb$({ skip }: { skip?}): Promise<IBdb>
	interface IBdb {

		/**
		 * Return canonical form of filename.
		 * 
		 *         For real filenames, the canonical form is a case-normalized (on
		 *         case insensitive filesystems) absolute path.  'Filenames' with
		 *         angle brackets, such as "<stdin>", generated in interactive
		 *         mode, are returned unchanged.
		 *         
		 */
		canonic(filename): Promise<any>
		canonic$({ filename }): Promise<any>

		/**
		 * Set values of attributes as ready to start debugging.
		 */
		reset(): Promise<any>
		reset$($: {}): Promise<any>

		/**
		 * Dispatch a trace function for debugged frames based on the event.
		 * 
		 *         This function is installed as the trace function for debugged
		 *         frames. Its return value is the new trace function, which is
		 *         usually itself. The default implementation decides how to
		 *         dispatch a frame, depending on the type of event (passed in as a
		 *         string) that is about to be executed.
		 * 
		 *         The event can be one of the following:
		 *             line: A new line of code is going to be executed.
		 *             call: A function is about to be called or another code block
		 *                   is entered.
		 *             return: A function or other code block is about to return.
		 *             exception: An exception has occurred.
		 *             c_call: A C function is about to be called.
		 *             c_return: A C function has returned.
		 *             c_exception: A C function has raised an exception.
		 * 
		 *         For the Python events, specialized functions (see the dispatch_*()
		 *         methods) are called.  For the C events, no action is taken.
		 * 
		 *         The arg parameter depends on the previous event.
		 *         
		 */
		trace_dispatch(frame, event, arg): Promise<any>
		trace_dispatch$({ frame, event, arg }): Promise<any>

		/**
		 * Invoke user function and return trace function for line event.
		 * 
		 *         If the debugger stops on the current line, invoke
		 *         self.user_line(). Raise BdbQuit if self.quitting is set.
		 *         Return self.trace_dispatch to continue tracing in this scope.
		 *         
		 */
		dispatch_line(frame): Promise<any>
		dispatch_line$({ frame }): Promise<any>

		/**
		 * Invoke user function and return trace function for call event.
		 * 
		 *         If the debugger stops on this function call, invoke
		 *         self.user_call(). Raise BdbQuit if self.quitting is set.
		 *         Return self.trace_dispatch to continue tracing in this scope.
		 *         
		 */
		dispatch_call(frame, arg): Promise<any>
		dispatch_call$({ frame, arg }): Promise<any>

		/**
		 * Invoke user function and return trace function for return event.
		 * 
		 *         If the debugger stops on this function return, invoke
		 *         self.user_return(). Raise BdbQuit if self.quitting is set.
		 *         Return self.trace_dispatch to continue tracing in this scope.
		 *         
		 */
		dispatch_return(frame, arg): Promise<any>
		dispatch_return$({ frame, arg }): Promise<any>

		/**
		 * Invoke user function and return trace function for exception event.
		 * 
		 *         If the debugger stops on this exception, invoke
		 *         self.user_exception(). Raise BdbQuit if self.quitting is set.
		 *         Return self.trace_dispatch to continue tracing in this scope.
		 *         
		 */
		dispatch_exception(frame, arg): Promise<any>
		dispatch_exception$({ frame, arg }): Promise<any>

		/**
		 * Return True if module_name matches any skip pattern.
		 */
		is_skipped_module(module_name): Promise<any>
		is_skipped_module$({ module_name }): Promise<any>

		/**
		 * Return True if frame is below the starting frame in the stack.
		 */
		stop_here(frame): Promise<any>
		stop_here$({ frame }): Promise<any>

		/**
		 * Return True if there is an effective breakpoint for this line.
		 * 
		 *         Check for line or function breakpoint and if in effect.
		 *         Delete temporary breakpoints if effective() says to.
		 *         
		 */
		break_here(frame): Promise<any>
		break_here$({ frame }): Promise<any>

		/**
		 * Remove temporary breakpoint.
		 * 
		 *         Must implement in derived classes or get NotImplementedError.
		 *         
		 */
		do_clear(arg): Promise<any>
		do_clear$({ arg }): Promise<any>

		/**
		 * Return True if there is any breakpoint for frame's filename.
		 *         
		 */
		break_anywhere(frame): Promise<any>
		break_anywhere$({ frame }): Promise<any>

		/**
		 * Called if we might stop in a function.
		 */
		user_call(frame, argument_list): Promise<any>
		user_call$({ frame, argument_list }): Promise<any>

		/**
		 * Called when we stop or break at a line.
		 */
		user_line(frame): Promise<any>
		user_line$({ frame }): Promise<any>

		/**
		 * Called when a return trap is set here.
		 */
		user_return(frame, return_value): Promise<any>
		user_return$({ frame, return_value }): Promise<any>

		/**
		 * Called when we stop on an exception.
		 */
		user_exception(frame, exc_info): Promise<any>
		user_exception$({ frame, exc_info }): Promise<any>

		/**
		 * Stop when the line with the lineno greater than the current one is
		 *         reached or when returning from current frame.
		 */
		set_until(frame, lineno?): Promise<any>
		set_until$({ frame, lineno }: { frame, lineno?}): Promise<any>

		/**
		 * Stop after one line of code.
		 */
		set_step(): Promise<any>
		set_step$($: {}): Promise<any>

		/**
		 * Stop on the next line in or below the given frame.
		 */
		set_next(frame): Promise<any>
		set_next$({ frame }): Promise<any>

		/**
		 * Stop when returning from the given frame.
		 */
		set_return(frame): Promise<any>
		set_return$({ frame }): Promise<any>

		/**
		 * Start debugging from frame.
		 * 
		 *         If frame is not specified, debugging starts from caller's frame.
		 *         
		 */
		set_trace(frame?): Promise<any>
		set_trace$({ frame }: { frame?}): Promise<any>

		/**
		 * Stop only at breakpoints or when finished.
		 * 
		 *         If there are no breakpoints, set the system trace function to None.
		 *         
		 */
		set_continue(): Promise<any>
		set_continue$($: {}): Promise<any>

		/**
		 * Set quitting attribute to True.
		 * 
		 *         Raises BdbQuit exception in the next call to a dispatch_*() method.
		 *         
		 */
		set_quit(): Promise<any>
		set_quit$($: {}): Promise<any>

		/**
		 * Set a new breakpoint for filename:lineno.
		 * 
		 *         If lineno doesn't exist for the filename, return an error message.
		 *         The filename should be in canonical form.
		 *         
		 */
		set_break(filename, lineno, temporary?: boolean, cond?, funcname?): Promise<any>
		set_break$({ filename, lineno, temporary, cond, funcname }: { filename, lineno, temporary?, cond?, funcname?}): Promise<any>

		/**
		 * Delete breakpoints for filename:lineno.
		 * 
		 *         If no breakpoints were set, return an error message.
		 *         
		 */
		clear_break(filename, lineno): Promise<any>
		clear_break$({ filename, lineno }): Promise<any>

		/**
		 * Delete a breakpoint by its index in Breakpoint.bpbynumber.
		 * 
		 *         If arg is invalid, return an error message.
		 *         
		 */
		clear_bpbynumber(arg): Promise<any>
		clear_bpbynumber$({ arg }): Promise<any>

		/**
		 * Delete all breakpoints in filename.
		 * 
		 *         If none were set, return an error message.
		 *         
		 */
		clear_all_file_breaks(filename): Promise<any>
		clear_all_file_breaks$({ filename }): Promise<any>

		/**
		 * Delete all existing breakpoints.
		 * 
		 *         If none were set, return an error message.
		 *         
		 */
		clear_all_breaks(): Promise<any>
		clear_all_breaks$($: {}): Promise<any>

		/**
		 * Return a breakpoint by its index in Breakpoint.bybpnumber.
		 * 
		 *         For invalid arg values or if the breakpoint doesn't exist,
		 *         raise a ValueError.
		 *         
		 */
		get_bpbynumber(arg): Promise<any>
		get_bpbynumber$({ arg }): Promise<any>

		/**
		 * Return True if there is a breakpoint for filename:lineno.
		 */
		get_break(filename, lineno): Promise<any>
		get_break$({ filename, lineno }): Promise<any>

		/**
		 * Return all breakpoints for filename:lineno.
		 * 
		 *         If no breakpoints are set, return an empty list.
		 *         
		 */
		get_breaks(filename, lineno): Promise<any>
		get_breaks$({ filename, lineno }): Promise<any>

		/**
		 * Return all lines with breakpoints for filename.
		 * 
		 *         If no breakpoints are set, return an empty list.
		 *         
		 */
		get_file_breaks(filename): Promise<any>
		get_file_breaks$({ filename }): Promise<any>

		/**
		 * Return all breakpoints that are set.
		 */
		get_all_breaks(): Promise<any>
		get_all_breaks$($: {}): Promise<any>

		/**
		 * Return a list of (frame, lineno) in a stack trace and a size.
		 * 
		 *         List starts with original calling frame, if there is one.
		 *         Size may be number of frames above or below f.
		 *         
		 */
		get_stack(f, t): Promise<any>
		get_stack$({ f, t }): Promise<any>

		/**
		 * Return a string with information about a stack entry.
		 * 
		 *         The stack entry frame_lineno is a (frame, lineno) tuple.  The
		 *         return string contains the canonical filename, the function name
		 *         or '<lambda>', the input arguments, the return value, and the
		 *         line of code (if it exists).
		 * 
		 *         
		 */
		format_stack_entry(frame_lineno, lprefix?): Promise<any>
		format_stack_entry$({ frame_lineno, lprefix }: { frame_lineno, lprefix?}): Promise<any>

		/**
		 * Debug a statement executed via the exec() function.
		 * 
		 *         globals defaults to __main__.dict; locals defaults to globals.
		 *         
		 */
		run(cmd, globals?, locals?): Promise<any>
		run$({ cmd, globals, locals }: { cmd, globals?, locals?}): Promise<any>

		/**
		 * Debug an expression executed via the eval() function.
		 * 
		 *         globals defaults to __main__.dict; locals defaults to globals.
		 *         
		 */
		runeval(expr, globals?, locals?): Promise<any>
		runeval$({ expr, globals, locals }: { expr, globals?, locals?}): Promise<any>

		/**
		 * For backwards-compatibility.  Defers to run().
		 */
		runctx(cmd, globals, locals): Promise<any>
		runctx$({ cmd, globals, locals }): Promise<any>

		/**
		 * Debug a single function call.
		 * 
		 *         Return the result of the function call.
		 *         
		 */
		runcall(func): Promise<any>
		runcall$({ func }): Promise<any>
	}

	/**
	 * Breakpoint class.
	 * 
	 *     Implements temporary breakpoints, ignore counts, disabling and
	 *     (re)-enabling, and conditionals.
	 * 
	 *     Breakpoints are indexed by number through bpbynumber and by
	 *     the (file, line) tuple using bplist.  The former points to a
	 *     single instance of class Breakpoint.  The latter points to a
	 *     list of such instances since there may be more than one
	 *     breakpoint per line.
	 * 
	 *     When creating a breakpoint, its associated filename should be
	 *     in canonical form.  If funcname is defined, a breakpoint hit will be
	 *     counted when the first line of that function is executed.  A
	 *     conditional breakpoint always counts a hit.
	 *     
	 */
	function Breakpoint(file, line, temporary?: boolean, cond?, funcname?): Promise<IBreakpoint>
	function Breakpoint$({ file, line, temporary, cond, funcname }: { file, line, temporary?, cond?, funcname?}): Promise<IBreakpoint>
	interface IBreakpoint {
		clearBreakpoints(): Promise<any>
		clearBreakpoints$($: {}): Promise<any>

		/**
		 * Delete the breakpoint from the list associated to a file:line.
		 * 
		 *         If it is the last breakpoint in that position, it also deletes
		 *         the entry for the file:line.
		 *         
		 */
		deleteMe(): Promise<any>
		deleteMe$($: {}): Promise<any>

		/**
		 * Mark the breakpoint as enabled.
		 */
		enable(): Promise<any>
		enable$($: {}): Promise<any>

		/**
		 * Mark the breakpoint as disabled.
		 */
		disable(): Promise<any>
		disable$($: {}): Promise<any>

		/**
		 * Print the output of bpformat().
		 * 
		 *         The optional out argument directs where the output is sent
		 *         and defaults to standard output.
		 *         
		 */
		bpprint(out?): Promise<any>
		bpprint$({ out }: { out?}): Promise<any>

		/**
		 * Return a string with information about the breakpoint.
		 * 
		 *         The information includes the breakpoint number, temporary
		 *         status, file:line position, break condition, number of times to
		 *         ignore, and number of times hit.
		 * 
		 *         
		 */
		bpformat(): Promise<any>
		bpformat$($: {}): Promise<any>
		next
		bplist
		bpbynumber
	}
	interface ITdb extends IBdb {
		user_call(frame, args): Promise<any>
		user_call$({ frame, args }): Promise<any>
		user_line(frame): Promise<any>
		user_line$({ frame }): Promise<any>
		user_return(frame, retval): Promise<any>
		user_return$({ frame, retval }): Promise<any>
		user_exception(frame, exc_stuff): Promise<any>
		user_exception$({ frame, exc_stuff }): Promise<any>
	}
	let GENERATOR_AND_COROUTINE_FLAGS: Promise<any>
}
declare module binhex {
	var _
	function getfileinfo(name): Promise<any>
	function getfileinfo$({ name }): Promise<any>

	/**
	 * binhex(infilename, outfilename): create binhex-encoded copy of a file
	 */
	function binhex(inp, out): Promise<any>
	function binhex$({ inp, out }): Promise<any>

	/**
	 * hexbin(infilename, outfilename) - Decode binhexed file
	 */
	function hexbin(inp, out): Promise<any>
	function hexbin$({ inp, out }): Promise<any>
	interface IError {
	}
	function FInfo(): Promise<IFInfo>
	function FInfo$({ }): Promise<IFInfo>
	interface IFInfo {
	}
	function openrsrc(): Promise<Iopenrsrc>
	function openrsrc$({ }): Promise<Iopenrsrc>
	interface Iopenrsrc {
		read(): Promise<any>
		read$($: {}): Promise<any>
		write(): Promise<any>
		write$($: {}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 * Write data to the coder in 3-byte chunks
	 */
	interface I_Hqxcoderengine {
		write(data): Promise<any>
		write$({ data }): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 * Write data to the RLE-coder in suitably large chunks
	 */
	interface I_Rlecoderengine {
		write(data): Promise<any>
		write$({ data }): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}
	function BinHex(name_finfo_dlen_rlen, ofp): Promise<IBinHex>
	function BinHex$({ name_finfo_dlen_rlen, ofp }): Promise<IBinHex>
	interface IBinHex {
		write(data): Promise<any>
		write$({ data }): Promise<any>
		close_data(): Promise<any>
		close_data$($: {}): Promise<any>
		write_rsrc(data): Promise<any>
		write_rsrc$({ data }): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 * Read data via the decoder in 4-byte chunks
	 */
	interface I_Hqxdecoderengine {

		/**
		 * Read at least wtd bytes (or until EOF)
		 */
		read(totalwtd): Promise<any>
		read$({ totalwtd }): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 * Read data via the RLE-coder
	 */
	interface I_Rledecoderengine {
		read(wtd): Promise<any>
		read$({ wtd }): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}
	function HexBin(ifp): Promise<IHexBin>
	function HexBin$({ ifp }): Promise<IHexBin>
	interface IHexBin {
		read(): Promise<any>
		read$($: {}): Promise<any>
		close_data(): Promise<any>
		close_data$($: {}): Promise<any>
		read_rsrc(): Promise<any>
		read_rsrc$($: {}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}
	let REASONABLY_LARGE: Promise<any>
	let LINELEN: Promise<any>
	let RUNCHAR: Promise<any>
}
declare module bisect {
	var _

	/**
	 * Insert item x in list a, and keep it sorted assuming a is sorted.
	 * 
	 *     If x is already in a, insert it to the right of the rightmost x.
	 * 
	 *     Optional args lo (default 0) and hi (default len(a)) bound the
	 *     slice of a to be searched.
	 *     
	 */
	function insort_right(a, x, lo?, hi?): Promise<any>
	function insort_right$({ a, x, lo, hi }: { a, x, lo?, hi?}): Promise<any>

	/**
	 * Return the index where to insert item x in list a, assuming a is sorted.
	 * 
	 *     The return value i is such that all e in a[:i] have e <= x, and all e in
	 *     a[i:] have e > x.  So if x already appears in the list, a.insert(i, x) will
	 *     insert just after the rightmost x already there.
	 * 
	 *     Optional args lo (default 0) and hi (default len(a)) bound the
	 *     slice of a to be searched.
	 *     
	 */
	function bisect_right(a, x, lo?, hi?): Promise<any>
	function bisect_right$({ a, x, lo, hi }: { a, x, lo?, hi?}): Promise<any>

	/**
	 * Insert item x in list a, and keep it sorted assuming a is sorted.
	 * 
	 *     If x is already in a, insert it to the left of the leftmost x.
	 * 
	 *     Optional args lo (default 0) and hi (default len(a)) bound the
	 *     slice of a to be searched.
	 *     
	 */
	function insort_left(a, x, lo?, hi?): Promise<any>
	function insort_left$({ a, x, lo, hi }: { a, x, lo?, hi?}): Promise<any>

	/**
	 * Return the index where to insert item x in list a, assuming a is sorted.
	 * 
	 *     The return value i is such that all e in a[:i] have e < x, and all e in
	 *     a[i:] have e >= x.  So if x already appears in the list, a.insert(i, x) will
	 *     insert just before the leftmost x already there.
	 * 
	 *     Optional args lo (default 0) and hi (default len(a)) bound the
	 *     slice of a to be searched.
	 *     
	 */
	function bisect_left(a, x, lo?, hi?): Promise<any>
	function bisect_left$({ a, x, lo, hi }: { a, x, lo?, hi?}): Promise<any>
	let bisect: Promise<any>
	let insort: Promise<any>
}
declare module bz2 {
	var _

	/**
	 * Open a bzip2-compressed file in binary or text mode.
	 * 
	 *     The filename argument can be an actual filename (a str, bytes, or
	 *     PathLike object), or an existing file object to read from or write
	 *     to.
	 * 
	 *     The mode argument can be "r", "rb", "w", "wb", "x", "xb", "a" or
	 *     "ab" for binary mode, or "rt", "wt", "xt" or "at" for text mode.
	 *     The default mode is "rb", and the default compresslevel is 9.
	 * 
	 *     For binary mode, this function is equivalent to the BZ2File
	 *     constructor: BZ2File(filename, mode, compresslevel). In this case,
	 *     the encoding, errors and newline arguments must not be provided.
	 * 
	 *     For text mode, a BZ2File object is created, and wrapped in an
	 *     io.TextIOWrapper instance with the specified encoding, error
	 *     handling behavior, and line ending(s).
	 * 
	 *     
	 */
	function open(filename, mode?, compresslevel?, encoding?, errors?, newline?): Promise<any>
	function open$({ filename, mode, compresslevel, encoding, errors, newline }: { filename, mode?, compresslevel?, encoding?, errors?, newline?}): Promise<any>

	/**
	 * Compress a block of data.
	 * 
	 *     compresslevel, if given, must be a number between 1 and 9.
	 * 
	 *     For incremental compression, use a BZ2Compressor object instead.
	 *     
	 */
	function compress(data, compresslevel?): Promise<any>
	function compress$({ data, compresslevel }: { data, compresslevel?}): Promise<any>

	/**
	 * Decompress a block of data.
	 * 
	 *     For incremental decompression, use a BZ2Decompressor object instead.
	 *     
	 */
	function decompress(data): Promise<any>
	function decompress$({ data }): Promise<any>

	/**
	 * A file object providing transparent bzip2 (de)compression.
	 * 
	 *     A BZ2File can act as a wrapper for an existing file object, or refer
	 *     directly to a named file on disk.
	 * 
	 *     Note that BZ2File provides a *binary* file interface - data read is
	 *     returned as bytes, and data to be written should be given as bytes.
	 *     
	 */

	/**
	 * Open a bzip2-compressed file.
	 * 
	 *         If filename is a str, bytes, or PathLike object, it gives the
	 *         name of the file to be opened. Otherwise, it should be a file
	 *         object, which will be used to read or write the compressed data.
	 * 
	 *         mode can be 'r' for reading (default), 'w' for (over)writing,
	 *         'x' for creating exclusively, or 'a' for appending. These can
	 *         equivalently be given as 'rb', 'wb', 'xb', and 'ab'.
	 * 
	 *         If mode is 'w', 'x' or 'a', compresslevel can be a number between 1
	 *         and 9 specifying the level of compression: 1 produces the least
	 *         compression, and 9 (default) produces the most compression.
	 * 
	 *         If mode is 'r', the input file may be the concatenation of
	 *         multiple compressed streams.
	 *         
	 */
	function BZ2File(filename, mode?): Promise<IBZ2File>
	function BZ2File$({ filename, mode }: { filename, mode?}): Promise<IBZ2File>
	interface IBZ2File {

		/**
		 * Flush and close the file.
		 * 
		 *         May be called more than once without error. Once the file is
		 *         closed, any other operation on it will raise a ValueError.
		 *         
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>

		/**
		 * True if this file is closed.
		 */
		closed(): Promise<any>
		closed$($: {}): Promise<any>

		/**
		 * Return the file descriptor for the underlying file.
		 */
		fileno(): Promise<any>
		fileno$($: {}): Promise<any>

		/**
		 * Return whether the file supports seeking.
		 */
		seekable(): Promise<any>
		seekable$($: {}): Promise<any>

		/**
		 * Return whether the file was opened for reading.
		 */
		readable(): Promise<any>
		readable$($: {}): Promise<any>

		/**
		 * Return whether the file was opened for writing.
		 */
		writable(): Promise<any>
		writable$($: {}): Promise<any>

		/**
		 * Return buffered data without advancing the file position.
		 * 
		 *         Always returns at least one byte of data, unless at EOF.
		 *         The exact number of bytes returned is unspecified.
		 *         
		 */
		peek(n?): Promise<any>
		peek$({ n }: { n?}): Promise<any>

		/**
		 * Read up to size uncompressed bytes from the file.
		 * 
		 *         If size is negative or omitted, read until EOF is reached.
		 *         Returns b'' if the file is already at EOF.
		 *         
		 */
		read(size?): Promise<any>
		read$({ size }: { size?}): Promise<any>

		/**
		 * Read up to size uncompressed bytes, while trying to avoid
		 *         making multiple reads from the underlying stream. Reads up to a
		 *         buffer's worth of data if size is negative.
		 * 
		 *         Returns b'' if the file is at EOF.
		 *         
		 */
		read1(size?): Promise<any>
		read1$({ size }: { size?}): Promise<any>

		/**
		 * Read bytes into b.
		 * 
		 *         Returns the number of bytes read (0 for EOF).
		 *         
		 */
		readinto(b): Promise<any>
		readinto$({ b }): Promise<any>

		/**
		 * Read a line of uncompressed bytes from the file.
		 * 
		 *         The terminating newline (if present) is retained. If size is
		 *         non-negative, no more than size bytes will be read (in which
		 *         case the line may be incomplete). Returns b'' if already at EOF.
		 *         
		 */
		readline(size?): Promise<any>
		readline$({ size }: { size?}): Promise<any>

		/**
		 * Read a list of lines of uncompressed bytes from the file.
		 * 
		 *         size can be specified to control the number of lines read: no
		 *         further lines will be read once the total size of the lines read
		 *         so far equals or exceeds size.
		 *         
		 */
		readlines(size?): Promise<any>
		readlines$({ size }: { size?}): Promise<any>

		/**
		 * Write a byte string to the file.
		 * 
		 *         Returns the number of uncompressed bytes written, which is
		 *         always len(data). Note that due to buffering, the file on disk
		 *         may not reflect the data written until close() is called.
		 *         
		 */
		write(data): Promise<any>
		write$({ data }): Promise<any>

		/**
		 * Write a sequence of byte strings to the file.
		 * 
		 *         Returns the number of uncompressed bytes written.
		 *         seq can be any iterable yielding byte strings.
		 * 
		 *         Line separators are not added between the written byte strings.
		 *         
		 */
		writelines(seq): Promise<any>
		writelines$({ seq }): Promise<any>

		/**
		 * Change the file position.
		 * 
		 *         The new position is specified by offset, relative to the
		 *         position indicated by whence. Values for whence are:
		 * 
		 *             0: start of stream (default); offset must not be negative
		 *             1: current stream position
		 *             2: end of stream; offset must not be positive
		 * 
		 *         Returns the new file position.
		 * 
		 *         Note that seeking is emulated, so depending on the parameters,
		 *         this operation may be extremely slow.
		 *         
		 */
		seek(offset, whence?): Promise<any>
		seek$({ offset, whence }: { offset, whence?}): Promise<any>

		/**
		 * Return the current file position.
		 */
		tell(): Promise<any>
		tell$($: {}): Promise<any>
	}
}
declare module cProfile {
	var _
	function run(statement, filename?, sort?): Promise<any>
	function run$({ statement, filename, sort }: { statement, filename?, sort?}): Promise<any>
	function runctx(statement, globals, locals, filename?, sort?): Promise<any>
	function runctx$({ statement, globals, locals, filename, sort }: { statement, globals, locals, filename?, sort?}): Promise<any>
	function label(code): Promise<any>
	function label$({ code }): Promise<any>
	function main(): Promise<any>
	function main$($: {}): Promise<any>

	/**
	 * Profile(timer=None, timeunit=None, subcalls=True, builtins=True)
	 * 
	 *     Builds a profiler object using the specified timer function.
	 *     The default timer is a fast built-in one based on real time.
	 *     For custom timer functions returning integers, timeunit can
	 *     be a float specifying a scale (i.e. how long each integer unit
	 *     is, in seconds).
	 *     
	 */
	interface IProfile {
		print_stats(sort?): Promise<any>
		print_stats$({ sort }: { sort?}): Promise<any>
		dump_stats(file): Promise<any>
		dump_stats$({ file }): Promise<any>
		create_stats(): Promise<any>
		create_stats$($: {}): Promise<any>
		snapshot_stats(): Promise<any>
		snapshot_stats$($: {}): Promise<any>
		run(cmd): Promise<any>
		run$({ cmd }): Promise<any>
		runctx(cmd, globals, locals): Promise<any>
		runctx$({ cmd, globals, locals }): Promise<any>
		runcall(func): Promise<any>
		runcall$({ func }): Promise<any>
	}
}
declare module calendar {
	var _

	/**
	 * Return True for leap years, False for non-leap years.
	 */
	function isleap(year): Promise<any>
	function isleap$({ year }): Promise<any>

	/**
	 * Return number of leap years in range [y1, y2).
	 *        Assume y1 <= y2.
	 */
	function leapdays(y1, y2): Promise<any>
	function leapdays$({ y1, y2 }): Promise<any>

	/**
	 * Return weekday (0-6 ~ Mon-Sun) for year, month (1-12), day (1-31).
	 */
	function weekday(year, month, day): Promise<any>
	function weekday$({ year, month, day }): Promise<any>

	/**
	 * Return weekday (0-6 ~ Mon-Sun) and number of days (28-31) for
	 *        year, month.
	 */
	function monthrange(year, month): Promise<any>
	function monthrange$({ year, month }): Promise<any>
	function setfirstweekday(firstweekday): Promise<any>
	function setfirstweekday$({ firstweekday }): Promise<any>

	/**
	 * Prints multi-column formatting for year calendars
	 */
	function format(cols, colwidth?, spacing?): Promise<any>
	function format$({ cols, colwidth, spacing }: { cols, colwidth?, spacing?}): Promise<any>

	/**
	 * Returns a string formatted from n strings, centered within n columns.
	 */
	function formatstring(cols, colwidth?, spacing?): Promise<any>
	function formatstring$({ cols, colwidth, spacing }: { cols, colwidth?, spacing?}): Promise<any>

	/**
	 * Unrelated but handy function to calculate Unix timestamp from GMT.
	 */
	function timegm(tuple): Promise<any>
	function timegm$({ tuple }): Promise<any>
	function main(args): Promise<any>
	function main$({ args }): Promise<any>
	function IllegalMonthError(month): Promise<IIllegalMonthError>
	function IllegalMonthError$({ month }): Promise<IIllegalMonthError>
	interface IIllegalMonthError {
	}
	function IllegalWeekdayError(weekday): Promise<IIllegalWeekdayError>
	function IllegalWeekdayError$({ weekday }): Promise<IIllegalWeekdayError>
	interface IIllegalWeekdayError {
	}
	interface I_localized_month {
	}
	interface I_localized_day {
	}

	/**
	 * 
	 *     Base calendar class. This class doesn't do any formatting. It simply
	 *     provides data to subclasses.
	 *     
	 */
	function Calendar(firstweekday?): Promise<ICalendar>
	function Calendar$({ firstweekday }: { firstweekday?}): Promise<ICalendar>
	interface ICalendar {
		getfirstweekday(): Promise<any>
		getfirstweekday$($: {}): Promise<any>
		setfirstweekday(firstweekday): Promise<any>
		setfirstweekday$({ firstweekday }): Promise<any>

		/**
		 * 
		 *         Return an iterator for one week of weekday numbers starting with the
		 *         configured first one.
		 *         
		 */
		iterweekdays(): Promise<any>
		iterweekdays$($: {}): Promise<any>

		/**
		 * 
		 *         Return an iterator for one month. The iterator will yield datetime.date
		 *         values and will always iterate through complete weeks, so it will yield
		 *         dates outside the specified month.
		 *         
		 */
		itermonthdates(year, month): Promise<any>
		itermonthdates$({ year, month }): Promise<any>

		/**
		 * 
		 *         Like itermonthdates(), but will yield day numbers. For days outside
		 *         the specified month the day number is 0.
		 *         
		 */
		itermonthdays(year, month): Promise<any>
		itermonthdays$({ year, month }): Promise<any>

		/**
		 * 
		 *         Like itermonthdates(), but will yield (day number, weekday number)
		 *         tuples. For days outside the specified month the day number is 0.
		 *         
		 */
		itermonthdays2(year, month): Promise<any>
		itermonthdays2$({ year, month }): Promise<any>

		/**
		 * 
		 *         Like itermonthdates(), but will yield (year, month, day) tuples.  Can be
		 *         used for dates outside of datetime.date range.
		 *         
		 */
		itermonthdays3(year, month): Promise<any>
		itermonthdays3$({ year, month }): Promise<any>

		/**
		 * 
		 *         Like itermonthdates(), but will yield (year, month, day, day_of_week) tuples.
		 *         Can be used for dates outside of datetime.date range.
		 *         
		 */
		itermonthdays4(year, month): Promise<any>
		itermonthdays4$({ year, month }): Promise<any>

		/**
		 * 
		 *         Return a matrix (list of lists) representing a month's calendar.
		 *         Each row represents a week; week entries are datetime.date values.
		 *         
		 */
		monthdatescalendar(year, month): Promise<any>
		monthdatescalendar$({ year, month }): Promise<any>

		/**
		 * 
		 *         Return a matrix representing a month's calendar.
		 *         Each row represents a week; week entries are
		 *         (day number, weekday number) tuples. Day numbers outside this month
		 *         are zero.
		 *         
		 */
		monthdays2calendar(year, month): Promise<any>
		monthdays2calendar$({ year, month }): Promise<any>

		/**
		 * 
		 *         Return a matrix representing a month's calendar.
		 *         Each row represents a week; days outside this month are zero.
		 *         
		 */
		monthdayscalendar(year, month): Promise<any>
		monthdayscalendar$({ year, month }): Promise<any>

		/**
		 * 
		 *         Return the data for the specified year ready for formatting. The return
		 *         value is a list of month rows. Each month row contains up to width months.
		 *         Each month contains between 4 and 6 weeks and each week contains 1-7
		 *         days. Days are datetime.date objects.
		 *         
		 */
		yeardatescalendar(year, width?): Promise<any>
		yeardatescalendar$({ year, width }: { year, width?}): Promise<any>

		/**
		 * 
		 *         Return the data for the specified year ready for formatting (similar to
		 *         yeardatescalendar()). Entries in the week lists are
		 *         (day number, weekday number) tuples. Day numbers outside this month are
		 *         zero.
		 *         
		 */
		yeardays2calendar(year, width?): Promise<any>
		yeardays2calendar$({ year, width }: { year, width?}): Promise<any>

		/**
		 * 
		 *         Return the data for the specified year ready for formatting (similar to
		 *         yeardatescalendar()). Entries in the week lists are day numbers.
		 *         Day numbers outside this month are zero.
		 *         
		 */
		yeardayscalendar(year, width?): Promise<any>
		yeardayscalendar$({ year, width }: { year, width?}): Promise<any>
		firstweekday
	}

	/**
	 * 
	 *     Subclass of Calendar that outputs a calendar as a simple plain text
	 *     similar to the UNIX program cal.
	 *     
	 */
	interface ITextCalendar extends ICalendar {

		/**
		 * 
		 *         Print a single week (no newline).
		 *         
		 */
		prweek(theweek, width): Promise<any>
		prweek$({ theweek, width }): Promise<any>

		/**
		 * 
		 *         Returns a formatted day.
		 *         
		 */
		formatday(day, weekday, width): Promise<any>
		formatday$({ day, weekday, width }): Promise<any>

		/**
		 * 
		 *         Returns a single week in a string (no newline).
		 *         
		 */
		formatweek(theweek, width): Promise<any>
		formatweek$({ theweek, width }): Promise<any>

		/**
		 * 
		 *         Returns a formatted week day name.
		 *         
		 */
		formatweekday(day, width): Promise<any>
		formatweekday$({ day, width }): Promise<any>

		/**
		 * 
		 *         Return a header for a week.
		 *         
		 */
		formatweekheader(width): Promise<any>
		formatweekheader$({ width }): Promise<any>

		/**
		 * 
		 *         Return a formatted month name.
		 *         
		 */
		formatmonthname(theyear, themonth, width, withyear?: boolean): Promise<any>
		formatmonthname$({ theyear, themonth, width, withyear }: { theyear, themonth, width, withyear?}): Promise<any>

		/**
		 * 
		 *         Print a month's calendar.
		 *         
		 */
		prmonth(theyear, themonth, w?, l?): Promise<any>
		prmonth$({ theyear, themonth, w, l }: { theyear, themonth, w?, l?}): Promise<any>

		/**
		 * 
		 *         Return a month's calendar string (multi-line).
		 *         
		 */
		formatmonth(theyear, themonth, w?, l?): Promise<any>
		formatmonth$({ theyear, themonth, w, l }: { theyear, themonth, w?, l?}): Promise<any>

		/**
		 * 
		 *         Returns a year's calendar as a multi-line string.
		 *         
		 */
		formatyear(theyear, w?, l?, c?, m?): Promise<any>
		formatyear$({ theyear, w, l, c, m }: { theyear, w?, l?, c?, m?}): Promise<any>

		/**
		 * Print a year's calendar.
		 */
		pryear(theyear, w?, l?, c?, m?): Promise<any>
		pryear$({ theyear, w, l, c, m }: { theyear, w?, l?, c?, m?}): Promise<any>
	}

	/**
	 * 
	 *     This calendar returns complete HTML pages.
	 *     
	 */
	interface IHTMLCalendar extends ICalendar {

		/**
		 * 
		 *         Return a day as a table cell.
		 *         
		 */
		formatday(day, weekday): Promise<any>
		formatday$({ day, weekday }): Promise<any>

		/**
		 * 
		 *         Return a complete week as a table row.
		 *         
		 */
		formatweek(theweek): Promise<any>
		formatweek$({ theweek }): Promise<any>

		/**
		 * 
		 *         Return a weekday name as a table header.
		 *         
		 */
		formatweekday(day): Promise<any>
		formatweekday$({ day }): Promise<any>

		/**
		 * 
		 *         Return a header for a week as a table row.
		 *         
		 */
		formatweekheader(): Promise<any>
		formatweekheader$($: {}): Promise<any>

		/**
		 * 
		 *         Return a month name as a table row.
		 *         
		 */
		formatmonthname(theyear, themonth, withyear?: boolean): Promise<any>
		formatmonthname$({ theyear, themonth, withyear }: { theyear, themonth, withyear?}): Promise<any>

		/**
		 * 
		 *         Return a formatted month as a table.
		 *         
		 */
		formatmonth(theyear, themonth, withyear?: boolean): Promise<any>
		formatmonth$({ theyear, themonth, withyear }: { theyear, themonth, withyear?}): Promise<any>

		/**
		 * 
		 *         Return a formatted year as a table of tables.
		 *         
		 */
		formatyear(theyear, width?): Promise<any>
		formatyear$({ theyear, width }: { theyear, width?}): Promise<any>

		/**
		 * 
		 *         Return a formatted year as a complete HTML page.
		 *         
		 */
		formatyearpage(theyear, width?, css?, encoding?): Promise<any>
		formatyearpage$({ theyear, width, css, encoding }: { theyear, width?, css?, encoding?}): Promise<any>
		cssclasses
		cssclasses_weekday_head
		cssclass_noday
		cssclass_month_head
		cssclass_month
		cssclass_year_head
		cssclass_year
	}
	function different_locale(locale): Promise<Idifferent_locale>
	function different_locale$({ locale }): Promise<Idifferent_locale>
	interface Idifferent_locale {
	}

	/**
	 * 
	 *     This class can be passed a locale name in the constructor and will return
	 *     month and weekday names in the specified locale. If this locale includes
	 *     an encoding all strings containing month and weekday names will be returned
	 *     as unicode.
	 *     
	 */
	function LocaleTextCalendar(firstweekday?, locale?): Promise<ILocaleTextCalendar>
	function LocaleTextCalendar$({ firstweekday, locale }: { firstweekday?, locale?}): Promise<ILocaleTextCalendar>
	interface ILocaleTextCalendar extends ITextCalendar {
		formatweekday(day, width): Promise<any>
		formatweekday$({ day, width }): Promise<any>
		formatmonthname(theyear, themonth, width, withyear?: boolean): Promise<any>
		formatmonthname$({ theyear, themonth, width, withyear }: { theyear, themonth, width, withyear?}): Promise<any>
	}

	/**
	 * 
	 *     This class can be passed a locale name in the constructor and will return
	 *     month and weekday names in the specified locale. If this locale includes
	 *     an encoding all strings containing month and weekday names will be returned
	 *     as unicode.
	 *     
	 */
	function LocaleHTMLCalendar(firstweekday?, locale?): Promise<ILocaleHTMLCalendar>
	function LocaleHTMLCalendar$({ firstweekday, locale }: { firstweekday?, locale?}): Promise<ILocaleHTMLCalendar>
	interface ILocaleHTMLCalendar extends IHTMLCalendar {
		formatweekday(day): Promise<any>
		formatweekday$({ day }): Promise<any>
		formatmonthname(theyear, themonth, withyear?: boolean): Promise<any>
		formatmonthname$({ theyear, themonth, withyear }: { theyear, themonth, withyear?}): Promise<any>
	}
	let error: Promise<any>
	let January: Promise<any>
	let February: Promise<any>
	let mdays: Promise<any>
	let day_name: Promise<any>
	let day_abbr: Promise<any>
	let month_name: Promise<any>
	let month_abbr: Promise<any>
	let c: Promise<any>
	let monthcalendar: Promise<any>
	let week: Promise<any>
	let weekheader: Promise<any>
	let month: Promise<any>
	let calendar: Promise<any>
	let prcal: Promise<any>
	let EPOCH: Promise<any>
}
declare module cgi {
	var _

	/**
	 * Write a log message, if there is a log file.
	 * 
	 *     Even though this function is called initlog(), you should always
	 *     use log(); log is a variable that is set either to initlog
	 *     (initially), to dolog (once the log file has been opened), or to
	 *     nolog (when logging is disabled).
	 * 
	 *     The first argument is a format string; the remaining arguments (if
	 *     any) are arguments to the % operator, so e.g.
	 *         log("%s: %s", "a", "b")
	 *     will write "a: b" to the log file, followed by a newline.
	 * 
	 *     If the global logfp is not None, it should be a file object to
	 *     which log data is written.
	 * 
	 *     If the global logfp is None, the global logfile may be a string
	 *     giving a filename to open, in append mode.  This file should be
	 *     world writable!!!  If the file can't be opened, logging is
	 *     silently disabled (since there is no safe place where we could
	 *     send an error message).
	 * 
	 *     
	 */
	function initlog(): Promise<any>
	function initlog$($: {}): Promise<any>

	/**
	 * Write a log message to the log file.  See initlog() for docs.
	 */
	function dolog(fmt): Promise<any>
	function dolog$({ fmt }): Promise<any>

	/**
	 * Dummy function, assigned to log when logging is disabled.
	 */
	function nolog(): Promise<any>
	function nolog$($: {}): Promise<any>

	/**
	 * Close the log file.
	 */
	function closelog(): Promise<any>
	function closelog$($: {}): Promise<any>

	/**
	 * Parse a query in the environment or from a file (default stdin)
	 * 
	 *         Arguments, all optional:
	 * 
	 *         fp              : file pointer; default: sys.stdin.buffer
	 * 
	 *         environ         : environment dictionary; default: os.environ
	 * 
	 *         keep_blank_values: flag indicating whether blank values in
	 *             percent-encoded forms should be treated as blank strings.
	 *             A true value indicates that blanks should be retained as
	 *             blank strings.  The default false value indicates that
	 *             blank values are to be ignored and treated as if they were
	 *             not included.
	 * 
	 *         strict_parsing: flag indicating what to do with parsing errors.
	 *             If false (the default), errors are silently ignored.
	 *             If true, errors raise a ValueError exception.
	 * 
	 *         separator: str. The symbol to use for separating the query arguments.
	 *             Defaults to &.
	 *     
	 */
	function parse(fp?, environ?, keep_blank_values?, strict_parsing?, separator?): Promise<any>
	function parse$({ fp, environ, keep_blank_values, strict_parsing, separator }: { fp?, environ?, keep_blank_values?, strict_parsing?, separator?}): Promise<any>

	/**
	 * Parse multipart input.
	 * 
	 *     Arguments:
	 *     fp   : input file
	 *     pdict: dictionary containing other parameters of content-type header
	 *     encoding, errors: request encoding and error handler, passed to
	 *         FieldStorage
	 * 
	 *     Returns a dictionary just like parse_qs(): keys are the field names, each
	 *     value is a list of values for that field. For non-file fields, the value
	 *     is a list of strings.
	 *     
	 */
	function parse_multipart(fp, pdict, encoding?, errors?, separator?): Promise<any>
	function parse_multipart$({ fp, pdict, encoding, errors, separator }: { fp, pdict, encoding?, errors?, separator?}): Promise<any>

	/**
	 * Parse a Content-type like header.
	 * 
	 *     Return the main content-type and a dictionary of options.
	 * 
	 *     
	 */
	function parse_header(line): Promise<any>
	function parse_header$({ line }): Promise<any>

	/**
	 * Robust test CGI script, usable as main program.
	 * 
	 *     Write minimal HTTP headers and dump all information provided to
	 *     the script in HTML form.
	 * 
	 *     
	 */
	function test(environ?): Promise<any>
	function test$({ environ }: { environ?}): Promise<any>
	function print_exception(type?, value?, tb?, limit?): Promise<any>
	function print_exception$({ type, value, tb, limit }: { type?, value?, tb?, limit?}): Promise<any>

	/**
	 * Dump the shell environment as HTML.
	 */
	function print_environ(environ?): Promise<any>
	function print_environ$({ environ }: { environ?}): Promise<any>

	/**
	 * Dump the contents of a form as HTML.
	 */
	function print_form(form): Promise<any>
	function print_form$({ form }): Promise<any>

	/**
	 * Dump the current directory as HTML.
	 */
	function print_directory(): Promise<any>
	function print_directory$($: {}): Promise<any>
	function print_arguments(): Promise<any>
	function print_arguments$($: {}): Promise<any>

	/**
	 * Dump a list of environment variables used by CGI as HTML.
	 */
	function print_environ_usage(): Promise<any>
	function print_environ_usage$($: {}): Promise<any>
	function valid_boundary(s): Promise<any>
	function valid_boundary$({ s }): Promise<any>

	/**
	 * Like FieldStorage, for use when no file uploads are possible.
	 */

	/**
	 * Constructor from field name and value.
	 */
	function MiniFieldStorage(name, value): Promise<IMiniFieldStorage>
	function MiniFieldStorage$({ name, value }): Promise<IMiniFieldStorage>
	interface IMiniFieldStorage {
		filename
		list
		type
		file
		type_options
		disposition
		disposition_options
		headers
	}

	/**
	 * Store a sequence of fields, reading multipart/form-data.
	 * 
	 *     This class provides naming, typing, files stored on disk, and
	 *     more.  At the top level, it is accessible like a dictionary, whose
	 *     keys are the field names.  (Note: None can occur as a field name.)
	 *     The items are either a Python list (if there's multiple values) or
	 *     another FieldStorage or MiniFieldStorage object.  If it's a single
	 *     object, it has the following attributes:
	 * 
	 *     name: the field name, if specified; otherwise None
	 * 
	 *     filename: the filename, if specified; otherwise None; this is the
	 *         client side filename, *not* the file name on which it is
	 *         stored (that's a temporary file you don't deal with)
	 * 
	 *     value: the value as a *string*; for file uploads, this
	 *         transparently reads the file every time you request the value
	 *         and returns *bytes*
	 * 
	 *     file: the file(-like) object from which you can read the data *as
	 *         bytes* ; None if the data is stored a simple string
	 * 
	 *     type: the content-type, or None if not specified
	 * 
	 *     type_options: dictionary of options specified on the content-type
	 *         line
	 * 
	 *     disposition: content-disposition, or None if not specified
	 * 
	 *     disposition_options: dictionary of corresponding options
	 * 
	 *     headers: a dictionary(-like) object (sometimes email.message.Message or a
	 *         subclass thereof) containing *all* headers
	 * 
	 *     The class is subclassable, mostly for the purpose of overriding
	 *     the make_file() method, which is called internally to come up with
	 *     a file open for reading and writing.  This makes it possible to
	 *     override the default choice of storing all files in a temporary
	 *     directory and unlinking them as soon as they have been opened.
	 * 
	 *     
	 */

	/**
	 * Constructor.  Read multipart/* until last part.
	 * 
	 *         Arguments, all optional:
	 * 
	 *         fp              : file pointer; default: sys.stdin.buffer
	 *             (not used when the request method is GET)
	 *             Can be :
	 *             1. a TextIOWrapper object
	 *             2. an object whose read() and readline() methods return bytes
	 * 
	 *         headers         : header dictionary-like object; default:
	 *             taken from environ as per CGI spec
	 * 
	 *         outerboundary   : terminating multipart boundary
	 *             (for internal use only)
	 * 
	 *         environ         : environment dictionary; default: os.environ
	 * 
	 *         keep_blank_values: flag indicating whether blank values in
	 *             percent-encoded forms should be treated as blank strings.
	 *             A true value indicates that blanks should be retained as
	 *             blank strings.  The default false value indicates that
	 *             blank values are to be ignored and treated as if they were
	 *             not included.
	 * 
	 *         strict_parsing: flag indicating what to do with parsing errors.
	 *             If false (the default), errors are silently ignored.
	 *             If true, errors raise a ValueError exception.
	 * 
	 *         limit : used internally to read parts of multipart/form-data forms,
	 *             to exit from the reading loop when reached. It is the difference
	 *             between the form content-length and the number of bytes already
	 *             read
	 * 
	 *         encoding, errors : the encoding and error handler used to decode the
	 *             binary stream to strings. Must be the same as the charset defined
	 *             for the page sending the form (content-type : meta http-equiv or
	 *             header)
	 * 
	 *         max_num_fields: int. If set, then __init__ throws a ValueError
	 *             if there are more than n fields read by parse_qsl().
	 * 
	 *         
	 */
	function FieldStorage(fp?, headers?, outerboundary?, environ?, keep_blank_values?, strict_parsing?, limit?, encoding?, errors?, max_num_fields?, separator?): Promise<IFieldStorage>
	function FieldStorage$({ fp, headers, outerboundary, environ, keep_blank_values, strict_parsing, limit, encoding, errors, max_num_fields, separator }: { fp?, headers?, outerboundary?, environ?, keep_blank_values?, strict_parsing?, limit?, encoding?, errors?, max_num_fields?, separator?}): Promise<IFieldStorage>
	interface IFieldStorage {

		/**
		 * Dictionary style get() method, including 'value' lookup.
		 */
		getvalue(key, def?): Promise<any>
		getvalue$({ key, def }: { key, def?}): Promise<any>

		/**
		 *  Return the first value received.
		 */
		getfirst(key, def?): Promise<any>
		getfirst$({ key, def }: { key, def?}): Promise<any>

		/**
		 *  Return list of received values.
		 */
		getlist(key): Promise<any>
		getlist$({ key }): Promise<any>

		/**
		 * Dictionary style keys() method.
		 */
		keys(): Promise<any>
		keys$($: {}): Promise<any>

		/**
		 * Internal: read data in query string format.
		 */
		read_urlencoded(): Promise<any>
		read_urlencoded$($: {}): Promise<any>

		/**
		 * Internal: read a part that is itself multipart.
		 */
		read_multi(environ, keep_blank_values, strict_parsing): Promise<any>
		read_multi$({ environ, keep_blank_values, strict_parsing }): Promise<any>

		/**
		 * Internal: read an atomic part.
		 */
		read_single(): Promise<any>
		read_single$($: {}): Promise<any>

		/**
		 * Internal: read binary data.
		 */
		read_binary(): Promise<any>
		read_binary$($: {}): Promise<any>

		/**
		 * Internal: read lines until EOF or outerboundary.
		 */
		read_lines(): Promise<any>
		read_lines$($: {}): Promise<any>

		/**
		 * Internal: read lines until EOF.
		 */
		read_lines_to_eof(): Promise<any>
		read_lines_to_eof$($: {}): Promise<any>

		/**
		 * Internal: read lines until outerboundary.
		 *         Data is read as bytes: boundaries and line ends must be converted
		 *         to bytes for comparisons.
		 *         
		 */
		read_lines_to_outerboundary(): Promise<any>
		read_lines_to_outerboundary$($: {}): Promise<any>

		/**
		 * Internal: skip lines until outer boundary if defined.
		 */
		skip_lines(): Promise<any>
		skip_lines$($: {}): Promise<any>

		/**
		 * Overridable: return a readable & writable file.
		 * 
		 *         The file will be used as follows:
		 *         - data is written to it
		 *         - seek(0)
		 *         - data is read from it
		 * 
		 *         The file is opened in binary mode for files, in text mode
		 *         for other fields
		 * 
		 *         This version opens a temporary file for reading and writing,
		 *         and immediately deletes (unlinks) it.  The trick (on Unix!) is
		 *         that the file can still be used, but it can't be opened by
		 *         another process, and it will automatically be deleted when it
		 *         is closed or when the current process terminates.
		 * 
		 *         If you want a more permanent file, you derive a class which
		 *         overrides this method.  If you want a visible temporary file
		 *         that is nevertheless automatically deleted when the script
		 *         terminates, try defining a __del__ method in a derived class
		 *         which unlinks the temporary files you have created.
		 * 
		 *         
		 */
		make_file(): Promise<any>
		make_file$($: {}): Promise<any>
		FieldStorageClass
		bufsize
	}
	let logfile: Promise<any>
	let logfp: Promise<any>
	let log: Promise<any>
	let maxlen: Promise<any>
}
declare module cgitb {
	var _

	/**
	 * Return a string that resets the CGI and browser to a known state.
	 */
	function reset(): Promise<any>
	function reset$($: {}): Promise<any>
	function small(text): Promise<any>
	function small$({ text }): Promise<any>
	function strong(text): Promise<any>
	function strong$({ text }): Promise<any>
	function grey(text): Promise<any>
	function grey$({ text }): Promise<any>

	/**
	 * Find the value for a given name in the given environment.
	 */
	function lookup(name, frame, locals): Promise<any>
	function lookup$({ name, frame, locals }): Promise<any>

	/**
	 * Scan one logical line of Python and look up values of variables used.
	 */
	function scanvars(reader, frame, locals): Promise<any>
	function scanvars$({ reader, frame, locals }): Promise<any>

	/**
	 * Return a nice HTML document describing a given traceback.
	 */
	function html(einfo, context?): Promise<any>
	function html$({ einfo, context }: { einfo, context?}): Promise<any>

	/**
	 * Return a plain text document describing a given traceback.
	 */
	function text(einfo, context?): Promise<any>
	function text$({ einfo, context }: { einfo, context?}): Promise<any>

	/**
	 * Install an exception handler that formats tracebacks as HTML.
	 * 
	 *     The optional argument 'display' can be set to 0 to suppress sending the
	 *     traceback to the browser, and 'logdir' can be set to a directory to cause
	 *     tracebacks to be written to files there.
	 */
	function enable(display?, logdir?, context?, format?): Promise<any>
	function enable$({ display, logdir, context, format }: { display?, logdir?, context?, format?}): Promise<any>

	/**
	 * A hook to replace sys.excepthook that shows tracebacks in HTML.
	 */
	function Hook(display?, logdir?, context?, file?, format?): Promise<IHook>
	function Hook$({ display, logdir, context, file, format }: { display?, logdir?, context?, file?, format?}): Promise<IHook>
	interface IHook {
		handle(info?): Promise<any>
		handle$({ info }: { info?}): Promise<any>
	}
	let handler: Promise<any>
}
declare module chunk {
	var _
	function Chunk(file, align?: boolean, bigendian?: boolean, inclheader?: boolean): Promise<IChunk>
	function Chunk$({ file, align, bigendian, inclheader }: { file, align?, bigendian?, inclheader?}): Promise<IChunk>
	interface IChunk {

		/**
		 * Return the name (ID) of the current chunk.
		 */
		getname(): Promise<any>
		getname$($: {}): Promise<any>

		/**
		 * Return the size of the current chunk.
		 */
		getsize(): Promise<any>
		getsize$($: {}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
		isatty(): Promise<any>
		isatty$($: {}): Promise<any>

		/**
		 * Seek to specified position into the chunk.
		 *         Default position is 0 (start of chunk).
		 *         If the file is not seekable, this will result in an error.
		 *         
		 */
		seek(pos, whence?): Promise<any>
		seek$({ pos, whence }: { pos, whence?}): Promise<any>
		tell(): Promise<any>
		tell$($: {}): Promise<any>

		/**
		 * Read at most size bytes from the chunk.
		 *         If size is omitted or negative, read until the end
		 *         of the chunk.
		 *         
		 */
		read(size?): Promise<any>
		read$({ size }: { size?}): Promise<any>

		/**
		 * Skip the rest of the chunk.
		 *         If you are not interested in the contents of the chunk,
		 *         this method should be called so that the file points to
		 *         the start of the next chunk.
		 *         
		 */
		skip(): Promise<any>
		skip$($: {}): Promise<any>
	}
}
declare module cmd {
	var _

	/**
	 * A simple framework for writing line-oriented command interpreters.
	 * 
	 *     These are often useful for test harnesses, administrative tools, and
	 *     prototypes that will later be wrapped in a more sophisticated interface.
	 * 
	 *     A Cmd instance or subclass instance is a line-oriented interpreter
	 *     framework.  There is no good reason to instantiate Cmd itself; rather,
	 *     it's useful as a superclass of an interpreter class you define yourself
	 *     in order to inherit Cmd's methods and encapsulate action methods.
	 * 
	 *     
	 */

	/**
	 * Instantiate a line-oriented interpreter framework.
	 * 
	 *         The optional argument 'completekey' is the readline name of a
	 *         completion key; it defaults to the Tab key. If completekey is
	 *         not None and the readline module is available, command completion
	 *         is done automatically. The optional arguments stdin and stdout
	 *         specify alternate input and output file objects; if not specified,
	 *         sys.stdin and sys.stdout are used.
	 * 
	 *         
	 */
	function Cmd(completekey?, stdin?, stdout?): Promise<ICmd>
	function Cmd$({ completekey, stdin, stdout }: { completekey?, stdin?, stdout?}): Promise<ICmd>
	interface ICmd {

		/**
		 * Repeatedly issue a prompt, accept input, parse an initial prefix
		 *         off the received input, and dispatch to action methods, passing them
		 *         the remainder of the line as argument.
		 * 
		 *         
		 */
		cmdloop(intro?): Promise<any>
		cmdloop$({ intro }: { intro?}): Promise<any>

		/**
		 * Hook method executed just before the command line is
		 *         interpreted, but after the input prompt is generated and issued.
		 * 
		 *         
		 */
		precmd(line): Promise<any>
		precmd$({ line }): Promise<any>

		/**
		 * Hook method executed just after a command dispatch is finished.
		 */
		postcmd(stop, line): Promise<any>
		postcmd$({ stop, line }): Promise<any>

		/**
		 * Hook method executed once when the cmdloop() method is called.
		 */
		preloop(): Promise<any>
		preloop$($: {}): Promise<any>

		/**
		 * Hook method executed once when the cmdloop() method is about to
		 *         return.
		 * 
		 *         
		 */
		postloop(): Promise<any>
		postloop$($: {}): Promise<any>

		/**
		 * Parse the line into a command name and a string containing
		 *         the arguments.  Returns a tuple containing (command, args, line).
		 *         'command' and 'args' may be None if the line couldn't be parsed.
		 *         
		 */
		parseline(line): Promise<any>
		parseline$({ line }): Promise<any>

		/**
		 * Interpret the argument as though it had been typed in response
		 *         to the prompt.
		 * 
		 *         This may be overridden, but should not normally need to be;
		 *         see the precmd() and postcmd() methods for useful execution hooks.
		 *         The return value is a flag indicating whether interpretation of
		 *         commands by the interpreter should stop.
		 * 
		 *         
		 */
		onecmd(line): Promise<any>
		onecmd$({ line }): Promise<any>

		/**
		 * Called when an empty line is entered in response to the prompt.
		 * 
		 *         If this method is not overridden, it repeats the last nonempty
		 *         command entered.
		 * 
		 *         
		 */
		emptyline(): Promise<any>
		emptyline$($: {}): Promise<any>

		/**
		 * Called on an input line when the command prefix is not recognized.
		 * 
		 *         If this method is not overridden, it prints an error message and
		 *         returns.
		 * 
		 *         
		 */
		default(line): Promise<any>
		default$({ line }): Promise<any>

		/**
		 * Method called to complete an input line when no command-specific
		 *         complete_*() method is available.
		 * 
		 *         By default, it returns an empty list.
		 * 
		 *         
		 */
		completedefault(): Promise<any>
		completedefault$($: {}): Promise<any>
		completenames(text): Promise<any>
		completenames$({ text }): Promise<any>

		/**
		 * Return the next possible completion for 'text'.
		 * 
		 *         If a command has not been entered, then complete against command list.
		 *         Otherwise try to call complete_<command> to get list of completions.
		 *         
		 */
		complete(text, state): Promise<any>
		complete$({ text, state }): Promise<any>
		get_names(): Promise<any>
		get_names$($: {}): Promise<any>
		complete_help(): Promise<any>
		complete_help$($: {}): Promise<any>

		/**
		 * List available commands with "help" or detailed help with "help cmd".
		 */
		do_help(arg): Promise<any>
		do_help$({ arg }): Promise<any>
		print_topics(header, cmds, cmdlen, maxcol): Promise<any>
		print_topics$({ header, cmds, cmdlen, maxcol }): Promise<any>

		/**
		 * Display a list of strings as a compact set of columns.
		 * 
		 *         Each column is only as wide as necessary.
		 *         Columns are separated by two spaces (one was not legible enough).
		 *         
		 */
		columnize(list, displaywidth?): Promise<any>
		columnize$({ list, displaywidth }: { list, displaywidth?}): Promise<any>
		prompt
		identchars
		ruler
		lastcmd
		intro
		doc_leader
		doc_header
		misc_header
		undoc_header
		nohelp
		use_rawinput
	}
	let PROMPT: Promise<any>
	let IDENTCHARS: Promise<any>
}
declare module code {
	var _

	/**
	 * Closely emulate the interactive Python interpreter.
	 * 
	 *     This is a backwards compatible interface to the InteractiveConsole
	 *     class.  When readfunc is not specified, it attempts to import the
	 *     readline module to enable GNU readline if it is available.
	 * 
	 *     Arguments (all optional, all default to None):
	 * 
	 *     banner -- passed to InteractiveConsole.interact()
	 *     readfunc -- if not None, replaces InteractiveConsole.raw_input()
	 *     local -- passed to InteractiveInterpreter.__init__()
	 *     exitmsg -- passed to InteractiveConsole.interact()
	 * 
	 *     
	 */
	function interact(banner?, readfunc?, local?, exitmsg?): Promise<any>
	function interact$({ banner, readfunc, local, exitmsg }: { banner?, readfunc?, local?, exitmsg?}): Promise<any>

	/**
	 * Base class for InteractiveConsole.
	 * 
	 *     This class deals with parsing and interpreter state (the user's
	 *     namespace); it doesn't deal with input buffering or prompting or
	 *     input file naming (the filename is always passed in explicitly).
	 * 
	 *     
	 */

	/**
	 * Constructor.
	 * 
	 *         The optional 'locals' argument specifies the dictionary in
	 *         which code will be executed; it defaults to a newly created
	 *         dictionary with key "__name__" set to "__console__" and key
	 *         "__doc__" set to None.
	 * 
	 *         
	 */
	function InteractiveInterpreter(locals?): Promise<IInteractiveInterpreter>
	function InteractiveInterpreter$({ locals }: { locals?}): Promise<IInteractiveInterpreter>
	interface IInteractiveInterpreter {

		/**
		 * Compile and run some source in the interpreter.
		 * 
		 *         Arguments are as for compile_command().
		 * 
		 *         One of several things can happen:
		 * 
		 *         1) The input is incorrect; compile_command() raised an
		 *         exception (SyntaxError or OverflowError).  A syntax traceback
		 *         will be printed by calling the showsyntaxerror() method.
		 * 
		 *         2) The input is incomplete, and more input is required;
		 *         compile_command() returned None.  Nothing happens.
		 * 
		 *         3) The input is complete; compile_command() returned a code
		 *         object.  The code is executed by calling self.runcode() (which
		 *         also handles run-time exceptions, except for SystemExit).
		 * 
		 *         The return value is True in case 2, False in the other cases (unless
		 *         an exception is raised).  The return value can be used to
		 *         decide whether to use sys.ps1 or sys.ps2 to prompt the next
		 *         line.
		 * 
		 *         
		 */
		runsource(source, filename?, symbol?): Promise<any>
		runsource$({ source, filename, symbol }: { source, filename?, symbol?}): Promise<any>

		/**
		 * Execute a code object.
		 * 
		 *         When an exception occurs, self.showtraceback() is called to
		 *         display a traceback.  All exceptions are caught except
		 *         SystemExit, which is reraised.
		 * 
		 *         A note about KeyboardInterrupt: this exception may occur
		 *         elsewhere in this code, and may not always be caught.  The
		 *         caller should be prepared to deal with it.
		 * 
		 *         
		 */
		runcode(code): Promise<any>
		runcode$({ code }): Promise<any>

		/**
		 * Display the syntax error that just occurred.
		 * 
		 *         This doesn't display a stack trace because there isn't one.
		 * 
		 *         If a filename is given, it is stuffed in the exception instead
		 *         of what was there before (because Python's parser always uses
		 *         "<string>" when reading from a string).
		 * 
		 *         The output is written by self.write(), below.
		 * 
		 *         
		 */
		showsyntaxerror(filename?): Promise<any>
		showsyntaxerror$({ filename }: { filename?}): Promise<any>

		/**
		 * Display the exception that just occurred.
		 * 
		 *         We remove the first stack item because it is our own code.
		 * 
		 *         The output is written by self.write(), below.
		 * 
		 *         
		 */
		showtraceback(): Promise<any>
		showtraceback$($: {}): Promise<any>

		/**
		 * Write a string.
		 * 
		 *         The base implementation writes to sys.stderr; a subclass may
		 *         replace this with a different implementation.
		 * 
		 *         
		 */
		write(data): Promise<any>
		write$({ data }): Promise<any>
	}

	/**
	 * Closely emulate the behavior of the interactive Python interpreter.
	 * 
	 *     This class builds on InteractiveInterpreter and adds prompting
	 *     using the familiar sys.ps1 and sys.ps2, and input buffering.
	 * 
	 *     
	 */

	/**
	 * Constructor.
	 * 
	 *         The optional locals argument will be passed to the
	 *         InteractiveInterpreter base class.
	 * 
	 *         The optional filename argument should specify the (file)name
	 *         of the input stream; it will show up in tracebacks.
	 * 
	 *         
	 */
	function InteractiveConsole(locals?, filename?): Promise<IInteractiveConsole>
	function InteractiveConsole$({ locals, filename }: { locals?, filename?}): Promise<IInteractiveConsole>
	interface IInteractiveConsole extends IInteractiveInterpreter {

		/**
		 * Reset the input buffer.
		 */
		resetbuffer(): Promise<any>
		resetbuffer$($: {}): Promise<any>

		/**
		 * Closely emulate the interactive Python console.
		 * 
		 *         The optional banner argument specifies the banner to print
		 *         before the first interaction; by default it prints a banner
		 *         similar to the one printed by the real Python interpreter,
		 *         followed by the current class name in parentheses (so as not
		 *         to confuse this with the real interpreter -- since it's so
		 *         close!).
		 * 
		 *         The optional exitmsg argument specifies the exit message
		 *         printed when exiting. Pass the empty string to suppress
		 *         printing an exit message. If exitmsg is not given or None,
		 *         a default message is printed.
		 * 
		 *         
		 */
		interact(banner?, exitmsg?): Promise<any>
		interact$({ banner, exitmsg }: { banner?, exitmsg?}): Promise<any>

		/**
		 * Push a line to the interpreter.
		 * 
		 *         The line should not have a trailing newline; it may have
		 *         internal newlines.  The line is appended to a buffer and the
		 *         interpreter's runsource() method is called with the
		 *         concatenated contents of the buffer as source.  If this
		 *         indicates that the command was executed or invalid, the buffer
		 *         is reset; otherwise, the command is incomplete, and the buffer
		 *         is left as it was after the line was appended.  The return
		 *         value is 1 if more input is required, 0 if the line was dealt
		 *         with in some way (this is the same as runsource()).
		 * 
		 *         
		 */
		push(line): Promise<any>
		push$({ line }): Promise<any>

		/**
		 * Write a prompt and read a line.
		 * 
		 *         The returned line does not include the trailing newline.
		 *         When the user enters the EOF key sequence, EOFError is raised.
		 * 
		 *         The base implementation uses the built-in function
		 *         input(); a subclass may replace this with a different
		 *         implementation.
		 * 
		 *         
		 */
		raw_input(prompt?): Promise<any>
		raw_input$({ prompt }: { prompt?}): Promise<any>
	}
	let parser: Promise<any>
	let args: Promise<any>
	let banner: Promise<any>
}
declare module codecs {
	var _

	/**
	 *  Open an encoded file using the given mode and return
	 *         a wrapped version providing transparent encoding/decoding.
	 * 
	 *         Note: The wrapped version will only accept the object format
	 *         defined by the codecs, i.e. Unicode objects for most builtin
	 *         codecs. Output is also codec dependent and will usually be
	 *         Unicode as well.
	 * 
	 *         Underlying encoded files are always opened in binary mode.
	 *         The default file mode is 'r', meaning to open the file in read mode.
	 * 
	 *         encoding specifies the encoding which is to be used for the
	 *         file.
	 * 
	 *         errors may be given to define the error handling. It defaults
	 *         to 'strict' which causes ValueErrors to be raised in case an
	 *         encoding error occurs.
	 * 
	 *         buffering has the same meaning as for the builtin open() API.
	 *         It defaults to -1 which means that the default buffer size will
	 *         be used.
	 * 
	 *         The returned wrapped file object provides an extra attribute
	 *         .encoding which allows querying the used encoding. This
	 *         attribute is only available if an encoding was specified as
	 *         parameter.
	 * 
	 *     
	 */
	function open(filename, mode?, encoding?, errors?, buffering?): Promise<any>
	function open$({ filename, mode, encoding, errors, buffering }: { filename, mode?, encoding?, errors?, buffering?}): Promise<any>

	/**
	 *  Return a wrapped version of file which provides transparent
	 *         encoding translation.
	 * 
	 *         Data written to the wrapped file is decoded according
	 *         to the given data_encoding and then encoded to the underlying
	 *         file using file_encoding. The intermediate data type
	 *         will usually be Unicode but depends on the specified codecs.
	 * 
	 *         Bytes read from the file are decoded using file_encoding and then
	 *         passed back to the caller encoded using data_encoding.
	 * 
	 *         If file_encoding is not given, it defaults to data_encoding.
	 * 
	 *         errors may be given to define the error handling. It defaults
	 *         to 'strict' which causes ValueErrors to be raised in case an
	 *         encoding error occurs.
	 * 
	 *         The returned wrapped file object provides two extra attributes
	 *         .data_encoding and .file_encoding which reflect the given
	 *         parameters of the same name. The attributes can be used for
	 *         introspection by Python programs.
	 * 
	 *     
	 */
	function EncodedFile(file, data_encoding, file_encoding?, errors?): Promise<any>
	function EncodedFile$({ file, data_encoding, file_encoding, errors }: { file, data_encoding, file_encoding?, errors?}): Promise<any>

	/**
	 *  Lookup up the codec for the given encoding and return
	 *         its encoder function.
	 * 
	 *         Raises a LookupError in case the encoding cannot be found.
	 * 
	 *     
	 */
	function getencoder(encoding): Promise<any>
	function getencoder$({ encoding }): Promise<any>

	/**
	 *  Lookup up the codec for the given encoding and return
	 *         its decoder function.
	 * 
	 *         Raises a LookupError in case the encoding cannot be found.
	 * 
	 *     
	 */
	function getdecoder(encoding): Promise<any>
	function getdecoder$({ encoding }): Promise<any>

	/**
	 *  Lookup up the codec for the given encoding and return
	 *         its IncrementalEncoder class or factory function.
	 * 
	 *         Raises a LookupError in case the encoding cannot be found
	 *         or the codecs doesn't provide an incremental encoder.
	 * 
	 *     
	 */
	function getincrementalencoder(encoding): Promise<any>
	function getincrementalencoder$({ encoding }): Promise<any>

	/**
	 *  Lookup up the codec for the given encoding and return
	 *         its IncrementalDecoder class or factory function.
	 * 
	 *         Raises a LookupError in case the encoding cannot be found
	 *         or the codecs doesn't provide an incremental decoder.
	 * 
	 *     
	 */
	function getincrementaldecoder(encoding): Promise<any>
	function getincrementaldecoder$({ encoding }): Promise<any>

	/**
	 *  Lookup up the codec for the given encoding and return
	 *         its StreamReader class or factory function.
	 * 
	 *         Raises a LookupError in case the encoding cannot be found.
	 * 
	 *     
	 */
	function getreader(encoding): Promise<any>
	function getreader$({ encoding }): Promise<any>

	/**
	 *  Lookup up the codec for the given encoding and return
	 *         its StreamWriter class or factory function.
	 * 
	 *         Raises a LookupError in case the encoding cannot be found.
	 * 
	 *     
	 */
	function getwriter(encoding): Promise<any>
	function getwriter$({ encoding }): Promise<any>

	/**
	 * 
	 *     Encoding iterator.
	 * 
	 *     Encodes the input strings from the iterator using an IncrementalEncoder.
	 * 
	 *     errors and kwargs are passed through to the IncrementalEncoder
	 *     constructor.
	 *     
	 */
	function iterencode(iterator, encoding, errors?): Promise<any>
	function iterencode$({ iterator, encoding, errors }: { iterator, encoding, errors?}): Promise<any>

	/**
	 * 
	 *     Decoding iterator.
	 * 
	 *     Decodes the input strings from the iterator using an IncrementalDecoder.
	 * 
	 *     errors and kwargs are passed through to the IncrementalDecoder
	 *     constructor.
	 *     
	 */
	function iterdecode(iterator, encoding, errors?): Promise<any>
	function iterdecode$({ iterator, encoding, errors }: { iterator, encoding, errors?}): Promise<any>

	/**
	 *  make_identity_dict(rng) -> dict
	 * 
	 *         Return a dictionary where elements of the rng sequence are
	 *         mapped to themselves.
	 * 
	 *     
	 */
	function make_identity_dict(rng): Promise<any>
	function make_identity_dict$({ rng }): Promise<any>

	/**
	 *  Creates an encoding map from a decoding map.
	 * 
	 *         If a target mapping in the decoding map occurs multiple
	 *         times, then that target is mapped to None (undefined mapping),
	 *         causing an exception when encountered by the charmap codec
	 *         during translation.
	 * 
	 *         One example where this happens is cp875.py which decodes
	 *         multiple character to \u001a.
	 * 
	 *     
	 */
	function make_encoding_map(decoding_map): Promise<any>
	function make_encoding_map$({ decoding_map }): Promise<any>

	/**
	 * Codec details when looking up the codec registry
	 */
	interface ICodecInfo {
	}

	/**
	 *  Defines the interface for stateless encoders/decoders.
	 * 
	 *         The .encode()/.decode() methods may use different error
	 *         handling schemes by providing the errors argument. These
	 *         string values are predefined:
	 * 
	 *          'strict' - raise a ValueError error (or a subclass)
	 *          'ignore' - ignore the character and continue with the next
	 *          'replace' - replace with a suitable replacement character;
	 *                     Python will use the official U+FFFD REPLACEMENT
	 *                     CHARACTER for the builtin Unicode codecs on
	 *                     decoding and '?' on encoding.
	 *          'surrogateescape' - replace with private code points U+DCnn.
	 *          'xmlcharrefreplace' - Replace with the appropriate XML
	 *                                character reference (only for encoding).
	 *          'backslashreplace'  - Replace with backslashed escape sequences.
	 *          'namereplace'       - Replace with \N{...} escape sequences
	 *                                (only for encoding).
	 * 
	 *         The set of allowed values can be extended via register_error.
	 * 
	 *     
	 */
	interface ICodec {

		/**
		 *  Encodes the object input and returns a tuple (output
		 *             object, length consumed).
		 * 
		 *             errors defines the error handling to apply. It defaults to
		 *             'strict' handling.
		 * 
		 *             The method may not store state in the Codec instance. Use
		 *             StreamWriter for codecs which have to keep state in order to
		 *             make encoding efficient.
		 * 
		 *             The encoder must be able to handle zero length input and
		 *             return an empty object of the output object type in this
		 *             situation.
		 * 
		 *         
		 */
		encode(input, errors?): Promise<any>
		encode$({ input, errors }: { input, errors?}): Promise<any>

		/**
		 *  Decodes the object input and returns a tuple (output
		 *             object, length consumed).
		 * 
		 *             input must be an object which provides the bf_getreadbuf
		 *             buffer slot. Python strings, buffer objects and memory
		 *             mapped files are examples of objects providing this slot.
		 * 
		 *             errors defines the error handling to apply. It defaults to
		 *             'strict' handling.
		 * 
		 *             The method may not store state in the Codec instance. Use
		 *             StreamReader for codecs which have to keep state in order to
		 *             make decoding efficient.
		 * 
		 *             The decoder must be able to handle zero length input and
		 *             return an empty object of the output object type in this
		 *             situation.
		 * 
		 *         
		 */
		decode(input, errors?): Promise<any>
		decode$({ input, errors }: { input, errors?}): Promise<any>
	}

	/**
	 * 
	 *     An IncrementalEncoder encodes an input in multiple steps. The input can
	 *     be passed piece by piece to the encode() method. The IncrementalEncoder
	 *     remembers the state of the encoding process between calls to encode().
	 *     
	 */

	/**
	 * 
	 *         Creates an IncrementalEncoder instance.
	 * 
	 *         The IncrementalEncoder may use different error handling schemes by
	 *         providing the errors keyword argument. See the module docstring
	 *         for a list of possible values.
	 *         
	 */
	function IncrementalEncoder(errors?): Promise<IIncrementalEncoder>
	function IncrementalEncoder$({ errors }: { errors?}): Promise<IIncrementalEncoder>
	interface IIncrementalEncoder {

		/**
		 * 
		 *         Encodes input and returns the resulting object.
		 *         
		 */
		encode(input, final?: boolean): Promise<any>
		encode$({ input, final }: { input, final?}): Promise<any>

		/**
		 * 
		 *         Resets the encoder to the initial state.
		 *         
		 */
		reset(): Promise<any>
		reset$($: {}): Promise<any>

		/**
		 * 
		 *         Return the current state of the encoder.
		 *         
		 */
		getstate(): Promise<any>
		getstate$($: {}): Promise<any>

		/**
		 * 
		 *         Set the current state of the encoder. state must have been
		 *         returned by getstate().
		 *         
		 */
		setstate(state): Promise<any>
		setstate$({ state }): Promise<any>
	}

	/**
	 * 
	 *     This subclass of IncrementalEncoder can be used as the baseclass for an
	 *     incremental encoder if the encoder must keep some of the output in a
	 *     buffer between calls to encode().
	 *     
	 */
	function BufferedIncrementalEncoder(errors?): Promise<IBufferedIncrementalEncoder>
	function BufferedIncrementalEncoder$({ errors }: { errors?}): Promise<IBufferedIncrementalEncoder>
	interface IBufferedIncrementalEncoder extends IIncrementalEncoder {
		encode(input, final?: boolean): Promise<any>
		encode$({ input, final }: { input, final?}): Promise<any>
		reset(): Promise<any>
		reset$($: {}): Promise<any>
		getstate(): Promise<any>
		getstate$($: {}): Promise<any>
		setstate(state): Promise<any>
		setstate$({ state }): Promise<any>
	}

	/**
	 * 
	 *     An IncrementalDecoder decodes an input in multiple steps. The input can
	 *     be passed piece by piece to the decode() method. The IncrementalDecoder
	 *     remembers the state of the decoding process between calls to decode().
	 *     
	 */

	/**
	 * 
	 *         Create an IncrementalDecoder instance.
	 * 
	 *         The IncrementalDecoder may use different error handling schemes by
	 *         providing the errors keyword argument. See the module docstring
	 *         for a list of possible values.
	 *         
	 */
	function IncrementalDecoder(errors?): Promise<IIncrementalDecoder>
	function IncrementalDecoder$({ errors }: { errors?}): Promise<IIncrementalDecoder>
	interface IIncrementalDecoder {

		/**
		 * 
		 *         Decode input and returns the resulting object.
		 *         
		 */
		decode(input, final?: boolean): Promise<any>
		decode$({ input, final }: { input, final?}): Promise<any>

		/**
		 * 
		 *         Reset the decoder to the initial state.
		 *         
		 */
		reset(): Promise<any>
		reset$($: {}): Promise<any>

		/**
		 * 
		 *         Return the current state of the decoder.
		 * 
		 *         This must be a (buffered_input, additional_state_info) tuple.
		 *         buffered_input must be a bytes object containing bytes that
		 *         were passed to decode() that have not yet been converted.
		 *         additional_state_info must be a non-negative integer
		 *         representing the state of the decoder WITHOUT yet having
		 *         processed the contents of buffered_input.  In the initial state
		 *         and after reset(), getstate() must return (b"", 0).
		 *         
		 */
		getstate(): Promise<any>
		getstate$($: {}): Promise<any>

		/**
		 * 
		 *         Set the current state of the decoder.
		 * 
		 *         state must have been returned by getstate().  The effect of
		 *         setstate((b"", 0)) must be equivalent to reset().
		 *         
		 */
		setstate(state): Promise<any>
		setstate$({ state }): Promise<any>
	}

	/**
	 * 
	 *     This subclass of IncrementalDecoder can be used as the baseclass for an
	 *     incremental decoder if the decoder must be able to handle incomplete
	 *     byte sequences.
	 *     
	 */
	function BufferedIncrementalDecoder(errors?): Promise<IBufferedIncrementalDecoder>
	function BufferedIncrementalDecoder$({ errors }: { errors?}): Promise<IBufferedIncrementalDecoder>
	interface IBufferedIncrementalDecoder extends IIncrementalDecoder {
		decode(input, final?: boolean): Promise<any>
		decode$({ input, final }: { input, final?}): Promise<any>
		reset(): Promise<any>
		reset$($: {}): Promise<any>
		getstate(): Promise<any>
		getstate$($: {}): Promise<any>
		setstate(state): Promise<any>
		setstate$({ state }): Promise<any>
	}

	/**
	 *  Creates a StreamWriter instance.
	 * 
	 *             stream must be a file-like object open for writing.
	 * 
	 *             The StreamWriter may use different error handling
	 *             schemes by providing the errors keyword argument. These
	 *             parameters are predefined:
	 * 
	 *              'strict' - raise a ValueError (or a subclass)
	 *              'ignore' - ignore the character and continue with the next
	 *              'replace'- replace with a suitable replacement character
	 *              'xmlcharrefreplace' - Replace with the appropriate XML
	 *                                    character reference.
	 *              'backslashreplace'  - Replace with backslashed escape
	 *                                    sequences.
	 *              'namereplace'       - Replace with \N{...} escape sequences.
	 * 
	 *             The set of allowed parameter values can be extended via
	 *             register_error.
	 *         
	 */
	function StreamWriter(stream, errors?): Promise<IStreamWriter>
	function StreamWriter$({ stream, errors }: { stream, errors?}): Promise<IStreamWriter>
	interface IStreamWriter extends ICodec {

		/**
		 *  Writes the object's contents encoded to self.stream.
		 *         
		 */
		write(object): Promise<any>
		write$({ object }): Promise<any>

		/**
		 *  Writes the concatenated list of strings to the stream
		 *             using .write().
		 *         
		 */
		writelines(list): Promise<any>
		writelines$({ list }): Promise<any>

		/**
		 *  Resets the codec buffers used for keeping internal state.
		 * 
		 *             Calling this method should ensure that the data on the
		 *             output is put into a clean state, that allows appending
		 *             of new fresh data without having to rescan the whole
		 *             stream to recover state.
		 * 
		 *         
		 */
		reset(): Promise<any>
		reset$($: {}): Promise<any>
		seek(offset, whence?): Promise<any>
		seek$({ offset, whence }: { offset, whence?}): Promise<any>
	}

	/**
	 *  Creates a StreamReader instance.
	 * 
	 *             stream must be a file-like object open for reading.
	 * 
	 *             The StreamReader may use different error handling
	 *             schemes by providing the errors keyword argument. These
	 *             parameters are predefined:
	 * 
	 *              'strict' - raise a ValueError (or a subclass)
	 *              'ignore' - ignore the character and continue with the next
	 *              'replace'- replace with a suitable replacement character
	 *              'backslashreplace' - Replace with backslashed escape sequences;
	 * 
	 *             The set of allowed parameter values can be extended via
	 *             register_error.
	 *         
	 */
	function StreamReader(stream, errors?): Promise<IStreamReader>
	function StreamReader$({ stream, errors }: { stream, errors?}): Promise<IStreamReader>
	interface IStreamReader extends ICodec {
		decode(input, errors?): Promise<any>
		decode$({ input, errors }: { input, errors?}): Promise<any>

		/**
		 *  Decodes data from the stream self.stream and returns the
		 *             resulting object.
		 * 
		 *             chars indicates the number of decoded code points or bytes to
		 *             return. read() will never return more data than requested,
		 *             but it might return less, if there is not enough available.
		 * 
		 *             size indicates the approximate maximum number of decoded
		 *             bytes or code points to read for decoding. The decoder
		 *             can modify this setting as appropriate. The default value
		 *             -1 indicates to read and decode as much as possible.  size
		 *             is intended to prevent having to decode huge files in one
		 *             step.
		 * 
		 *             If firstline is true, and a UnicodeDecodeError happens
		 *             after the first line terminator in the input only the first line
		 *             will be returned, the rest of the input will be kept until the
		 *             next call to read().
		 * 
		 *             The method should use a greedy read strategy, meaning that
		 *             it should read as much data as is allowed within the
		 *             definition of the encoding and the given size, e.g.  if
		 *             optional encoding endings or state markers are available
		 *             on the stream, these should be read too.
		 *         
		 */
		read(size?, chars?, firstline?: boolean): Promise<any>
		read$({ size, chars, firstline }: { size?, chars?, firstline?}): Promise<any>

		/**
		 *  Read one line from the input stream and return the
		 *             decoded data.
		 * 
		 *             size, if given, is passed as size argument to the
		 *             read() method.
		 * 
		 *         
		 */
		readline(size?, keepends?: boolean): Promise<any>
		readline$({ size, keepends }: { size?, keepends?}): Promise<any>

		/**
		 *  Read all lines available on the input stream
		 *             and return them as a list.
		 * 
		 *             Line breaks are implemented using the codec's decoder
		 *             method and are included in the list entries.
		 * 
		 *             sizehint, if given, is ignored since there is no efficient
		 *             way to finding the true end-of-line.
		 * 
		 *         
		 */
		readlines(sizehint?, keepends?: boolean): Promise<any>
		readlines$({ sizehint, keepends }: { sizehint?, keepends?}): Promise<any>

		/**
		 *  Resets the codec buffers used for keeping internal state.
		 * 
		 *             Note that no stream repositioning should take place.
		 *             This method is primarily intended to be able to recover
		 *             from decoding errors.
		 * 
		 *         
		 */
		reset(): Promise<any>
		reset$($: {}): Promise<any>

		/**
		 *  Set the input stream's current position.
		 * 
		 *             Resets the codec buffers used for keeping state.
		 *         
		 */
		seek(offset, whence?): Promise<any>
		seek$({ offset, whence }: { offset, whence?}): Promise<any>
		charbuffertype
	}

	/**
	 *  StreamReaderWriter instances allow wrapping streams which
	 *         work in both read and write modes.
	 * 
	 *         The design is such that one can use the factory functions
	 *         returned by the codec.lookup() function to construct the
	 *         instance.
	 * 
	 *     
	 */

	/**
	 *  Creates a StreamReaderWriter instance.
	 * 
	 *             stream must be a Stream-like object.
	 * 
	 *             Reader, Writer must be factory functions or classes
	 *             providing the StreamReader, StreamWriter interface resp.
	 * 
	 *             Error handling is done in the same way as defined for the
	 *             StreamWriter/Readers.
	 * 
	 *         
	 */
	function StreamReaderWriter(stream, Reader, Writer, errors?): Promise<IStreamReaderWriter>
	function StreamReaderWriter$({ stream, Reader, Writer, errors }: { stream, Reader, Writer, errors?}): Promise<IStreamReaderWriter>
	interface IStreamReaderWriter {
		read(size?): Promise<any>
		read$({ size }: { size?}): Promise<any>
		readline(size?): Promise<any>
		readline$({ size }: { size?}): Promise<any>
		readlines(sizehint?): Promise<any>
		readlines$({ sizehint }: { sizehint?}): Promise<any>
		write(data): Promise<any>
		write$({ data }): Promise<any>
		writelines(list): Promise<any>
		writelines$({ list }): Promise<any>
		reset(): Promise<any>
		reset$($: {}): Promise<any>
		seek(offset, whence?): Promise<any>
		seek$({ offset, whence }: { offset, whence?}): Promise<any>
		encoding
	}

	/**
	 *  StreamRecoder instances translate data from one encoding to another.
	 * 
	 *         They use the complete set of APIs returned by the
	 *         codecs.lookup() function to implement their task.
	 * 
	 *         Data written to the StreamRecoder is first decoded into an
	 *         intermediate format (depending on the "decode" codec) and then
	 *         written to the underlying stream using an instance of the provided
	 *         Writer class.
	 * 
	 *         In the other direction, data is read from the underlying stream using
	 *         a Reader instance and then encoded and returned to the caller.
	 * 
	 *     
	 */

	/**
	 *  Creates a StreamRecoder instance which implements a two-way
	 *             conversion: encode and decode work on the frontend (the
	 *             data visible to .read() and .write()) while Reader and Writer
	 *             work on the backend (the data in stream).
	 * 
	 *             You can use these objects to do transparent
	 *             transcodings from e.g. latin-1 to utf-8 and back.
	 * 
	 *             stream must be a file-like object.
	 * 
	 *             encode and decode must adhere to the Codec interface; Reader and
	 *             Writer must be factory functions or classes providing the
	 *             StreamReader and StreamWriter interfaces resp.
	 * 
	 *             Error handling is done in the same way as defined for the
	 *             StreamWriter/Readers.
	 * 
	 *         
	 */
	function StreamRecoder(stream, encode, decode, Reader, Writer, errors?): Promise<IStreamRecoder>
	function StreamRecoder$({ stream, encode, decode, Reader, Writer, errors }: { stream, encode, decode, Reader, Writer, errors?}): Promise<IStreamRecoder>
	interface IStreamRecoder {
		read(size?): Promise<any>
		read$({ size }: { size?}): Promise<any>
		readline(size?): Promise<any>
		readline$({ size }: { size?}): Promise<any>
		readlines(sizehint?): Promise<any>
		readlines$({ sizehint }: { sizehint?}): Promise<any>
		write(data): Promise<any>
		write$({ data }): Promise<any>
		writelines(list): Promise<any>
		writelines$({ list }): Promise<any>
		reset(): Promise<any>
		reset$($: {}): Promise<any>
		seek(offset, whence?): Promise<any>
		seek$({ offset, whence }: { offset, whence?}): Promise<any>
		data_encoding
		file_encoding
	}
	let BOM_UTF8: Promise<any>
	let BOM_LE: Promise<any>
	let BOM_UTF16_LE: Promise<any>
	let BOM_BE: Promise<any>
	let BOM_UTF16_BE: Promise<any>
	let BOM_UTF32_LE: Promise<any>
	let BOM_UTF32_BE: Promise<any>
	let BOM: Promise<any>
	let BOM_UTF16: Promise<any>
	let BOM_UTF32: Promise<any>
	let BOM32_LE: Promise<any>
	let BOM32_BE: Promise<any>
	let BOM64_LE: Promise<any>
	let BOM64_BE: Promise<any>
	let strict_errors: Promise<any>
	let ignore_errors: Promise<any>
	let replace_errors: Promise<any>
	let xmlcharrefreplace_errors: Promise<any>
	let backslashreplace_errors: Promise<any>
	let namereplace_errors: Promise<any>
}
declare module codeop {
	var _

	/**
	 * Compile a command and determine whether it is incomplete.
	 * 
	 *     Arguments:
	 * 
	 *     source -- the source string; may contain \n characters
	 *     filename -- optional filename from which source was read; default
	 *                 "<input>"
	 *     symbol -- optional grammar start symbol; "single" (default), "exec"
	 *               or "eval"
	 * 
	 *     Return value / exceptions raised:
	 * 
	 *     - Return a code object if the command is complete and valid
	 *     - Return None if the command is incomplete
	 *     - Raise SyntaxError, ValueError or OverflowError if the command is a
	 *       syntax error (OverflowError and ValueError can be produced by
	 *       malformed literals).
	 *     
	 */
	function compile_command(source, filename?, symbol?): Promise<any>
	function compile_command$({ source, filename, symbol }: { source, filename?, symbol?}): Promise<any>

	/**
	 * Instances of this class behave much like the built-in compile
	 *     function, but if one is used to compile text containing a future
	 *     statement, it "remembers" and compiles all subsequent program texts
	 *     with the statement in force.
	 */
	function Compile(): Promise<ICompile>
	function Compile$({ }): Promise<ICompile>
	interface ICompile {
	}

	/**
	 * Instances of this class have __call__ methods identical in
	 *     signature to compile_command; the difference is that if the
	 *     instance compiles program text containing a __future__ statement,
	 *     the instance 'remembers' and compiles all subsequent program texts
	 *     with the statement in force.
	 */
	function CommandCompiler(): Promise<ICommandCompiler>
	function CommandCompiler$({ }): Promise<ICommandCompiler>
	interface ICommandCompiler {
	}
	let PyCF_DONT_IMPLY_DEDENT: Promise<any>
}
declare module collections {
	var _

	/**
	 * Returns a new subclass of tuple with named fields.
	 * 
	 *     >>> Point = namedtuple('Point', ['x', 'y'])
	 *     >>> Point.__doc__                   # docstring for the new class
	 *     'Point(x, y)'
	 *     >>> p = Point(11, y=22)             # instantiate with positional args or keywords
	 *     >>> p[0] + p[1]                     # indexable like a plain tuple
	 *     33
	 *     >>> x, y = p                        # unpack like a regular tuple
	 *     >>> x, y
	 *     (11, 22)
	 *     >>> p.x + p.y                       # fields also accessible by name
	 *     33
	 *     >>> d = p._asdict()                 # convert to a dictionary
	 *     >>> d['x']
	 *     11
	 *     >>> Point(**d)                      # convert from a dictionary
	 *     Point(x=11, y=22)
	 *     >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields
	 *     Point(x=100, y=22)
	 * 
	 *     
	 */
	function namedtuple(typename, field_names): Promise<any>
	function namedtuple$({ typename, field_names }): Promise<any>
	interface I_OrderedDictKeysView {
	}
	interface I_OrderedDictItemsView {
	}
	interface I_OrderedDictValuesView {
	}
	interface I_Link {
	}

	/**
	 * Dictionary that remembers insertion order
	 */

	/**
	 * Initialize an ordered dictionary.  The signature is the same as
	 *         regular dictionaries.  Keyword argument order is preserved.
	 *         
	 */
	function OrderedDict(other?): Promise<IOrderedDict>
	function OrderedDict$({ other }: { other?}): Promise<IOrderedDict>
	interface IOrderedDict {

		/**
		 * od.clear() -> None.  Remove all items from od.
		 */
		clear(): Promise<any>
		clear$($: {}): Promise<any>

		/**
		 * Remove and return a (key, value) pair from the dictionary.
		 * 
		 *         Pairs are returned in LIFO order if last is true or FIFO order if false.
		 *         
		 */
		popitem(last?: boolean): Promise<any>
		popitem$({ last }: { last?}): Promise<any>

		/**
		 * Move an existing element to the end (or beginning if last is false).
		 * 
		 *         Raise KeyError if the element does not exist.
		 *         
		 */
		move_to_end(key, last?: boolean): Promise<any>
		move_to_end$({ key, last }: { key, last?}): Promise<any>

		/**
		 * D.keys() -> a set-like object providing a view on D's keys
		 */
		keys(): Promise<any>
		keys$($: {}): Promise<any>

		/**
		 * D.items() -> a set-like object providing a view on D's items
		 */
		items(): Promise<any>
		items$($: {}): Promise<any>

		/**
		 * D.values() -> an object providing a view on D's values
		 */
		values(): Promise<any>
		values$($: {}): Promise<any>

		/**
		 * od.pop(k[,d]) -> v, remove specified key and return the corresponding
		 *         value.  If key is not found, d is returned if given, otherwise KeyError
		 *         is raised.
		 * 
		 *         
		 */
		pop(key, def?): Promise<any>
		pop$({ key, def }: { key, def?}): Promise<any>

		/**
		 * Insert key with a value of default if key is not in the dictionary.
		 * 
		 *         Return the value for key if key is in the dictionary, else default.
		 *         
		 */
		setdefault(key, def?): Promise<any>
		setdefault$({ key, def }: { key, def?}): Promise<any>

		/**
		 * od.copy() -> a shallow copy of od
		 */
		copy(): Promise<any>
		copy$($: {}): Promise<any>

		/**
		 * Create a new ordered dictionary with keys from iterable and values set to value.
		 *         
		 */
		fromkeys(iterable, value?): Promise<any>
		fromkeys$({ iterable, value }: { iterable, value?}): Promise<any>
		update
	}

	/**
	 * Dict subclass for counting hashable items.  Sometimes called a bag
	 *     or multiset.  Elements are stored as dictionary keys and their counts
	 *     are stored as dictionary values.
	 * 
	 *     >>> c = Counter('abcdeabcdabcaba')  # count elements from a string
	 * 
	 *     >>> c.most_common(3)                # three most common elements
	 *     [('a', 5), ('b', 4), ('c', 3)]
	 *     >>> sorted(c)                       # list all unique elements
	 *     ['a', 'b', 'c', 'd', 'e']
	 *     >>> ''.join(sorted(c.elements()))   # list elements with repetitions
	 *     'aaaaabbbbcccdde'
	 *     >>> sum(c.values())                 # total of all counts
	 *     15
	 * 
	 *     >>> c['a']                          # count of letter 'a'
	 *     5
	 *     >>> for elem in 'shazam':           # update counts from an iterable
	 *     ...     c[elem] += 1                # by adding 1 to each element's count
	 *     >>> c['a']                          # now there are seven 'a'
	 *     7
	 *     >>> del c['b']                      # remove all 'b'
	 *     >>> c['b']                          # now there are zero 'b'
	 *     0
	 * 
	 *     >>> d = Counter('simsalabim')       # make another counter
	 *     >>> c.update(d)                     # add in the second counter
	 *     >>> c['a']                          # now there are nine 'a'
	 *     9
	 * 
	 *     >>> c.clear()                       # empty the counter
	 *     >>> c
	 *     Counter()
	 * 
	 *     Note:  If a count is set to zero or reduced to zero, it will remain
	 *     in the counter until the entry is deleted or the counter is cleared:
	 * 
	 *     >>> c = Counter('aaabbc')
	 *     >>> c['b'] -= 2                     # reduce the count of 'b' by two
	 *     >>> c.most_common()                 # 'b' is still in, but its count is zero
	 *     [('a', 3), ('c', 1), ('b', 0)]
	 * 
	 *     
	 */

	/**
	 * Create a new, empty Counter object.  And if given, count elements
	 *         from an input iterable.  Or, initialize the count from another mapping
	 *         of elements to their counts.
	 * 
	 *         >>> c = Counter()                           # a new, empty counter
	 *         >>> c = Counter('gallahad')                 # a new counter from an iterable
	 *         >>> c = Counter({'a': 4, 'b': 2})           # a new counter from a mapping
	 *         >>> c = Counter(a=4, b=2)                   # a new counter from keyword args
	 * 
	 *         
	 */
	function Counter(iterable?): Promise<ICounter>
	function Counter$({ iterable }: { iterable?}): Promise<ICounter>
	interface ICounter {

		/**
		 * Sum of the counts
		 */
		total(): Promise<any>
		total$($: {}): Promise<any>

		/**
		 * List the n most common elements and their counts from the most
		 *         common to the least.  If n is None, then list all element counts.
		 * 
		 *         >>> Counter('abracadabra').most_common(3)
		 *         [('a', 5), ('b', 2), ('r', 2)]
		 * 
		 *         
		 */
		most_common(n?): Promise<any>
		most_common$({ n }: { n?}): Promise<any>

		/**
		 * Iterator over elements repeating each as many times as its count.
		 * 
		 *         >>> c = Counter('ABCABC')
		 *         >>> sorted(c.elements())
		 *         ['A', 'A', 'B', 'B', 'C', 'C']
		 * 
		 *         # Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1
		 *         >>> prime_factors = Counter({2: 2, 3: 3, 17: 1})
		 *         >>> product = 1
		 *         >>> for factor in prime_factors.elements():     # loop over factors
		 *         ...     product *= factor                       # and multiply them
		 *         >>> product
		 *         1836
		 * 
		 *         Note, if an element's count has been set to zero or is a negative
		 *         number, elements() will ignore it.
		 * 
		 *         
		 */
		elements(): Promise<any>
		elements$($: {}): Promise<any>
		fromkeys(iterable, v?): Promise<any>
		fromkeys$({ iterable, v }: { iterable, v?}): Promise<any>

		/**
		 * Like dict.update() but add counts instead of replacing them.
		 * 
		 *         Source can be an iterable, a dictionary, or another Counter instance.
		 * 
		 *         >>> c = Counter('which')
		 *         >>> c.update('witch')           # add elements from another iterable
		 *         >>> d = Counter('watch')
		 *         >>> c.update(d)                 # add elements from another counter
		 *         >>> c['h']                      # four 'h' in which, witch, and watch
		 *         4
		 * 
		 *         
		 */
		update(iterable?): Promise<any>
		update$({ iterable }: { iterable?}): Promise<any>

		/**
		 * Like dict.update() but subtracts counts instead of replacing them.
		 *         Counts can be reduced below zero.  Both the inputs and outputs are
		 *         allowed to contain zero and negative counts.
		 * 
		 *         Source can be an iterable, a dictionary, or another Counter instance.
		 * 
		 *         >>> c = Counter('which')
		 *         >>> c.subtract('witch')             # subtract elements from another iterable
		 *         >>> c.subtract(Counter('watch'))    # subtract elements from another counter
		 *         >>> c['h']                          # 2 in which, minus 1 in witch, minus 1 in watch
		 *         0
		 *         >>> c['w']                          # 1 in which, minus 1 in witch, minus 1 in watch
		 *         -1
		 * 
		 *         
		 */
		subtract(iterable?): Promise<any>
		subtract$({ iterable }: { iterable?}): Promise<any>

		/**
		 * Return a shallow copy.
		 */
		copy(): Promise<any>
		copy$($: {}): Promise<any>
	}

	/**
	 *  A ChainMap groups multiple dicts (or other mappings) together
	 *     to create a single, updateable view.
	 * 
	 *     The underlying mappings are stored in a list.  That list is public and can
	 *     be accessed or updated using the *maps* attribute.  There is no other
	 *     state.
	 * 
	 *     Lookups search the underlying mappings successively until a key is found.
	 *     In contrast, writes, updates, and deletions only operate on the first
	 *     mapping.
	 * 
	 *     
	 */

	/**
	 * Initialize a ChainMap by setting *maps* to the given mappings.
	 *         If no mappings are provided, a single empty dictionary is used.
	 * 
	 *         
	 */
	function ChainMap(): Promise<IChainMap>
	function ChainMap$({ }): Promise<IChainMap>
	interface IChainMap {
		get(key, def?): Promise<any>
		get$({ key, def }: { key, def?}): Promise<any>

		/**
		 * Create a ChainMap with a single dict created from the iterable.
		 */
		fromkeys(iterable): Promise<any>
		fromkeys$({ iterable }): Promise<any>

		/**
		 * New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]
		 */
		copy(): Promise<any>
		copy$($: {}): Promise<any>

		/**
		 * New ChainMap with a new map followed by all previous maps.
		 *         If no map is provided, an empty dict is used.
		 *         Keyword arguments update the map or new empty dict.
		 *         
		 */
		new_child(m?): Promise<any>
		new_child$({ m }: { m?}): Promise<any>

		/**
		 * New ChainMap from maps[1:].
		 */
		parents(): Promise<any>
		parents$($: {}): Promise<any>

		/**
		 * Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.
		 */
		popitem(): Promise<any>
		popitem$($: {}): Promise<any>

		/**
		 * Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].
		 */
		pop(key): Promise<any>
		pop$({ key }): Promise<any>

		/**
		 * Clear maps[0], leaving maps[1:] intact.
		 */
		clear(): Promise<any>
		clear$($: {}): Promise<any>
	}
	function UserDict(dict?): Promise<IUserDict>
	function UserDict$({ dict }: { dict?}): Promise<IUserDict>
	interface IUserDict {
		copy(): Promise<any>
		copy$($: {}): Promise<any>
		fromkeys(iterable, value?): Promise<any>
		fromkeys$({ iterable, value }: { iterable, value?}): Promise<any>
	}

	/**
	 * A more or less complete user-defined wrapper around list objects.
	 */
	function UserList(initlist?): Promise<IUserList>
	function UserList$({ initlist }: { initlist?}): Promise<IUserList>
	interface IUserList {
		append(item): Promise<any>
		append$({ item }): Promise<any>
		insert(i, item): Promise<any>
		insert$({ i, item }): Promise<any>
		pop(i?): Promise<any>
		pop$({ i }: { i?}): Promise<any>
		remove(item): Promise<any>
		remove$({ item }): Promise<any>
		clear(): Promise<any>
		clear$($: {}): Promise<any>
		copy(): Promise<any>
		copy$($: {}): Promise<any>
		count(item): Promise<any>
		count$({ item }): Promise<any>
		index(item): Promise<any>
		index$({ item }): Promise<any>
		reverse(): Promise<any>
		reverse$($: {}): Promise<any>
		sort(): Promise<any>
		sort$($: {}): Promise<any>
		extend(other): Promise<any>
		extend$({ other }): Promise<any>
	}
	function UserString(seq): Promise<IUserString>
	function UserString$({ seq }): Promise<IUserString>
	interface IUserString {
		capitalize(): Promise<any>
		capitalize$($: {}): Promise<any>
		casefold(): Promise<any>
		casefold$($: {}): Promise<any>
		center(width): Promise<any>
		center$({ width }): Promise<any>
		count(sub, start?, end?): Promise<any>
		count$({ sub, start, end }: { sub, start?, end?}): Promise<any>
		removeprefix(prefix): Promise<any>
		removeprefix$({ prefix }): Promise<any>
		removesuffix(suffix): Promise<any>
		removesuffix$({ suffix }): Promise<any>
		encode(encoding?, errors?): Promise<any>
		encode$({ encoding, errors }: { encoding?, errors?}): Promise<any>
		endswith(suffix, start?, end?): Promise<any>
		endswith$({ suffix, start, end }: { suffix, start?, end?}): Promise<any>
		expandtabs(tabsize?): Promise<any>
		expandtabs$({ tabsize }: { tabsize?}): Promise<any>
		find(sub, start?, end?): Promise<any>
		find$({ sub, start, end }: { sub, start?, end?}): Promise<any>
		format(): Promise<any>
		format$($: {}): Promise<any>
		format_map(mapping): Promise<any>
		format_map$({ mapping }): Promise<any>
		index(sub, start?, end?): Promise<any>
		index$({ sub, start, end }: { sub, start?, end?}): Promise<any>
		isalpha(): Promise<any>
		isalpha$($: {}): Promise<any>
		isalnum(): Promise<any>
		isalnum$($: {}): Promise<any>
		isascii(): Promise<any>
		isascii$($: {}): Promise<any>
		isdecimal(): Promise<any>
		isdecimal$($: {}): Promise<any>
		isdigit(): Promise<any>
		isdigit$($: {}): Promise<any>
		isidentifier(): Promise<any>
		isidentifier$($: {}): Promise<any>
		islower(): Promise<any>
		islower$($: {}): Promise<any>
		isnumeric(): Promise<any>
		isnumeric$($: {}): Promise<any>
		isprintable(): Promise<any>
		isprintable$($: {}): Promise<any>
		isspace(): Promise<any>
		isspace$($: {}): Promise<any>
		istitle(): Promise<any>
		istitle$($: {}): Promise<any>
		isupper(): Promise<any>
		isupper$($: {}): Promise<any>
		join(seq): Promise<any>
		join$({ seq }): Promise<any>
		ljust(width): Promise<any>
		ljust$({ width }): Promise<any>
		lower(): Promise<any>
		lower$($: {}): Promise<any>
		lstrip(chars?): Promise<any>
		lstrip$({ chars }: { chars?}): Promise<any>
		partition(sep): Promise<any>
		partition$({ sep }): Promise<any>
		replace(old, New, maxsplit?): Promise<any>
		replace$({ old, New, maxsplit }: { old, New, maxsplit?}): Promise<any>
		rfind(sub, start?, end?): Promise<any>
		rfind$({ sub, start, end }: { sub, start?, end?}): Promise<any>
		rindex(sub, start?, end?): Promise<any>
		rindex$({ sub, start, end }: { sub, start?, end?}): Promise<any>
		rjust(width): Promise<any>
		rjust$({ width }): Promise<any>
		rpartition(sep): Promise<any>
		rpartition$({ sep }): Promise<any>
		rstrip(chars?): Promise<any>
		rstrip$({ chars }: { chars?}): Promise<any>
		split(sep?, maxsplit?): Promise<any>
		split$({ sep, maxsplit }: { sep?, maxsplit?}): Promise<any>
		rsplit(sep?, maxsplit?): Promise<any>
		rsplit$({ sep, maxsplit }: { sep?, maxsplit?}): Promise<any>
		splitlines(keepends?: boolean): Promise<any>
		splitlines$({ keepends }: { keepends?}): Promise<any>
		startswith(prefix, start?, end?): Promise<any>
		startswith$({ prefix, start, end }: { prefix, start?, end?}): Promise<any>
		strip(chars?): Promise<any>
		strip$({ chars }: { chars?}): Promise<any>
		swapcase(): Promise<any>
		swapcase$($: {}): Promise<any>
		title(): Promise<any>
		title$($: {}): Promise<any>
		translate(): Promise<any>
		translate$($: {}): Promise<any>
		upper(): Promise<any>
		upper$($: {}): Promise<any>
		zfill(width): Promise<any>
		zfill$({ width }): Promise<any>
		maketrans
	}
	module abc {
		var _
	}
}
declare module colorsys {
	var _
	function rgb_to_yiq(r, g, b): Promise<any>
	function rgb_to_yiq$({ r, g, b }): Promise<any>
	function yiq_to_rgb(y, i, q): Promise<any>
	function yiq_to_rgb$({ y, i, q }): Promise<any>
	function rgb_to_hls(r, g, b): Promise<any>
	function rgb_to_hls$({ r, g, b }): Promise<any>
	function hls_to_rgb(h, l, s): Promise<any>
	function hls_to_rgb$({ h, l, s }): Promise<any>
	function rgb_to_hsv(r, g, b): Promise<any>
	function rgb_to_hsv$({ r, g, b }): Promise<any>
	function hsv_to_rgb(h, s, v): Promise<any>
	function hsv_to_rgb$({ h, s, v }): Promise<any>
	let ONE_THIRD: Promise<any>
	let ONE_SIXTH: Promise<any>
	let TWO_THIRD: Promise<any>
}
declare module compileall {
	var _

	/**
	 * Byte-compile all modules in the given directory tree.
	 * 
	 *     Arguments (only dir is required):
	 * 
	 *     dir:       the directory to byte-compile
	 *     maxlevels: maximum recursion level (default `sys.getrecursionlimit()`)
	 *     ddir:      the directory that will be prepended to the path to the
	 *                file as it is compiled into each byte-code file.
	 *     force:     if True, force compilation, even if timestamps are up-to-date
	 *     quiet:     full output with False or 0, errors only with 1,
	 *                no output with 2
	 *     legacy:    if True, produce legacy pyc paths instead of PEP 3147 paths
	 *     optimize:  int or list of optimization levels or -1 for level of
	 *                the interpreter. Multiple levels leads to multiple compiled
	 *                files each with one optimization level.
	 *     workers:   maximum number of parallel workers
	 *     invalidation_mode: how the up-to-dateness of the pyc will be checked
	 *     stripdir:  part of path to left-strip from source file path
	 *     prependdir: path to prepend to beginning of original file path, applied
	 *                after stripdir
	 *     limit_sl_dest: ignore symlinks if they are pointing outside of
	 *                    the defined path
	 *     hardlink_dupes: hardlink duplicated pyc files
	 *     
	 */
	function compile_dir(dir, maxlevels?, ddir?, force?: boolean, rx?, quiet?, legacy?: boolean, optimize?, workers?, invalidation_mode?): Promise<any>
	function compile_dir$({ dir, maxlevels, ddir, force, rx, quiet, legacy, optimize, workers, invalidation_mode }: { dir, maxlevels?, ddir?, force?, rx?, quiet?, legacy?, optimize?, workers?, invalidation_mode?}): Promise<any>

	/**
	 * Byte-compile one file.
	 * 
	 *     Arguments (only fullname is required):
	 * 
	 *     fullname:  the file to byte-compile
	 *     ddir:      if given, the directory name compiled in to the
	 *                byte-code file.
	 *     force:     if True, force compilation, even if timestamps are up-to-date
	 *     quiet:     full output with False or 0, errors only with 1,
	 *                no output with 2
	 *     legacy:    if True, produce legacy pyc paths instead of PEP 3147 paths
	 *     optimize:  int or list of optimization levels or -1 for level of
	 *                the interpreter. Multiple levels leads to multiple compiled
	 *                files each with one optimization level.
	 *     invalidation_mode: how the up-to-dateness of the pyc will be checked
	 *     stripdir:  part of path to left-strip from source file path
	 *     prependdir: path to prepend to beginning of original file path, applied
	 *                after stripdir
	 *     limit_sl_dest: ignore symlinks if they are pointing outside of
	 *                    the defined path.
	 *     hardlink_dupes: hardlink duplicated pyc files
	 *     
	 */
	function compile_file(fullname, ddir?, force?: boolean, rx?, quiet?, legacy?: boolean, optimize?, invalidation_mode?): Promise<any>
	function compile_file$({ fullname, ddir, force, rx, quiet, legacy, optimize, invalidation_mode }: { fullname, ddir?, force?, rx?, quiet?, legacy?, optimize?, invalidation_mode?}): Promise<any>

	/**
	 * Byte-compile all module on sys.path.
	 * 
	 *     Arguments (all optional):
	 * 
	 *     skip_curdir: if true, skip current directory (default True)
	 *     maxlevels:   max recursion level (default 0)
	 *     force: as for compile_dir() (default False)
	 *     quiet: as for compile_dir() (default 0)
	 *     legacy: as for compile_dir() (default False)
	 *     optimize: as for compile_dir() (default -1)
	 *     invalidation_mode: as for compiler_dir()
	 *     
	 */
	function compile_path(skip_curdir?, maxlevels?, force?: boolean, quiet?, legacy?: boolean, optimize?, invalidation_mode?): Promise<any>
	function compile_path$({ skip_curdir, maxlevels, force, quiet, legacy, optimize, invalidation_mode }: { skip_curdir?, maxlevels?, force?, quiet?, legacy?, optimize?, invalidation_mode?}): Promise<any>

	/**
	 * Script main program.
	 */
	function main(): Promise<any>
	function main$($: {}): Promise<any>
	let exit_status: Promise<any>
}
declare module concurrent {
	var _
	module futures {
		var _
		module _base {
			var _

			/**
			 * An iterator over the given futures that yields each as it completes.
			 * 
			 *     Args:
			 *         fs: The sequence of Futures (possibly created by different Executors) to
			 *             iterate over.
			 *         timeout: The maximum number of seconds to wait. If None, then there
			 *             is no limit on the wait time.
			 * 
			 *     Returns:
			 *         An iterator that yields the given Futures as they complete (finished or
			 *         cancelled). If any given Futures are duplicated, they will be returned
			 *         once.
			 * 
			 *     Raises:
			 *         TimeoutError: If the entire result iterator could not be generated
			 *             before the given timeout.
			 *     
			 */
			function as_completed(fs, timeout?): Promise<any>
			function as_completed$({ fs, timeout }: { fs, timeout?}): Promise<any>

			/**
			 * Wait for the futures in the given sequence to complete.
			 * 
			 *     Args:
			 *         fs: The sequence of Futures (possibly created by different Executors) to
			 *             wait upon.
			 *         timeout: The maximum number of seconds to wait. If None, then there
			 *             is no limit on the wait time.
			 *         return_when: Indicates when this function should return. The options
			 *             are:
			 * 
			 *             FIRST_COMPLETED - Return when any future finishes or is
			 *                               cancelled.
			 *             FIRST_EXCEPTION - Return when any future finishes by raising an
			 *                               exception. If no future raises an exception
			 *                               then it is equivalent to ALL_COMPLETED.
			 *             ALL_COMPLETED -   Return when all futures finish or are cancelled.
			 * 
			 *     Returns:
			 *         A named 2-tuple of sets. The first set, named 'done', contains the
			 *         futures that completed (is finished or cancelled) before the wait
			 *         completed. The second set, named 'not_done', contains uncompleted
			 *         futures.
			 *     
			 */
			function wait(fs, timeout?, return_when?): Promise<any>
			function wait$({ fs, timeout, return_when }: { fs, timeout?, return_when?}): Promise<any>

			/**
			 * Base class for all future-related exceptions.
			 */
			interface IError {
			}

			/**
			 * The Future was cancelled.
			 */
			interface ICancelledError extends IError {
			}

			/**
			 * The operation exceeded the given deadline.
			 */
			interface ITimeoutError extends IError {
			}

			/**
			 * The operation is not allowed in this state.
			 */
			interface IInvalidStateError extends IError {
			}

			/**
			 * Provides the event that wait() and as_completed() block on.
			 */
			interface I_Waiter {
				add_result(future): Promise<any>
				add_result$({ future }): Promise<any>
				add_exception(future): Promise<any>
				add_exception$({ future }): Promise<any>
				add_cancelled(future): Promise<any>
				add_cancelled$({ future }): Promise<any>
			}

			/**
			 * Used by as_completed().
			 */
			interface I_AsCompletedWaiter extends I_Waiter {
				add_result(future): Promise<any>
				add_result$({ future }): Promise<any>
				add_exception(future): Promise<any>
				add_exception$({ future }): Promise<any>
				add_cancelled(future): Promise<any>
				add_cancelled$({ future }): Promise<any>
			}

			/**
			 * Used by wait(return_when=FIRST_COMPLETED).
			 */
			interface I_FirstCompletedWaiter extends I_Waiter {
				add_result(future): Promise<any>
				add_result$({ future }): Promise<any>
				add_exception(future): Promise<any>
				add_exception$({ future }): Promise<any>
				add_cancelled(future): Promise<any>
				add_cancelled$({ future }): Promise<any>
			}

			/**
			 * Used by wait(return_when=FIRST_EXCEPTION and ALL_COMPLETED).
			 */
			interface I_AllCompletedWaiter extends I_Waiter {
				add_result(future): Promise<any>
				add_result$({ future }): Promise<any>
				add_exception(future): Promise<any>
				add_exception$({ future }): Promise<any>
				add_cancelled(future): Promise<any>
				add_cancelled$({ future }): Promise<any>
			}

			/**
			 * A context manager that does an ordered acquire of Future conditions.
			 */
			interface I_AcquireFutures {
			}

			/**
			 * Represents the result of an asynchronous computation.
			 */

			/**
			 * Initializes the future. Should not be called by clients.
			 */
			function Future(): Promise<IFuture>
			function Future$({ }): Promise<IFuture>
			interface IFuture {

				/**
				 * Cancel the future if possible.
				 * 
				 *         Returns True if the future was cancelled, False otherwise. A future
				 *         cannot be cancelled if it is running or has already completed.
				 *         
				 */
				cancel(): Promise<any>
				cancel$($: {}): Promise<any>

				/**
				 * Return True if the future was cancelled.
				 */
				cancelled(): Promise<any>
				cancelled$($: {}): Promise<any>

				/**
				 * Return True if the future is currently executing.
				 */
				running(): Promise<any>
				running$($: {}): Promise<any>

				/**
				 * Return True of the future was cancelled or finished executing.
				 */
				done(): Promise<any>
				done$($: {}): Promise<any>

				/**
				 * Attaches a callable that will be called when the future finishes.
				 * 
				 *         Args:
				 *             fn: A callable that will be called with this future as its only
				 *                 argument when the future completes or is cancelled. The callable
				 *                 will always be called by a thread in the same process in which
				 *                 it was added. If the future has already completed or been
				 *                 cancelled then the callable will be called immediately. These
				 *                 callables are called in the order that they were added.
				 *         
				 */
				add_done_callback(fn): Promise<any>
				add_done_callback$({ fn }): Promise<any>

				/**
				 * Return the result of the call that the future represents.
				 * 
				 *         Args:
				 *             timeout: The number of seconds to wait for the result if the future
				 *                 isn't done. If None, then there is no limit on the wait time.
				 * 
				 *         Returns:
				 *             The result of the call that the future represents.
				 * 
				 *         Raises:
				 *             CancelledError: If the future was cancelled.
				 *             TimeoutError: If the future didn't finish executing before the given
				 *                 timeout.
				 *             Exception: If the call raised then that exception will be raised.
				 *         
				 */
				result(timeout?): Promise<any>
				result$({ timeout }: { timeout?}): Promise<any>

				/**
				 * Return the exception raised by the call that the future represents.
				 * 
				 *         Args:
				 *             timeout: The number of seconds to wait for the exception if the
				 *                 future isn't done. If None, then there is no limit on the wait
				 *                 time.
				 * 
				 *         Returns:
				 *             The exception raised by the call that the future represents or None
				 *             if the call completed without raising.
				 * 
				 *         Raises:
				 *             CancelledError: If the future was cancelled.
				 *             TimeoutError: If the future didn't finish executing before the given
				 *                 timeout.
				 *         
				 */
				exception(timeout?): Promise<any>
				exception$({ timeout }: { timeout?}): Promise<any>

				/**
				 * Mark the future as running or process any cancel notifications.
				 * 
				 *         Should only be used by Executor implementations and unit tests.
				 * 
				 *         If the future has been cancelled (cancel() was called and returned
				 *         True) then any threads waiting on the future completing (though calls
				 *         to as_completed() or wait()) are notified and False is returned.
				 * 
				 *         If the future was not cancelled then it is put in the running state
				 *         (future calls to running() will return True) and True is returned.
				 * 
				 *         This method should be called by Executor implementations before
				 *         executing the work associated with this future. If this method returns
				 *         False then the work should not be executed.
				 * 
				 *         Returns:
				 *             False if the Future was cancelled, True otherwise.
				 * 
				 *         Raises:
				 *             RuntimeError: if this method was already called or if set_result()
				 *                 or set_exception() was called.
				 *         
				 */
				set_running_or_notify_cancel(): Promise<any>
				set_running_or_notify_cancel$($: {}): Promise<any>

				/**
				 * Sets the return value of work associated with the future.
				 * 
				 *         Should only be used by Executor implementations and unit tests.
				 *         
				 */
				set_result(result): Promise<any>
				set_result$({ result }): Promise<any>

				/**
				 * Sets the result of the future as being the given exception.
				 * 
				 *         Should only be used by Executor implementations and unit tests.
				 *         
				 */
				set_exception(exception): Promise<any>
				set_exception$({ exception }): Promise<any>
			}

			/**
			 * This is an abstract base class for concrete asynchronous executors.
			 */
			interface IExecutor {

				/**
				 * Submits a callable to be executed with the given arguments.
				 * 
				 *         Schedules the callable to be executed as fn(*args, **kwargs) and returns
				 *         a Future instance representing the execution of the callable.
				 * 
				 *         Returns:
				 *             A Future representing the given call.
				 *         
				 */
				submit(fn): Promise<any>
				submit$({ fn }): Promise<any>

				/**
				 * Returns an iterator equivalent to map(fn, iter).
				 * 
				 *         Args:
				 *             fn: A callable that will take as many arguments as there are
				 *                 passed iterables.
				 *             timeout: The maximum number of seconds to wait. If None, then there
				 *                 is no limit on the wait time.
				 *             chunksize: The size of the chunks the iterable will be broken into
				 *                 before being passed to a child process. This argument is only
				 *                 used by ProcessPoolExecutor; it is ignored by
				 *                 ThreadPoolExecutor.
				 * 
				 *         Returns:
				 *             An iterator equivalent to: map(func, *iterables) but the calls may
				 *             be evaluated out-of-order.
				 * 
				 *         Raises:
				 *             TimeoutError: If the entire result iterator could not be generated
				 *                 before the given timeout.
				 *             Exception: If fn(*args) raises for any values.
				 *         
				 */
				map(fn): Promise<any>
				map$({ fn }): Promise<any>

				/**
				 * Clean-up the resources associated with the Executor.
				 * 
				 *         It is safe to call this method several times. Otherwise, no other
				 *         methods can be called after this one.
				 * 
				 *         Args:
				 *             wait: If True then shutdown will not return until all running
				 *                 futures have finished executing and the resources used by the
				 *                 executor have been reclaimed.
				 *             cancel_futures: If True then shutdown will cancel all pending
				 *                 futures. Futures that are completed or running will not be
				 *                 cancelled.
				 *         
				 */
				shutdown(wait?: boolean): Promise<any>
				shutdown$({ wait }: { wait?}): Promise<any>
			}

			/**
			 * 
			 *     Raised when a executor has become non-functional after a severe failure.
			 *     
			 */
			interface IBrokenExecutor {
			}
			let FIRST_COMPLETED: Promise<any>
			let FIRST_EXCEPTION: Promise<any>
			let ALL_COMPLETED: Promise<any>
			let PENDING: Promise<any>
			let RUNNING: Promise<any>
			let CANCELLED: Promise<any>
			let CANCELLED_AND_NOTIFIED: Promise<any>
			let FINISHED: Promise<any>
			let LOGGER: Promise<any>
			let DoneAndNotDoneFutures: Promise<any>
		}
		module process {
			var _
			interface I_ThreadWakeup {
				close(): Promise<any>
				close$($: {}): Promise<any>
				wakeup(): Promise<any>
				wakeup$($: {}): Promise<any>
				clear(): Promise<any>
				clear$($: {}): Promise<any>
			}
			interface I_RemoteTraceback {
			}
			interface I_ExceptionWithTraceback {
			}
			interface I_WorkItem {
			}
			interface I_ResultItem {
			}
			interface I_CallItem {
			}

			/**
			 * Safe Queue set exception to the future object linked to a job
			 */
			interface I_SafeQueue {
			}

			/**
			 * Manages the communication between this process and the worker processes.
			 * 
			 *     The manager is run in a local thread.
			 * 
			 *     Args:
			 *         executor: A reference to the ProcessPoolExecutor that owns
			 *             this thread. A weakref will be own by the manager as well as
			 *             references to internal objects used to introspect the state of
			 *             the executor.
			 *     
			 */
			interface I_ExecutorManagerThread {
				run(): Promise<any>
				run$($: {}): Promise<any>
				add_call_item_to_queue(): Promise<any>
				add_call_item_to_queue$($: {}): Promise<any>
				wait_result_broken_or_wakeup(): Promise<any>
				wait_result_broken_or_wakeup$($: {}): Promise<any>
				process_result_item(result_item): Promise<any>
				process_result_item$({ result_item }): Promise<any>
				is_shutting_down(): Promise<any>
				is_shutting_down$($: {}): Promise<any>
				terminate_broken(cause): Promise<any>
				terminate_broken$({ cause }): Promise<any>
				flag_executor_shutting_down(): Promise<any>
				flag_executor_shutting_down$($: {}): Promise<any>
				shutdown_workers(): Promise<any>
				shutdown_workers$($: {}): Promise<any>
				join_executor_internals(): Promise<any>
				join_executor_internals$($: {}): Promise<any>
				get_n_children_alive(): Promise<any>
				get_n_children_alive$($: {}): Promise<any>
			}

			/**
			 * 
			 *     Raised when a process in a ProcessPoolExecutor terminated abruptly
			 *     while a future was in the running state.
			 *     
			 */
			interface IBrokenProcessPool {
			}

			/**
			 * Initializes a new ProcessPoolExecutor instance.
			 * 
			 *         Args:
			 *             max_workers: The maximum number of processes that can be used to
			 *                 execute the given calls. If None or not given then as many
			 *                 worker processes will be created as the machine has processors.
			 *             mp_context: A multiprocessing context to launch the workers. This
			 *                 object should provide SimpleQueue, Queue and Process.
			 *             initializer: A callable used to initialize worker processes.
			 *             initargs: A tuple of arguments to pass to the initializer.
			 *         
			 */
			function ProcessPoolExecutor(max_workers?, mp_context?, initializer?, initargs?): Promise<IProcessPoolExecutor>
			function ProcessPoolExecutor$({ max_workers, mp_context, initializer, initargs }: { max_workers?, mp_context?, initializer?, initargs?}): Promise<IProcessPoolExecutor>
			interface IProcessPoolExecutor {
				submit(fn): Promise<any>
				submit$({ fn }): Promise<any>

				/**
				 * Returns an iterator equivalent to map(fn, iter).
				 * 
				 *         Args:
				 *             fn: A callable that will take as many arguments as there are
				 *                 passed iterables.
				 *             timeout: The maximum number of seconds to wait. If None, then there
				 *                 is no limit on the wait time.
				 *             chunksize: If greater than one, the iterables will be chopped into
				 *                 chunks of size chunksize and submitted to the process pool.
				 *                 If set to one, the items in the list will be sent one at a time.
				 * 
				 *         Returns:
				 *             An iterator equivalent to: map(func, *iterables) but the calls may
				 *             be evaluated out-of-order.
				 * 
				 *         Raises:
				 *             TimeoutError: If the entire result iterator could not be generated
				 *                 before the given timeout.
				 *             Exception: If fn(*args) raises for any values.
				 *         
				 */
				map(fn): Promise<any>
				map$({ fn }): Promise<any>
				shutdown(wait?: boolean): Promise<any>
				shutdown$({ wait }: { wait?}): Promise<any>
			}
			let EXTRA_QUEUED_CALLS: Promise<any>
		}
		module thread {
			var _
			interface I_WorkItem {
				run(): Promise<any>
				run$($: {}): Promise<any>
			}

			/**
			 * 
			 *     Raised when a worker thread in a ThreadPoolExecutor failed initializing.
			 *     
			 */
			interface IBrokenThreadPool {
			}

			/**
			 * Initializes a new ThreadPoolExecutor instance.
			 * 
			 *         Args:
			 *             max_workers: The maximum number of threads that can be used to
			 *                 execute the given calls.
			 *             thread_name_prefix: An optional name prefix to give our threads.
			 *             initializer: A callable used to initialize worker threads.
			 *             initargs: A tuple of arguments to pass to the initializer.
			 *         
			 */
			function ThreadPoolExecutor(max_workers?, thread_name_prefix?, initializer?, initargs?): Promise<IThreadPoolExecutor>
			function ThreadPoolExecutor$({ max_workers, thread_name_prefix, initializer, initargs }: { max_workers?, thread_name_prefix?, initializer?, initargs?}): Promise<IThreadPoolExecutor>
			interface IThreadPoolExecutor {
				submit(fn): Promise<any>
				submit$({ fn }): Promise<any>
				shutdown(wait?: boolean): Promise<any>
				shutdown$({ wait }: { wait?}): Promise<any>
			}
		}
	}
}
declare module configparser {
	var _

	/**
	 * Base class for ConfigParser exceptions.
	 */
	function Error(msg?): Promise<IError>
	function Error$({ msg }: { msg?}): Promise<IError>
	interface IError {
	}

	/**
	 * Raised when no section matches a requested option.
	 */
	function NoSectionError(section): Promise<INoSectionError>
	function NoSectionError$({ section }): Promise<INoSectionError>
	interface INoSectionError extends IError {
	}

	/**
	 * Raised when a section is repeated in an input source.
	 * 
	 *     Possible repetitions that raise this exception are: multiple creation
	 *     using the API or in strict parsers when a section is found more than once
	 *     in a single input file, string or dictionary.
	 *     
	 */
	function DuplicateSectionError(section, source?, lineno?): Promise<IDuplicateSectionError>
	function DuplicateSectionError$({ section, source, lineno }: { section, source?, lineno?}): Promise<IDuplicateSectionError>
	interface IDuplicateSectionError extends IError {
	}

	/**
	 * Raised by strict parsers when an option is repeated in an input source.
	 * 
	 *     Current implementation raises this exception only when an option is found
	 *     more than once in a single file, string or dictionary.
	 *     
	 */
	function DuplicateOptionError(section, option, source?, lineno?): Promise<IDuplicateOptionError>
	function DuplicateOptionError$({ section, option, source, lineno }: { section, option, source?, lineno?}): Promise<IDuplicateOptionError>
	interface IDuplicateOptionError extends IError {
	}

	/**
	 * A requested option was not found.
	 */
	function NoOptionError(option, section): Promise<INoOptionError>
	function NoOptionError$({ option, section }): Promise<INoOptionError>
	interface INoOptionError extends IError {
	}

	/**
	 * Base class for interpolation-related exceptions.
	 */
	function InterpolationError(option, section, msg): Promise<IInterpolationError>
	function InterpolationError$({ option, section, msg }): Promise<IInterpolationError>
	interface IInterpolationError extends IError {
	}

	/**
	 * A string substitution required a setting which was not available.
	 */
	function InterpolationMissingOptionError(option, section, rawval, reference): Promise<IInterpolationMissingOptionError>
	function InterpolationMissingOptionError$({ option, section, rawval, reference }): Promise<IInterpolationMissingOptionError>
	interface IInterpolationMissingOptionError extends IInterpolationError {
	}

	/**
	 * Raised when the source text contains invalid syntax.
	 * 
	 *     Current implementation raises this exception when the source text into
	 *     which substitutions are made does not conform to the required syntax.
	 *     
	 */
	interface IInterpolationSyntaxError extends IInterpolationError {
	}

	/**
	 * Raised when substitutions are nested too deeply.
	 */
	function InterpolationDepthError(option, section, rawval): Promise<IInterpolationDepthError>
	function InterpolationDepthError$({ option, section, rawval }): Promise<IInterpolationDepthError>
	interface IInterpolationDepthError extends IInterpolationError {
	}

	/**
	 * Raised when a configuration file does not follow legal syntax.
	 */
	function ParsingError(source?, filename?): Promise<IParsingError>
	function ParsingError$({ source, filename }: { source?, filename?}): Promise<IParsingError>
	interface IParsingError extends IError {

		/**
		 * Deprecated, use `source'.
		 */
		filename(): Promise<any>
		filename$($: {}): Promise<any>

		/**
		 * Deprecated, user `source'.
		 */
		filename(value): Promise<any>
		filename$({ value }): Promise<any>
		append(lineno, line): Promise<any>
		append$({ lineno, line }): Promise<any>
	}

	/**
	 * Raised when a key-value pair is found before any section header.
	 */
	function MissingSectionHeaderError(filename, lineno, line): Promise<IMissingSectionHeaderError>
	function MissingSectionHeaderError$({ filename, lineno, line }): Promise<IMissingSectionHeaderError>
	interface IMissingSectionHeaderError extends IParsingError {
	}

	/**
	 * Dummy interpolation that passes the value through with no changes.
	 */
	interface IInterpolation {
		before_get(parser, section, option, value, defaults): Promise<any>
		before_get$({ parser, section, option, value, defaults }): Promise<any>
		before_set(parser, section, option, value): Promise<any>
		before_set$({ parser, section, option, value }): Promise<any>
		before_read(parser, section, option, value): Promise<any>
		before_read$({ parser, section, option, value }): Promise<any>
		before_write(parser, section, option, value): Promise<any>
		before_write$({ parser, section, option, value }): Promise<any>
	}

	/**
	 * Interpolation as implemented in the classic ConfigParser.
	 * 
	 *     The option values can contain format strings which refer to other values in
	 *     the same section, or values in the special default section.
	 * 
	 *     For example:
	 * 
	 *         something: %(dir)s/whatever
	 * 
	 *     would resolve the "%(dir)s" to the value of dir.  All reference
	 *     expansions are done late, on demand. If a user needs to use a bare % in
	 *     a configuration file, she can escape it by writing %%. Other % usage
	 *     is considered a user error and raises `InterpolationSyntaxError'.
	 */
	interface IBasicInterpolation extends IInterpolation {
		before_get(parser, section, option, value, defaults): Promise<any>
		before_get$({ parser, section, option, value, defaults }): Promise<any>
		before_set(parser, section, option, value): Promise<any>
		before_set$({ parser, section, option, value }): Promise<any>
	}

	/**
	 * Advanced variant of interpolation, supports the syntax used by
	 *     `zc.buildout'. Enables interpolation between sections.
	 */
	interface IExtendedInterpolation extends IInterpolation {
		before_get(parser, section, option, value, defaults): Promise<any>
		before_get$({ parser, section, option, value, defaults }): Promise<any>
		before_set(parser, section, option, value): Promise<any>
		before_set$({ parser, section, option, value }): Promise<any>
	}

	/**
	 * Deprecated interpolation used in old versions of ConfigParser.
	 *     Use BasicInterpolation or ExtendedInterpolation instead.
	 */
	interface ILegacyInterpolation extends IInterpolation {
		before_get(parser, section, option, value, vars): Promise<any>
		before_get$({ parser, section, option, value, vars }): Promise<any>
		before_set(parser, section, option, value): Promise<any>
		before_set$({ parser, section, option, value }): Promise<any>
	}

	/**
	 * ConfigParser that does not do interpolation.
	 */
	function RawConfigParser(defaults?, dict_type?, allow_no_value?: boolean): Promise<IRawConfigParser>
	function RawConfigParser$({ defaults, dict_type, allow_no_value }: { defaults?, dict_type?, allow_no_value?}): Promise<IRawConfigParser>
	interface IRawConfigParser {
		defaults(): Promise<any>
		defaults$($: {}): Promise<any>

		/**
		 * Return a list of section names, excluding [DEFAULT]
		 */
		sections(): Promise<any>
		sections$($: {}): Promise<any>

		/**
		 * Create a new section in the configuration.
		 * 
		 *         Raise DuplicateSectionError if a section by the specified name
		 *         already exists. Raise ValueError if name is DEFAULT.
		 *         
		 */
		add_section(section): Promise<any>
		add_section$({ section }): Promise<any>

		/**
		 * Indicate whether the named section is present in the configuration.
		 * 
		 *         The DEFAULT section is not acknowledged.
		 *         
		 */
		has_section(section): Promise<any>
		has_section$({ section }): Promise<any>

		/**
		 * Return a list of option names for the given section name.
		 */
		options(section): Promise<any>
		options$({ section }): Promise<any>

		/**
		 * Read and parse a filename or an iterable of filenames.
		 * 
		 *         Files that cannot be opened are silently ignored; this is
		 *         designed so that you can specify an iterable of potential
		 *         configuration file locations (e.g. current directory, user's
		 *         home directory, systemwide directory), and all existing
		 *         configuration files in the iterable will be read.  A single
		 *         filename may also be given.
		 * 
		 *         Return list of successfully read files.
		 *         
		 */
		read(filenames, encoding?): Promise<any>
		read$({ filenames, encoding }: { filenames, encoding?}): Promise<any>

		/**
		 * Like read() but the argument must be a file-like object.
		 * 
		 *         The `f' argument must be iterable, returning one line at a time.
		 *         Optional second argument is the `source' specifying the name of the
		 *         file being read. If not given, it is taken from f.name. If `f' has no
		 *         `name' attribute, `<???>' is used.
		 *         
		 */
		read_file(f, source?): Promise<any>
		read_file$({ f, source }: { f, source?}): Promise<any>

		/**
		 * Read configuration from a given string.
		 */
		read_string(string, source?): Promise<any>
		read_string$({ string, source }: { string, source?}): Promise<any>

		/**
		 * Read configuration from a dictionary.
		 * 
		 *         Keys are section names, values are dictionaries with keys and values
		 *         that should be present in the section. If the used dictionary type
		 *         preserves order, sections and their keys will be added in order.
		 * 
		 *         All types held in the dictionary are converted to strings during
		 *         reading, including section names, option names and keys.
		 * 
		 *         Optional second argument is the `source' specifying the name of the
		 *         dictionary being read.
		 *         
		 */
		read_dict(dictionary, source?): Promise<any>
		read_dict$({ dictionary, source }: { dictionary, source?}): Promise<any>

		/**
		 * Deprecated, use read_file instead.
		 */
		readfp(fp, filename?): Promise<any>
		readfp$({ fp, filename }: { fp, filename?}): Promise<any>

		/**
		 * Get an option value for a given section.
		 * 
		 *         If `vars' is provided, it must be a dictionary. The option is looked up
		 *         in `vars' (if provided), `section', and in `DEFAULTSECT' in that order.
		 *         If the key is not found and `fallback' is provided, it is used as
		 *         a fallback value. `None' can be provided as a `fallback' value.
		 * 
		 *         If interpolation is enabled and the optional argument `raw' is False,
		 *         all interpolations are expanded in the return values.
		 * 
		 *         Arguments `raw', `vars', and `fallback' are keyword only.
		 * 
		 *         The section DEFAULT is special.
		 *         
		 */
		get(section, option): Promise<any>
		get$({ section, option }): Promise<any>
		getint(section, option): Promise<any>
		getint$({ section, option }): Promise<any>
		getfloat(section, option): Promise<any>
		getfloat$({ section, option }): Promise<any>
		getboolean(section, option): Promise<any>
		getboolean$({ section, option }): Promise<any>

		/**
		 * Return a list of (name, value) tuples for each option in a section.
		 * 
		 *         All % interpolations are expanded in the return values, based on the
		 *         defaults passed into the constructor, unless the optional argument
		 *         `raw' is true.  Additional substitutions may be provided using the
		 *         `vars' argument, which must be a dictionary whose contents overrides
		 *         any pre-existing defaults.
		 * 
		 *         The section DEFAULT is special.
		 *         
		 */
		items(section?, raw?: boolean, vars?): Promise<any>
		items$({ section, raw, vars }: { section?, raw?, vars?}): Promise<any>

		/**
		 * Remove a section from the parser and return it as
		 *         a (section_name, section_proxy) tuple. If no section is present, raise
		 *         KeyError.
		 * 
		 *         The section DEFAULT is never returned because it cannot be removed.
		 *         
		 */
		popitem(): Promise<any>
		popitem$($: {}): Promise<any>
		optionxform(optionstr): Promise<any>
		optionxform$({ optionstr }): Promise<any>

		/**
		 * Check for the existence of a given option in a given section.
		 *         If the specified `section' is None or an empty string, DEFAULT is
		 *         assumed. If the specified `section' does not exist, returns False.
		 */
		has_option(section, option): Promise<any>
		has_option$({ section, option }): Promise<any>

		/**
		 * Set an option.
		 */
		set(section, option, value?): Promise<any>
		set$({ section, option, value }: { section, option, value?}): Promise<any>

		/**
		 * Write an .ini-format representation of the configuration state.
		 * 
		 *         If `space_around_delimiters' is True (the default), delimiters
		 *         between keys and values are surrounded by spaces.
		 * 
		 *         Please note that comments in the original configuration file are not
		 *         preserved when writing the configuration back.
		 *         
		 */
		write(fp, space_around_delimiters?: boolean): Promise<any>
		write$({ fp, space_around_delimiters }: { fp, space_around_delimiters?}): Promise<any>

		/**
		 * Remove an option.
		 */
		remove_option(section, option): Promise<any>
		remove_option$({ section, option }): Promise<any>

		/**
		 * Remove a file section.
		 */
		remove_section(section): Promise<any>
		remove_section$({ section }): Promise<any>
		converters(): Promise<any>
		converters$($: {}): Promise<any>
		SECTCRE
		OPTCRE
		OPTCRE_NV
		NONSPACECRE
		BOOLEAN_STATES
	}

	/**
	 * ConfigParser implementing interpolation.
	 */
	interface IConfigParser extends IRawConfigParser {

		/**
		 * Set an option.  Extends RawConfigParser.set by validating type and
		 *         interpolation syntax on the value.
		 */
		set(section, option, value?): Promise<any>
		set$({ section, option, value }: { section, option, value?}): Promise<any>

		/**
		 * Create a new section in the configuration.  Extends
		 *         RawConfigParser.add_section by validating if the section name is
		 *         a string.
		 */
		add_section(section): Promise<any>
		add_section$({ section }): Promise<any>
	}

	/**
	 * ConfigParser alias for backwards compatibility purposes.
	 */
	function SafeConfigParser(): Promise<ISafeConfigParser>
	function SafeConfigParser$({ }): Promise<ISafeConfigParser>
	interface ISafeConfigParser extends IConfigParser {
	}

	/**
	 * A proxy for a single section from a parser.
	 */

	/**
	 * Creates a view on a section of the specified `name` in `parser`.
	 */
	function SectionProxy(parser, name): Promise<ISectionProxy>
	function SectionProxy$({ parser, name }): Promise<ISectionProxy>
	interface ISectionProxy {
		parser(): Promise<any>
		parser$($: {}): Promise<any>
		name(): Promise<any>
		name$($: {}): Promise<any>

		/**
		 * Get an option value.
		 * 
		 *         Unless `fallback` is provided, `None` will be returned if the option
		 *         is not found.
		 * 
		 *         
		 */
		get(option, fallback?): Promise<any>
		get$({ option, fallback }: { option, fallback?}): Promise<any>
	}

	/**
	 * Enables reuse of get*() methods between the parser and section proxies.
	 * 
	 *     If a parser class implements a getter directly, the value for the given
	 *     key will be ``None``. The presence of the converter name here enables
	 *     section proxies to find and use the implementation on the parser class.
	 *     
	 */
	function ConverterMapping(parser): Promise<IConverterMapping>
	function ConverterMapping$({ parser }): Promise<IConverterMapping>
	interface IConverterMapping {
		GETTERCRE
	}
	let DEFAULTSECT: Promise<any>
	let MAX_INTERPOLATION_DEPTH: Promise<any>
}
declare module contextlib {
	var _

	/**
	 * @contextmanager decorator.
	 * 
	 *     Typical usage:
	 * 
	 *         @contextmanager
	 *         def some_generator(<arguments>):
	 *             <setup>
	 *             try:
	 *                 yield <value>
	 *             finally:
	 *                 <cleanup>
	 * 
	 *     This makes this:
	 * 
	 *         with some_generator(<arguments>) as <variable>:
	 *             <body>
	 * 
	 *     equivalent to this:
	 * 
	 *         <setup>
	 *         try:
	 *             <variable> = <value>
	 *             <body>
	 *         finally:
	 *             <cleanup>
	 *     
	 */
	function contextmanager(func): Promise<any>
	function contextmanager$({ func }): Promise<any>

	/**
	 * @asynccontextmanager decorator.
	 * 
	 *     Typical usage:
	 * 
	 *         @asynccontextmanager
	 *         async def some_async_generator(<arguments>):
	 *             <setup>
	 *             try:
	 *                 yield <value>
	 *             finally:
	 *                 <cleanup>
	 * 
	 *     This makes this:
	 * 
	 *         async with some_async_generator(<arguments>) as <variable>:
	 *             <body>
	 * 
	 *     equivalent to this:
	 * 
	 *         <setup>
	 *         try:
	 *             <variable> = <value>
	 *             <body>
	 *         finally:
	 *             <cleanup>
	 *     
	 */
	function asynccontextmanager(func): Promise<any>
	function asynccontextmanager$({ func }): Promise<any>

	/**
	 * An abstract base class for context managers.
	 */
	interface IAbstractContextManager {
	}

	/**
	 * An abstract base class for asynchronous context managers.
	 */
	interface IAbstractAsyncContextManager {
	}

	/**
	 * A base class or mixin that enables context managers to work as decorators.
	 */
	interface IContextDecorator {
	}

	/**
	 * A base class or mixin that enables async context managers to work as decorators.
	 */
	interface IAsyncContextDecorator {
	}

	/**
	 * Shared functionality for @contextmanager and @asynccontextmanager.
	 */
	interface I_GeneratorContextManagerBase {
	}

	/**
	 * Helper for @contextmanager decorator.
	 */
	interface I_GeneratorContextManager extends I_GeneratorContextManagerBase, IAbstractContextManager, IContextDecorator {
	}

	/**
	 * Helper for @asynccontextmanager.
	 */
	interface I_AsyncGeneratorContextManager extends I_GeneratorContextManagerBase, IAbstractAsyncContextManager, IAsyncContextDecorator {
	}

	/**
	 * Context to automatically close something at the end of a block.
	 * 
	 *     Code like this:
	 * 
	 *         with closing(<module>.open(<arguments>)) as f:
	 *             <block>
	 * 
	 *     is equivalent to this:
	 * 
	 *         f = <module>.open(<arguments>)
	 *         try:
	 *             <block>
	 *         finally:
	 *             f.close()
	 * 
	 *     
	 */
	function closing(thing): Promise<Iclosing>
	function closing$({ thing }): Promise<Iclosing>
	interface Iclosing extends IAbstractContextManager {
	}

	/**
	 * Async context manager for safely finalizing an asynchronously cleaned-up
	 *     resource such as an async generator, calling its ``aclose()`` method.
	 * 
	 *     Code like this:
	 * 
	 *         async with aclosing(<module>.fetch(<arguments>)) as agen:
	 *             <block>
	 * 
	 *     is equivalent to this:
	 * 
	 *         agen = <module>.fetch(<arguments>)
	 *         try:
	 *             <block>
	 *         finally:
	 *             await agen.aclose()
	 * 
	 *     
	 */
	function aclosing(thing): Promise<Iaclosing>
	function aclosing$({ thing }): Promise<Iaclosing>
	interface Iaclosing extends IAbstractAsyncContextManager {
	}
	interface I_RedirectStream extends IAbstractContextManager {
	}

	/**
	 * Context manager for temporarily redirecting stdout to another file.
	 * 
	 *         # How to send help() to stderr
	 *         with redirect_stdout(sys.stderr):
	 *             help(dir)
	 * 
	 *         # How to write help() to a file
	 *         with open('help.txt', 'w') as f:
	 *             with redirect_stdout(f):
	 *                 help(pow)
	 *     
	 */
	interface Iredirect_stdout extends I_RedirectStream {
	}

	/**
	 * Context manager for temporarily redirecting stderr to another file.
	 */
	interface Iredirect_stderr extends I_RedirectStream {
	}

	/**
	 * Context manager to suppress specified exceptions
	 * 
	 *     After the exception is suppressed, execution proceeds with the next
	 *     statement following the with statement.
	 * 
	 *          with suppress(FileNotFoundError):
	 *              os.remove(somefile)
	 *          # Execution still resumes here if the file was already removed
	 *     
	 */
	function suppress(): Promise<Isuppress>
	function suppress$({ }): Promise<Isuppress>
	interface Isuppress extends IAbstractContextManager {
	}

	/**
	 * A base class for ExitStack and AsyncExitStack.
	 */
	interface I_BaseExitStack {

		/**
		 * Preserve the context stack by transferring it to a new instance.
		 */
		pop_all(): Promise<any>
		pop_all$($: {}): Promise<any>

		/**
		 * Registers a callback with the standard __exit__ method signature.
		 * 
		 *         Can suppress exceptions the same way __exit__ method can.
		 *         Also accepts any object with an __exit__ method (registering a call
		 *         to the method instead of the object itself).
		 *         
		 */
		push(exit): Promise<any>
		push$({ exit }): Promise<any>

		/**
		 * Enters the supplied context manager.
		 * 
		 *         If successful, also pushes its __exit__ method as a callback and
		 *         returns the result of the __enter__ method.
		 *         
		 */
		enter_context(cm): Promise<any>
		enter_context$({ cm }): Promise<any>

		/**
		 * Registers an arbitrary callback and arguments.
		 * 
		 *         Cannot suppress exceptions.
		 *         
		 */
		callback(callback): Promise<any>
		callback$({ callback }): Promise<any>
	}

	/**
	 * Context manager for dynamic management of a stack of exit callbacks.
	 * 
	 *     For example:
	 *         with ExitStack() as stack:
	 *             files = [stack.enter_context(open(fname)) for fname in filenames]
	 *             # All opened files will automatically be closed at the end of
	 *             # the with statement, even if attempts to open files later
	 *             # in the list raise an exception.
	 *     
	 */
	interface IExitStack extends I_BaseExitStack, IAbstractContextManager {

		/**
		 * Immediately unwind the context stack.
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 * Async context manager for dynamic management of a stack of exit
	 *     callbacks.
	 * 
	 *     For example:
	 *         async with AsyncExitStack() as stack:
	 *             connections = [await stack.enter_async_context(get_connection())
	 *                 for i in range(5)]
	 *             # All opened connections will automatically be released at the
	 *             # end of the async with statement, even if attempts to open a
	 *             # connection later in the list raise an exception.
	 *     
	 */
	interface IAsyncExitStack extends I_BaseExitStack, IAbstractAsyncContextManager {

		/**
		 * Registers a coroutine function with the standard __aexit__ method
		 *         signature.
		 * 
		 *         Can suppress exceptions the same way __aexit__ method can.
		 *         Also accepts any object with an __aexit__ method (registering a call
		 *         to the method instead of the object itself).
		 *         
		 */
		push_async_exit(exit): Promise<any>
		push_async_exit$({ exit }): Promise<any>

		/**
		 * Registers an arbitrary coroutine function and arguments.
		 * 
		 *         Cannot suppress exceptions.
		 *         
		 */
		push_async_callback(callback): Promise<any>
		push_async_callback$({ callback }): Promise<any>
	}

	/**
	 * Context manager that does no additional processing.
	 * 
	 *     Used as a stand-in for a normal context manager, when a particular
	 *     block of code is only sometimes used with a normal context manager:
	 * 
	 *     cm = optional_cm if condition else nullcontext()
	 *     with cm:
	 *         # Perform operation, using optional_cm if condition is True
	 *     
	 */
	function nullcontext(enter_result?): Promise<Inullcontext>
	function nullcontext$({ enter_result }: { enter_result?}): Promise<Inullcontext>
	interface Inullcontext extends IAbstractContextManager, IAbstractAsyncContextManager {
	}
}
declare module contextvars {
	var _
}
declare module copy {
	var _

	/**
	 * Shallow copy operation on arbitrary Python objects.
	 * 
	 *     See the module's __doc__ string for more info.
	 *     
	 */
	function copy(x): Promise<any>
	function copy$({ x }): Promise<any>

	/**
	 * Deep copy operation on arbitrary Python objects.
	 * 
	 *     See the module's __doc__ string for more info.
	 *     
	 */
	function deepcopy(x, memo?, _nil?): Promise<any>
	function deepcopy$({ x, memo, _nil }: { x, memo?, _nil?}): Promise<any>
	interface IError {
	}
	let error: Promise<any>
	let d: Promise<any>
	let t: Promise<any>
}
declare module copyreg {
	var _
	function pickle(ob_type, pickle_function, constructor_ob?): Promise<any>
	function pickle$({ ob_type, pickle_function, constructor_ob }: { ob_type, pickle_function, constructor_ob?}): Promise<any>
	function constructor(object): Promise<any>
	function constructor$({ object }): Promise<any>
	function pickle_complex(c): Promise<any>
	function pickle_complex$({ c }): Promise<any>

	/**
	 * Register an extension code.
	 */
	function add_extension(module, name, code): Promise<any>
	function add_extension$({ module, name, code }): Promise<any>

	/**
	 * Unregister an extension code.  For testing only.
	 */
	function remove_extension(module, name, code): Promise<any>
	function remove_extension$({ module, name, code }): Promise<any>
	function clear_extension_cache(): Promise<any>
	function clear_extension_cache$($: {}): Promise<any>
	let dispatch_table: Promise<any>
}
declare module crypt {
	var _

	/**
	 * Generate a salt for the specified method.
	 * 
	 *     If not specified, the strongest available method will be used.
	 * 
	 *     
	 */
	function mksalt(method?): Promise<any>
	function mksalt$({ method }: { method?}): Promise<any>

	/**
	 * Return a string representing the one-way hash of a password, with a salt
	 *     prepended.
	 * 
	 *     If ``salt`` is not specified or is ``None``, the strongest
	 *     available method will be selected and a salt generated.  Otherwise,
	 *     ``salt`` may be one of the ``crypt.METHOD_*`` values, or a string as
	 *     returned by ``crypt.mksalt()``.
	 * 
	 *     
	 */
	function crypt(word, salt?): Promise<any>
	function crypt$({ word, salt }: { word, salt?}): Promise<any>

	/**
	 * Class representing a salt method per the Modular Crypt Format or the
	 *     legacy 2-character crypt method.
	 */
	interface I_Method {
	}
	let methods: Promise<any>
}
declare module csv {
	var _

	/**
	 * Describe a CSV dialect.
	 * 
	 *     This must be subclassed (see csv.excel).  Valid attributes are:
	 *     delimiter, quotechar, escapechar, doublequote, skipinitialspace,
	 *     lineterminator, quoting.
	 * 
	 *     
	 */
	function Dialect(): Promise<IDialect>
	function Dialect$({ }): Promise<IDialect>
	interface IDialect {
		delimiter
		quotechar
		escapechar
		doublequote
		skipinitialspace
		lineterminator
		quoting
	}

	/**
	 * Describe the usual properties of Excel-generated CSV files.
	 */
	interface Iexcel extends IDialect {
	}

	/**
	 * Describe the usual properties of Excel-generated TAB-delimited files.
	 */
	interface Iexcel_tab extends Iexcel {
	}

	/**
	 * Describe the usual properties of Unix-generated CSV files.
	 */
	interface Iunix_dialect extends IDialect {
	}
	function DictReader(f, fieldnames?, restkey?, restval?, dialect?): Promise<IDictReader>
	function DictReader$({ f, fieldnames, restkey, restval, dialect }: { f, fieldnames?, restkey?, restval?, dialect?}): Promise<IDictReader>
	interface IDictReader {
		fieldnames(): Promise<any>
		fieldnames$($: {}): Promise<any>
		fieldnames(value): Promise<any>
		fieldnames$({ value }): Promise<any>
	}
	function DictWriter(f, fieldnames, restval?, extrasaction?, dialect?): Promise<IDictWriter>
	function DictWriter$({ f, fieldnames, restval, extrasaction, dialect }: { f, fieldnames, restval?, extrasaction?, dialect?}): Promise<IDictWriter>
	interface IDictWriter {
		writeheader(): Promise<any>
		writeheader$($: {}): Promise<any>
		writerow(rowdict): Promise<any>
		writerow$({ rowdict }): Promise<any>
		writerows(rowdicts): Promise<any>
		writerows$({ rowdicts }): Promise<any>
	}

	/**
	 * 
	 *     "Sniffs" the format of a CSV file (i.e. delimiter, quotechar)
	 *     Returns a Dialect object.
	 *     
	 */
	function Sniffer(): Promise<ISniffer>
	function Sniffer$({ }): Promise<ISniffer>
	interface ISniffer {

		/**
		 * 
		 *         Returns a dialect (or None) corresponding to the sample
		 *         
		 */
		sniff(sample, delimiters?): Promise<any>
		sniff$({ sample, delimiters }: { sample, delimiters?}): Promise<any>
		has_header(sample): Promise<any>
		has_header$({ sample }): Promise<any>
	}
}
declare module ctypes {
	var _

	/**
	 * create_string_buffer(aBytes) -> character array
	 *     create_string_buffer(anInteger) -> character array
	 *     create_string_buffer(aBytes, anInteger) -> character array
	 *     
	 */
	function create_string_buffer(init, size?): Promise<any>
	function create_string_buffer$({ init, size }: { init, size?}): Promise<any>
	function c_buffer(init, size?): Promise<any>
	function c_buffer$({ init, size }: { init, size?}): Promise<any>

	/**
	 * CFUNCTYPE(restype, *argtypes,
	 *                  use_errno=False, use_last_error=False) -> function prototype.
	 * 
	 *     restype: the result type
	 *     argtypes: a sequence specifying the argument types
	 * 
	 *     The function prototype can be called in different ways to create a
	 *     callable object:
	 * 
	 *     prototype(integer address) -> foreign function
	 *     prototype(callable) -> create and return a C callable function from callable
	 *     prototype(integer index, method name[, paramflags]) -> foreign function calling a COM method
	 *     prototype((ordinal number, dll object)[, paramflags]) -> foreign function exported by ordinal
	 *     prototype((function name, dll object)[, paramflags]) -> foreign function exported by name
	 *     
	 */
	function CFUNCTYPE(restype): Promise<any>
	function CFUNCTYPE$({ restype }): Promise<any>
	function WINFUNCTYPE(restype): Promise<any>
	function WINFUNCTYPE$({ restype }): Promise<any>

	/**
	 * create_unicode_buffer(aString) -> character array
	 *     create_unicode_buffer(anInteger) -> character array
	 *     create_unicode_buffer(aString, anInteger) -> character array
	 *     
	 */
	function create_unicode_buffer(init, size?): Promise<any>
	function create_unicode_buffer$({ init, size }: { init, size?}): Promise<any>
	function SetPointerType(pointer, cls): Promise<any>
	function SetPointerType$({ pointer, cls }): Promise<any>
	function ARRAY(typ, len): Promise<any>
	function ARRAY$({ typ, len }): Promise<any>
	function WinError(code?, descr?): Promise<any>
	function WinError$({ code, descr }: { code?, descr?}): Promise<any>
	function PYFUNCTYPE(restype): Promise<any>
	function PYFUNCTYPE$({ restype }): Promise<any>
	function cast(obj, typ): Promise<any>
	function cast$({ obj, typ }): Promise<any>

	/**
	 * string_at(addr[, size]) -> string
	 * 
	 *     Return the string at addr.
	 */
	function string_at(ptr, size?): Promise<any>
	function string_at$({ ptr, size }: { ptr, size?}): Promise<any>

	/**
	 * wstring_at(addr[, size]) -> string
	 * 
	 *         Return the string at addr.
	 */
	function wstring_at(ptr, size?): Promise<any>
	function wstring_at$({ ptr, size }: { ptr, size?}): Promise<any>
	function DllGetClassObject(rclsid, riid, ppv): Promise<any>
	function DllGetClassObject$({ rclsid, riid, ppv }): Promise<any>
	function DllCanUnloadNow(): Promise<any>
	function DllCanUnloadNow$($: {}): Promise<any>
	interface Ipy_object {
	}
	interface Ic_short {
	}
	interface Ic_ushort {
	}
	interface Ic_long {
	}
	interface Ic_ulong {
	}
	interface Ic_int {
	}
	interface Ic_uint {
	}
	interface Ic_float {
	}
	interface Ic_double {
	}
	interface Ic_longdouble {
	}
	interface Ic_longlong {
	}
	interface Ic_ulonglong {
	}
	interface Ic_ubyte {
	}
	interface Ic_byte {
	}
	interface Ic_char {
	}
	interface Ic_char_p {
	}
	interface Ic_void_p {
	}
	interface Ic_bool {
	}
	interface Ic_wchar_p {
	}
	interface Ic_wchar {
	}

	/**
	 * An instance of this class represents a loaded dll/shared
	 *     library, exporting functions using the standard C calling
	 *     convention (named 'cdecl' on Windows).
	 * 
	 *     The exported functions can be accessed as attributes, or by
	 *     indexing with the function name.  Examples:
	 * 
	 *     <obj>.qsort -> callable object
	 *     <obj>['qsort'] -> callable object
	 * 
	 *     Calling the functions releases the Python GIL during the call and
	 *     reacquires it afterwards.
	 *     
	 */
	function CDLL(name, mode?, handle?, use_errno?: boolean, use_last_error?: boolean, winmode?): Promise<ICDLL>
	function CDLL$({ name, mode, handle, use_errno, use_last_error, winmode }: { name, mode?, handle?, use_errno?, use_last_error?, winmode?}): Promise<ICDLL>
	interface ICDLL {
	}

	/**
	 * This class represents the Python library itself.  It allows
	 *     accessing Python API functions.  The GIL is not released, and
	 *     Python exceptions are handled correctly.
	 *     
	 */
	interface IPyDLL extends ICDLL {
	}

	/**
	 * This class represents a dll exporting functions using the
	 *         Windows stdcall calling convention.
	 *         
	 */
	interface IWinDLL extends ICDLL {
	}
	interface IHRESULT {
	}

	/**
	 * This class represents a dll exporting functions using the
	 *         Windows stdcall calling convention, and returning HRESULT.
	 *         HRESULT error values are automatically raised as OSError
	 *         exceptions.
	 *         
	 */
	interface IOleDLL extends ICDLL {
	}
	function LibraryLoader(dlltype): Promise<ILibraryLoader>
	function LibraryLoader$({ dlltype }): Promise<ILibraryLoader>
	interface ILibraryLoader {
		LoadLibrary(name): Promise<any>
		LoadLibrary$({ name }): Promise<any>
	}
	let DEFAULT_MODE: Promise<any>
	let c_int: Promise<any>
	let c_uint: Promise<any>
	let c_longdouble: Promise<any>
	let c_longlong: Promise<any>
	let c_ulonglong: Promise<any>
	let c_voidp: Promise<any>
	let cdll: Promise<any>
	let pydll: Promise<any>
	let pythonapi: Promise<any>
	let windll: Promise<any>
	let oledll: Promise<any>
	let GetLastError: Promise<any>
	let c_size_t: Promise<any>
	let c_ssize_t: Promise<any>
	let memmove: Promise<any>
	let memset: Promise<any>
	let c_int8: Promise<any>
	let c_uint8: Promise<any>
	let c_int16: Promise<any>
	let c_int32: Promise<any>
	let c_int64: Promise<any>
	let c_uint16: Promise<any>
	let c_uint32: Promise<any>
	let c_uint64: Promise<any>
	module _aix {
		var _
		function get_ld_header(p): Promise<any>
		function get_ld_header$({ p }): Promise<any>
		function get_ld_header_info(p): Promise<any>
		function get_ld_header_info$({ p }): Promise<any>

		/**
		 * 
		 *     Parse the header of the loader section of executable and archives
		 *     This function calls /usr/bin/dump -H as a subprocess
		 *     and returns a list of (ld_header, ld_header_info) tuples.
		 *     
		 */
		function get_ld_headers(file): Promise<any>
		function get_ld_headers$({ file }): Promise<any>

		/**
		 * 
		 *     extract the shareable objects from ld_headers
		 *     character "[" is used to strip off the path information.
		 *     Note: the "[" and "]" characters that are part of dump -H output
		 *     are not removed here.
		 *     
		 */
		function get_shared(ld_headers): Promise<any>
		function get_shared$({ ld_headers }): Promise<any>

		/**
		 * 
		 *     Must be only one match, otherwise result is None.
		 *     When there is a match, strip leading "[" and trailing "]"
		 *     
		 */
		function get_one_match(expr, lines): Promise<any>
		function get_one_match$({ expr, lines }): Promise<any>

		/**
		 * 
		 *     This routine provides historical aka legacy naming schemes started
		 *     in AIX4 shared library support for library members names.
		 *     e.g., in /usr/lib/libc.a the member name shr.o for 32-bit binary and
		 *     shr_64.o for 64-bit binary.
		 *     
		 */
		function get_legacy(members): Promise<any>
		function get_legacy$({ members }): Promise<any>

		/**
		 * 
		 *     Sort list of members and return highest numbered version - if it exists.
		 *     This function is called when an unversioned libFOO.a(libFOO.so) has
		 *     not been found.
		 * 
		 *     Versioning for the member name is expected to follow
		 *     GNU LIBTOOL conventions: the highest version (x, then X.y, then X.Y.z)
		 *      * find [libFoo.so.X]
		 *      * find [libFoo.so.X.Y]
		 *      * find [libFoo.so.X.Y.Z]
		 * 
		 *     Before the GNU convention became the standard scheme regardless of
		 *     binary size AIX packagers used GNU convention "as-is" for 32-bit
		 *     archive members but used an "distinguishing" name for 64-bit members.
		 *     This scheme inserted either 64 or _64 between libFOO and .so
		 *     - generally libFOO_64.so, but occasionally libFOO64.so
		 *     
		 */
		function get_version(name, members): Promise<any>
		function get_version$({ name, members }): Promise<any>

		/**
		 * 
		 *     Return an archive member matching the request in name.
		 *     Name is the library name without any prefix like lib, suffix like .so,
		 *     or version number.
		 *     Given a list of members find and return the most appropriate result
		 *     Priority is given to generic libXXX.so, then a versioned libXXX.so.a.b.c
		 *     and finally, legacy AIX naming scheme.
		 *     
		 */
		function get_member(name, members): Promise<any>
		function get_member$({ name, members }): Promise<any>

		/**
		 * 
		 *     On AIX, the buildtime searchpath is stored in the executable.
		 *     as "loader header information".
		 *     The command /usr/bin/dump -H extracts this info.
		 *     Prefix searched libraries with LD_LIBRARY_PATH (preferred),
		 *     or LIBPATH if defined. These paths are appended to the paths
		 *     to libraries the python executable is linked with.
		 *     This mimics AIX dlopen() behavior.
		 *     
		 */
		function get_libpaths(): Promise<any>
		function get_libpaths$($: {}): Promise<any>

		/**
		 * 
		 *     paths is a list of directories to search for an archive.
		 *     name is the abbreviated name given to find_library().
		 *     Process: search "paths" for archive, and if an archive is found
		 *     return the result of get_member().
		 *     If an archive is not found then return None
		 *     
		 */
		function find_shared(paths, name): Promise<any>
		function find_shared$({ paths, name }): Promise<any>

		/**
		 * AIX implementation of ctypes.util.find_library()
		 *     Find an archive member that will dlopen(). If not available,
		 *     also search for a file (or link) with a .so suffix.
		 * 
		 *     AIX supports two types of schemes that can be used with dlopen().
		 *     The so-called SystemV Release4 (svr4) format is commonly suffixed
		 *     with .so while the (default) AIX scheme has the library (archive)
		 *     ending with the suffix .a
		 *     As an archive has multiple members (e.g., 32-bit and 64-bit) in one file
		 *     the argument passed to dlopen must include both the library and
		 *     the member names in a single string.
		 * 
		 *     find_library() looks first for an archive (.a) with a suitable member.
		 *     If no archive+member pair is found, look for a .so file.
		 *     
		 */
		function find_library(name): Promise<any>
		function find_library$({ name }): Promise<any>
		let AIX_ABI: Promise<any>
	}
	module _endian {
		var _
		interface I_swapped_meta {
		}

		/**
		 * Structure with big endian byte order
		 */
		interface IBigEndianStructure {
		}

		/**
		 * Structure with little endian byte order
		 */
		interface ILittleEndianStructure {
		}
		let LittleEndianStructure: Promise<any>
		let BigEndianStructure: Promise<any>
	}
	module macholib {
		var _
		module dyld {
			var _
			function dyld_env(env, variable): Promise<any>
			function dyld_env$({ env, variable }): Promise<any>
			function dyld_image_suffix(env?): Promise<any>
			function dyld_image_suffix$({ env }: { env?}): Promise<any>
			function dyld_framework_path(env?): Promise<any>
			function dyld_framework_path$({ env }: { env?}): Promise<any>
			function dyld_library_path(env?): Promise<any>
			function dyld_library_path$({ env }: { env?}): Promise<any>
			function dyld_fallback_framework_path(env?): Promise<any>
			function dyld_fallback_framework_path$({ env }: { env?}): Promise<any>
			function dyld_fallback_library_path(env?): Promise<any>
			function dyld_fallback_library_path$({ env }: { env?}): Promise<any>

			/**
			 * For a potential path iterator, add DYLD_IMAGE_SUFFIX semantics
			 */
			function dyld_image_suffix_search(iterator, env?): Promise<any>
			function dyld_image_suffix_search$({ iterator, env }: { iterator, env?}): Promise<any>
			function dyld_override_search(name, env?): Promise<any>
			function dyld_override_search$({ name, env }: { name, env?}): Promise<any>
			function dyld_executable_path_search(name, executable_path?): Promise<any>
			function dyld_executable_path_search$({ name, executable_path }: { name, executable_path?}): Promise<any>
			function dyld_default_search(name, env?): Promise<any>
			function dyld_default_search$({ name, env }: { name, env?}): Promise<any>

			/**
			 * 
			 *     Find a library or framework using dyld semantics
			 *     
			 */
			function dyld_find(name, executable_path?, env?): Promise<any>
			function dyld_find$({ name, executable_path, env }: { name, executable_path?, env?}): Promise<any>

			/**
			 * 
			 *     Find a framework using dyld semantics in a very loose manner.
			 * 
			 *     Will take input such as:
			 *         Python
			 *         Python.framework
			 *         Python.framework/Versions/Current
			 *     
			 */
			function framework_find(fn, executable_path?, env?): Promise<any>
			function framework_find$({ fn, executable_path, env }: { fn, executable_path?, env?}): Promise<any>
			function test_dyld_find(): Promise<any>
			function test_dyld_find$($: {}): Promise<any>
			let DEFAULT_FRAMEWORK_FALLBACK: Promise<any>
			let DEFAULT_LIBRARY_FALLBACK: Promise<any>
		}
		module dylib {
			var _

			/**
			 * 
			 *     A dylib name can take one of the following four forms:
			 *         Location/Name.SomeVersion_Suffix.dylib
			 *         Location/Name.SomeVersion.dylib
			 *         Location/Name_Suffix.dylib
			 *         Location/Name.dylib
			 * 
			 *     returns None if not found or a mapping equivalent to:
			 *         dict(
			 *             location='Location',
			 *             name='Name.SomeVersion_Suffix.dylib',
			 *             shortname='Name',
			 *             version='SomeVersion',
			 *             suffix='Suffix',
			 *         )
			 * 
			 *     Note that SomeVersion and Suffix are optional and may be None
			 *     if not present.
			 *     
			 */
			function dylib_info(filename): Promise<any>
			function dylib_info$({ filename }): Promise<any>
			function test_dylib_info(): Promise<any>
			function test_dylib_info$($: {}): Promise<any>
			let DYLIB_RE: Promise<any>
		}
		module framework {
			var _

			/**
			 * 
			 *     A framework name can take one of the following four forms:
			 *         Location/Name.framework/Versions/SomeVersion/Name_Suffix
			 *         Location/Name.framework/Versions/SomeVersion/Name
			 *         Location/Name.framework/Name_Suffix
			 *         Location/Name.framework/Name
			 * 
			 *     returns None if not found, or a mapping equivalent to:
			 *         dict(
			 *             location='Location',
			 *             name='Name.framework/Versions/SomeVersion/Name_Suffix',
			 *             shortname='Name',
			 *             version='SomeVersion',
			 *             suffix='Suffix',
			 *         )
			 * 
			 *     Note that SomeVersion and Suffix are optional and may be None
			 *     if not present
			 *     
			 */
			function framework_info(filename): Promise<any>
			function framework_info$({ filename }): Promise<any>
			function test_framework_info(): Promise<any>
			function test_framework_info$($: {}): Promise<any>
			let STRICT_FRAMEWORK_RE: Promise<any>
		}
	}
	module util {
		var _

		/**
		 * Return the name of the VC runtime dll
		 */
		function find_msvcrt(): Promise<any>
		function find_msvcrt$($: {}): Promise<any>
		function find_library(name): Promise<any>
		function find_library$({ name }): Promise<any>
		function find_library(name): Promise<any>
		function find_library$({ name }): Promise<any>
		function find_library(name): Promise<any>
		function find_library$({ name }): Promise<any>
		function find_library(name, is64?: boolean): Promise<any>
		function find_library$({ name, is64 }: { name, is64?}): Promise<any>
		function find_library(name): Promise<any>
		function find_library$({ name }): Promise<any>
		function test(): Promise<any>
		function test$($: {}): Promise<any>
	}
	module wintypes {
		var _
		function RGB(red, green, blue): Promise<any>
		function RGB$({ red, green, blue }): Promise<any>
		interface IVARIANT_BOOL {
		}
		interface IRECT {
		}
		interface I_SMALL_RECT {
		}
		interface I_COORD {
		}
		interface IPOINT {
		}
		interface ISIZE {
		}
		interface IFILETIME {
		}
		interface IMSG {
		}
		interface IWIN32_FIND_DATAA {
		}
		interface IWIN32_FIND_DATAW {
		}
		let BYTE: Promise<any>
		let WORD: Promise<any>
		let DWORD: Promise<any>
		let CHAR: Promise<any>
		let WCHAR: Promise<any>
		let UINT: Promise<any>
		let INT: Promise<any>
		let DOUBLE: Promise<any>
		let FLOAT: Promise<any>
		let BOOLEAN: Promise<any>
		let BOOL: Promise<any>
		let ULONG: Promise<any>
		let LONG: Promise<any>
		let USHORT: Promise<any>
		let SHORT: Promise<any>
		let LARGE_INTEGER: Promise<any>
		let ULARGE_INTEGER: Promise<any>
		let LPCOLESTR: Promise<any>
		let LPOLESTR: Promise<any>
		let OLESTR: Promise<any>
		let LPCWSTR: Promise<any>
		let LPWSTR: Promise<any>
		let LPCSTR: Promise<any>
		let LPSTR: Promise<any>
		let LPCVOID: Promise<any>
		let LPVOID: Promise<any>
		let WPARAM: Promise<any>
		let LPARAM: Promise<any>
		let ATOM: Promise<any>
		let LANGID: Promise<any>
		let COLORREF: Promise<any>
		let LGRPID: Promise<any>
		let LCTYPE: Promise<any>
		let LCID: Promise<any>
		let HANDLE: Promise<any>
		let HACCEL: Promise<any>
		let HBITMAP: Promise<any>
		let HBRUSH: Promise<any>
		let HCOLORSPACE: Promise<any>
		let HDC: Promise<any>
		let HDESK: Promise<any>
		let HDWP: Promise<any>
		let HENHMETAFILE: Promise<any>
		let HFONT: Promise<any>
		let HGDIOBJ: Promise<any>
		let HGLOBAL: Promise<any>
		let HHOOK: Promise<any>
		let HICON: Promise<any>
		let HINSTANCE: Promise<any>
		let HKEY: Promise<any>
		let HKL: Promise<any>
		let HLOCAL: Promise<any>
		let HMENU: Promise<any>
		let HMETAFILE: Promise<any>
		let HMODULE: Promise<any>
		let HMONITOR: Promise<any>
		let HPALETTE: Promise<any>
		let HPEN: Promise<any>
		let HRGN: Promise<any>
		let HRSRC: Promise<any>
		let HSTR: Promise<any>
		let HTASK: Promise<any>
		let HWINSTA: Promise<any>
		let HWND: Promise<any>
		let SC_HANDLE: Promise<any>
		let SERVICE_STATUS_HANDLE: Promise<any>
		let tagRECT: Promise<any>
		let RECTL: Promise<any>
		let SMALL_RECT: Promise<any>
		let tagPOINT: Promise<any>
		let POINTL: Promise<any>
		let tagSIZE: Promise<any>
		let SIZEL: Promise<any>
		let tagMSG: Promise<any>
		let MAX_PATH: Promise<any>
		let LPBOOL: Promise<any>
		let PBOOL: Promise<any>
		let PBOOLEAN: Promise<any>
		let LPBYTE: Promise<any>
		let PBYTE: Promise<any>
		let PCHAR: Promise<any>
		let LPCOLORREF: Promise<any>
		let LPDWORD: Promise<any>
		let PDWORD: Promise<any>
		let LPFILETIME: Promise<any>
		let PFILETIME: Promise<any>
		let PFLOAT: Promise<any>
		let LPHANDLE: Promise<any>
		let PHANDLE: Promise<any>
		let PHKEY: Promise<any>
		let LPHKL: Promise<any>
		let LPINT: Promise<any>
		let PINT: Promise<any>
		let PLARGE_INTEGER: Promise<any>
		let PLCID: Promise<any>
		let LPLONG: Promise<any>
		let PLONG: Promise<any>
		let LPMSG: Promise<any>
		let PMSG: Promise<any>
		let LPPOINT: Promise<any>
		let PPOINT: Promise<any>
		let PPOINTL: Promise<any>
		let LPRECT: Promise<any>
		let PRECT: Promise<any>
		let LPRECTL: Promise<any>
		let PRECTL: Promise<any>
		let LPSC_HANDLE: Promise<any>
		let PSHORT: Promise<any>
		let LPSIZE: Promise<any>
		let PSIZE: Promise<any>
		let LPSIZEL: Promise<any>
		let PSIZEL: Promise<any>
		let PSMALL_RECT: Promise<any>
		let LPUINT: Promise<any>
		let PUINT: Promise<any>
		let PULARGE_INTEGER: Promise<any>
		let PULONG: Promise<any>
		let PUSHORT: Promise<any>
		let PWCHAR: Promise<any>
		let LPWIN32_FIND_DATAA: Promise<any>
		let PWIN32_FIND_DATAA: Promise<any>
		let LPWIN32_FIND_DATAW: Promise<any>
		let PWIN32_FIND_DATAW: Promise<any>
		let LPWORD: Promise<any>
		let PWORD: Promise<any>
	}
}
declare module curses {
	var _
	function initscr(): Promise<any>
	function initscr$($: {}): Promise<any>
	function start_color(): Promise<any>
	function start_color$($: {}): Promise<any>

	/**
	 * Wrapper function that initializes curses and calls another function,
	 *     restoring normal keyboard/screen behavior on error.
	 *     The callable object 'func' is then passed the main window 'stdscr'
	 *     as its first argument, followed by any other arguments passed to
	 *     wrapper().
	 *     
	 */
	function wrapper(func): Promise<any>
	function wrapper$({ func }): Promise<any>
	module ascii {
		var _
		function isalnum(c): Promise<any>
		function isalnum$({ c }): Promise<any>
		function isalpha(c): Promise<any>
		function isalpha$({ c }): Promise<any>
		function isascii(c): Promise<any>
		function isascii$({ c }): Promise<any>
		function isblank(c): Promise<any>
		function isblank$({ c }): Promise<any>
		function iscntrl(c): Promise<any>
		function iscntrl$({ c }): Promise<any>
		function isdigit(c): Promise<any>
		function isdigit$({ c }): Promise<any>
		function isgraph(c): Promise<any>
		function isgraph$({ c }): Promise<any>
		function islower(c): Promise<any>
		function islower$({ c }): Promise<any>
		function isprint(c): Promise<any>
		function isprint$({ c }): Promise<any>
		function ispunct(c): Promise<any>
		function ispunct$({ c }): Promise<any>
		function isspace(c): Promise<any>
		function isspace$({ c }): Promise<any>
		function isupper(c): Promise<any>
		function isupper$({ c }): Promise<any>
		function isxdigit(c): Promise<any>
		function isxdigit$({ c }): Promise<any>
		function isctrl(c): Promise<any>
		function isctrl$({ c }): Promise<any>
		function ismeta(c): Promise<any>
		function ismeta$({ c }): Promise<any>
		function ascii(c): Promise<any>
		function ascii$({ c }): Promise<any>
		function ctrl(c): Promise<any>
		function ctrl$({ c }): Promise<any>
		function alt(c): Promise<any>
		function alt$({ c }): Promise<any>
		function unctrl(c): Promise<any>
		function unctrl$({ c }): Promise<any>
		let NUL: Promise<any>
		let SOH: Promise<any>
		let STX: Promise<any>
		let ETX: Promise<any>
		let EOT: Promise<any>
		let ENQ: Promise<any>
		let ACK: Promise<any>
		let BEL: Promise<any>
		let BS: Promise<any>
		let TAB: Promise<any>
		let HT: Promise<any>
		let LF: Promise<any>
		let NL: Promise<any>
		let VT: Promise<any>
		let FF: Promise<any>
		let CR: Promise<any>
		let SO: Promise<any>
		let SI: Promise<any>
		let DLE: Promise<any>
		let DC1: Promise<any>
		let DC2: Promise<any>
		let DC3: Promise<any>
		let DC4: Promise<any>
		let NAK: Promise<any>
		let SYN: Promise<any>
		let ETB: Promise<any>
		let CAN: Promise<any>
		let EM: Promise<any>
		let SUB: Promise<any>
		let ESC: Promise<any>
		let FS: Promise<any>
		let GS: Promise<any>
		let RS: Promise<any>
		let US: Promise<any>
		let SP: Promise<any>
		let DEL: Promise<any>
		let controlnames: Promise<any>
	}
	module has_key {
		var _
		function has_key(ch): Promise<any>
		function has_key$({ ch }): Promise<any>
		let L: Promise<any>
		let system: Promise<any>
		let python: Promise<any>
	}
	module panel {
		var _
	}
	module textpad {
		var _

		/**
		 * Draw a rectangle with corners at the provided upper-left
		 *     and lower-right coordinates.
		 *     
		 */
		function rectangle(win, uly, ulx, lry, lrx): Promise<any>
		function rectangle$({ win, uly, ulx, lry, lrx }): Promise<any>
		function test_editbox(stdscr): Promise<any>
		function test_editbox$({ stdscr }): Promise<any>

		/**
		 * Editing widget using the interior of a window object.
		 *      Supports the following Emacs-like key bindings:
		 * 
		 *     Ctrl-A      Go to left edge of window.
		 *     Ctrl-B      Cursor left, wrapping to previous line if appropriate.
		 *     Ctrl-D      Delete character under cursor.
		 *     Ctrl-E      Go to right edge (stripspaces off) or end of line (stripspaces on).
		 *     Ctrl-F      Cursor right, wrapping to next line when appropriate.
		 *     Ctrl-G      Terminate, returning the window contents.
		 *     Ctrl-H      Delete character backward.
		 *     Ctrl-J      Terminate if the window is 1 line, otherwise insert newline.
		 *     Ctrl-K      If line is blank, delete it, otherwise clear to end of line.
		 *     Ctrl-L      Refresh screen.
		 *     Ctrl-N      Cursor down; move down one line.
		 *     Ctrl-O      Insert a blank line at cursor location.
		 *     Ctrl-P      Cursor up; move up one line.
		 * 
		 *     Move operations do nothing if the cursor is at an edge where the movement
		 *     is not possible.  The following synonyms are supported where possible:
		 * 
		 *     KEY_LEFT = Ctrl-B, KEY_RIGHT = Ctrl-F, KEY_UP = Ctrl-P, KEY_DOWN = Ctrl-N
		 *     KEY_BACKSPACE = Ctrl-h
		 *     
		 */
		function Textbox(win, insert_mode?: boolean): Promise<ITextbox>
		function Textbox$({ win, insert_mode }: { win, insert_mode?}): Promise<ITextbox>
		interface ITextbox {

			/**
			 * Process a single editing command.
			 */
			do_command(ch): Promise<any>
			do_command$({ ch }): Promise<any>

			/**
			 * Collect and return the contents of the window.
			 */
			gather(): Promise<any>
			gather$($: {}): Promise<any>

			/**
			 * Edit in the widget window and collect the results.
			 */
			edit(validate?): Promise<any>
			edit$({ validate }: { validate?}): Promise<any>
		}
		let str: Promise<any>
	}
}
declare module dataclasses {
	var _

	/**
	 * Return an object to identify dataclass fields.
	 * 
	 *     default is the default value of the field.  default_factory is a
	 *     0-argument function called to initialize a field's value.  If init
	 *     is true, the field will be a parameter to the class's __init__()
	 *     function.  If repr is true, the field will be included in the
	 *     object's repr().  If hash is true, the field will be included in the
	 *     object's hash().  If compare is true, the field will be used in
	 *     comparison functions.  metadata, if specified, must be a mapping
	 *     which is stored but not otherwise examined by dataclass.  If kw_only
	 *     is true, the field will become a keyword-only parameter to
	 *     __init__().
	 * 
	 *     It is an error to specify both default and default_factory.
	 *     
	 */
	function field(): Promise<any>
	function field$($: {}): Promise<any>

	/**
	 * Returns the same class as was passed in, with dunder methods
	 *     added based on the fields defined in the class.
	 * 
	 *     Examines PEP 526 __annotations__ to determine fields.
	 * 
	 *     If init is true, an __init__() method is added to the class. If
	 *     repr is true, a __repr__() method is added. If order is true, rich
	 *     comparison dunder methods are added. If unsafe_hash is true, a
	 *     __hash__() method function is added. If frozen is true, fields may
	 *     not be assigned to after instance creation. If match_args is true,
	 *     the __match_args__ tuple is added. If kw_only is true, then by
	 *     default all fields are keyword-only. If slots is true, an
	 *     __slots__ attribute is added.
	 *     
	 */
	function dataclass(cls?): Promise<any>
	function dataclass$({ cls }: { cls?}): Promise<any>

	/**
	 * Return a tuple describing the fields of this dataclass.
	 * 
	 *     Accepts a dataclass or an instance of one. Tuple elements are of
	 *     type Field.
	 *     
	 */
	function fields(class_or_instance): Promise<any>
	function fields$({ class_or_instance }): Promise<any>

	/**
	 * Returns True if obj is a dataclass or an instance of a
	 *     dataclass.
	 */
	function is_dataclass(obj): Promise<any>
	function is_dataclass$({ obj }): Promise<any>

	/**
	 * Return the fields of a dataclass instance as a new dictionary mapping
	 *     field names to field values.
	 * 
	 *     Example usage:
	 * 
	 *       @dataclass
	 *       class C:
	 *           x: int
	 *           y: int
	 * 
	 *       c = C(1, 2)
	 *       assert asdict(c) == {'x': 1, 'y': 2}
	 * 
	 *     If given, 'dict_factory' will be used instead of built-in dict.
	 *     The function applies recursively to field values that are
	 *     dataclass instances. This will also look into built-in containers:
	 *     tuples, lists, and dicts.
	 *     
	 */
	function asdict(obj): Promise<any>
	function asdict$({ obj }): Promise<any>

	/**
	 * Return the fields of a dataclass instance as a new tuple of field values.
	 * 
	 *     Example usage::
	 * 
	 *       @dataclass
	 *       class C:
	 *           x: int
	 *           y: int
	 * 
	 *     c = C(1, 2)
	 *     assert astuple(c) == (1, 2)
	 * 
	 *     If given, 'tuple_factory' will be used instead of built-in tuple.
	 *     The function applies recursively to field values that are
	 *     dataclass instances. This will also look into built-in containers:
	 *     tuples, lists, and dicts.
	 *     
	 */
	function astuple(obj): Promise<any>
	function astuple$({ obj }): Promise<any>

	/**
	 * Return a new dynamically created dataclass.
	 * 
	 *     The dataclass name will be 'cls_name'.  'fields' is an iterable
	 *     of either (name), (name, type) or (name, type, Field) objects. If type is
	 *     omitted, use the string 'typing.Any'.  Field objects are created by
	 *     the equivalent of calling 'field(name, type [, Field-info])'.
	 * 
	 *       C = make_dataclass('C', ['x', ('y', int), ('z', int, field(init=False))], bases=(Base,))
	 * 
	 *     is equivalent to:
	 * 
	 *       @dataclass
	 *       class C(Base):
	 *           x: 'typing.Any'
	 *           y: int
	 *           z: int = field(init=False)
	 * 
	 *     For the bases and namespace parameters, see the builtin type() function.
	 * 
	 *     The parameters init, repr, eq, order, unsafe_hash, and frozen are passed to
	 *     dataclass().
	 *     
	 */
	function make_dataclass(cls_name, fields): Promise<any>
	function make_dataclass$({ cls_name, fields }): Promise<any>

	/**
	 * Return a new object replacing specified fields with new values.
	 * 
	 *     This is especially useful for frozen classes.  Example usage:
	 * 
	 *       @dataclass(frozen=True)
	 *       class C:
	 *           x: int
	 *           y: int
	 * 
	 *       c = C(1, 2)
	 *       c1 = replace(c, x=3)
	 *       assert c1.x == 3 and c1.y == 2
	 *       
	 */
	function replace(obj): Promise<any>
	function replace$({ obj }): Promise<any>
	interface IFrozenInstanceError {
	}
	interface I_HAS_DEFAULT_FACTORY_CLASS {
	}
	interface I_MISSING_TYPE {
	}
	interface I_KW_ONLY_TYPE {
	}
	interface I_FIELD_BASE {
	}
	function InitVar(type): Promise<IInitVar>
	function InitVar$({ type }): Promise<IInitVar>
	interface IInitVar {
	}
	function Field(def, default_factory, init, repr, hash, compare, metadata, kw_only): Promise<IField>
	function Field$({ def, default_factory, init, repr, hash, compare, metadata, kw_only }): Promise<IField>
	interface IField {
	}
	interface I_DataclassParams {
	}
	let MISSING: Promise<any>
	let KW_ONLY: Promise<any>
}
declare module datetime {
	var _

	/**
	 * Represent the difference between two datetime objects.
	 * 
	 *     Supported operators:
	 * 
	 *     - add, subtract timedelta
	 *     - unary plus, minus, abs
	 *     - compare to timedelta
	 *     - multiply, divide by int
	 * 
	 *     In addition, datetime supports subtraction of two datetime objects
	 *     returning a timedelta, and addition or subtraction of a datetime
	 *     and a timedelta giving a datetime.
	 * 
	 *     Representation: (days, seconds, microseconds).  Why?  Because I
	 *     felt like it.
	 *     
	 */
	interface Itimedelta {

		/**
		 * Total seconds in the duration.
		 */
		total_seconds(): Promise<any>
		total_seconds$($: {}): Promise<any>

		/**
		 * days
		 */
		days(): Promise<any>
		days$($: {}): Promise<any>

		/**
		 * seconds
		 */
		seconds(): Promise<any>
		seconds$($: {}): Promise<any>

		/**
		 * microseconds
		 */
		microseconds(): Promise<any>
		microseconds$($: {}): Promise<any>
	}

	/**
	 * Concrete date type.
	 * 
	 *     Constructors:
	 * 
	 *     __new__()
	 *     fromtimestamp()
	 *     today()
	 *     fromordinal()
	 * 
	 *     Operators:
	 * 
	 *     __repr__, __str__
	 *     __eq__, __le__, __lt__, __ge__, __gt__, __hash__
	 *     __add__, __radd__, __sub__ (add/radd only with timedelta arg)
	 * 
	 *     Methods:
	 * 
	 *     timetuple()
	 *     toordinal()
	 *     weekday()
	 *     isoweekday(), isocalendar(), isoformat()
	 *     ctime()
	 *     strftime()
	 * 
	 *     Properties (readonly):
	 *     year, month, day
	 *     
	 */
	interface Idate {

		/**
		 * Construct a date from a POSIX timestamp (like time.time()).
		 */
		fromtimestamp(t): Promise<any>
		fromtimestamp$({ t }): Promise<any>

		/**
		 * Construct a date from time.time().
		 */
		today(): Promise<any>
		today$($: {}): Promise<any>

		/**
		 * Construct a date from a proleptic Gregorian ordinal.
		 * 
		 *         January 1 of year 1 is day 1.  Only the year, month and day are
		 *         non-zero in the result.
		 *         
		 */
		fromordinal(n): Promise<any>
		fromordinal$({ n }): Promise<any>

		/**
		 * Construct a date from the output of date.isoformat().
		 */
		fromisoformat(date_string): Promise<any>
		fromisoformat$({ date_string }): Promise<any>

		/**
		 * Construct a date from the ISO year, week number and weekday.
		 * 
		 *         This is the inverse of the date.isocalendar() function
		 */
		fromisocalendar(year, week, day): Promise<any>
		fromisocalendar$({ year, week, day }): Promise<any>

		/**
		 * Return ctime() style string.
		 */
		ctime(): Promise<any>
		ctime$($: {}): Promise<any>

		/**
		 * Format using strftime().
		 */
		strftime(fmt): Promise<any>
		strftime$({ fmt }): Promise<any>

		/**
		 * Return the date formatted according to ISO.
		 * 
		 *         This is 'YYYY-MM-DD'.
		 * 
		 *         References:
		 *         - http://www.w3.org/TR/NOTE-datetime
		 *         - http://www.cl.cam.ac.uk/~mgk25/iso-time.html
		 *         
		 */
		isoformat(): Promise<any>
		isoformat$($: {}): Promise<any>

		/**
		 * year (1-9999)
		 */
		year(): Promise<any>
		year$($: {}): Promise<any>

		/**
		 * month (1-12)
		 */
		month(): Promise<any>
		month$($: {}): Promise<any>

		/**
		 * day (1-31)
		 */
		day(): Promise<any>
		day$($: {}): Promise<any>

		/**
		 * Return local time tuple compatible with time.localtime().
		 */
		timetuple(): Promise<any>
		timetuple$($: {}): Promise<any>

		/**
		 * Return proleptic Gregorian ordinal for the year, month and day.
		 * 
		 *         January 1 of year 1 is day 1.  Only the year, month and day values
		 *         contribute to the result.
		 *         
		 */
		toordinal(): Promise<any>
		toordinal$($: {}): Promise<any>

		/**
		 * Return a new date with new values for the specified fields.
		 */
		replace(year?, month?, day?): Promise<any>
		replace$({ year, month, day }: { year?, month?, day?}): Promise<any>

		/**
		 * Return day of the week, where Monday == 0 ... Sunday == 6.
		 */
		weekday(): Promise<any>
		weekday$($: {}): Promise<any>

		/**
		 * Return day of the week, where Monday == 1 ... Sunday == 7.
		 */
		isoweekday(): Promise<any>
		isoweekday$($: {}): Promise<any>

		/**
		 * Return a named tuple containing ISO year, week number, and weekday.
		 * 
		 *         The first ISO week of the year is the (Mon-Sun) week
		 *         containing the year's first Thursday; everything else derives
		 *         from that.
		 * 
		 *         The first week is 1; Monday is 1 ... Sunday is 7.
		 * 
		 *         ISO calendar algorithm taken from
		 *         http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm
		 *         (used with permission)
		 *         
		 */
		isocalendar(): Promise<any>
		isocalendar$($: {}): Promise<any>
	}

	/**
	 * Abstract base class for time zone info classes.
	 * 
	 *     Subclasses must override the name(), utcoffset() and dst() methods.
	 *     
	 */
	interface Itzinfo {

		/**
		 * datetime -> string name of time zone.
		 */
		tzname(dt): Promise<any>
		tzname$({ dt }): Promise<any>

		/**
		 * datetime -> timedelta, positive for east of UTC, negative for west of UTC
		 */
		utcoffset(dt): Promise<any>
		utcoffset$({ dt }): Promise<any>

		/**
		 * datetime -> DST offset as timedelta, positive for east of UTC.
		 * 
		 *         Return 0 if DST not in effect.  utcoffset() must include the DST
		 *         offset.
		 *         
		 */
		dst(dt): Promise<any>
		dst$({ dt }): Promise<any>

		/**
		 * datetime in UTC -> datetime in local time.
		 */
		fromutc(dt): Promise<any>
		fromutc$({ dt }): Promise<any>
	}
	interface IIsoCalendarDate {
		year(): Promise<any>
		year$($: {}): Promise<any>
		week(): Promise<any>
		week$($: {}): Promise<any>
		weekday(): Promise<any>
		weekday$($: {}): Promise<any>
	}

	/**
	 * Time with time zone.
	 * 
	 *     Constructors:
	 * 
	 *     __new__()
	 * 
	 *     Operators:
	 * 
	 *     __repr__, __str__
	 *     __eq__, __le__, __lt__, __ge__, __gt__, __hash__
	 * 
	 *     Methods:
	 * 
	 *     strftime()
	 *     isoformat()
	 *     utcoffset()
	 *     tzname()
	 *     dst()
	 * 
	 *     Properties (readonly):
	 *     hour, minute, second, microsecond, tzinfo, fold
	 *     
	 */
	interface Itime {

		/**
		 * hour (0-23)
		 */
		hour(): Promise<any>
		hour$($: {}): Promise<any>

		/**
		 * minute (0-59)
		 */
		minute(): Promise<any>
		minute$($: {}): Promise<any>

		/**
		 * second (0-59)
		 */
		second(): Promise<any>
		second$($: {}): Promise<any>

		/**
		 * microsecond (0-999999)
		 */
		microsecond(): Promise<any>
		microsecond$($: {}): Promise<any>

		/**
		 * timezone info object
		 */
		tzinfo(): Promise<any>
		tzinfo$($: {}): Promise<any>
		fold(): Promise<any>
		fold$($: {}): Promise<any>

		/**
		 * Return the time formatted according to ISO.
		 * 
		 *         The full format is 'HH:MM:SS.mmmmmm+zz:zz'. By default, the fractional
		 *         part is omitted if self.microsecond == 0.
		 * 
		 *         The optional argument timespec specifies the number of additional
		 *         terms of the time to include. Valid options are 'auto', 'hours',
		 *         'minutes', 'seconds', 'milliseconds' and 'microseconds'.
		 *         
		 */
		isoformat(timespec?): Promise<any>
		isoformat$({ timespec }: { timespec?}): Promise<any>

		/**
		 * Construct a time from the output of isoformat().
		 */
		fromisoformat(time_string): Promise<any>
		fromisoformat$({ time_string }): Promise<any>

		/**
		 * Format using strftime().  The date part of the timestamp passed
		 *         to underlying strftime should not be used.
		 *         
		 */
		strftime(fmt): Promise<any>
		strftime$({ fmt }): Promise<any>

		/**
		 * Return the timezone offset as timedelta, positive east of UTC
		 *          (negative west of UTC).
		 */
		utcoffset(): Promise<any>
		utcoffset$($: {}): Promise<any>

		/**
		 * Return the timezone name.
		 * 
		 *         Note that the name is 100% informational -- there's no requirement that
		 *         it mean anything in particular. For example, "GMT", "UTC", "-500",
		 *         "-5:00", "EDT", "US/Eastern", "America/New York" are all valid replies.
		 *         
		 */
		tzname(): Promise<any>
		tzname$($: {}): Promise<any>

		/**
		 * Return 0 if DST is not in effect, or the DST offset (as timedelta
		 *         positive eastward) if DST is in effect.
		 * 
		 *         This is purely informational; the DST offset has already been added to
		 *         the UTC offset returned by utcoffset() if applicable, so there's no
		 *         need to consult dst() unless you're interested in displaying the DST
		 *         info.
		 *         
		 */
		dst(): Promise<any>
		dst$($: {}): Promise<any>

		/**
		 * Return a new time with new values for the specified fields.
		 */
		replace(hour?, minute?, second?, microsecond?, tzinfo?: boolean): Promise<any>
		replace$({ hour, minute, second, microsecond, tzinfo }: { hour?, minute?, second?, microsecond?, tzinfo?}): Promise<any>
	}

	/**
	 * datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])
	 * 
	 *     The year, month and day arguments are required. tzinfo may be None, or an
	 *     instance of a tzinfo subclass. The remaining arguments may be ints.
	 *     
	 */
	interface Idatetime extends Idate {

		/**
		 * hour (0-23)
		 */
		hour(): Promise<any>
		hour$($: {}): Promise<any>

		/**
		 * minute (0-59)
		 */
		minute(): Promise<any>
		minute$($: {}): Promise<any>

		/**
		 * second (0-59)
		 */
		second(): Promise<any>
		second$($: {}): Promise<any>

		/**
		 * microsecond (0-999999)
		 */
		microsecond(): Promise<any>
		microsecond$($: {}): Promise<any>

		/**
		 * timezone info object
		 */
		tzinfo(): Promise<any>
		tzinfo$($: {}): Promise<any>
		fold(): Promise<any>
		fold$($: {}): Promise<any>

		/**
		 * Construct a datetime from a POSIX timestamp (like time.time()).
		 * 
		 *         A timezone info object may be passed in as well.
		 *         
		 */
		fromtimestamp(t, tz?): Promise<any>
		fromtimestamp$({ t, tz }: { t, tz?}): Promise<any>

		/**
		 * Construct a naive UTC datetime from a POSIX timestamp.
		 */
		utcfromtimestamp(t): Promise<any>
		utcfromtimestamp$({ t }): Promise<any>

		/**
		 * Construct a datetime from time.time() and optional time zone info.
		 */
		now(tz?): Promise<any>
		now$({ tz }: { tz?}): Promise<any>

		/**
		 * Construct a UTC datetime from time.time().
		 */
		utcnow(): Promise<any>
		utcnow$($: {}): Promise<any>

		/**
		 * Construct a datetime from a given date and a given time.
		 */
		combine(date, time, tzinfo?: boolean): Promise<any>
		combine$({ date, time, tzinfo }: { date, time, tzinfo?}): Promise<any>

		/**
		 * Construct a datetime from the output of datetime.isoformat().
		 */
		fromisoformat(date_string): Promise<any>
		fromisoformat$({ date_string }): Promise<any>

		/**
		 * Return local time tuple compatible with time.localtime().
		 */
		timetuple(): Promise<any>
		timetuple$($: {}): Promise<any>

		/**
		 * Return POSIX timestamp as float
		 */
		timestamp(): Promise<any>
		timestamp$($: {}): Promise<any>

		/**
		 * Return UTC time tuple compatible with time.gmtime().
		 */
		utctimetuple(): Promise<any>
		utctimetuple$($: {}): Promise<any>

		/**
		 * Return the date part.
		 */
		date(): Promise<any>
		date$($: {}): Promise<any>

		/**
		 * Return the time part, with tzinfo None.
		 */
		time(): Promise<any>
		time$($: {}): Promise<any>

		/**
		 * Return the time part, with same tzinfo.
		 */
		timetz(): Promise<any>
		timetz$($: {}): Promise<any>

		/**
		 * Return a new datetime with new values for the specified fields.
		 */
		replace(year?, month?, day?, hour?, minute?, second?, microsecond?, tzinfo?: boolean): Promise<any>
		replace$({ year, month, day, hour, minute, second, microsecond, tzinfo }: { year?, month?, day?, hour?, minute?, second?, microsecond?, tzinfo?}): Promise<any>
		astimezone(tz?): Promise<any>
		astimezone$({ tz }: { tz?}): Promise<any>

		/**
		 * Return ctime() style string.
		 */
		ctime(): Promise<any>
		ctime$($: {}): Promise<any>

		/**
		 * Return the time formatted according to ISO.
		 * 
		 *         The full format looks like 'YYYY-MM-DD HH:MM:SS.mmmmmm'.
		 *         By default, the fractional part is omitted if self.microsecond == 0.
		 * 
		 *         If self.tzinfo is not None, the UTC offset is also attached, giving
		 *         giving a full format of 'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM'.
		 * 
		 *         Optional argument sep specifies the separator between date and
		 *         time, default 'T'.
		 * 
		 *         The optional argument timespec specifies the number of additional
		 *         terms of the time to include. Valid options are 'auto', 'hours',
		 *         'minutes', 'seconds', 'milliseconds' and 'microseconds'.
		 *         
		 */
		isoformat(sep?, timespec?): Promise<any>
		isoformat$({ sep, timespec }: { sep?, timespec?}): Promise<any>

		/**
		 * string, format -> new datetime parsed from a string (like time.strptime()).
		 */
		strptime(date_string, format): Promise<any>
		strptime$({ date_string, format }): Promise<any>

		/**
		 * Return the timezone offset as timedelta positive east of UTC (negative west of
		 *         UTC).
		 */
		utcoffset(): Promise<any>
		utcoffset$($: {}): Promise<any>

		/**
		 * Return the timezone name.
		 * 
		 *         Note that the name is 100% informational -- there's no requirement that
		 *         it mean anything in particular. For example, "GMT", "UTC", "-500",
		 *         "-5:00", "EDT", "US/Eastern", "America/New York" are all valid replies.
		 *         
		 */
		tzname(): Promise<any>
		tzname$($: {}): Promise<any>

		/**
		 * Return 0 if DST is not in effect, or the DST offset (as timedelta
		 *         positive eastward) if DST is in effect.
		 * 
		 *         This is purely informational; the DST offset has already been added to
		 *         the UTC offset returned by utcoffset() if applicable, so there's no
		 *         need to consult dst() unless you're interested in displaying the DST
		 *         info.
		 *         
		 */
		dst(): Promise<any>
		dst$($: {}): Promise<any>
	}
	interface Itimezone extends Itzinfo {
		utcoffset(dt): Promise<any>
		utcoffset$({ dt }): Promise<any>
		tzname(dt): Promise<any>
		tzname$({ dt }): Promise<any>
		dst(dt): Promise<any>
		dst$({ dt }): Promise<any>
		fromutc(dt): Promise<any>
		fromutc$({ dt }): Promise<any>
	}
	let MINYEAR: Promise<any>
	let MAXYEAR: Promise<any>
	let dbm: Promise<any>
}
declare module dbm {
	var _

	/**
	 * Open or create database at path given by *file*.
	 * 
	 *     Optional argument *flag* can be 'r' (default) for read-only access, 'w'
	 *     for read-write access of an existing database, 'c' for read-write access
	 *     to a new or existing database, and 'n' for read-write access to a new
	 *     database.
	 * 
	 *     Note: 'r' and 'w' fail if the database doesn't exist; 'c' creates it
	 *     only if it doesn't exist; and 'n' always creates a new database.
	 *     
	 */
	function open(file, flag?, mode?): Promise<any>
	function open$({ file, flag, mode }: { file, flag?, mode?}): Promise<any>

	/**
	 * Guess which db package to use to open a db file.
	 * 
	 *     Return values:
	 * 
	 *     - None if the database file can't be read;
	 *     - empty string if the file can be read but can't be recognized
	 *     - the name of the dbm submodule (e.g. "ndbm" or "gnu") if recognized.
	 * 
	 *     Importing the given module may still fail, and opening the
	 *     database using that module may still fail.
	 *     
	 */
	function whichdb(filename): Promise<any>
	function whichdb$({ filename }): Promise<any>
	interface Ierror {
	}
	let error: Promise<any>
	module dumb {
		var _

		/**
		 * Open the database file, filename, and return corresponding object.
		 * 
		 *     The flag argument, used to control how the database is opened in the
		 *     other DBM implementations, supports only the semantics of 'c' and 'n'
		 *     values.  Other values will default to the semantics of 'c' value:
		 *     the database will always opened for update and will be created if it
		 *     does not exist.
		 * 
		 *     The optional mode argument is the UNIX mode of the file, used only when
		 *     the database has to be created.  It defaults to octal code 0o666 (and
		 *     will be modified by the prevailing umask).
		 * 
		 *     
		 */
		function open(file, flag?, mode?): Promise<any>
		function open$({ file, flag, mode }: { file, flag?, mode?}): Promise<any>
		interface I_Database {
			keys(): Promise<any>
			keys$($: {}): Promise<any>
			items(): Promise<any>
			items$($: {}): Promise<any>
			iterkeys(): Promise<any>
			iterkeys$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			sync
		}
		let error: Promise<any>
	}
	module gnu {
		var _
	}
	module ndbm {
		var _
	}
}
declare module decimal {
	var _
}
declare module difflib {
	var _

	/**
	 * Use SequenceMatcher to return list of the best "good enough" matches.
	 * 
	 *     word is a sequence for which close matches are desired (typically a
	 *     string).
	 * 
	 *     possibilities is a list of sequences against which to match word
	 *     (typically a list of strings).
	 * 
	 *     Optional arg n (default 3) is the maximum number of close matches to
	 *     return.  n must be > 0.
	 * 
	 *     Optional arg cutoff (default 0.6) is a float in [0, 1].  Possibilities
	 *     that don't score at least that similar to word are ignored.
	 * 
	 *     The best (no more than n) matches among the possibilities are returned
	 *     in a list, sorted by similarity score, most similar first.
	 * 
	 *     >>> get_close_matches("appel", ["ape", "apple", "peach", "puppy"])
	 *     ['apple', 'ape']
	 *     >>> import keyword as _keyword
	 *     >>> get_close_matches("wheel", _keyword.kwlist)
	 *     ['while']
	 *     >>> get_close_matches("Apple", _keyword.kwlist)
	 *     []
	 *     >>> get_close_matches("accept", _keyword.kwlist)
	 *     ['except']
	 *     
	 */
	function get_close_matches(word, possibilities, n?, cutoff?): Promise<any>
	function get_close_matches$({ word, possibilities, n, cutoff }: { word, possibilities, n?, cutoff?}): Promise<any>

	/**
	 * 
	 *     Return True for ignorable line: iff `line` is blank or contains a single '#'.
	 * 
	 *     Examples:
	 * 
	 *     >>> IS_LINE_JUNK('\n')
	 *     True
	 *     >>> IS_LINE_JUNK('  #   \n')
	 *     True
	 *     >>> IS_LINE_JUNK('hello\n')
	 *     False
	 *     
	 */
	function IS_LINE_JUNK(line, pat?): Promise<any>
	function IS_LINE_JUNK$({ line, pat }: { line, pat?}): Promise<any>

	/**
	 * 
	 *     Return True for ignorable character: iff `ch` is a space or tab.
	 * 
	 *     Examples:
	 * 
	 *     >>> IS_CHARACTER_JUNK(' ')
	 *     True
	 *     >>> IS_CHARACTER_JUNK('\t')
	 *     True
	 *     >>> IS_CHARACTER_JUNK('\n')
	 *     False
	 *     >>> IS_CHARACTER_JUNK('x')
	 *     False
	 *     
	 */
	function IS_CHARACTER_JUNK(ch, ws?): Promise<any>
	function IS_CHARACTER_JUNK$({ ch, ws }: { ch, ws?}): Promise<any>

	/**
	 * 
	 *     Compare two sequences of lines; generate the delta as a unified diff.
	 * 
	 *     Unified diffs are a compact way of showing line changes and a few
	 *     lines of context.  The number of context lines is set by 'n' which
	 *     defaults to three.
	 * 
	 *     By default, the diff control lines (those with ---, +++, or @@) are
	 *     created with a trailing newline.  This is helpful so that inputs
	 *     created from file.readlines() result in diffs that are suitable for
	 *     file.writelines() since both the inputs and outputs have trailing
	 *     newlines.
	 * 
	 *     For inputs that do not have trailing newlines, set the lineterm
	 *     argument to "" so that the output will be uniformly newline free.
	 * 
	 *     The unidiff format normally has a header for filenames and modification
	 *     times.  Any or all of these may be specified using strings for
	 *     'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.
	 *     The modification times are normally expressed in the ISO 8601 format.
	 * 
	 *     Example:
	 * 
	 *     >>> for line in unified_diff('one two three four'.split(),
	 *     ...             'zero one tree four'.split(), 'Original', 'Current',
	 *     ...             '2005-01-26 23:30:50', '2010-04-02 10:20:52',
	 *     ...             lineterm=''):
	 *     ...     print(line)                 # doctest: +NORMALIZE_WHITESPACE
	 *     --- Original        2005-01-26 23:30:50
	 *     +++ Current         2010-04-02 10:20:52
	 *     @@ -1,4 +1,4 @@
	 *     +zero
	 *      one
	 *     -two
	 *     -three
	 *     +tree
	 *      four
	 *     
	 */
	function unified_diff(a, b, fromfile?, tofile?, fromfiledate?, tofiledate?, n?, lineterm?): Promise<any>
	function unified_diff$({ a, b, fromfile, tofile, fromfiledate, tofiledate, n, lineterm }: { a, b, fromfile?, tofile?, fromfiledate?, tofiledate?, n?, lineterm?}): Promise<any>

	/**
	 * 
	 *     Compare two sequences of lines; generate the delta as a context diff.
	 * 
	 *     Context diffs are a compact way of showing line changes and a few
	 *     lines of context.  The number of context lines is set by 'n' which
	 *     defaults to three.
	 * 
	 *     By default, the diff control lines (those with *** or ---) are
	 *     created with a trailing newline.  This is helpful so that inputs
	 *     created from file.readlines() result in diffs that are suitable for
	 *     file.writelines() since both the inputs and outputs have trailing
	 *     newlines.
	 * 
	 *     For inputs that do not have trailing newlines, set the lineterm
	 *     argument to "" so that the output will be uniformly newline free.
	 * 
	 *     The context diff format normally has a header for filenames and
	 *     modification times.  Any or all of these may be specified using
	 *     strings for 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.
	 *     The modification times are normally expressed in the ISO 8601 format.
	 *     If not specified, the strings default to blanks.
	 * 
	 *     Example:
	 * 
	 *     >>> print(''.join(context_diff('one\ntwo\nthree\nfour\n'.splitlines(True),
	 *     ...       'zero\none\ntree\nfour\n'.splitlines(True), 'Original', 'Current')),
	 *     ...       end="")
	 *     *** Original
	 *     --- Current
	 *     ***************
	 *     *** 1,4 ****
	 *       one
	 *     ! two
	 *     ! three
	 *       four
	 *     --- 1,4 ----
	 *     + zero
	 *       one
	 *     ! tree
	 *       four
	 *     
	 */
	function context_diff(a, b, fromfile?, tofile?, fromfiledate?, tofiledate?, n?, lineterm?): Promise<any>
	function context_diff$({ a, b, fromfile, tofile, fromfiledate, tofiledate, n, lineterm }: { a, b, fromfile?, tofile?, fromfiledate?, tofiledate?, n?, lineterm?}): Promise<any>

	/**
	 * 
	 *     Compare `a` and `b`, two sequences of lines represented as bytes rather
	 *     than str. This is a wrapper for `dfunc`, which is typically either
	 *     unified_diff() or context_diff(). Inputs are losslessly converted to
	 *     strings so that `dfunc` only has to worry about strings, and encoded
	 *     back to bytes on return. This is necessary to compare files with
	 *     unknown or inconsistent encoding. All other inputs (except `n`) must be
	 *     bytes rather than str.
	 *     
	 */
	function diff_bytes(dfunc, a, b, fromfile?, tofile?, fromfiledate?, tofiledate?, n?, lineterm?): Promise<any>
	function diff_bytes$({ dfunc, a, b, fromfile, tofile, fromfiledate, tofiledate, n, lineterm }: { dfunc, a, b, fromfile?, tofile?, fromfiledate?, tofiledate?, n?, lineterm?}): Promise<any>

	/**
	 * 
	 *     Compare `a` and `b` (lists of strings); return a `Differ`-style delta.
	 * 
	 *     Optional keyword parameters `linejunk` and `charjunk` are for filter
	 *     functions, or can be None:
	 * 
	 *     - linejunk: A function that should accept a single string argument and
	 *       return true iff the string is junk.  The default is None, and is
	 *       recommended; the underlying SequenceMatcher class has an adaptive
	 *       notion of "noise" lines.
	 * 
	 *     - charjunk: A function that accepts a character (string of length
	 *       1), and returns true iff the character is junk. The default is
	 *       the module-level function IS_CHARACTER_JUNK, which filters out
	 *       whitespace characters (a blank or tab; note: it's a bad idea to
	 *       include newline in this!).
	 * 
	 *     Tools/scripts/ndiff.py is a command-line front-end to this function.
	 * 
	 *     Example:
	 * 
	 *     >>> diff = ndiff('one\ntwo\nthree\n'.splitlines(keepends=True),
	 *     ...              'ore\ntree\nemu\n'.splitlines(keepends=True))
	 *     >>> print(''.join(diff), end="")
	 *     - one
	 *     ?  ^
	 *     + ore
	 *     ?  ^
	 *     - two
	 *     - three
	 *     ?  -
	 *     + tree
	 *     + emu
	 *     
	 */
	function ndiff(a, b, linejunk?, charjunk?): Promise<any>
	function ndiff$({ a, b, linejunk, charjunk }: { a, b, linejunk?, charjunk?}): Promise<any>

	/**
	 * 
	 *     Generate one of the two sequences that generated a delta.
	 * 
	 *     Given a `delta` produced by `Differ.compare()` or `ndiff()`, extract
	 *     lines originating from file 1 or 2 (parameter `which`), stripping off line
	 *     prefixes.
	 * 
	 *     Examples:
	 * 
	 *     >>> diff = ndiff('one\ntwo\nthree\n'.splitlines(keepends=True),
	 *     ...              'ore\ntree\nemu\n'.splitlines(keepends=True))
	 *     >>> diff = list(diff)
	 *     >>> print(''.join(restore(diff, 1)), end="")
	 *     one
	 *     two
	 *     three
	 *     >>> print(''.join(restore(diff, 2)), end="")
	 *     ore
	 *     tree
	 *     emu
	 *     
	 */
	function restore(delta, which): Promise<any>
	function restore$({ delta, which }): Promise<any>

	/**
	 * 
	 *     SequenceMatcher is a flexible class for comparing pairs of sequences of
	 *     any type, so long as the sequence elements are hashable.  The basic
	 *     algorithm predates, and is a little fancier than, an algorithm
	 *     published in the late 1980's by Ratcliff and Obershelp under the
	 *     hyperbolic name "gestalt pattern matching".  The basic idea is to find
	 *     the longest contiguous matching subsequence that contains no "junk"
	 *     elements (R-O doesn't address junk).  The same idea is then applied
	 *     recursively to the pieces of the sequences to the left and to the right
	 *     of the matching subsequence.  This does not yield minimal edit
	 *     sequences, but does tend to yield matches that "look right" to people.
	 * 
	 *     SequenceMatcher tries to compute a "human-friendly diff" between two
	 *     sequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the
	 *     longest *contiguous* & junk-free matching subsequence.  That's what
	 *     catches peoples' eyes.  The Windows(tm) windiff has another interesting
	 *     notion, pairing up elements that appear uniquely in each sequence.
	 *     That, and the method here, appear to yield more intuitive difference
	 *     reports than does diff.  This method appears to be the least vulnerable
	 *     to synching up on blocks of "junk lines", though (like blank lines in
	 *     ordinary text files, or maybe "<P>" lines in HTML files).  That may be
	 *     because this is the only method of the 3 that has a *concept* of
	 *     "junk" <wink>.
	 * 
	 *     Example, comparing two strings, and considering blanks to be "junk":
	 * 
	 *     >>> s = SequenceMatcher(lambda x: x == " ",
	 *     ...                     "private Thread currentThread;",
	 *     ...                     "private volatile Thread currentThread;")
	 *     >>>
	 * 
	 *     .ratio() returns a float in [0, 1], measuring the "similarity" of the
	 *     sequences.  As a rule of thumb, a .ratio() value over 0.6 means the
	 *     sequences are close matches:
	 * 
	 *     >>> print(round(s.ratio(), 3))
	 *     0.866
	 *     >>>
	 * 
	 *     If you're only interested in where the sequences match,
	 *     .get_matching_blocks() is handy:
	 * 
	 *     >>> for block in s.get_matching_blocks():
	 *     ...     print("a[%d] and b[%d] match for %d elements" % block)
	 *     a[0] and b[0] match for 8 elements
	 *     a[8] and b[17] match for 21 elements
	 *     a[29] and b[38] match for 0 elements
	 * 
	 *     Note that the last tuple returned by .get_matching_blocks() is always a
	 *     dummy, (len(a), len(b), 0), and this is the only case in which the last
	 *     tuple element (number of elements matched) is 0.
	 * 
	 *     If you want to know how to change the first sequence into the second,
	 *     use .get_opcodes():
	 * 
	 *     >>> for opcode in s.get_opcodes():
	 *     ...     print("%6s a[%d:%d] b[%d:%d]" % opcode)
	 *      equal a[0:8] b[0:8]
	 *     insert a[8:8] b[8:17]
	 *      equal a[8:29] b[17:38]
	 * 
	 *     See the Differ class for a fancy human-friendly file differencer, which
	 *     uses SequenceMatcher both to compare sequences of lines, and to compare
	 *     sequences of characters within similar (near-matching) lines.
	 * 
	 *     See also function get_close_matches() in this module, which shows how
	 *     simple code building on SequenceMatcher can be used to do useful work.
	 * 
	 *     Timing:  Basic R-O is cubic time worst case and quadratic time expected
	 *     case.  SequenceMatcher is quadratic time for the worst case and has
	 *     expected-case behavior dependent in a complicated way on how many
	 *     elements the sequences have in common; best case time is linear.
	 * 
	 *     Methods:
	 * 
	 *     __init__(isjunk=None, a='', b='')
	 *         Construct a SequenceMatcher.
	 * 
	 *     set_seqs(a, b)
	 *         Set the two sequences to be compared.
	 * 
	 *     set_seq1(a)
	 *         Set the first sequence to be compared.
	 * 
	 *     set_seq2(b)
	 *         Set the second sequence to be compared.
	 * 
	 *     find_longest_match(alo=0, ahi=None, blo=0, bhi=None)
	 *         Find longest matching block in a[alo:ahi] and b[blo:bhi].
	 * 
	 *     get_matching_blocks()
	 *         Return list of triples describing matching subsequences.
	 * 
	 *     get_opcodes()
	 *         Return list of 5-tuples describing how to turn a into b.
	 * 
	 *     ratio()
	 *         Return a measure of the sequences' similarity (float in [0,1]).
	 * 
	 *     quick_ratio()
	 *         Return an upper bound on .ratio() relatively quickly.
	 * 
	 *     real_quick_ratio()
	 *         Return an upper bound on ratio() very quickly.
	 *     
	 */

	/**
	 * Construct a SequenceMatcher.
	 * 
	 *         Optional arg isjunk is None (the default), or a one-argument
	 *         function that takes a sequence element and returns true iff the
	 *         element is junk.  None is equivalent to passing "lambda x: 0", i.e.
	 *         no elements are considered to be junk.  For example, pass
	 *             lambda x: x in " \t"
	 *         if you're comparing lines as sequences of characters, and don't
	 *         want to synch up on blanks or hard tabs.
	 * 
	 *         Optional arg a is the first of two sequences to be compared.  By
	 *         default, an empty string.  The elements of a must be hashable.  See
	 *         also .set_seqs() and .set_seq1().
	 * 
	 *         Optional arg b is the second of two sequences to be compared.  By
	 *         default, an empty string.  The elements of b must be hashable. See
	 *         also .set_seqs() and .set_seq2().
	 * 
	 *         Optional arg autojunk should be set to False to disable the
	 *         "automatic junk heuristic" that treats popular elements as junk
	 *         (see module documentation for more information).
	 *         
	 */
	function SequenceMatcher(isjunk?, a?, b?, autojunk?: boolean): Promise<ISequenceMatcher>
	function SequenceMatcher$({ isjunk, a, b, autojunk }: { isjunk?, a?, b?, autojunk?}): Promise<ISequenceMatcher>
	interface ISequenceMatcher {

		/**
		 * Set the two sequences to be compared.
		 * 
		 *         >>> s = SequenceMatcher()
		 *         >>> s.set_seqs("abcd", "bcde")
		 *         >>> s.ratio()
		 *         0.75
		 *         
		 */
		set_seqs(a, b): Promise<any>
		set_seqs$({ a, b }): Promise<any>

		/**
		 * Set the first sequence to be compared.
		 * 
		 *         The second sequence to be compared is not changed.
		 * 
		 *         >>> s = SequenceMatcher(None, "abcd", "bcde")
		 *         >>> s.ratio()
		 *         0.75
		 *         >>> s.set_seq1("bcde")
		 *         >>> s.ratio()
		 *         1.0
		 *         >>>
		 * 
		 *         SequenceMatcher computes and caches detailed information about the
		 *         second sequence, so if you want to compare one sequence S against
		 *         many sequences, use .set_seq2(S) once and call .set_seq1(x)
		 *         repeatedly for each of the other sequences.
		 * 
		 *         See also set_seqs() and set_seq2().
		 *         
		 */
		set_seq1(a): Promise<any>
		set_seq1$({ a }): Promise<any>

		/**
		 * Set the second sequence to be compared.
		 * 
		 *         The first sequence to be compared is not changed.
		 * 
		 *         >>> s = SequenceMatcher(None, "abcd", "bcde")
		 *         >>> s.ratio()
		 *         0.75
		 *         >>> s.set_seq2("abcd")
		 *         >>> s.ratio()
		 *         1.0
		 *         >>>
		 * 
		 *         SequenceMatcher computes and caches detailed information about the
		 *         second sequence, so if you want to compare one sequence S against
		 *         many sequences, use .set_seq2(S) once and call .set_seq1(x)
		 *         repeatedly for each of the other sequences.
		 * 
		 *         See also set_seqs() and set_seq1().
		 *         
		 */
		set_seq2(b): Promise<any>
		set_seq2$({ b }): Promise<any>

		/**
		 * Find longest matching block in a[alo:ahi] and b[blo:bhi].
		 * 
		 *         By default it will find the longest match in the entirety of a and b.
		 * 
		 *         If isjunk is not defined:
		 * 
		 *         Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where
		 *             alo <= i <= i+k <= ahi
		 *             blo <= j <= j+k <= bhi
		 *         and for all (i',j',k') meeting those conditions,
		 *             k >= k'
		 *             i <= i'
		 *             and if i == i', j <= j'
		 * 
		 *         In other words, of all maximal matching blocks, return one that
		 *         starts earliest in a, and of all those maximal matching blocks that
		 *         start earliest in a, return the one that starts earliest in b.
		 * 
		 *         >>> s = SequenceMatcher(None, " abcd", "abcd abcd")
		 *         >>> s.find_longest_match(0, 5, 0, 9)
		 *         Match(a=0, b=4, size=5)
		 * 
		 *         If isjunk is defined, first the longest matching block is
		 *         determined as above, but with the additional restriction that no
		 *         junk element appears in the block.  Then that block is extended as
		 *         far as possible by matching (only) junk elements on both sides.  So
		 *         the resulting block never matches on junk except as identical junk
		 *         happens to be adjacent to an "interesting" match.
		 * 
		 *         Here's the same example as before, but considering blanks to be
		 *         junk.  That prevents " abcd" from matching the " abcd" at the tail
		 *         end of the second sequence directly.  Instead only the "abcd" can
		 *         match, and matches the leftmost "abcd" in the second sequence:
		 * 
		 *         >>> s = SequenceMatcher(lambda x: x==" ", " abcd", "abcd abcd")
		 *         >>> s.find_longest_match(0, 5, 0, 9)
		 *         Match(a=1, b=0, size=4)
		 * 
		 *         If no blocks match, return (alo, blo, 0).
		 * 
		 *         >>> s = SequenceMatcher(None, "ab", "c")
		 *         >>> s.find_longest_match(0, 2, 0, 1)
		 *         Match(a=0, b=0, size=0)
		 *         
		 */
		find_longest_match(alo?, ahi?, blo?, bhi?): Promise<any>
		find_longest_match$({ alo, ahi, blo, bhi }: { alo?, ahi?, blo?, bhi?}): Promise<any>

		/**
		 * Return list of triples describing matching subsequences.
		 * 
		 *         Each triple is of the form (i, j, n), and means that
		 *         a[i:i+n] == b[j:j+n].  The triples are monotonically increasing in
		 *         i and in j.  New in Python 2.5, it's also guaranteed that if
		 *         (i, j, n) and (i', j', n') are adjacent triples in the list, and
		 *         the second is not the last triple in the list, then i+n != i' or
		 *         j+n != j'.  IOW, adjacent triples never describe adjacent equal
		 *         blocks.
		 * 
		 *         The last triple is a dummy, (len(a), len(b), 0), and is the only
		 *         triple with n==0.
		 * 
		 *         >>> s = SequenceMatcher(None, "abxcd", "abcd")
		 *         >>> list(s.get_matching_blocks())
		 *         [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]
		 *         
		 */
		get_matching_blocks(): Promise<any>
		get_matching_blocks$($: {}): Promise<any>

		/**
		 * Return list of 5-tuples describing how to turn a into b.
		 * 
		 *         Each tuple is of the form (tag, i1, i2, j1, j2).  The first tuple
		 *         has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the
		 *         tuple preceding it, and likewise for j1 == the previous j2.
		 * 
		 *         The tags are strings, with these meanings:
		 * 
		 *         'replace':  a[i1:i2] should be replaced by b[j1:j2]
		 *         'delete':   a[i1:i2] should be deleted.
		 *                     Note that j1==j2 in this case.
		 *         'insert':   b[j1:j2] should be inserted at a[i1:i1].
		 *                     Note that i1==i2 in this case.
		 *         'equal':    a[i1:i2] == b[j1:j2]
		 * 
		 *         >>> a = "qabxcd"
		 *         >>> b = "abycdf"
		 *         >>> s = SequenceMatcher(None, a, b)
		 *         >>> for tag, i1, i2, j1, j2 in s.get_opcodes():
		 *         ...    print(("%7s a[%d:%d] (%s) b[%d:%d] (%s)" %
		 *         ...           (tag, i1, i2, a[i1:i2], j1, j2, b[j1:j2])))
		 *          delete a[0:1] (q) b[0:0] ()
		 *           equal a[1:3] (ab) b[0:2] (ab)
		 *         replace a[3:4] (x) b[2:3] (y)
		 *           equal a[4:6] (cd) b[3:5] (cd)
		 *          insert a[6:6] () b[5:6] (f)
		 *         
		 */
		get_opcodes(): Promise<any>
		get_opcodes$($: {}): Promise<any>

		/**
		 *  Isolate change clusters by eliminating ranges with no changes.
		 * 
		 *         Return a generator of groups with up to n lines of context.
		 *         Each group is in the same format as returned by get_opcodes().
		 * 
		 *         >>> from pprint import pprint
		 *         >>> a = list(map(str, range(1,40)))
		 *         >>> b = a[:]
		 *         >>> b[8:8] = ['i']     # Make an insertion
		 *         >>> b[20] += 'x'       # Make a replacement
		 *         >>> b[23:28] = []      # Make a deletion
		 *         >>> b[30] += 'y'       # Make another replacement
		 *         >>> pprint(list(SequenceMatcher(None,a,b).get_grouped_opcodes()))
		 *         [[('equal', 5, 8, 5, 8), ('insert', 8, 8, 8, 9), ('equal', 8, 11, 9, 12)],
		 *          [('equal', 16, 19, 17, 20),
		 *           ('replace', 19, 20, 20, 21),
		 *           ('equal', 20, 22, 21, 23),
		 *           ('delete', 22, 27, 23, 23),
		 *           ('equal', 27, 30, 23, 26)],
		 *          [('equal', 31, 34, 27, 30),
		 *           ('replace', 34, 35, 30, 31),
		 *           ('equal', 35, 38, 31, 34)]]
		 *         
		 */
		get_grouped_opcodes(n?): Promise<any>
		get_grouped_opcodes$({ n }: { n?}): Promise<any>

		/**
		 * Return a measure of the sequences' similarity (float in [0,1]).
		 * 
		 *         Where T is the total number of elements in both sequences, and
		 *         M is the number of matches, this is 2.0*M / T.
		 *         Note that this is 1 if the sequences are identical, and 0 if
		 *         they have nothing in common.
		 * 
		 *         .ratio() is expensive to compute if you haven't already computed
		 *         .get_matching_blocks() or .get_opcodes(), in which case you may
		 *         want to try .quick_ratio() or .real_quick_ratio() first to get an
		 *         upper bound.
		 * 
		 *         >>> s = SequenceMatcher(None, "abcd", "bcde")
		 *         >>> s.ratio()
		 *         0.75
		 *         >>> s.quick_ratio()
		 *         0.75
		 *         >>> s.real_quick_ratio()
		 *         1.0
		 *         
		 */
		ratio(): Promise<any>
		ratio$($: {}): Promise<any>

		/**
		 * Return an upper bound on ratio() relatively quickly.
		 * 
		 *         This isn't defined beyond that it is an upper bound on .ratio(), and
		 *         is faster to compute.
		 *         
		 */
		quick_ratio(): Promise<any>
		quick_ratio$($: {}): Promise<any>

		/**
		 * Return an upper bound on ratio() very quickly.
		 * 
		 *         This isn't defined beyond that it is an upper bound on .ratio(), and
		 *         is faster to compute than either .ratio() or .quick_ratio().
		 *         
		 */
		real_quick_ratio(): Promise<any>
		real_quick_ratio$($: {}): Promise<any>
	}

	/**
	 * 
	 *     Differ is a class for comparing sequences of lines of text, and
	 *     producing human-readable differences or deltas.  Differ uses
	 *     SequenceMatcher both to compare sequences of lines, and to compare
	 *     sequences of characters within similar (near-matching) lines.
	 * 
	 *     Each line of a Differ delta begins with a two-letter code:
	 * 
	 *         '- '    line unique to sequence 1
	 *         '+ '    line unique to sequence 2
	 *         '  '    line common to both sequences
	 *         '? '    line not present in either input sequence
	 * 
	 *     Lines beginning with '? ' attempt to guide the eye to intraline
	 *     differences, and were not present in either input sequence.  These lines
	 *     can be confusing if the sequences contain tab characters.
	 * 
	 *     Note that Differ makes no claim to produce a *minimal* diff.  To the
	 *     contrary, minimal diffs are often counter-intuitive, because they synch
	 *     up anywhere possible, sometimes accidental matches 100 pages apart.
	 *     Restricting synch points to contiguous matches preserves some notion of
	 *     locality, at the occasional cost of producing a longer diff.
	 * 
	 *     Example: Comparing two texts.
	 * 
	 *     First we set up the texts, sequences of individual single-line strings
	 *     ending with newlines (such sequences can also be obtained from the
	 *     `readlines()` method of file-like objects):
	 * 
	 *     >>> text1 = '''  1. Beautiful is better than ugly.
	 *     ...   2. Explicit is better than implicit.
	 *     ...   3. Simple is better than complex.
	 *     ...   4. Complex is better than complicated.
	 *     ... '''.splitlines(keepends=True)
	 *     >>> len(text1)
	 *     4
	 *     >>> text1[0][-1]
	 *     '\n'
	 *     >>> text2 = '''  1. Beautiful is better than ugly.
	 *     ...   3.   Simple is better than complex.
	 *     ...   4. Complicated is better than complex.
	 *     ...   5. Flat is better than nested.
	 *     ... '''.splitlines(keepends=True)
	 * 
	 *     Next we instantiate a Differ object:
	 * 
	 *     >>> d = Differ()
	 * 
	 *     Note that when instantiating a Differ object we may pass functions to
	 *     filter out line and character 'junk'.  See Differ.__init__ for details.
	 * 
	 *     Finally, we compare the two:
	 * 
	 *     >>> result = list(d.compare(text1, text2))
	 * 
	 *     'result' is a list of strings, so let's pretty-print it:
	 * 
	 *     >>> from pprint import pprint as _pprint
	 *     >>> _pprint(result)
	 *     ['    1. Beautiful is better than ugly.\n',
	 *      '-   2. Explicit is better than implicit.\n',
	 *      '-   3. Simple is better than complex.\n',
	 *      '+   3.   Simple is better than complex.\n',
	 *      '?     ++\n',
	 *      '-   4. Complex is better than complicated.\n',
	 *      '?            ^                     ---- ^\n',
	 *      '+   4. Complicated is better than complex.\n',
	 *      '?           ++++ ^                      ^\n',
	 *      '+   5. Flat is better than nested.\n']
	 * 
	 *     As a single multi-line string it looks like this:
	 * 
	 *     >>> print(''.join(result), end="")
	 *         1. Beautiful is better than ugly.
	 *     -   2. Explicit is better than implicit.
	 *     -   3. Simple is better than complex.
	 *     +   3.   Simple is better than complex.
	 *     ?     ++
	 *     -   4. Complex is better than complicated.
	 *     ?            ^                     ---- ^
	 *     +   4. Complicated is better than complex.
	 *     ?           ++++ ^                      ^
	 *     +   5. Flat is better than nested.
	 * 
	 *     Methods:
	 * 
	 *     __init__(linejunk=None, charjunk=None)
	 *         Construct a text differencer, with optional filters.
	 * 
	 *     compare(a, b)
	 *         Compare two sequences of lines; generate the resulting delta.
	 *     
	 */

	/**
	 * 
	 *         Construct a text differencer, with optional filters.
	 * 
	 *         The two optional keyword parameters are for filter functions:
	 * 
	 *         - `linejunk`: A function that should accept a single string argument,
	 *           and return true iff the string is junk. The module-level function
	 *           `IS_LINE_JUNK` may be used to filter out lines without visible
	 *           characters, except for at most one splat ('#').  It is recommended
	 *           to leave linejunk None; the underlying SequenceMatcher class has
	 *           an adaptive notion of "noise" lines that's better than any static
	 *           definition the author has ever been able to craft.
	 * 
	 *         - `charjunk`: A function that should accept a string of length 1. The
	 *           module-level function `IS_CHARACTER_JUNK` may be used to filter out
	 *           whitespace characters (a blank or tab; **note**: bad idea to include
	 *           newline in this!).  Use of IS_CHARACTER_JUNK is recommended.
	 *         
	 */
	function Differ(linejunk?, charjunk?): Promise<IDiffer>
	function Differ$({ linejunk, charjunk }: { linejunk?, charjunk?}): Promise<IDiffer>
	interface IDiffer {

		/**
		 * 
		 *         Compare two sequences of lines; generate the resulting delta.
		 * 
		 *         Each sequence must contain individual single-line strings ending with
		 *         newlines. Such sequences can be obtained from the `readlines()` method
		 *         of file-like objects.  The delta generated also consists of newline-
		 *         terminated strings, ready to be printed as-is via the writeline()
		 *         method of a file-like object.
		 * 
		 *         Example:
		 * 
		 *         >>> print(''.join(Differ().compare('one\ntwo\nthree\n'.splitlines(True),
		 *         ...                                'ore\ntree\nemu\n'.splitlines(True))),
		 *         ...       end="")
		 *         - one
		 *         ?  ^
		 *         + ore
		 *         ?  ^
		 *         - two
		 *         - three
		 *         ?  -
		 *         + tree
		 *         + emu
		 *         
		 */
		compare(a, b): Promise<any>
		compare$({ a, b }): Promise<any>
	}

	/**
	 * For producing HTML side by side comparison with change highlights.
	 * 
	 *     This class can be used to create an HTML table (or a complete HTML file
	 *     containing the table) showing a side by side, line by line comparison
	 *     of text with inter-line and intra-line change highlights.  The table can
	 *     be generated in either full or contextual difference mode.
	 * 
	 *     The following methods are provided for HTML generation:
	 * 
	 *     make_table -- generates HTML for a single side by side table
	 *     make_file -- generates complete HTML file with a single side by side table
	 * 
	 *     See tools/scripts/diff.py for an example usage of this class.
	 *     
	 */

	/**
	 * HtmlDiff instance initializer
	 * 
	 *         Arguments:
	 *         tabsize -- tab stop spacing, defaults to 8.
	 *         wrapcolumn -- column number where lines are broken and wrapped,
	 *             defaults to None where lines are not wrapped.
	 *         linejunk,charjunk -- keyword arguments passed into ndiff() (used by
	 *             HtmlDiff() to generate the side by side HTML differences).  See
	 *             ndiff() documentation for argument default values and descriptions.
	 *         
	 */
	function HtmlDiff(tabsize?, wrapcolumn?, linejunk?, charjunk?): Promise<IHtmlDiff>
	function HtmlDiff$({ tabsize, wrapcolumn, linejunk, charjunk }: { tabsize?, wrapcolumn?, linejunk?, charjunk?}): Promise<IHtmlDiff>
	interface IHtmlDiff {

		/**
		 * Returns HTML file of side by side comparison with change highlights
		 * 
		 *         Arguments:
		 *         fromlines -- list of "from" lines
		 *         tolines -- list of "to" lines
		 *         fromdesc -- "from" file column header string
		 *         todesc -- "to" file column header string
		 *         context -- set to True for contextual differences (defaults to False
		 *             which shows full differences).
		 *         numlines -- number of context lines.  When context is set True,
		 *             controls number of lines displayed before and after the change.
		 *             When context is False, controls the number of lines to place
		 *             the "next" link anchors before the next change (so click of
		 *             "next" link jumps to just before the change).
		 *         charset -- charset of the HTML document
		 *         
		 */
		make_file(fromlines, tolines, fromdesc?, todesc?, context?: boolean, numlines?): Promise<any>
		make_file$({ fromlines, tolines, fromdesc, todesc, context, numlines }: { fromlines, tolines, fromdesc?, todesc?, context?, numlines?}): Promise<any>

		/**
		 * Returns HTML table of side by side comparison with change highlights
		 * 
		 *         Arguments:
		 *         fromlines -- list of "from" lines
		 *         tolines -- list of "to" lines
		 *         fromdesc -- "from" file column header string
		 *         todesc -- "to" file column header string
		 *         context -- set to True for contextual differences (defaults to False
		 *             which shows full differences).
		 *         numlines -- number of context lines.  When context is set True,
		 *             controls number of lines displayed before and after the change.
		 *             When context is False, controls the number of lines to place
		 *             the "next" link anchors before the next change (so click of
		 *             "next" link jumps to just before the change).
		 *         
		 */
		make_table(fromlines, tolines, fromdesc?, todesc?, context?: boolean, numlines?): Promise<any>
		make_table$({ fromlines, tolines, fromdesc, todesc, context, numlines }: { fromlines, tolines, fromdesc?, todesc?, context?, numlines?}): Promise<any>
	}
	let Match: Promise<any>
}
declare module dis {
	var _

	/**
	 * Disassemble classes, methods, functions, and other compiled objects.
	 * 
	 *     With no argument, disassemble the last traceback.
	 * 
	 *     Compiled objects currently include generator objects, async generator
	 *     objects, and coroutine objects, all of which store their code object
	 *     in a special attribute.
	 *     
	 */
	function dis(x?): Promise<any>
	function dis$({ x }: { x?}): Promise<any>

	/**
	 * Disassemble a traceback (default: last traceback).
	 */
	function distb(tb?): Promise<any>
	function distb$({ tb }: { tb?}): Promise<any>

	/**
	 * Return pretty representation of code flags.
	 */
	function pretty_flags(flags): Promise<any>
	function pretty_flags$({ flags }): Promise<any>

	/**
	 * Formatted details of methods, functions, or code.
	 */
	function code_info(x): Promise<any>
	function code_info$({ x }): Promise<any>

	/**
	 * Print details of methods, functions, or code to *file*.
	 * 
	 *     If *file* is not provided, the output is printed on stdout.
	 *     
	 */
	function show_code(co): Promise<any>
	function show_code$({ co }): Promise<any>

	/**
	 * Iterator for the opcodes in methods, functions or code
	 * 
	 *     Generates a series of Instruction named tuples giving the details of
	 *     each operations in the supplied code.
	 * 
	 *     If *first_line* is not None, it indicates the line number that should
	 *     be reported for the first source line in the disassembled code.
	 *     Otherwise, the source line information (if any) is taken directly from
	 *     the disassembled code object.
	 *     
	 */
	function get_instructions(x): Promise<any>
	function get_instructions$({ x }): Promise<any>
	function parse_varint(iterator): Promise<any>
	function parse_varint$({ iterator }): Promise<any>
	function parse_exception_table(code): Promise<any>
	function parse_exception_table$({ code }): Promise<any>

	/**
	 * Disassemble a code object.
	 */
	function disassemble(co, lasti?): Promise<any>
	function disassemble$({ co, lasti }: { co, lasti?}): Promise<any>

	/**
	 * Detect all offsets in a byte code which are jump targets.
	 * 
	 *     Return the list of offsets.
	 * 
	 *     
	 */
	function findlabels(code): Promise<any>
	function findlabels$({ code }): Promise<any>

	/**
	 * Find the offsets in a byte code which are start of lines in the source.
	 * 
	 *     Generate pairs (offset, lineno)
	 *     
	 */
	function findlinestarts(code): Promise<any>
	function findlinestarts$({ code }): Promise<any>

	/**
	 * Details for a bytecode operation
	 * 
	 *        Defined fields:
	 *          opname - human readable name for operation
	 *          opcode - numeric code for operation
	 *          arg - numeric argument to operation (if any), otherwise None
	 *          argval - resolved arg value (if known), otherwise same as arg
	 *          argrepr - human readable description of operation argument
	 *          offset - start index of operation within bytecode sequence
	 *          starts_line - line started by this opcode (if any), otherwise None
	 *          is_jump_target - True if other code jumps to here, otherwise False
	 *     
	 */
	interface IInstruction {
	}

	/**
	 * The bytecode operations of a piece of code
	 * 
	 *     Instantiate this with a function, method, other compiled object, string of
	 *     code, or a code object (as returned by compile()).
	 * 
	 *     Iterating over this yields the bytecode operations as Instruction instances.
	 *     
	 */
	function Bytecode(x): Promise<IBytecode>
	function Bytecode$({ x }): Promise<IBytecode>
	interface IBytecode {

		/**
		 *  Construct a Bytecode from the given traceback 
		 */
		from_traceback(tb): Promise<any>
		from_traceback$({ tb }): Promise<any>

		/**
		 * Return formatted information about the code object.
		 */
		info(): Promise<any>
		info$($: {}): Promise<any>

		/**
		 * Return a formatted view of the bytecode operations.
		 */
		dis(): Promise<any>
		dis$($: {}): Promise<any>
	}
	let FORMAT_VALUE: Promise<any>
	let FORMAT_VALUE_CONVERTERS: Promise<any>
	let MAKE_FUNCTION: Promise<any>
	let MAKE_FUNCTION_FLAGS: Promise<any>
	let COMPILER_FLAG_NAMES: Promise<any>
	let disco: Promise<any>
}
declare module distutils {
	var _
	module _msvccompiler {
		var _

		/**
		 * Concrete class that implements an interface to Microsoft Visual C++,
		 *        as defined by the CCompiler abstract class.
		 */
		function MSVCCompiler(verbose?, dry_run?, force?): Promise<IMSVCCompiler>
		function MSVCCompiler$({ verbose, dry_run, force }: { verbose?, dry_run?, force?}): Promise<IMSVCCompiler>
		interface IMSVCCompiler {
			initialize(plat_name?): Promise<any>
			initialize$({ plat_name }: { plat_name?}): Promise<any>
			object_filenames(source_filenames, strip_dir?, output_dir?): Promise<any>
			object_filenames$({ source_filenames, strip_dir, output_dir }: { source_filenames, strip_dir?, output_dir?}): Promise<any>
			compile(sources, output_dir?, macros?, include_dirs?, debug?, extra_preargs?, extra_postargs?, depends?): Promise<any>
			compile$({ sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends }: { sources, output_dir?, macros?, include_dirs?, debug?, extra_preargs?, extra_postargs?, depends?}): Promise<any>
			create_static_lib(objects, output_libname, output_dir?, debug?, target_lang?): Promise<any>
			create_static_lib$({ objects, output_libname, output_dir, debug, target_lang }: { objects, output_libname, output_dir?, debug?, target_lang?}): Promise<any>
			link(target_desc, objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?): Promise<any>
			link$({ target_desc, objects, output_filename, output_dir, libraries, library_dirs, runtime_library_dirs, export_symbols, debug, extra_preargs, extra_postargs, build_temp, target_lang }: { target_desc, objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?}): Promise<any>
			spawn(cmd): Promise<any>
			spawn$({ cmd }): Promise<any>
			library_dir_option(dir): Promise<any>
			library_dir_option$({ dir }): Promise<any>
			runtime_library_dir_option(dir): Promise<any>
			runtime_library_dir_option$({ dir }): Promise<any>
			library_option(lib): Promise<any>
			library_option$({ lib }): Promise<any>
			find_library_file(dirs, lib, debug?): Promise<any>
			find_library_file$({ dirs, lib, debug }: { dirs, lib, debug?}): Promise<any>
			compiler_type
			executables
			src_extensions
			res_extension
			obj_extension
			static_lib_extension
			shared_lib_extension
			static_lib_format
			shared_lib_format
			exe_extension
		}
		let PLAT_SPEC_TO_RUNTIME: Promise<any>
		let PLAT_TO_VCVARS: Promise<any>
	}
	module archive_util {
		var _

		/**
		 * Create a (possibly compressed) tar file from all the files under
		 *     'base_dir'.
		 * 
		 *     'compress' must be "gzip" (the default), "bzip2", "xz", "compress", or
		 *     None.  ("compress" will be deprecated in Python 3.2)
		 * 
		 *     'owner' and 'group' can be used to define an owner and a group for the
		 *     archive that is being built. If not provided, the current owner and group
		 *     will be used.
		 * 
		 *     The output tar file will be named 'base_dir' +  ".tar", possibly plus
		 *     the appropriate compression extension (".gz", ".bz2", ".xz" or ".Z").
		 * 
		 *     Returns the output filename.
		 *     
		 */
		function make_tarball(base_name, base_dir, compress?, verbose?, dry_run?, owner?, group?): Promise<any>
		function make_tarball$({ base_name, base_dir, compress, verbose, dry_run, owner, group }: { base_name, base_dir, compress?, verbose?, dry_run?, owner?, group?}): Promise<any>

		/**
		 * Create a zip file from all the files under 'base_dir'.
		 * 
		 *     The output zip file will be named 'base_name' + ".zip".  Uses either the
		 *     "zipfile" Python module (if available) or the InfoZIP "zip" utility
		 *     (if installed and found on the default search path).  If neither tool is
		 *     available, raises DistutilsExecError.  Returns the name of the output zip
		 *     file.
		 *     
		 */
		function make_zipfile(base_name, base_dir, verbose?, dry_run?): Promise<any>
		function make_zipfile$({ base_name, base_dir, verbose, dry_run }: { base_name, base_dir, verbose?, dry_run?}): Promise<any>

		/**
		 * Returns the first format from the 'format' list that is unknown.
		 * 
		 *     If all formats are known, returns None
		 *     
		 */
		function check_archive_formats(formats): Promise<any>
		function check_archive_formats$({ formats }): Promise<any>

		/**
		 * Create an archive file (eg. zip or tar).
		 * 
		 *     'base_name' is the name of the file to create, minus any format-specific
		 *     extension; 'format' is the archive format: one of "zip", "tar", "gztar",
		 *     "bztar", "xztar", or "ztar".
		 * 
		 *     'root_dir' is a directory that will be the root directory of the
		 *     archive; ie. we typically chdir into 'root_dir' before creating the
		 *     archive.  'base_dir' is the directory where we start archiving from;
		 *     ie. 'base_dir' will be the common prefix of all files and
		 *     directories in the archive.  'root_dir' and 'base_dir' both default
		 *     to the current directory.  Returns the name of the archive file.
		 * 
		 *     'owner' and 'group' are used when creating a tar archive. By default,
		 *     uses the current owner and group.
		 *     
		 */
		function make_archive(base_name, format, root_dir?, base_dir?, verbose?, dry_run?, owner?, group?): Promise<any>
		function make_archive$({ base_name, format, root_dir, base_dir, verbose, dry_run, owner, group }: { base_name, format, root_dir?, base_dir?, verbose?, dry_run?, owner?, group?}): Promise<any>
		let ARCHIVE_FORMATS: Promise<any>
	}
	module bcppcompiler {
		var _

		/**
		 * Concrete class that implements an interface to the Borland C/C++
		 *     compiler, as defined by the CCompiler abstract class.
		 *     
		 */
		function BCPPCompiler(verbose?, dry_run?, force?): Promise<IBCPPCompiler>
		function BCPPCompiler$({ verbose, dry_run, force }: { verbose?, dry_run?, force?}): Promise<IBCPPCompiler>
		interface IBCPPCompiler {
			compile(sources, output_dir?, macros?, include_dirs?, debug?, extra_preargs?, extra_postargs?, depends?): Promise<any>
			compile$({ sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends }: { sources, output_dir?, macros?, include_dirs?, debug?, extra_preargs?, extra_postargs?, depends?}): Promise<any>
			create_static_lib(objects, output_libname, output_dir?, debug?, target_lang?): Promise<any>
			create_static_lib$({ objects, output_libname, output_dir, debug, target_lang }: { objects, output_libname, output_dir?, debug?, target_lang?}): Promise<any>
			link(target_desc, objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?): Promise<any>
			link$({ target_desc, objects, output_filename, output_dir, libraries, library_dirs, runtime_library_dirs, export_symbols, debug, extra_preargs, extra_postargs, build_temp, target_lang }: { target_desc, objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?}): Promise<any>
			find_library_file(dirs, lib, debug?): Promise<any>
			find_library_file$({ dirs, lib, debug }: { dirs, lib, debug?}): Promise<any>
			object_filenames(source_filenames, strip_dir?, output_dir?): Promise<any>
			object_filenames$({ source_filenames, strip_dir, output_dir }: { source_filenames, strip_dir?, output_dir?}): Promise<any>
			preprocess(source, output_file?, macros?, include_dirs?, extra_preargs?, extra_postargs?): Promise<any>
			preprocess$({ source, output_file, macros, include_dirs, extra_preargs, extra_postargs }: { source, output_file?, macros?, include_dirs?, extra_preargs?, extra_postargs?}): Promise<any>
			compiler_type
			executables
			src_extensions
			obj_extension
			static_lib_extension
			shared_lib_extension
			static_lib_format
			shared_lib_format
			exe_extension
		}
	}
	module ccompiler {
		var _

		/**
		 * Determine the default compiler to use for the given platform.
		 * 
		 *        osname should be one of the standard Python OS names (i.e. the
		 *        ones returned by os.name) and platform the common value
		 *        returned by sys.platform for the platform in question.
		 * 
		 *        The default values are os.name and sys.platform in case the
		 *        parameters are not given.
		 *     
		 */
		function get_default_compiler(osname?, platform?): Promise<any>
		function get_default_compiler$({ osname, platform }: { osname?, platform?}): Promise<any>

		/**
		 * Print list of available compilers (used by the "--help-compiler"
		 *     options to "build", "build_ext", "build_clib").
		 *     
		 */
		function show_compilers(): Promise<any>
		function show_compilers$($: {}): Promise<any>

		/**
		 * Generate an instance of some CCompiler subclass for the supplied
		 *     platform/compiler combination.  'plat' defaults to 'os.name'
		 *     (eg. 'posix', 'nt'), and 'compiler' defaults to the default compiler
		 *     for that platform.  Currently only 'posix' and 'nt' are supported, and
		 *     the default compilers are "traditional Unix interface" (UnixCCompiler
		 *     class) and Visual C++ (MSVCCompiler class).  Note that it's perfectly
		 *     possible to ask for a Unix compiler object under Windows, and a
		 *     Microsoft compiler object under Unix -- if you supply a value for
		 *     'compiler', 'plat' is ignored.
		 *     
		 */
		function new_compiler(plat?, compiler?, verbose?, dry_run?, force?): Promise<any>
		function new_compiler$({ plat, compiler, verbose, dry_run, force }: { plat?, compiler?, verbose?, dry_run?, force?}): Promise<any>

		/**
		 * Generate C pre-processor options (-D, -U, -I) as used by at least
		 *     two types of compilers: the typical Unix compiler and Visual C++.
		 *     'macros' is the usual thing, a list of 1- or 2-tuples, where (name,)
		 *     means undefine (-U) macro 'name', and (name,value) means define (-D)
		 *     macro 'name' to 'value'.  'include_dirs' is just a list of directory
		 *     names to be added to the header file search path (-I).  Returns a list
		 *     of command-line options suitable for either Unix compilers or Visual
		 *     C++.
		 *     
		 */
		function gen_preprocess_options(macros, include_dirs): Promise<any>
		function gen_preprocess_options$({ macros, include_dirs }): Promise<any>

		/**
		 * Generate linker options for searching library directories and
		 *     linking with specific libraries.  'libraries' and 'library_dirs' are,
		 *     respectively, lists of library names (not filenames!) and search
		 *     directories.  Returns a list of command-line options suitable for use
		 *     with some compiler (depending on the two format strings passed in).
		 *     
		 */
		function gen_lib_options(compiler, library_dirs, runtime_library_dirs, libraries): Promise<any>
		function gen_lib_options$({ compiler, library_dirs, runtime_library_dirs, libraries }): Promise<any>

		/**
		 * Abstract base class to define the interface that must be implemented
		 *     by real compiler classes.  Also has some utility methods used by
		 *     several compiler classes.
		 * 
		 *     The basic idea behind a compiler abstraction class is that each
		 *     instance can be used for all the compile/link steps in building a
		 *     single project.  Thus, attributes common to all of those compile and
		 *     link steps -- include directories, macros to define, libraries to link
		 *     against, etc. -- are attributes of the compiler instance.  To allow for
		 *     variability in how individual files are treated, most of those
		 *     attributes may be varied on a per-compilation or per-link basis.
		 *     
		 */
		function CCompiler(verbose?, dry_run?, force?): Promise<ICCompiler>
		function CCompiler$({ verbose, dry_run, force }: { verbose?, dry_run?, force?}): Promise<ICCompiler>
		interface ICCompiler {

			/**
			 * Define the executables (and options for them) that will be run
			 *         to perform the various stages of compilation.  The exact set of
			 *         executables that may be specified here depends on the compiler
			 *         class (via the 'executables' class attribute), but most will have:
			 *           compiler      the C/C++ compiler
			 *           linker_so     linker used to create shared objects and libraries
			 *           linker_exe    linker used to create binary executables
			 *           archiver      static library creator
			 * 
			 *         On platforms with a command-line (Unix, DOS/Windows), each of these
			 *         is a string that will be split into executable name and (optional)
			 *         list of arguments.  (Splitting the string is done similarly to how
			 *         Unix shells operate: words are delimited by spaces, but quotes and
			 *         backslashes can override this.  See
			 *         'distutils.util.split_quoted()'.)
			 *         
			 */
			set_executables(): Promise<any>
			set_executables$($: {}): Promise<any>
			set_executable(key, value): Promise<any>
			set_executable$({ key, value }): Promise<any>

			/**
			 * Define a preprocessor macro for all compilations driven by this
			 *         compiler object.  The optional parameter 'value' should be a
			 *         string; if it is not supplied, then the macro will be defined
			 *         without an explicit value and the exact outcome depends on the
			 *         compiler used (XXX true? does ANSI say anything about this?)
			 *         
			 */
			define_macro(name, value?): Promise<any>
			define_macro$({ name, value }: { name, value?}): Promise<any>

			/**
			 * Undefine a preprocessor macro for all compilations driven by
			 *         this compiler object.  If the same macro is defined by
			 *         'define_macro()' and undefined by 'undefine_macro()' the last call
			 *         takes precedence (including multiple redefinitions or
			 *         undefinitions).  If the macro is redefined/undefined on a
			 *         per-compilation basis (ie. in the call to 'compile()'), then that
			 *         takes precedence.
			 *         
			 */
			undefine_macro(name): Promise<any>
			undefine_macro$({ name }): Promise<any>

			/**
			 * Add 'dir' to the list of directories that will be searched for
			 *         header files.  The compiler is instructed to search directories in
			 *         the order in which they are supplied by successive calls to
			 *         'add_include_dir()'.
			 *         
			 */
			add_include_dir(dir): Promise<any>
			add_include_dir$({ dir }): Promise<any>

			/**
			 * Set the list of directories that will be searched to 'dirs' (a
			 *         list of strings).  Overrides any preceding calls to
			 *         'add_include_dir()'; subsequence calls to 'add_include_dir()' add
			 *         to the list passed to 'set_include_dirs()'.  This does not affect
			 *         any list of standard include directories that the compiler may
			 *         search by default.
			 *         
			 */
			set_include_dirs(dirs): Promise<any>
			set_include_dirs$({ dirs }): Promise<any>

			/**
			 * Add 'libname' to the list of libraries that will be included in
			 *         all links driven by this compiler object.  Note that 'libname'
			 *         should *not* be the name of a file containing a library, but the
			 *         name of the library itself: the actual filename will be inferred by
			 *         the linker, the compiler, or the compiler class (depending on the
			 *         platform).
			 * 
			 *         The linker will be instructed to link against libraries in the
			 *         order they were supplied to 'add_library()' and/or
			 *         'set_libraries()'.  It is perfectly valid to duplicate library
			 *         names; the linker will be instructed to link against libraries as
			 *         many times as they are mentioned.
			 *         
			 */
			add_library(libname): Promise<any>
			add_library$({ libname }): Promise<any>

			/**
			 * Set the list of libraries to be included in all links driven by
			 *         this compiler object to 'libnames' (a list of strings).  This does
			 *         not affect any standard system libraries that the linker may
			 *         include by default.
			 *         
			 */
			set_libraries(libnames): Promise<any>
			set_libraries$({ libnames }): Promise<any>

			/**
			 * Add 'dir' to the list of directories that will be searched for
			 *         libraries specified to 'add_library()' and 'set_libraries()'.  The
			 *         linker will be instructed to search for libraries in the order they
			 *         are supplied to 'add_library_dir()' and/or 'set_library_dirs()'.
			 *         
			 */
			add_library_dir(dir): Promise<any>
			add_library_dir$({ dir }): Promise<any>

			/**
			 * Set the list of library search directories to 'dirs' (a list of
			 *         strings).  This does not affect any standard library search path
			 *         that the linker may search by default.
			 *         
			 */
			set_library_dirs(dirs): Promise<any>
			set_library_dirs$({ dirs }): Promise<any>

			/**
			 * Add 'dir' to the list of directories that will be searched for
			 *         shared libraries at runtime.
			 *         
			 */
			add_runtime_library_dir(dir): Promise<any>
			add_runtime_library_dir$({ dir }): Promise<any>

			/**
			 * Set the list of directories to search for shared libraries at
			 *         runtime to 'dirs' (a list of strings).  This does not affect any
			 *         standard search path that the runtime linker may search by
			 *         default.
			 *         
			 */
			set_runtime_library_dirs(dirs): Promise<any>
			set_runtime_library_dirs$({ dirs }): Promise<any>

			/**
			 * Add 'object' to the list of object files (or analogues, such as
			 *         explicitly named library files or the output of "resource
			 *         compilers") to be included in every link driven by this compiler
			 *         object.
			 *         
			 */
			add_link_object(object): Promise<any>
			add_link_object$({ object }): Promise<any>

			/**
			 * Set the list of object files (or analogues) to be included in
			 *         every link to 'objects'.  This does not affect any standard object
			 *         files that the linker may include by default (such as system
			 *         libraries).
			 *         
			 */
			set_link_objects(objects): Promise<any>
			set_link_objects$({ objects }): Promise<any>

			/**
			 * Detect the language of a given file, or list of files. Uses
			 *         language_map, and language_order to do the job.
			 *         
			 */
			detect_language(sources): Promise<any>
			detect_language$({ sources }): Promise<any>

			/**
			 * Preprocess a single C/C++ source file, named in 'source'.
			 *         Output will be written to file named 'output_file', or stdout if
			 *         'output_file' not supplied.  'macros' is a list of macro
			 *         definitions as for 'compile()', which will augment the macros set
			 *         with 'define_macro()' and 'undefine_macro()'.  'include_dirs' is a
			 *         list of directory names that will be added to the default list.
			 * 
			 *         Raises PreprocessError on failure.
			 *         
			 */
			preprocess(source, output_file?, macros?, include_dirs?, extra_preargs?, extra_postargs?): Promise<any>
			preprocess$({ source, output_file, macros, include_dirs, extra_preargs, extra_postargs }: { source, output_file?, macros?, include_dirs?, extra_preargs?, extra_postargs?}): Promise<any>

			/**
			 * Compile one or more source files.
			 * 
			 *         'sources' must be a list of filenames, most likely C/C++
			 *         files, but in reality anything that can be handled by a
			 *         particular compiler and compiler class (eg. MSVCCompiler can
			 *         handle resource files in 'sources').  Return a list of object
			 *         filenames, one per source filename in 'sources'.  Depending on
			 *         the implementation, not all source files will necessarily be
			 *         compiled, but all corresponding object filenames will be
			 *         returned.
			 * 
			 *         If 'output_dir' is given, object files will be put under it, while
			 *         retaining their original path component.  That is, "foo/bar.c"
			 *         normally compiles to "foo/bar.o" (for a Unix implementation); if
			 *         'output_dir' is "build", then it would compile to
			 *         "build/foo/bar.o".
			 * 
			 *         'macros', if given, must be a list of macro definitions.  A macro
			 *         definition is either a (name, value) 2-tuple or a (name,) 1-tuple.
			 *         The former defines a macro; if the value is None, the macro is
			 *         defined without an explicit value.  The 1-tuple case undefines a
			 *         macro.  Later definitions/redefinitions/ undefinitions take
			 *         precedence.
			 * 
			 *         'include_dirs', if given, must be a list of strings, the
			 *         directories to add to the default include file search path for this
			 *         compilation only.
			 * 
			 *         'debug' is a boolean; if true, the compiler will be instructed to
			 *         output debug symbols in (or alongside) the object file(s).
			 * 
			 *         'extra_preargs' and 'extra_postargs' are implementation- dependent.
			 *         On platforms that have the notion of a command-line (e.g. Unix,
			 *         DOS/Windows), they are most likely lists of strings: extra
			 *         command-line arguments to prepend/append to the compiler command
			 *         line.  On other platforms, consult the implementation class
			 *         documentation.  In any event, they are intended as an escape hatch
			 *         for those occasions when the abstract compiler framework doesn't
			 *         cut the mustard.
			 * 
			 *         'depends', if given, is a list of filenames that all targets
			 *         depend on.  If a source file is older than any file in
			 *         depends, then the source file will be recompiled.  This
			 *         supports dependency tracking, but only at a coarse
			 *         granularity.
			 * 
			 *         Raises CompileError on failure.
			 *         
			 */
			compile(sources, output_dir?, macros?, include_dirs?, debug?, extra_preargs?, extra_postargs?, depends?): Promise<any>
			compile$({ sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends }: { sources, output_dir?, macros?, include_dirs?, debug?, extra_preargs?, extra_postargs?, depends?}): Promise<any>

			/**
			 * Link a bunch of stuff together to create a static library file.
			 *         The "bunch of stuff" consists of the list of object files supplied
			 *         as 'objects', the extra object files supplied to
			 *         'add_link_object()' and/or 'set_link_objects()', the libraries
			 *         supplied to 'add_library()' and/or 'set_libraries()', and the
			 *         libraries supplied as 'libraries' (if any).
			 * 
			 *         'output_libname' should be a library name, not a filename; the
			 *         filename will be inferred from the library name.  'output_dir' is
			 *         the directory where the library file will be put.
			 * 
			 *         'debug' is a boolean; if true, debugging information will be
			 *         included in the library (note that on most platforms, it is the
			 *         compile step where this matters: the 'debug' flag is included here
			 *         just for consistency).
			 * 
			 *         'target_lang' is the target language for which the given objects
			 *         are being compiled. This allows specific linkage time treatment of
			 *         certain languages.
			 * 
			 *         Raises LibError on failure.
			 *         
			 */
			create_static_lib(objects, output_libname, output_dir?, debug?, target_lang?): Promise<any>
			create_static_lib$({ objects, output_libname, output_dir, debug, target_lang }: { objects, output_libname, output_dir?, debug?, target_lang?}): Promise<any>

			/**
			 * Link a bunch of stuff together to create an executable or
			 *         shared library file.
			 * 
			 *         The "bunch of stuff" consists of the list of object files supplied
			 *         as 'objects'.  'output_filename' should be a filename.  If
			 *         'output_dir' is supplied, 'output_filename' is relative to it
			 *         (i.e. 'output_filename' can provide directory components if
			 *         needed).
			 * 
			 *         'libraries' is a list of libraries to link against.  These are
			 *         library names, not filenames, since they're translated into
			 *         filenames in a platform-specific way (eg. "foo" becomes "libfoo.a"
			 *         on Unix and "foo.lib" on DOS/Windows).  However, they can include a
			 *         directory component, which means the linker will look in that
			 *         specific directory rather than searching all the normal locations.
			 * 
			 *         'library_dirs', if supplied, should be a list of directories to
			 *         search for libraries that were specified as bare library names
			 *         (ie. no directory component).  These are on top of the system
			 *         default and those supplied to 'add_library_dir()' and/or
			 *         'set_library_dirs()'.  'runtime_library_dirs' is a list of
			 *         directories that will be embedded into the shared library and used
			 *         to search for other shared libraries that *it* depends on at
			 *         run-time.  (This may only be relevant on Unix.)
			 * 
			 *         'export_symbols' is a list of symbols that the shared library will
			 *         export.  (This appears to be relevant only on Windows.)
			 * 
			 *         'debug' is as for 'compile()' and 'create_static_lib()', with the
			 *         slight distinction that it actually matters on most platforms (as
			 *         opposed to 'create_static_lib()', which includes a 'debug' flag
			 *         mostly for form's sake).
			 * 
			 *         'extra_preargs' and 'extra_postargs' are as for 'compile()' (except
			 *         of course that they supply command-line arguments for the
			 *         particular linker being used).
			 * 
			 *         'target_lang' is the target language for which the given objects
			 *         are being compiled. This allows specific linkage time treatment of
			 *         certain languages.
			 * 
			 *         Raises LinkError on failure.
			 *         
			 */
			link(target_desc, objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?): Promise<any>
			link$({ target_desc, objects, output_filename, output_dir, libraries, library_dirs, runtime_library_dirs, export_symbols, debug, extra_preargs, extra_postargs, build_temp, target_lang }: { target_desc, objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?}): Promise<any>
			link_shared_lib(objects, output_libname, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?): Promise<any>
			link_shared_lib$({ objects, output_libname, output_dir, libraries, library_dirs, runtime_library_dirs, export_symbols, debug, extra_preargs, extra_postargs, build_temp, target_lang }: { objects, output_libname, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?}): Promise<any>
			link_shared_object(objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?): Promise<any>
			link_shared_object$({ objects, output_filename, output_dir, libraries, library_dirs, runtime_library_dirs, export_symbols, debug, extra_preargs, extra_postargs, build_temp, target_lang }: { objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?}): Promise<any>
			link_executable(objects, output_progname, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, debug?, extra_preargs?, extra_postargs?, target_lang?): Promise<any>
			link_executable$({ objects, output_progname, output_dir, libraries, library_dirs, runtime_library_dirs, debug, extra_preargs, extra_postargs, target_lang }: { objects, output_progname, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, debug?, extra_preargs?, extra_postargs?, target_lang?}): Promise<any>

			/**
			 * Return the compiler option to add 'dir' to the list of
			 *         directories searched for libraries.
			 *         
			 */
			library_dir_option(dir): Promise<any>
			library_dir_option$({ dir }): Promise<any>

			/**
			 * Return the compiler option to add 'dir' to the list of
			 *         directories searched for runtime libraries.
			 *         
			 */
			runtime_library_dir_option(dir): Promise<any>
			runtime_library_dir_option$({ dir }): Promise<any>

			/**
			 * Return the compiler option to add 'lib' to the list of libraries
			 *         linked into the shared library or executable.
			 *         
			 */
			library_option(lib): Promise<any>
			library_option$({ lib }): Promise<any>

			/**
			 * Return a boolean indicating whether funcname is supported on
			 *         the current platform.  The optional arguments can be used to
			 *         augment the compilation environment.
			 *         
			 */
			has_function(funcname, includes?, include_dirs?, libraries?, library_dirs?): Promise<any>
			has_function$({ funcname, includes, include_dirs, libraries, library_dirs }: { funcname, includes?, include_dirs?, libraries?, library_dirs?}): Promise<any>

			/**
			 * Search the specified list of directories for a static or shared
			 *         library file 'lib' and return the full path to that file.  If
			 *         'debug' true, look for a debugging version (if that makes sense on
			 *         the current platform).  Return None if 'lib' wasn't found in any of
			 *         the specified directories.
			 *         
			 */
			find_library_file(dirs, lib, debug?): Promise<any>
			find_library_file$({ dirs, lib, debug }: { dirs, lib, debug?}): Promise<any>
			object_filenames(source_filenames, strip_dir?, output_dir?): Promise<any>
			object_filenames$({ source_filenames, strip_dir, output_dir }: { source_filenames, strip_dir?, output_dir?}): Promise<any>
			shared_object_filename(basename, strip_dir?, output_dir?): Promise<any>
			shared_object_filename$({ basename, strip_dir, output_dir }: { basename, strip_dir?, output_dir?}): Promise<any>
			executable_filename(basename, strip_dir?, output_dir?): Promise<any>
			executable_filename$({ basename, strip_dir, output_dir }: { basename, strip_dir?, output_dir?}): Promise<any>
			library_filename(libname, lib_type?, strip_dir?, output_dir?): Promise<any>
			library_filename$({ libname, lib_type, strip_dir, output_dir }: { libname, lib_type?, strip_dir?, output_dir?}): Promise<any>
			announce(msg, level?): Promise<any>
			announce$({ msg, level }: { msg, level?}): Promise<any>
			debug_print(msg): Promise<any>
			debug_print$({ msg }): Promise<any>
			warn(msg): Promise<any>
			warn$({ msg }): Promise<any>
			execute(func, args, msg?, level?): Promise<any>
			execute$({ func, args, msg, level }: { func, args, msg?, level?}): Promise<any>
			spawn(cmd): Promise<any>
			spawn$({ cmd }): Promise<any>
			move_file(src, dst): Promise<any>
			move_file$({ src, dst }): Promise<any>
			mkpath(name, mode?): Promise<any>
			mkpath$({ name, mode }: { name, mode?}): Promise<any>
			compiler_type
			src_extensions
			obj_extension
			static_lib_extension
			shared_lib_extension
			static_lib_format
			shared_lib_format
			exe_extension
			language_map
			language_order
			SHARED_OBJECT
			SHARED_LIBRARY
			EXECUTABLE
		}
		let compiler_class: Promise<any>
	}
	module cmd {
		var _

		/**
		 * Abstract base class for defining command classes, the "worker bees"
		 *     of the Distutils.  A useful analogy for command classes is to think of
		 *     them as subroutines with local variables called "options".  The options
		 *     are "declared" in 'initialize_options()' and "defined" (given their
		 *     final values, aka "finalized") in 'finalize_options()', both of which
		 *     must be defined by every command class.  The distinction between the
		 *     two is necessary because option values might come from the outside
		 *     world (command line, config file, ...), and any options dependent on
		 *     other options must be computed *after* these outside influences have
		 *     been processed -- hence 'finalize_options()'.  The "body" of the
		 *     subroutine, where it does all its work based on the values of its
		 *     options, is the 'run()' method, which must also be implemented by every
		 *     command class.
		 *     
		 */

		/**
		 * Create and initialize a new Command object.  Most importantly,
		 *         invokes the 'initialize_options()' method, which is the real
		 *         initializer and depends on the actual command being
		 *         instantiated.
		 *         
		 */
		function Command(dist): Promise<ICommand>
		function Command$({ dist }): Promise<ICommand>
		interface ICommand {
			ensure_finalized(): Promise<any>
			ensure_finalized$($: {}): Promise<any>

			/**
			 * Set default values for all the options that this command
			 *         supports.  Note that these defaults may be overridden by other
			 *         commands, by the setup script, by config files, or by the
			 *         command-line.  Thus, this is not the place to code dependencies
			 *         between options; generally, 'initialize_options()' implementations
			 *         are just a bunch of "self.foo = None" assignments.
			 * 
			 *         This method must be implemented by all command classes.
			 *         
			 */
			initialize_options(): Promise<any>
			initialize_options$($: {}): Promise<any>

			/**
			 * Set final values for all the options that this command supports.
			 *         This is always called as late as possible, ie.  after any option
			 *         assignments from the command-line or from other commands have been
			 *         done.  Thus, this is the place to code option dependencies: if
			 *         'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as
			 *         long as 'foo' still has the same value it was assigned in
			 *         'initialize_options()'.
			 * 
			 *         This method must be implemented by all command classes.
			 *         
			 */
			finalize_options(): Promise<any>
			finalize_options$($: {}): Promise<any>
			dump_options(header?, indent?): Promise<any>
			dump_options$({ header, indent }: { header?, indent?}): Promise<any>

			/**
			 * A command's raison d'etre: carry out the action it exists to
			 *         perform, controlled by the options initialized in
			 *         'initialize_options()', customized by other commands, the setup
			 *         script, the command-line, and config files, and finalized in
			 *         'finalize_options()'.  All terminal output and filesystem
			 *         interaction should be done by 'run()'.
			 * 
			 *         This method must be implemented by all command classes.
			 *         
			 */
			run(): Promise<any>
			run$($: {}): Promise<any>

			/**
			 * If the current verbosity level is of greater than or equal to
			 *         'level' print 'msg' to stdout.
			 *         
			 */
			announce(msg, level?): Promise<any>
			announce$({ msg, level }: { msg, level?}): Promise<any>

			/**
			 * Print 'msg' to stdout if the global DEBUG (taken from the
			 *         DISTUTILS_DEBUG environment variable) flag is true.
			 *         
			 */
			debug_print(msg): Promise<any>
			debug_print$({ msg }): Promise<any>

			/**
			 * Ensure that 'option' is a string; if not defined, set it to
			 *         'default'.
			 *         
			 */
			ensure_string(option, def?): Promise<any>
			ensure_string$({ option, def }: { option, def?}): Promise<any>

			/**
			 * Ensure that 'option' is a list of strings.  If 'option' is
			 *         currently a string, we split it either on /,\s*/ or /\s+/, so
			 *         "foo bar baz", "foo,bar,baz", and "foo,   bar baz" all become
			 *         ["foo", "bar", "baz"].
			 *         
			 */
			ensure_string_list(option): Promise<any>
			ensure_string_list$({ option }): Promise<any>

			/**
			 * Ensure that 'option' is the name of an existing file.
			 */
			ensure_filename(option): Promise<any>
			ensure_filename$({ option }): Promise<any>
			ensure_dirname(option): Promise<any>
			ensure_dirname$({ option }): Promise<any>
			get_command_name(): Promise<any>
			get_command_name$($: {}): Promise<any>

			/**
			 * Set the values of any "undefined" options from corresponding
			 *         option values in some other command object.  "Undefined" here means
			 *         "is None", which is the convention used to indicate that an option
			 *         has not been changed between 'initialize_options()' and
			 *         'finalize_options()'.  Usually called from 'finalize_options()' for
			 *         options that depend on some other command rather than another
			 *         option of the same command.  'src_cmd' is the other command from
			 *         which option values will be taken (a command object will be created
			 *         for it if necessary); the remaining arguments are
			 *         '(src_option,dst_option)' tuples which mean "take the value of
			 *         'src_option' in the 'src_cmd' command object, and copy it to
			 *         'dst_option' in the current command object".
			 *         
			 */
			set_undefined_options(src_cmd): Promise<any>
			set_undefined_options$({ src_cmd }): Promise<any>

			/**
			 * Wrapper around Distribution's 'get_command_obj()' method: find
			 *         (create if necessary and 'create' is true) the command object for
			 *         'command', call its 'ensure_finalized()' method, and return the
			 *         finalized command object.
			 *         
			 */
			get_finalized_command(command, create?): Promise<any>
			get_finalized_command$({ command, create }: { command, create?}): Promise<any>
			reinitialize_command(command, reinit_subcommands?): Promise<any>
			reinitialize_command$({ command, reinit_subcommands }: { command, reinit_subcommands?}): Promise<any>

			/**
			 * Run some other command: uses the 'run_command()' method of
			 *         Distribution, which creates and finalizes the command object if
			 *         necessary and then invokes its 'run()' method.
			 *         
			 */
			run_command(command): Promise<any>
			run_command$({ command }): Promise<any>

			/**
			 * Determine the sub-commands that are relevant in the current
			 *         distribution (ie., that need to be run).  This is based on the
			 *         'sub_commands' class attribute: each tuple in that list may include
			 *         a method that we call to determine if the subcommand needs to be
			 *         run for the current distribution.  Return a list of command names.
			 *         
			 */
			get_sub_commands(): Promise<any>
			get_sub_commands$($: {}): Promise<any>
			warn(msg): Promise<any>
			warn$({ msg }): Promise<any>
			execute(func, args, msg?, level?): Promise<any>
			execute$({ func, args, msg, level }: { func, args, msg?, level?}): Promise<any>
			mkpath(name, mode?): Promise<any>
			mkpath$({ name, mode }: { name, mode?}): Promise<any>

			/**
			 * Copy a file respecting verbose, dry-run and force flags.  (The
			 *         former two default to whatever is in the Distribution object, and
			 *         the latter defaults to false for commands that don't define it.)
			 */
			copy_file(infile, outfile, preserve_mode?, preserve_times?, link?, level?): Promise<any>
			copy_file$({ infile, outfile, preserve_mode, preserve_times, link, level }: { infile, outfile, preserve_mode?, preserve_times?, link?, level?}): Promise<any>

			/**
			 * Copy an entire directory tree respecting verbose, dry-run,
			 *         and force flags.
			 *         
			 */
			copy_tree(infile, outfile, preserve_mode?, preserve_times?, preserve_symlinks?, level?): Promise<any>
			copy_tree$({ infile, outfile, preserve_mode, preserve_times, preserve_symlinks, level }: { infile, outfile, preserve_mode?, preserve_times?, preserve_symlinks?, level?}): Promise<any>

			/**
			 * Move a file respecting dry-run flag.
			 */
			move_file(src, dst, level?): Promise<any>
			move_file$({ src, dst, level }: { src, dst, level?}): Promise<any>

			/**
			 * Spawn an external command respecting dry-run flag.
			 */
			spawn(cmd, search_path?, level?): Promise<any>
			spawn$({ cmd, search_path, level }: { cmd, search_path?, level?}): Promise<any>
			make_archive(base_name, format, root_dir?, base_dir?, owner?, group?): Promise<any>
			make_archive$({ base_name, format, root_dir, base_dir, owner, group }: { base_name, format, root_dir?, base_dir?, owner?, group?}): Promise<any>

			/**
			 * Special case of 'execute()' for operations that process one or
			 *         more input files and generate one output file.  Works just like
			 *         'execute()', except the operation is skipped and a different
			 *         message printed if 'outfile' already exists and is newer than all
			 *         files listed in 'infiles'.  If the command defined 'self.force',
			 *         and it is true, then the command is unconditionally run -- does no
			 *         timestamp checks.
			 *         
			 */
			make_file(infiles, outfile, func, args, exec_msg?, skip_msg?, level?): Promise<any>
			make_file$({ infiles, outfile, func, args, exec_msg, skip_msg, level }: { infiles, outfile, func, args, exec_msg?, skip_msg?, level?}): Promise<any>
			sub_commands
		}
	}
	module command {
		var _
		module bdist {
			var _

			/**
			 * Print list of available formats (arguments to "--format" option).
			 *     
			 */
			function show_formats(): Promise<any>
			function show_formats$($: {}): Promise<any>
			interface Ibdist {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>
				description
				user_options
				boolean_options
				help_options
				no_format_option
				default_format
				format_commands
				format_command
			}
		}
		module bdist_dumb {
			var _
			interface Ibdist_dumb {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>
				description
				user_options
				boolean_options
				default_format
			}
		}
		module bdist_msi {
			var _

			/**
			 * Dialog class with a fixed layout: controls at the top, then a ruler,
			 *     then a list of buttons: back, next, cancel. Optionally a bitmap at the
			 *     left.
			 */

			/**
			 * Dialog(database, name, x, y, w, h, attributes, title, first,
			 *         default, cancel, bitmap=true)
			 */
			function PyDialog(): Promise<IPyDialog>
			function PyDialog$({ }): Promise<IPyDialog>
			interface IPyDialog {

				/**
				 * Set the title text of the dialog at the top.
				 */
				title(title): Promise<any>
				title$({ title }): Promise<any>

				/**
				 * Add a back button with a given title, the tab-next button,
				 *         its name in the Control table, possibly initially disabled.
				 * 
				 *         Return the button, so that events can be associated
				 */
				back(title, next, name?, active?): Promise<any>
				back$({ title, next, name, active }: { title, next, name?, active?}): Promise<any>

				/**
				 * Add a cancel button with a given title, the tab-next button,
				 *         its name in the Control table, possibly initially disabled.
				 * 
				 *         Return the button, so that events can be associated
				 */
				cancel(title, next, name?, active?): Promise<any>
				cancel$({ title, next, name, active }: { title, next, name?, active?}): Promise<any>

				/**
				 * Add a Next button with a given title, the tab-next button,
				 *         its name in the Control table, possibly initially disabled.
				 * 
				 *         Return the button, so that events can be associated
				 */
				next(title, next, name?, active?): Promise<any>
				next$({ title, next, name, active }: { title, next, name?, active?}): Promise<any>

				/**
				 * Add a button with a given title, the tab-next button,
				 *         its name in the Control table, giving its x position; the
				 *         y-position is aligned with the other buttons.
				 * 
				 *         Return the button, so that events can be associated
				 */
				xbutton(name, title, next, xpos): Promise<any>
				xbutton$({ name, title, next, xpos }): Promise<any>
			}
			function bdist_msi(): Promise<Ibdist_msi>
			function bdist_msi$({ }): Promise<Ibdist_msi>
			interface Ibdist_msi {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>
				add_files(): Promise<any>
				add_files$($: {}): Promise<any>

				/**
				 * Adds code to the installer to compute the location of Python.
				 * 
				 *         Properties PYTHON.MACHINE.X.Y and PYTHON.USER.X.Y will be set from the
				 *         registry for each version of Python.
				 * 
				 *         Properties TARGETDIRX.Y will be set from PYTHON.USER.X.Y if defined,
				 *         else from PYTHON.MACHINE.X.Y.
				 * 
				 *         Properties PYTHONX.Y will be set to TARGETDIRX.Y\python.exe
				 */
				add_find_python(): Promise<any>
				add_find_python$($: {}): Promise<any>
				add_scripts(): Promise<any>
				add_scripts$($: {}): Promise<any>
				add_ui(): Promise<any>
				add_ui$($: {}): Promise<any>
				get_installer_filename(fullname): Promise<any>
				get_installer_filename$({ fullname }): Promise<any>
				description
				user_options
				boolean_options
				all_versions
				other_version
			}
		}
		module bdist_rpm {
			var _
			interface Ibdist_rpm {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				finalize_package_data(): Promise<any>
				finalize_package_data$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>
				description
				user_options
				boolean_options
				negative_opt
			}
		}
		module build {
			var _
			function show_compilers(): Promise<any>
			function show_compilers$($: {}): Promise<any>
			interface Ibuild {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>
				has_pure_modules(): Promise<any>
				has_pure_modules$($: {}): Promise<any>
				has_c_libraries(): Promise<any>
				has_c_libraries$($: {}): Promise<any>
				has_ext_modules(): Promise<any>
				has_ext_modules$($: {}): Promise<any>
				has_scripts(): Promise<any>
				has_scripts$($: {}): Promise<any>
				description
				user_options
				boolean_options
				help_options
				sub_commands
			}
		}
		module build_clib {
			var _
			function show_compilers(): Promise<any>
			function show_compilers$($: {}): Promise<any>
			interface Ibuild_clib {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>

				/**
				 * Ensure that the list of libraries is valid.
				 * 
				 *         `library` is presumably provided as a command option 'libraries'.
				 *         This method checks that it is a list of 2-tuples, where the tuples
				 *         are (library_name, build_info_dict).
				 * 
				 *         Raise DistutilsSetupError if the structure is invalid anywhere;
				 *         just returns otherwise.
				 *         
				 */
				check_library_list(libraries): Promise<any>
				check_library_list$({ libraries }): Promise<any>
				get_library_names(): Promise<any>
				get_library_names$($: {}): Promise<any>
				get_source_files(): Promise<any>
				get_source_files$($: {}): Promise<any>
				build_libraries(libraries): Promise<any>
				build_libraries$({ libraries }): Promise<any>
				description
				user_options
				boolean_options
				help_options
			}
		}
		module build_ext {
			var _
			function show_compilers(): Promise<any>
			function show_compilers$($: {}): Promise<any>
			interface Ibuild_ext {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>

				/**
				 * Ensure that the list of extensions (presumably provided as a
				 *         command option 'extensions') is valid, i.e. it is a list of
				 *         Extension objects.  We also support the old-style list of 2-tuples,
				 *         where the tuples are (ext_name, build_info), which are converted to
				 *         Extension instances here.
				 * 
				 *         Raise DistutilsSetupError if the structure is invalid anywhere;
				 *         just returns otherwise.
				 *         
				 */
				check_extensions_list(extensions): Promise<any>
				check_extensions_list$({ extensions }): Promise<any>
				get_source_files(): Promise<any>
				get_source_files$($: {}): Promise<any>
				get_outputs(): Promise<any>
				get_outputs$($: {}): Promise<any>
				build_extensions(): Promise<any>
				build_extensions$($: {}): Promise<any>
				build_extension(ext): Promise<any>
				build_extension$({ ext }): Promise<any>

				/**
				 * Walk the list of source files in 'sources', looking for SWIG
				 *         interface (.i) files.  Run SWIG on all that are found, and
				 *         return a modified 'sources' list with SWIG source files replaced
				 *         by the generated C (or C++) files.
				 *         
				 */
				swig_sources(sources, extension): Promise<any>
				swig_sources$({ sources, extension }): Promise<any>

				/**
				 * Return the name of the SWIG executable.  On Unix, this is
				 *         just "swig" -- it should be in the PATH.  Tries a bit harder on
				 *         Windows.
				 *         
				 */
				find_swig(): Promise<any>
				find_swig$($: {}): Promise<any>

				/**
				 * Returns the path of the filename for a given extension.
				 * 
				 *         The file is located in `build_lib` or directly in the package
				 *         (inplace option).
				 *         
				 */
				get_ext_fullpath(ext_name): Promise<any>
				get_ext_fullpath$({ ext_name }): Promise<any>

				/**
				 * Returns the fullname of a given extension name.
				 * 
				 *         Adds the `package.` prefix
				 */
				get_ext_fullname(ext_name): Promise<any>
				get_ext_fullname$({ ext_name }): Promise<any>

				/**
				 * Convert the name of an extension (eg. "foo.bar") into the name
				 *         of the file from which it will be loaded (eg. "foo/bar.so", or
				 *         "foo\bar.pyd").
				 *         
				 */
				get_ext_filename(ext_name): Promise<any>
				get_ext_filename$({ ext_name }): Promise<any>

				/**
				 * Return the list of symbols that a shared extension has to
				 *         export.  This either uses 'ext.export_symbols' or, if it's not
				 *         provided, "PyInit_" + module_name.  Only relevant on Windows, where
				 *         the .pyd file (DLL) must export the module "PyInit_" function.
				 *         
				 */
				get_export_symbols(ext): Promise<any>
				get_export_symbols$({ ext }): Promise<any>

				/**
				 * Return the list of libraries to link against when building a
				 *         shared extension.  On most platforms, this is just 'ext.libraries';
				 *         on Windows, we add the Python library (eg. python20.dll).
				 *         
				 */
				get_libraries(ext): Promise<any>
				get_libraries$({ ext }): Promise<any>
				description
				sep_by
				user_options
				boolean_options
				help_options
			}
			let extension_name_re: Promise<any>
		}
		module build_py {
			var _
			interface Ibuild_py {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>

				/**
				 * Generate list of '(package,src_dir,build_dir,filenames)' tuples
				 */
				get_data_files(): Promise<any>
				get_data_files$($: {}): Promise<any>

				/**
				 * Return filenames for package's data files in 'src_dir'
				 */
				find_data_files(package, src_dir): Promise<any>
				find_data_files$({ package, src_dir }): Promise<any>

				/**
				 * Copy data files into build directory
				 */
				build_package_data(): Promise<any>
				build_package_data$($: {}): Promise<any>

				/**
				 * Return the directory, relative to the top of the source
				 *            distribution, where package 'package' should be found
				 *            (at least according to the 'package_dir' option, if any).
				 */
				get_package_dir(package): Promise<any>
				get_package_dir$({ package }): Promise<any>
				check_package(package, package_dir): Promise<any>
				check_package$({ package, package_dir }): Promise<any>
				check_module(module, module_file): Promise<any>
				check_module$({ module, module_file }): Promise<any>
				find_package_modules(package, package_dir): Promise<any>
				find_package_modules$({ package, package_dir }): Promise<any>

				/**
				 * Finds individually-specified Python modules, ie. those listed by
				 *         module name in 'self.py_modules'.  Returns a list of tuples (package,
				 *         module_base, filename): 'package' is a tuple of the path through
				 *         package-space to the module; 'module_base' is the bare (no
				 *         packages, no dots) module name, and 'filename' is the path to the
				 *         ".py" file (relative to the distribution root) that implements the
				 *         module.
				 *         
				 */
				find_modules(): Promise<any>
				find_modules$($: {}): Promise<any>

				/**
				 * Compute the list of all modules that will be built, whether
				 *         they are specified one-module-at-a-time ('self.py_modules') or
				 *         by whole packages ('self.packages').  Return a list of tuples
				 *         (package, module, module_file), just like 'find_modules()' and
				 *         'find_package_modules()' do.
				 */
				find_all_modules(): Promise<any>
				find_all_modules$($: {}): Promise<any>
				get_source_files(): Promise<any>
				get_source_files$($: {}): Promise<any>
				get_module_outfile(build_dir, package, module): Promise<any>
				get_module_outfile$({ build_dir, package, module }): Promise<any>
				get_outputs(include_bytecode?): Promise<any>
				get_outputs$({ include_bytecode }: { include_bytecode?}): Promise<any>
				build_module(module, module_file, package): Promise<any>
				build_module$({ module, module_file, package }): Promise<any>
				build_modules(): Promise<any>
				build_modules$($: {}): Promise<any>
				build_packages(): Promise<any>
				build_packages$($: {}): Promise<any>
				byte_compile(files): Promise<any>
				byte_compile$({ files }): Promise<any>
				description
				user_options
				boolean_options
				negative_opt
			}
			interface Ibuild_py_2to3 extends Ibuild_py {
				run(): Promise<any>
				run$($: {}): Promise<any>
				build_module(module, module_file, package): Promise<any>
				build_module$({ module, module_file, package }): Promise<any>
			}
		}
		module build_scripts {
			var _
			interface Ibuild_scripts {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				get_source_files(): Promise<any>
				get_source_files$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>

				/**
				 * Copy each script listed in 'self.scripts'; if it's marked as a
				 *         Python script in the Unix way (first line matches 'first_line_re',
				 *         ie. starts with "\#!" and contains "python"), then adjust the first
				 *         line to refer to the current Python interpreter as we copy.
				 *         
				 */
				copy_scripts(): Promise<any>
				copy_scripts$($: {}): Promise<any>
				description
				user_options
				boolean_options
			}
			interface Ibuild_scripts_2to3 extends Ibuild_scripts {
				copy_scripts(): Promise<any>
				copy_scripts$($: {}): Promise<any>
			}
			let first_line_re: Promise<any>
		}
		module check {
			var _
			function SilentReporter(source, report_level, halt_level, stream?, debug?, encoding?, error_handler?): Promise<ISilentReporter>
			function SilentReporter$({ source, report_level, halt_level, stream, debug, encoding, error_handler }: { source, report_level, halt_level, stream?, debug?, encoding?, error_handler?}): Promise<ISilentReporter>
			interface ISilentReporter {
				system_message(level, message): Promise<any>
				system_message$({ level, message }): Promise<any>
			}

			/**
			 * This command checks the meta-data of the package.
			 *     
			 */
			interface Icheck {

				/**
				 * Sets default values for options.
				 */
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>

				/**
				 * Counts the number of warnings that occurs.
				 */
				warn(msg): Promise<any>
				warn$({ msg }): Promise<any>

				/**
				 * Runs the command.
				 */
				run(): Promise<any>
				run$($: {}): Promise<any>

				/**
				 * Ensures that all required elements of meta-data are supplied.
				 * 
				 *         Required fields:
				 *             name, version, URL
				 * 
				 *         Recommended fields:
				 *             (author and author_email) or (maintainer and maintainer_email))
				 * 
				 *         Warns if any are missing.
				 *         
				 */
				check_metadata(): Promise<any>
				check_metadata$($: {}): Promise<any>

				/**
				 * Checks if the long string fields are reST-compliant.
				 */
				check_restructuredtext(): Promise<any>
				check_restructuredtext$($: {}): Promise<any>
				description
				user_options
				boolean_options
			}
			let HAS_DOCUTILS: Promise<any>
		}
		module clean {
			var _
			interface Iclean {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>
				description
				user_options
				boolean_options
			}
		}
		module config {
			var _

			/**
			 * Dumps a file content into log.info.
			 * 
			 *     If head is not None, will be dumped before the file content.
			 *     
			 */
			function dump_file(filename, head?): Promise<any>
			function dump_file$({ filename, head }: { filename, head?}): Promise<any>
			interface Iconfig {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>

				/**
				 * Construct a source file from 'body' (a string containing lines
				 *         of C/C++ code) and 'headers' (a list of header files to include)
				 *         and run it through the preprocessor.  Return true if the
				 *         preprocessor succeeded, false if there were any errors.
				 *         ('body' probably isn't of much use, but what the heck.)
				 *         
				 */
				try_cpp(body?, headers?, include_dirs?, lang?): Promise<any>
				try_cpp$({ body, headers, include_dirs, lang }: { body?, headers?, include_dirs?, lang?}): Promise<any>

				/**
				 * Construct a source file (just like 'try_cpp()'), run it through
				 *         the preprocessor, and return true if any line of the output matches
				 *         'pattern'.  'pattern' should either be a compiled regex object or a
				 *         string containing a regex.  If both 'body' and 'headers' are None,
				 *         preprocesses an empty file -- which can be useful to determine the
				 *         symbols the preprocessor and compiler set by default.
				 *         
				 */
				search_cpp(pattern, body?, headers?, include_dirs?, lang?): Promise<any>
				search_cpp$({ pattern, body, headers, include_dirs, lang }: { pattern, body?, headers?, include_dirs?, lang?}): Promise<any>

				/**
				 * Try to compile a source file built from 'body' and 'headers'.
				 *         Return true on success, false otherwise.
				 *         
				 */
				try_compile(body, headers?, include_dirs?, lang?): Promise<any>
				try_compile$({ body, headers, include_dirs, lang }: { body, headers?, include_dirs?, lang?}): Promise<any>

				/**
				 * Try to compile and link a source file, built from 'body' and
				 *         'headers', to executable form.  Return true on success, false
				 *         otherwise.
				 *         
				 */
				try_link(body, headers?, include_dirs?, libraries?, library_dirs?, lang?): Promise<any>
				try_link$({ body, headers, include_dirs, libraries, library_dirs, lang }: { body, headers?, include_dirs?, libraries?, library_dirs?, lang?}): Promise<any>

				/**
				 * Try to compile, link to an executable, and run a program
				 *         built from 'body' and 'headers'.  Return true on success, false
				 *         otherwise.
				 *         
				 */
				try_run(body, headers?, include_dirs?, libraries?, library_dirs?, lang?): Promise<any>
				try_run$({ body, headers, include_dirs, libraries, library_dirs, lang }: { body, headers?, include_dirs?, libraries?, library_dirs?, lang?}): Promise<any>

				/**
				 * Determine if function 'func' is available by constructing a
				 *         source file that refers to 'func', and compiles and links it.
				 *         If everything succeeds, returns true; otherwise returns false.
				 * 
				 *         The constructed source file starts out by including the header
				 *         files listed in 'headers'.  If 'decl' is true, it then declares
				 *         'func' (as "int func()"); you probably shouldn't supply 'headers'
				 *         and set 'decl' true in the same call, or you might get errors about
				 *         a conflicting declarations for 'func'.  Finally, the constructed
				 *         'main()' function either references 'func' or (if 'call' is true)
				 *         calls it.  'libraries' and 'library_dirs' are used when
				 *         linking.
				 *         
				 */
				check_func(func, headers?, include_dirs?, libraries?, library_dirs?, decl?, call?): Promise<any>
				check_func$({ func, headers, include_dirs, libraries, library_dirs, decl, call }: { func, headers?, include_dirs?, libraries?, library_dirs?, decl?, call?}): Promise<any>

				/**
				 * Determine if 'library' is available to be linked against,
				 *         without actually checking that any particular symbols are provided
				 *         by it.  'headers' will be used in constructing the source file to
				 *         be compiled, but the only effect of this is to check if all the
				 *         header files listed are available.  Any libraries listed in
				 *         'other_libraries' will be included in the link, in case 'library'
				 *         has symbols that depend on other libraries.
				 *         
				 */
				check_lib(library, library_dirs?, headers?, include_dirs?, other_libraries?): Promise<any>
				check_lib$({ library, library_dirs, headers, include_dirs, other_libraries }: { library, library_dirs?, headers?, include_dirs?, other_libraries?}): Promise<any>

				/**
				 * Determine if the system header file named by 'header_file'
				 *         exists and can be found by the preprocessor; return true if so,
				 *         false otherwise.
				 *         
				 */
				check_header(header, include_dirs?, library_dirs?, lang?): Promise<any>
				check_header$({ header, include_dirs, library_dirs, lang }: { header, include_dirs?, library_dirs?, lang?}): Promise<any>
				description
				user_options
			}
			let LANG_EXT: Promise<any>
		}
		module install {
			var _
			interface Iinstall {

				/**
				 * Initializes options.
				 */
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>

				/**
				 * Finalizes options.
				 */
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>

				/**
				 * Dumps the list of user options.
				 */
				dump_dirs(msg): Promise<any>
				dump_dirs$({ msg }): Promise<any>

				/**
				 * Finalizes options for posix platforms.
				 */
				finalize_unix(): Promise<any>
				finalize_unix$($: {}): Promise<any>

				/**
				 * Finalizes options for non-posix platforms
				 */
				finalize_other(): Promise<any>
				finalize_other$($: {}): Promise<any>

				/**
				 * Sets the install directories by applying the install schemes.
				 */
				select_scheme(name): Promise<any>
				select_scheme$({ name }): Promise<any>

				/**
				 * Calls `os.path.expanduser` on install_base, install_platbase and
				 *         root.
				 */
				expand_basedirs(): Promise<any>
				expand_basedirs$($: {}): Promise<any>

				/**
				 * Calls `os.path.expanduser` on install dirs.
				 */
				expand_dirs(): Promise<any>
				expand_dirs$($: {}): Promise<any>

				/**
				 * Call `convert_path` over `names`.
				 */
				convert_paths(): Promise<any>
				convert_paths$($: {}): Promise<any>

				/**
				 * Set `path_file` and `extra_dirs` using `extra_path`.
				 */
				handle_extra_path(): Promise<any>
				handle_extra_path$($: {}): Promise<any>

				/**
				 * Change the install directories pointed by name using root.
				 */
				change_roots(): Promise<any>
				change_roots$($: {}): Promise<any>

				/**
				 * Create directories under ~.
				 */
				create_home_path(): Promise<any>
				create_home_path$($: {}): Promise<any>

				/**
				 * Runs the command.
				 */
				run(): Promise<any>
				run$($: {}): Promise<any>

				/**
				 * Creates the .pth file
				 */
				create_path_file(): Promise<any>
				create_path_file$($: {}): Promise<any>

				/**
				 * Assembles the outputs of all the sub-commands.
				 */
				get_outputs(): Promise<any>
				get_outputs$($: {}): Promise<any>

				/**
				 * Returns the inputs of all the sub-commands
				 */
				get_inputs(): Promise<any>
				get_inputs$($: {}): Promise<any>

				/**
				 * Returns true if the current distribution has any Python
				 *         modules to install.
				 */
				has_lib(): Promise<any>
				has_lib$($: {}): Promise<any>

				/**
				 * Returns true if the current distribution has any headers to
				 *         install.
				 */
				has_headers(): Promise<any>
				has_headers$($: {}): Promise<any>

				/**
				 * Returns true if the current distribution has any scripts to.
				 *         install.
				 */
				has_scripts(): Promise<any>
				has_scripts$($: {}): Promise<any>

				/**
				 * Returns true if the current distribution has any data to.
				 *         install.
				 */
				has_data(): Promise<any>
				has_data$($: {}): Promise<any>
				description
				user_options
				boolean_options
				negative_opt
				sub_commands
			}
			let HAS_USER_SITE: Promise<any>
			let SCHEME_KEYS: Promise<any>
			let INSTALL_SCHEMES: Promise<any>
			let sys_key: Promise<any>
			let sys_scheme: Promise<any>
			let value: Promise<any>
		}
		module install_data {
			var _
			interface Iinstall_data {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>
				get_inputs(): Promise<any>
				get_inputs$($: {}): Promise<any>
				get_outputs(): Promise<any>
				get_outputs$($: {}): Promise<any>
				description
				user_options
				boolean_options
			}
		}
		module install_egg_info {
			var _

			/**
			 * Convert an arbitrary string to a standard distribution name
			 * 
			 *     Any runs of non-alphanumeric/. characters are replaced with a single '-'.
			 *     
			 */
			function safe_name(name): Promise<any>
			function safe_name$({ name }): Promise<any>

			/**
			 * Convert an arbitrary string to a standard version string
			 * 
			 *     Spaces become dots, and all other non-alphanumeric characters become
			 *     dashes, with runs of multiple dashes condensed to a single dash.
			 *     
			 */
			function safe_version(version): Promise<any>
			function safe_version$({ version }): Promise<any>

			/**
			 * Convert a project or version name to its filename-escaped form
			 * 
			 *     Any '-' characters are currently replaced with '_'.
			 *     
			 */
			function to_filename(name): Promise<any>
			function to_filename$({ name }): Promise<any>

			/**
			 * Install an .egg-info file for the package
			 */
			interface Iinstall_egg_info {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>
				get_outputs(): Promise<any>
				get_outputs$($: {}): Promise<any>
				description
				user_options
			}
		}
		module install_headers {
			var _
			interface Iinstall_headers {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>
				get_inputs(): Promise<any>
				get_inputs$($: {}): Promise<any>
				get_outputs(): Promise<any>
				get_outputs$($: {}): Promise<any>
				description
				user_options
				boolean_options
			}
		}
		module install_lib {
			var _
			interface Iinstall_lib {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>
				build(): Promise<any>
				build$($: {}): Promise<any>
				install(): Promise<any>
				install$($: {}): Promise<any>
				byte_compile(files): Promise<any>
				byte_compile$({ files }): Promise<any>

				/**
				 * Return the list of files that would be installed if this command
				 *         were actually run.  Not affected by the "dry-run" flag or whether
				 *         modules have actually been built yet.
				 *         
				 */
				get_outputs(): Promise<any>
				get_outputs$($: {}): Promise<any>

				/**
				 * Get the list of files that are input to this command, ie. the
				 *         files that get installed as they are named in the build tree.
				 *         The files in this list correspond one-to-one to the output
				 *         filenames returned by 'get_outputs()'.
				 *         
				 */
				get_inputs(): Promise<any>
				get_inputs$($: {}): Promise<any>
				description
				user_options
				boolean_options
				negative_opt
			}
			let PYTHON_SOURCE_EXTENSION: Promise<any>
		}
		module install_scripts {
			var _
			interface Iinstall_scripts {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>
				get_inputs(): Promise<any>
				get_inputs$($: {}): Promise<any>
				get_outputs(): Promise<any>
				get_outputs$($: {}): Promise<any>
				description
				user_options
				boolean_options
			}
		}
		module register {
			var _
			interface Iregister {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>

				/**
				 * Deprecated API.
				 */
				check_metadata(): Promise<any>
				check_metadata$($: {}): Promise<any>

				/**
				 *  Fetch the list of classifiers from the server.
				 *         
				 */
				classifiers(): Promise<any>
				classifiers$($: {}): Promise<any>

				/**
				 *  Send the metadata to the package index server to be checked.
				 *         
				 */
				verify_metadata(): Promise<any>
				verify_metadata$($: {}): Promise<any>

				/**
				 *  Send the metadata to the package index server.
				 * 
				 *             Well, do the following:
				 *             1. figure who the user is, and then
				 *             2. send the data as a Basic auth'ed POST.
				 * 
				 *             First we try to read the username/password from $HOME/.pypirc,
				 *             which is a ConfigParser-formatted file with a section
				 *             [distutils] containing username and password entries (both
				 *             in clear text). Eg:
				 * 
				 *                 [distutils]
				 *                 index-servers =
				 *                     pypi
				 * 
				 *                 [pypi]
				 *                 username: fred
				 *                 password: sekrit
				 * 
				 *             Otherwise, to figure who the user is, we offer the user three
				 *             choices:
				 * 
				 *              1. use existing login,
				 *              2. register as a new user, or
				 *              3. set the password to a random string and email the user.
				 * 
				 *         
				 */
				send_metadata(): Promise<any>
				send_metadata$($: {}): Promise<any>
				build_post_data(action): Promise<any>
				build_post_data$({ action }): Promise<any>

				/**
				 *  Post a query to the server, and return a string response.
				 *         
				 */
				post_to_server(data, auth?): Promise<any>
				post_to_server$({ data, auth }: { data, auth?}): Promise<any>
				description
				user_options
				boolean_options
				sub_commands
			}
		}
		module sdist {
			var _

			/**
			 * Print all possible values for the 'formats' option (used by
			 *     the "--help-formats" command-line option).
			 *     
			 */
			function show_formats(): Promise<any>
			function show_formats$($: {}): Promise<any>
			interface Isdist {

				/**
				 * Callable used for the check sub-command.
				 * 
				 *         Placed here so user_options can view it
				 */
				checking_metadata(): Promise<any>
				checking_metadata$($: {}): Promise<any>
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>

				/**
				 * Deprecated API.
				 */
				check_metadata(): Promise<any>
				check_metadata$($: {}): Promise<any>

				/**
				 * Figure out the list of files to include in the source
				 *         distribution, and put it in 'self.filelist'.  This might involve
				 *         reading the manifest template (and writing the manifest), or just
				 *         reading the manifest, or just using the default file set -- it all
				 *         depends on the user's options.
				 *         
				 */
				get_file_list(): Promise<any>
				get_file_list$($: {}): Promise<any>

				/**
				 * Add all the default files to self.filelist:
				 *           - README or README.txt
				 *           - setup.py
				 *           - test/test*.py
				 *           - all pure Python modules mentioned in setup script
				 *           - all files pointed by package_data (build_py)
				 *           - all files defined in data_files.
				 *           - all files defined as scripts.
				 *           - all C sources listed as part of extensions or C libraries
				 *             in the setup script (doesn't catch C headers!)
				 *         Warns if (README or README.txt) or setup.py are missing; everything
				 *         else is optional.
				 *         
				 */
				add_defaults(): Promise<any>
				add_defaults$($: {}): Promise<any>

				/**
				 * Read and parse manifest template file named by self.template.
				 * 
				 *         (usually "MANIFEST.in") The parsing and processing is done by
				 *         'self.filelist', which updates itself accordingly.
				 *         
				 */
				read_template(): Promise<any>
				read_template$($: {}): Promise<any>

				/**
				 * Prune off branches that might slip into the file list as created
				 *         by 'read_template()', but really don't belong there:
				 *           * the build tree (typically "build")
				 *           * the release tree itself (only an issue if we ran "sdist"
				 *             previously with --keep-temp, or it aborted)
				 *           * any RCS, CVS, .svn, .hg, .git, .bzr, _darcs directories
				 *         
				 */
				prune_file_list(): Promise<any>
				prune_file_list$($: {}): Promise<any>

				/**
				 * Write the file list in 'self.filelist' (presumably as filled in
				 *         by 'add_defaults()' and 'read_template()') to the manifest file
				 *         named by 'self.manifest'.
				 *         
				 */
				write_manifest(): Promise<any>
				write_manifest$($: {}): Promise<any>

				/**
				 * Read the manifest file (named by 'self.manifest') and use it to
				 *         fill in 'self.filelist', the list of files to include in the source
				 *         distribution.
				 *         
				 */
				read_manifest(): Promise<any>
				read_manifest$($: {}): Promise<any>

				/**
				 * Create the directory tree that will become the source
				 *         distribution archive.  All directories implied by the filenames in
				 *         'files' are created under 'base_dir', and then we hard link or copy
				 *         (if hard linking is unavailable) those files into place.
				 *         Essentially, this duplicates the developer's source tree, but in a
				 *         directory named after the distribution, containing only the files
				 *         to be distributed.
				 *         
				 */
				make_release_tree(base_dir, files): Promise<any>
				make_release_tree$({ base_dir, files }): Promise<any>

				/**
				 * Create the source distribution(s).  First, we create the release
				 *         tree with 'make_release_tree()'; then, we create all required
				 *         archive files (according to 'self.formats') from the release tree.
				 *         Finally, we clean up by blowing away the release tree (unless
				 *         'self.keep_temp' is true).  The list of archive files created is
				 *         stored so it can be retrieved later by 'get_archive_files()'.
				 *         
				 */
				make_distribution(): Promise<any>
				make_distribution$($: {}): Promise<any>

				/**
				 * Return the list of archive files created when the command
				 *         was run, or None if the command hasn't run yet.
				 *         
				 */
				get_archive_files(): Promise<any>
				get_archive_files$($: {}): Promise<any>
				description
				user_options
				boolean_options
				help_options
				negative_opt
				sub_commands
				READMES
			}
		}
		module upload {
			var _
			interface Iupload {
				initialize_options(): Promise<any>
				initialize_options$($: {}): Promise<any>
				finalize_options(): Promise<any>
				finalize_options$($: {}): Promise<any>
				run(): Promise<any>
				run$($: {}): Promise<any>
				upload_file(command, pyversion, filename): Promise<any>
				upload_file$({ command, pyversion, filename }): Promise<any>
				description
				user_options
				boolean_options
			}
		}
	}
	module config {
		var _

		/**
		 * Base command that knows how to handle the .pypirc file
		 *     
		 */
		interface IPyPIRCCommand {

			/**
			 * Initialize options.
			 */
			initialize_options(): Promise<any>
			initialize_options$($: {}): Promise<any>

			/**
			 * Finalizes options.
			 */
			finalize_options(): Promise<any>
			finalize_options$($: {}): Promise<any>
			DEFAULT_REPOSITORY
			DEFAULT_REALM
			repository
			realm
			user_options
			boolean_options
		}
		let DEFAULT_PYPIRC: Promise<any>
	}
	module core {
		var _
		function gen_usage(script_name): Promise<any>
		function gen_usage$({ script_name }): Promise<any>

		/**
		 * The gateway to the Distutils: do everything your setup script needs
		 *     to do, in a highly flexible and user-driven way.  Briefly: create a
		 *     Distribution instance; find and parse config files; parse the command
		 *     line; run each Distutils command found there, customized by the options
		 *     supplied to 'setup()' (as keyword arguments), in config files, and on
		 *     the command line.
		 * 
		 *     The Distribution instance might be an instance of a class supplied via
		 *     the 'distclass' keyword argument to 'setup'; if no such class is
		 *     supplied, then the Distribution class (in dist.py) is instantiated.
		 *     All other arguments to 'setup' (except for 'cmdclass') are used to set
		 *     attributes of the Distribution instance.
		 * 
		 *     The 'cmdclass' argument, if supplied, is a dictionary mapping command
		 *     names to command classes.  Each command encountered on the command line
		 *     will be turned into a command class, which is in turn instantiated; any
		 *     class found in 'cmdclass' is used in place of the default, which is
		 *     (for command 'foo_bar') class 'foo_bar' in module
		 *     'distutils.command.foo_bar'.  The command class must provide a
		 *     'user_options' attribute which is a list of option specifiers for
		 *     'distutils.fancy_getopt'.  Any command-line options between the current
		 *     and the next command are used to set attributes of the current command
		 *     object.
		 * 
		 *     When the entire command-line has been successfully parsed, calls the
		 *     'run()' method on each command object in turn.  This method will be
		 *     driven entirely by the Distribution object (which each command object
		 *     has a reference to, thanks to its constructor), and the
		 *     command-specific options that became attributes of each command
		 *     object.
		 *     
		 */
		function setup(): Promise<any>
		function setup$($: {}): Promise<any>

		/**
		 * Run a setup script in a somewhat controlled environment, and
		 *     return the Distribution instance that drives things.  This is useful
		 *     if you need to find out the distribution meta-data (passed as
		 *     keyword args from 'script' to 'setup()', or the contents of the
		 *     config files or command-line.
		 * 
		 *     'script_name' is a file that will be read and run with 'exec()';
		 *     'sys.argv[0]' will be replaced with 'script' for the duration of the
		 *     call.  'script_args' is a list of strings; if supplied,
		 *     'sys.argv[1:]' will be replaced by 'script_args' for the duration of
		 *     the call.
		 * 
		 *     'stop_after' tells 'setup()' when to stop processing; possible
		 *     values:
		 *       init
		 *         stop after the Distribution instance has been created and
		 *         populated with the keyword arguments to 'setup()'
		 *       config
		 *         stop after config files have been parsed (and their data
		 *         stored in the Distribution instance)
		 *       commandline
		 *         stop after the command-line ('sys.argv[1:]' or 'script_args')
		 *         have been parsed (and the data stored in the Distribution)
		 *       run [default]
		 *         stop after all commands have been run (the same as if 'setup()'
		 *         had been called in the usual way
		 * 
		 *     Returns the Distribution instance, which provides all information
		 *     used to drive the Distutils.
		 *     
		 */
		function run_setup(script_name, script_args?, stop_after?): Promise<any>
		function run_setup$({ script_name, script_args, stop_after }: { script_name, script_args?, stop_after?}): Promise<any>
		let USAGE: Promise<any>
		let setup_keywords: Promise<any>
		let extension_keywords: Promise<any>
	}
	module cygwinccompiler {
		var _

		/**
		 * Include the appropriate MSVC runtime library if Python was built
		 *     with MSVC 7.0 or later.
		 *     
		 */
		function get_msvcr(): Promise<any>
		function get_msvcr$($: {}): Promise<any>

		/**
		 * Check if the current Python installation appears amenable to building
		 *     extensions with GCC.
		 * 
		 *     Returns a tuple (status, details), where 'status' is one of the following
		 *     constants:
		 * 
		 *     - CONFIG_H_OK: all is well, go ahead and compile
		 *     - CONFIG_H_NOTOK: doesn't look good
		 *     - CONFIG_H_UNCERTAIN: not sure -- unable to read pyconfig.h
		 * 
		 *     'details' is a human-readable string explaining the situation.
		 * 
		 *     Note there are two ways to conclude "OK": either 'sys.version' contains
		 *     the string "GCC" (implying that this Python was built with GCC), or the
		 *     installed "pyconfig.h" contains the string "__GNUC__".
		 *     
		 */
		function check_config_h(): Promise<any>
		function check_config_h$($: {}): Promise<any>

		/**
		 *  Try to find out the versions of gcc, ld and dllwrap.
		 * 
		 *     If not possible it returns None for it.
		 *     
		 */
		function get_versions(): Promise<any>
		function get_versions$($: {}): Promise<any>

		/**
		 * Try to determine if the gcc that would be used is from cygwin.
		 */
		function is_cygwingcc(): Promise<any>
		function is_cygwingcc$($: {}): Promise<any>

		/**
		 *  Handles the Cygwin port of the GNU C compiler to Windows.
		 *     
		 */
		function CygwinCCompiler(verbose?, dry_run?, force?): Promise<ICygwinCCompiler>
		function CygwinCCompiler$({ verbose, dry_run, force }: { verbose?, dry_run?, force?}): Promise<ICygwinCCompiler>
		interface ICygwinCCompiler {

			/**
			 * Link the objects.
			 */
			link(target_desc, objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?): Promise<any>
			link$({ target_desc, objects, output_filename, output_dir, libraries, library_dirs, runtime_library_dirs, export_symbols, debug, extra_preargs, extra_postargs, build_temp, target_lang }: { target_desc, objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?}): Promise<any>

			/**
			 * Adds supports for rc and res files.
			 */
			object_filenames(source_filenames, strip_dir?, output_dir?): Promise<any>
			object_filenames$({ source_filenames, strip_dir, output_dir }: { source_filenames, strip_dir?, output_dir?}): Promise<any>
			compiler_type
			obj_extension
			static_lib_extension
			shared_lib_extension
			static_lib_format
			shared_lib_format
			exe_extension
		}

		/**
		 *  Handles the Mingw32 port of the GNU C compiler to Windows.
		 *     
		 */
		function Mingw32CCompiler(verbose?, dry_run?, force?): Promise<IMingw32CCompiler>
		function Mingw32CCompiler$({ verbose, dry_run, force }: { verbose?, dry_run?, force?}): Promise<IMingw32CCompiler>
		interface IMingw32CCompiler extends ICygwinCCompiler {
		}
		let CONFIG_H_OK: Promise<any>
		let CONFIG_H_NOTOK: Promise<any>
		let CONFIG_H_UNCERTAIN: Promise<any>
		let RE_VERSION: Promise<any>
	}
	module debug {
		var _
		let DEBUG: Promise<any>
	}
	module dep_util {
		var _

		/**
		 * Return true if 'source' exists and is more recently modified than
		 *     'target', or if 'source' exists and 'target' doesn't.  Return false if
		 *     both exist and 'target' is the same age or younger than 'source'.
		 *     Raise DistutilsFileError if 'source' does not exist.
		 *     
		 */
		function newer(source, target): Promise<any>
		function newer$({ source, target }): Promise<any>

		/**
		 * Walk two filename lists in parallel, testing if each source is newer
		 *     than its corresponding target.  Return a pair of lists (sources,
		 *     targets) where source is newer than target, according to the semantics
		 *     of 'newer()'.
		 *     
		 */
		function newer_pairwise(sources, targets): Promise<any>
		function newer_pairwise$({ sources, targets }): Promise<any>

		/**
		 * Return true if 'target' is out-of-date with respect to any file
		 *     listed in 'sources'.  In other words, if 'target' exists and is newer
		 *     than every file in 'sources', return false; otherwise return true.
		 *     'missing' controls what we do when a source file is missing; the
		 *     default ("error") is to blow up with an OSError from inside 'stat()';
		 *     if it is "ignore", we silently drop any missing source files; if it is
		 *     "newer", any missing source files make us assume that 'target' is
		 *     out-of-date (this is handy in "dry-run" mode: it'll make you pretend to
		 *     carry out commands that wouldn't work because inputs are missing, but
		 *     that doesn't matter because you're not actually going to run the
		 *     commands).
		 *     
		 */
		function newer_group(sources, target, missing?): Promise<any>
		function newer_group$({ sources, target, missing }: { sources, target, missing?}): Promise<any>
	}
	module dir_util {
		var _

		/**
		 * Create a directory and any missing ancestor directories.
		 * 
		 *     If the directory already exists (or if 'name' is the empty string, which
		 *     means the current directory, which of course exists), then do nothing.
		 *     Raise DistutilsFileError if unable to create some directory along the way
		 *     (eg. some sub-path exists, but is a file rather than a directory).
		 *     If 'verbose' is true, print a one-line summary of each mkdir to stdout.
		 *     Return the list of directories actually created.
		 *     
		 */
		function mkpath(name, mode?, verbose?, dry_run?): Promise<any>
		function mkpath$({ name, mode, verbose, dry_run }: { name, mode?, verbose?, dry_run?}): Promise<any>

		/**
		 * Create all the empty directories under 'base_dir' needed to put 'files'
		 *     there.
		 * 
		 *     'base_dir' is just the name of a directory which doesn't necessarily
		 *     exist yet; 'files' is a list of filenames to be interpreted relative to
		 *     'base_dir'.  'base_dir' + the directory portion of every file in 'files'
		 *     will be created if it doesn't already exist.  'mode', 'verbose' and
		 *     'dry_run' flags are as for 'mkpath()'.
		 *     
		 */
		function create_tree(base_dir, files, mode?, verbose?, dry_run?): Promise<any>
		function create_tree$({ base_dir, files, mode, verbose, dry_run }: { base_dir, files, mode?, verbose?, dry_run?}): Promise<any>

		/**
		 * Copy an entire directory tree 'src' to a new location 'dst'.
		 * 
		 *     Both 'src' and 'dst' must be directory names.  If 'src' is not a
		 *     directory, raise DistutilsFileError.  If 'dst' does not exist, it is
		 *     created with 'mkpath()'.  The end result of the copy is that every
		 *     file in 'src' is copied to 'dst', and directories under 'src' are
		 *     recursively copied to 'dst'.  Return the list of files that were
		 *     copied or might have been copied, using their output name.  The
		 *     return value is unaffected by 'update' or 'dry_run': it is simply
		 *     the list of all files under 'src', with the names changed to be
		 *     under 'dst'.
		 * 
		 *     'preserve_mode' and 'preserve_times' are the same as for
		 *     'copy_file'; note that they only apply to regular files, not to
		 *     directories.  If 'preserve_symlinks' is true, symlinks will be
		 *     copied as symlinks (on platforms that support them!); otherwise
		 *     (the default), the destination of the symlink will be copied.
		 *     'update' and 'verbose' are the same as for 'copy_file'.
		 *     
		 */
		function copy_tree(src, dst, preserve_mode?, preserve_times?, preserve_symlinks?, update?, verbose?, dry_run?): Promise<any>
		function copy_tree$({ src, dst, preserve_mode, preserve_times, preserve_symlinks, update, verbose, dry_run }: { src, dst, preserve_mode?, preserve_times?, preserve_symlinks?, update?, verbose?, dry_run?}): Promise<any>

		/**
		 * Recursively remove an entire directory tree.
		 * 
		 *     Any errors are ignored (apart from being reported to stdout if 'verbose'
		 *     is true).
		 *     
		 */
		function remove_tree(directory, verbose?, dry_run?): Promise<any>
		function remove_tree$({ directory, verbose, dry_run }: { directory, verbose?, dry_run?}): Promise<any>

		/**
		 * Take the full path 'path', and make it a relative path.
		 * 
		 *     This is useful to make 'path' the second argument to os.path.join().
		 *     
		 */
		function ensure_relative(path): Promise<any>
		function ensure_relative$({ path }): Promise<any>
	}
	module dist {
		var _

		/**
		 * Convert a 4-tuple 'help_options' list as found in various command
		 *     classes to the 3-tuple form required by FancyGetopt.
		 *     
		 */
		function fix_help_options(options): Promise<any>
		function fix_help_options$({ options }): Promise<any>

		/**
		 * The core of the Distutils.  Most of the work hiding behind 'setup'
		 *     is really done within a Distribution instance, which farms the work out
		 *     to the Distutils commands specified on the command line.
		 * 
		 *     Setup scripts will almost never instantiate Distribution directly,
		 *     unless the 'setup()' function is totally inadequate to their needs.
		 *     However, it is conceivable that a setup script might wish to subclass
		 *     Distribution for some specialized purpose, and then pass the subclass
		 *     to 'setup()' as the 'distclass' keyword argument.  If so, it is
		 *     necessary to respect the expectations that 'setup' has of Distribution.
		 *     See the code for 'setup()', in core.py, for details.
		 *     
		 */

		/**
		 * Construct a new Distribution instance: initialize all the
		 *         attributes of a Distribution, and then use 'attrs' (a dictionary
		 *         mapping attribute names to values) to assign some of those
		 *         attributes their "real" values.  (Any attributes not mentioned in
		 *         'attrs' will be assigned to some null value: 0, None, an empty list
		 *         or dictionary, etc.)  Most importantly, initialize the
		 *         'command_obj' attribute to the empty dictionary; this will be
		 *         filled in with real command objects by 'parse_command_line()'.
		 *         
		 */
		function Distribution(attrs?): Promise<IDistribution>
		function Distribution$({ attrs }: { attrs?}): Promise<IDistribution>
		interface IDistribution {

			/**
			 * Get the option dictionary for a given command.  If that
			 *         command's option dictionary hasn't been created yet, then create it
			 *         and return the new dictionary; otherwise, return the existing
			 *         option dictionary.
			 *         
			 */
			get_option_dict(command): Promise<any>
			get_option_dict$({ command }): Promise<any>
			dump_option_dicts(header?, commands?, indent?): Promise<any>
			dump_option_dicts$({ header, commands, indent }: { header?, commands?, indent?}): Promise<any>

			/**
			 * Find as many configuration files as should be processed for this
			 *         platform, and return a list of filenames in the order in which they
			 *         should be parsed.  The filenames returned are guaranteed to exist
			 *         (modulo nasty race conditions).
			 * 
			 *         There are three possible config files: distutils.cfg in the
			 *         Distutils installation directory (ie. where the top-level
			 *         Distutils __inst__.py file lives), a file in the user's home
			 *         directory named .pydistutils.cfg on Unix and pydistutils.cfg
			 *         on Windows/Mac; and setup.cfg in the current directory.
			 * 
			 *         The file in the user's home directory can be disabled with the
			 *         --no-user-cfg option.
			 *         
			 */
			find_config_files(): Promise<any>
			find_config_files$($: {}): Promise<any>
			parse_config_files(filenames?): Promise<any>
			parse_config_files$({ filenames }: { filenames?}): Promise<any>

			/**
			 * Parse the setup script's command line, taken from the
			 *         'script_args' instance attribute (which defaults to 'sys.argv[1:]'
			 *         -- see 'setup()' in core.py).  This list is first processed for
			 *         "global options" -- options that set attributes of the Distribution
			 *         instance.  Then, it is alternately scanned for Distutils commands
			 *         and options for that command.  Each new command terminates the
			 *         options for the previous command.  The allowed options for a
			 *         command are determined by the 'user_options' attribute of the
			 *         command class -- thus, we have to be able to load command classes
			 *         in order to parse the command line.  Any error in that 'options'
			 *         attribute raises DistutilsGetoptError; any error on the
			 *         command-line raises DistutilsArgError.  If no Distutils commands
			 *         were found on the command line, raises DistutilsArgError.  Return
			 *         true if command-line was successfully parsed and we should carry
			 *         on with executing commands; false if no errors but we shouldn't
			 *         execute commands (currently, this only happens if user asks for
			 *         help).
			 *         
			 */
			parse_command_line(): Promise<any>
			parse_command_line$($: {}): Promise<any>

			/**
			 * Set final values for all the options on the Distribution
			 *         instance, analogous to the .finalize_options() method of Command
			 *         objects.
			 *         
			 */
			finalize_options(): Promise<any>
			finalize_options$($: {}): Promise<any>

			/**
			 * If there were any non-global "display-only" options
			 *         (--help-commands or the metadata display options) on the command
			 *         line, display the requested info and return true; else return
			 *         false.
			 *         
			 */
			handle_display_options(option_order): Promise<any>
			handle_display_options$({ option_order }): Promise<any>

			/**
			 * Print a subset of the list of all commands -- used by
			 *         'print_commands()'.
			 *         
			 */
			print_command_list(commands, header, max_length): Promise<any>
			print_command_list$({ commands, header, max_length }): Promise<any>

			/**
			 * Print out a help message listing all available commands with a
			 *         description of each.  The list is divided into "standard commands"
			 *         (listed in distutils.command.__all__) and "extra commands"
			 *         (mentioned in self.cmdclass, but not a standard command).  The
			 *         descriptions come from the command class attribute
			 *         'description'.
			 *         
			 */
			print_commands(): Promise<any>
			print_commands$($: {}): Promise<any>

			/**
			 * Get a list of (command, description) tuples.
			 *         The list is divided into "standard commands" (listed in
			 *         distutils.command.__all__) and "extra commands" (mentioned in
			 *         self.cmdclass, but not a standard command).  The descriptions come
			 *         from the command class attribute 'description'.
			 *         
			 */
			get_command_list(): Promise<any>
			get_command_list$($: {}): Promise<any>

			/**
			 * Return a list of packages from which commands are loaded.
			 */
			get_command_packages(): Promise<any>
			get_command_packages$($: {}): Promise<any>

			/**
			 * Return the class that implements the Distutils command named by
			 *         'command'.  First we check the 'cmdclass' dictionary; if the
			 *         command is mentioned there, we fetch the class object from the
			 *         dictionary and return it.  Otherwise we load the command module
			 *         ("distutils.command." + command) and fetch the command class from
			 *         the module.  The loaded class is also stored in 'cmdclass'
			 *         to speed future calls to 'get_command_class()'.
			 * 
			 *         Raises DistutilsModuleError if the expected module could not be
			 *         found, or if that module does not define the expected class.
			 *         
			 */
			get_command_class(command): Promise<any>
			get_command_class$({ command }): Promise<any>

			/**
			 * Return the command object for 'command'.  Normally this object
			 *         is cached on a previous call to 'get_command_obj()'; if no command
			 *         object for 'command' is in the cache, then we either create and
			 *         return it (if 'create' is true) or return None.
			 *         
			 */
			get_command_obj(command, create?): Promise<any>
			get_command_obj$({ command, create }: { command, create?}): Promise<any>

			/**
			 * Reinitializes a command to the state it was in when first
			 *         returned by 'get_command_obj()': ie., initialized but not yet
			 *         finalized.  This provides the opportunity to sneak option
			 *         values in programmatically, overriding or supplementing
			 *         user-supplied values from the config files and command line.
			 *         You'll have to re-finalize the command object (by calling
			 *         'finalize_options()' or 'ensure_finalized()') before using it for
			 *         real.
			 * 
			 *         'command' should be a command name (string) or command object.  If
			 *         'reinit_subcommands' is true, also reinitializes the command's
			 *         sub-commands, as declared by the 'sub_commands' class attribute (if
			 *         it has one).  See the "install" command for an example.  Only
			 *         reinitializes the sub-commands that actually matter, ie. those
			 *         whose test predicates return true.
			 * 
			 *         Returns the reinitialized command object.
			 *         
			 */
			reinitialize_command(command, reinit_subcommands?): Promise<any>
			reinitialize_command$({ command, reinit_subcommands }: { command, reinit_subcommands?}): Promise<any>
			announce(msg, level?): Promise<any>
			announce$({ msg, level }: { msg, level?}): Promise<any>

			/**
			 * Run each command that was seen on the setup script command line.
			 *         Uses the list of commands found and cache of command objects
			 *         created by 'get_command_obj()'.
			 *         
			 */
			run_commands(): Promise<any>
			run_commands$($: {}): Promise<any>

			/**
			 * Do whatever it takes to run a command (including nothing at all,
			 *         if the command has already been run).  Specifically: if we have
			 *         already created and run the command named by 'command', return
			 *         silently without doing anything.  If the command named by 'command'
			 *         doesn't even have a command object yet, create one.  Then invoke
			 *         'run()' on that command object (or an existing one).
			 *         
			 */
			run_command(command): Promise<any>
			run_command$({ command }): Promise<any>
			has_pure_modules(): Promise<any>
			has_pure_modules$($: {}): Promise<any>
			has_ext_modules(): Promise<any>
			has_ext_modules$($: {}): Promise<any>
			has_c_libraries(): Promise<any>
			has_c_libraries$($: {}): Promise<any>
			has_modules(): Promise<any>
			has_modules$($: {}): Promise<any>
			has_headers(): Promise<any>
			has_headers$($: {}): Promise<any>
			has_scripts(): Promise<any>
			has_scripts$($: {}): Promise<any>
			has_data_files(): Promise<any>
			has_data_files$($: {}): Promise<any>
			is_pure(): Promise<any>
			is_pure$($: {}): Promise<any>
			global_options
			common_usage
			display_options
			display_option_names
			negative_opt
		}

		/**
		 * Dummy class to hold the distribution meta-data: name, version,
		 *     author, and so forth.
		 *     
		 */
		function DistributionMetadata(path?): Promise<IDistributionMetadata>
		function DistributionMetadata$({ path }: { path?}): Promise<IDistributionMetadata>
		interface IDistributionMetadata {

			/**
			 * Reads the metadata values from a file object.
			 */
			read_pkg_file(file): Promise<any>
			read_pkg_file$({ file }): Promise<any>

			/**
			 * Write the PKG-INFO file into the release tree.
			 *         
			 */
			write_pkg_info(base_dir): Promise<any>
			write_pkg_info$({ base_dir }): Promise<any>

			/**
			 * Write the PKG-INFO format data to a file object.
			 *         
			 */
			write_pkg_file(file): Promise<any>
			write_pkg_file$({ file }): Promise<any>
			get_name(): Promise<any>
			get_name$($: {}): Promise<any>
			get_version(): Promise<any>
			get_version$($: {}): Promise<any>
			get_fullname(): Promise<any>
			get_fullname$($: {}): Promise<any>
			get_author(): Promise<any>
			get_author$($: {}): Promise<any>
			get_author_email(): Promise<any>
			get_author_email$($: {}): Promise<any>
			get_maintainer(): Promise<any>
			get_maintainer$($: {}): Promise<any>
			get_maintainer_email(): Promise<any>
			get_maintainer_email$($: {}): Promise<any>
			get_contact(): Promise<any>
			get_contact$($: {}): Promise<any>
			get_contact_email(): Promise<any>
			get_contact_email$($: {}): Promise<any>
			get_url(): Promise<any>
			get_url$($: {}): Promise<any>
			get_license(): Promise<any>
			get_license$($: {}): Promise<any>
			get_description(): Promise<any>
			get_description$($: {}): Promise<any>
			get_long_description(): Promise<any>
			get_long_description$($: {}): Promise<any>
			get_keywords(): Promise<any>
			get_keywords$($: {}): Promise<any>
			set_keywords(value): Promise<any>
			set_keywords$({ value }): Promise<any>
			get_platforms(): Promise<any>
			get_platforms$($: {}): Promise<any>
			set_platforms(value): Promise<any>
			set_platforms$({ value }): Promise<any>
			get_classifiers(): Promise<any>
			get_classifiers$($: {}): Promise<any>
			set_classifiers(value): Promise<any>
			set_classifiers$({ value }): Promise<any>
			get_download_url(): Promise<any>
			get_download_url$($: {}): Promise<any>
			get_requires(): Promise<any>
			get_requires$($: {}): Promise<any>
			set_requires(value): Promise<any>
			set_requires$({ value }): Promise<any>
			get_provides(): Promise<any>
			get_provides$($: {}): Promise<any>
			set_provides(value): Promise<any>
			set_provides$({ value }): Promise<any>
			get_obsoletes(): Promise<any>
			get_obsoletes$($: {}): Promise<any>
			set_obsoletes(value): Promise<any>
			set_obsoletes$({ value }): Promise<any>
			get_licence
		}
		let command_re: Promise<any>
	}
	module errors {
		var _

		/**
		 * The root of all Distutils evil.
		 */
		interface IDistutilsError {
		}

		/**
		 * Unable to load an expected module, or to find an expected class
		 *     within some module (in particular, command modules and classes).
		 */
		interface IDistutilsModuleError extends IDistutilsError {
		}

		/**
		 * Some command class (or possibly distribution class, if anyone
		 *     feels a need to subclass Distribution) is found not to be holding
		 *     up its end of the bargain, ie. implementing some part of the
		 *     "command "interface.
		 */
		interface IDistutilsClassError extends IDistutilsError {
		}

		/**
		 * The option table provided to 'fancy_getopt()' is bogus.
		 */
		interface IDistutilsGetoptError extends IDistutilsError {
		}

		/**
		 * Raised by fancy_getopt in response to getopt.error -- ie. an
		 *     error in the command line usage.
		 */
		interface IDistutilsArgError extends IDistutilsError {
		}

		/**
		 * Any problems in the filesystem: expected file not found, etc.
		 *     Typically this is for problems that we detect before OSError
		 *     could be raised.
		 */
		interface IDistutilsFileError extends IDistutilsError {
		}

		/**
		 * Syntactic/semantic errors in command options, such as use of
		 *     mutually conflicting options, or inconsistent options,
		 *     badly-spelled values, etc.  No distinction is made between option
		 *     values originating in the setup script, the command line, config
		 *     files, or what-have-you -- but if we *know* something originated in
		 *     the setup script, we'll raise DistutilsSetupError instead.
		 */
		interface IDistutilsOptionError extends IDistutilsError {
		}

		/**
		 * For errors that can be definitely blamed on the setup script,
		 *     such as invalid keyword arguments to 'setup()'.
		 */
		interface IDistutilsSetupError extends IDistutilsError {
		}

		/**
		 * We don't know how to do something on the current platform (but
		 *     we do know how to do it on some platform) -- eg. trying to compile
		 *     C files on a platform not supported by a CCompiler subclass.
		 */
		interface IDistutilsPlatformError extends IDistutilsError {
		}

		/**
		 * Any problems executing an external program (such as the C
		 *     compiler, when compiling C files).
		 */
		interface IDistutilsExecError extends IDistutilsError {
		}

		/**
		 * Internal inconsistencies or impossibilities (obviously, this
		 *     should never be seen if the code is working!).
		 */
		interface IDistutilsInternalError extends IDistutilsError {
		}

		/**
		 * Syntax error in a file list template.
		 */
		interface IDistutilsTemplateError extends IDistutilsError {
		}

		/**
		 * Byte compile error.
		 */
		interface IDistutilsByteCompileError extends IDistutilsError {
		}

		/**
		 * Some compile/link operation failed.
		 */
		interface ICCompilerError {
		}

		/**
		 * Failure to preprocess one or more C/C++ files.
		 */
		interface IPreprocessError extends ICCompilerError {
		}

		/**
		 * Failure to compile one or more C/C++ source files.
		 */
		interface ICompileError extends ICCompilerError {
		}

		/**
		 * Failure to create a static library from one or more C/C++ object
		 *     files.
		 */
		interface ILibError extends ICCompilerError {
		}

		/**
		 * Failure to link one or more C/C++ object files into an executable
		 *     or shared library file.
		 */
		interface ILinkError extends ICCompilerError {
		}

		/**
		 * Attempt to process an unknown file type.
		 */
		interface IUnknownFileError extends ICCompilerError {
		}
	}
	module extension {
		var _

		/**
		 * Reads a Setup file and returns Extension instances.
		 */
		function read_setup_file(filename): Promise<any>
		function read_setup_file$({ filename }): Promise<any>

		/**
		 * Just a collection of attributes that describes an extension
		 *     module and everything needed to build it (hopefully in a portable
		 *     way, but there are hooks that let you be as unportable as you need).
		 * 
		 *     Instance attributes:
		 *       name : string
		 *         the full name of the extension, including any packages -- ie.
		 *         *not* a filename or pathname, but Python dotted name
		 *       sources : [string]
		 *         list of source filenames, relative to the distribution root
		 *         (where the setup script lives), in Unix form (slash-separated)
		 *         for portability.  Source files may be C, C++, SWIG (.i),
		 *         platform-specific resource files, or whatever else is recognized
		 *         by the "build_ext" command as source for a Python extension.
		 *       include_dirs : [string]
		 *         list of directories to search for C/C++ header files (in Unix
		 *         form for portability)
		 *       define_macros : [(name : string, value : string|None)]
		 *         list of macros to define; each macro is defined using a 2-tuple,
		 *         where 'value' is either the string to define it to or None to
		 *         define it without a particular value (equivalent of "#define
		 *         FOO" in source or -DFOO on Unix C compiler command line)
		 *       undef_macros : [string]
		 *         list of macros to undefine explicitly
		 *       library_dirs : [string]
		 *         list of directories to search for C/C++ libraries at link time
		 *       libraries : [string]
		 *         list of library names (not filenames or paths) to link against
		 *       runtime_library_dirs : [string]
		 *         list of directories to search for C/C++ libraries at run time
		 *         (for shared extensions, this is when the extension is loaded)
		 *       extra_objects : [string]
		 *         list of extra files to link with (eg. object files not implied
		 *         by 'sources', static library that must be explicitly specified,
		 *         binary resource files, etc.)
		 *       extra_compile_args : [string]
		 *         any extra platform- and compiler-specific information to use
		 *         when compiling the source files in 'sources'.  For platforms and
		 *         compilers where "command line" makes sense, this is typically a
		 *         list of command-line arguments, but for other platforms it could
		 *         be anything.
		 *       extra_link_args : [string]
		 *         any extra platform- and compiler-specific information to use
		 *         when linking object files together to create the extension (or
		 *         to create a new static Python interpreter).  Similar
		 *         interpretation as for 'extra_compile_args'.
		 *       export_symbols : [string]
		 *         list of symbols to be exported from a shared extension.  Not
		 *         used on all platforms, and not generally necessary for Python
		 *         extensions, which typically export exactly one symbol: "init" +
		 *         extension_name.
		 *       swig_opts : [string]
		 *         any extra options to pass to SWIG if a source file has the .i
		 *         extension.
		 *       depends : [string]
		 *         list of files that the extension depends on
		 *       language : string
		 *         extension language (i.e. "c", "c++", "objc"). Will be detected
		 *         from the source extensions if not provided.
		 *       optional : boolean
		 *         specifies that a build failure in the extension should not abort the
		 *         build process, but simply not install the failing extension.
		 *     
		 */
		function Extension(name, sources, include_dirs?, define_macros?, undef_macros?, library_dirs?, libraries?, runtime_library_dirs?, extra_objects?, extra_compile_args?, extra_link_args?, export_symbols?, swig_opts?, depends?, language?, optional?): Promise<IExtension>
		function Extension$({ name, sources, include_dirs, define_macros, undef_macros, library_dirs, libraries, runtime_library_dirs, extra_objects, extra_compile_args, extra_link_args, export_symbols, swig_opts, depends, language, optional }: { name, sources, include_dirs?, define_macros?, undef_macros?, library_dirs?, libraries?, runtime_library_dirs?, extra_objects?, extra_compile_args?, extra_link_args?, export_symbols?, swig_opts?, depends?, language?, optional?}): Promise<IExtension>
		interface IExtension {
		}
	}
	module fancy_getopt {
		var _
		function fancy_getopt(options, negative_opt, object, args): Promise<any>
		function fancy_getopt$({ options, negative_opt, object, args }): Promise<any>

		/**
		 * wrap_text(text : string, width : int) -> [string]
		 * 
		 *     Split 'text' into multiple lines of no more than 'width' characters
		 *     each, and return the list of strings that results.
		 *     
		 */
		function wrap_text(text, width): Promise<any>
		function wrap_text$({ text, width }): Promise<any>

		/**
		 * Convert a long option name to a valid Python identifier by
		 *     changing "-" to "_".
		 *     
		 */
		function translate_longopt(opt): Promise<any>
		function translate_longopt$({ opt }): Promise<any>

		/**
		 * Wrapper around the standard 'getopt()' module that provides some
		 *     handy extra functionality:
		 *       * short and long options are tied together
		 *       * options have help strings, and help text can be assembled
		 *         from them
		 *       * options set attributes of a passed-in object
		 *       * boolean options can have "negative aliases" -- eg. if
		 *         --quiet is the "negative alias" of --verbose, then "--quiet"
		 *         on the command line sets 'verbose' to false
		 *     
		 */
		function FancyGetopt(option_table?): Promise<IFancyGetopt>
		function FancyGetopt$({ option_table }: { option_table?}): Promise<IFancyGetopt>
		interface IFancyGetopt {
			set_option_table(option_table): Promise<any>
			set_option_table$({ option_table }): Promise<any>
			add_option(long_option, short_option?, help_string?): Promise<any>
			add_option$({ long_option, short_option, help_string }: { long_option, short_option?, help_string?}): Promise<any>

			/**
			 * Return true if the option table for this parser has an
			 *         option with long name 'long_option'.
			 */
			has_option(long_option): Promise<any>
			has_option$({ long_option }): Promise<any>

			/**
			 * Translate long option name 'long_option' to the form it
			 *         has as an attribute of some object: ie., translate hyphens
			 *         to underscores.
			 */
			get_attr_name(long_option): Promise<any>
			get_attr_name$({ long_option }): Promise<any>

			/**
			 * Set the aliases for this option parser.
			 */
			set_aliases(alias): Promise<any>
			set_aliases$({ alias }): Promise<any>

			/**
			 * Set the negative aliases for this option parser.
			 *         'negative_alias' should be a dictionary mapping option names to
			 *         option names, both the key and value must already be defined
			 *         in the option table.
			 */
			set_negative_aliases(negative_alias): Promise<any>
			set_negative_aliases$({ negative_alias }): Promise<any>

			/**
			 * Parse command-line options in args. Store as attributes on object.
			 * 
			 *         If 'args' is None or not supplied, uses 'sys.argv[1:]'.  If
			 *         'object' is None or not supplied, creates a new OptionDummy
			 *         object, stores option values there, and returns a tuple (args,
			 *         object).  If 'object' is supplied, it is modified in place and
			 *         'getopt()' just returns 'args'; in both cases, the returned
			 *         'args' is a modified copy of the passed-in 'args' list, which
			 *         is left untouched.
			 *         
			 */
			getopt(args?, object?): Promise<any>
			getopt$({ args, object }: { args?, object?}): Promise<any>

			/**
			 * Returns the list of (option, value) tuples processed by the
			 *         previous run of 'getopt()'.  Raises RuntimeError if
			 *         'getopt()' hasn't been called yet.
			 *         
			 */
			get_option_order(): Promise<any>
			get_option_order$($: {}): Promise<any>

			/**
			 * Generate help text (a list of strings, one per suggested line of
			 *         output) from the option table for this FancyGetopt object.
			 *         
			 */
			generate_help(header?): Promise<any>
			generate_help$({ header }: { header?}): Promise<any>
			print_help(header?, file?): Promise<any>
			print_help$({ header, file }: { header?, file?}): Promise<any>
		}

		/**
		 * Dummy class just used as a place to hold command-line option
		 *     values as instance attributes.
		 */

		/**
		 * Create a new OptionDummy instance.  The attributes listed in
		 *         'options' will be initialized to None.
		 */
		function OptionDummy(options?): Promise<IOptionDummy>
		function OptionDummy$({ options }: { options?}): Promise<IOptionDummy>
		interface IOptionDummy {
		}
		let longopt_pat: Promise<any>
		let longopt_re: Promise<any>
		let neg_alias_re: Promise<any>
		let longopt_xlate: Promise<any>
		let WS_TRANS: Promise<any>
		let text: Promise<any>
	}
	module file_util {
		var _

		/**
		 * Copy a file 'src' to 'dst'.  If 'dst' is a directory, then 'src' is
		 *     copied there with the same name; otherwise, it must be a filename.  (If
		 *     the file exists, it will be ruthlessly clobbered.)  If 'preserve_mode'
		 *     is true (the default), the file's mode (type and permission bits, or
		 *     whatever is analogous on the current platform) is copied.  If
		 *     'preserve_times' is true (the default), the last-modified and
		 *     last-access times are copied as well.  If 'update' is true, 'src' will
		 *     only be copied if 'dst' does not exist, or if 'dst' does exist but is
		 *     older than 'src'.
		 * 
		 *     'link' allows you to make hard links (os.link) or symbolic links
		 *     (os.symlink) instead of copying: set it to "hard" or "sym"; if it is
		 *     None (the default), files are copied.  Don't set 'link' on systems that
		 *     don't support it: 'copy_file()' doesn't check if hard or symbolic
		 *     linking is available. If hardlink fails, falls back to
		 *     _copy_file_contents().
		 * 
		 *     Under Mac OS, uses the native file copy function in macostools; on
		 *     other systems, uses '_copy_file_contents()' to copy file contents.
		 * 
		 *     Return a tuple (dest_name, copied): 'dest_name' is the actual name of
		 *     the output file, and 'copied' is true if the file was copied (or would
		 *     have been copied, if 'dry_run' true).
		 *     
		 */
		function copy_file(src, dst, preserve_mode?, preserve_times?, update?, link?, verbose?, dry_run?): Promise<any>
		function copy_file$({ src, dst, preserve_mode, preserve_times, update, link, verbose, dry_run }: { src, dst, preserve_mode?, preserve_times?, update?, link?, verbose?, dry_run?}): Promise<any>

		/**
		 * Move a file 'src' to 'dst'.  If 'dst' is a directory, the file will
		 *     be moved into it with the same name; otherwise, 'src' is just renamed
		 *     to 'dst'.  Return the new full name of the file.
		 * 
		 *     Handles cross-device moves on Unix using 'copy_file()'.  What about
		 *     other systems???
		 *     
		 */
		function move_file(src, dst, verbose?, dry_run?): Promise<any>
		function move_file$({ src, dst, verbose, dry_run }: { src, dst, verbose?, dry_run?}): Promise<any>

		/**
		 * Create a file with the specified name and write 'contents' (a
		 *     sequence of strings without line terminators) to it.
		 *     
		 */
		function write_file(filename, contents): Promise<any>
		function write_file$({ filename, contents }): Promise<any>
	}
	module filelist {
		var _

		/**
		 * 
		 *     Find all files under 'dir' and return the list of full filenames.
		 *     Unless dir is '.', return full filenames with dir prepended.
		 *     
		 */
		function findall(dir?): Promise<any>
		function findall$({ dir }: { dir?}): Promise<any>

		/**
		 * Translate a shell-like glob pattern to a regular expression; return
		 *     a string containing the regex.  Differs from 'fnmatch.translate()' in
		 *     that '*' does not match "special characters" (which are
		 *     platform-specific).
		 *     
		 */
		function glob_to_re(pattern): Promise<any>
		function glob_to_re$({ pattern }): Promise<any>

		/**
		 * Translate a shell-like wildcard pattern to a compiled regular
		 *     expression.  Return the compiled regex.  If 'is_regex' true,
		 *     then 'pattern' is directly compiled to a regex (if it's a string)
		 *     or just returned as-is (assumes it's a regex object).
		 *     
		 */
		function translate_pattern(pattern, anchor?, prefix?, is_regex?): Promise<any>
		function translate_pattern$({ pattern, anchor, prefix, is_regex }: { pattern, anchor?, prefix?, is_regex?}): Promise<any>

		/**
		 * A list of files built by on exploring the filesystem and filtered by
		 *     applying various patterns to what we find there.
		 * 
		 *     Instance attributes:
		 *       dir
		 *         directory from which files will be taken -- only used if
		 *         'allfiles' not supplied to constructor
		 *       files
		 *         list of filenames currently being built/filtered/manipulated
		 *       allfiles
		 *         complete list of files under consideration (ie. without any
		 *         filtering applied)
		 *     
		 */
		function FileList(warn?, debug_print?): Promise<IFileList>
		function FileList$({ warn, debug_print }: { warn?, debug_print?}): Promise<IFileList>
		interface IFileList {
			set_allfiles(allfiles): Promise<any>
			set_allfiles$({ allfiles }): Promise<any>
			findall(dir?): Promise<any>
			findall$({ dir }: { dir?}): Promise<any>

			/**
			 * Print 'msg' to stdout if the global DEBUG (taken from the
			 *         DISTUTILS_DEBUG environment variable) flag is true.
			 *         
			 */
			debug_print(msg): Promise<any>
			debug_print$({ msg }): Promise<any>
			append(item): Promise<any>
			append$({ item }): Promise<any>
			extend(items): Promise<any>
			extend$({ items }): Promise<any>
			sort(): Promise<any>
			sort$($: {}): Promise<any>
			remove_duplicates(): Promise<any>
			remove_duplicates$($: {}): Promise<any>
			process_template_line(line): Promise<any>
			process_template_line$({ line }): Promise<any>

			/**
			 * Select strings (presumably filenames) from 'self.files' that
			 *         match 'pattern', a Unix-style wildcard (glob) pattern.  Patterns
			 *         are not quite the same as implemented by the 'fnmatch' module: '*'
			 *         and '?'  match non-special characters, where "special" is platform-
			 *         dependent: slash on Unix; colon, slash, and backslash on
			 *         DOS/Windows; and colon on Mac OS.
			 * 
			 *         If 'anchor' is true (the default), then the pattern match is more
			 *         stringent: "*.py" will match "foo.py" but not "foo/bar.py".  If
			 *         'anchor' is false, both of these will match.
			 * 
			 *         If 'prefix' is supplied, then only filenames starting with 'prefix'
			 *         (itself a pattern) and ending with 'pattern', with anything in between
			 *         them, will match.  'anchor' is ignored in this case.
			 * 
			 *         If 'is_regex' is true, 'anchor' and 'prefix' are ignored, and
			 *         'pattern' is assumed to be either a string containing a regex or a
			 *         regex object -- no translation is done, the regex is just compiled
			 *         and used as-is.
			 * 
			 *         Selected strings will be added to self.files.
			 * 
			 *         Return True if files are found, False otherwise.
			 *         
			 */
			include_pattern(pattern, anchor?, prefix?, is_regex?): Promise<any>
			include_pattern$({ pattern, anchor, prefix, is_regex }: { pattern, anchor?, prefix?, is_regex?}): Promise<any>

			/**
			 * Remove strings (presumably filenames) from 'files' that match
			 *         'pattern'.  Other parameters are the same as for
			 *         'include_pattern()', above.
			 *         The list 'self.files' is modified in place.
			 *         Return True if files are found, False otherwise.
			 *         
			 */
			exclude_pattern(pattern, anchor?, prefix?, is_regex?): Promise<any>
			exclude_pattern$({ pattern, anchor, prefix, is_regex }: { pattern, anchor?, prefix?, is_regex?}): Promise<any>
		}
	}
	module log {
		var _
		function set_threshold(level): Promise<any>
		function set_threshold$({ level }): Promise<any>
		function set_verbosity(v): Promise<any>
		function set_verbosity$({ v }): Promise<any>
		function Log(threshold?): Promise<ILog>
		function Log$({ threshold }: { threshold?}): Promise<ILog>
		interface ILog {
			log(level, msg): Promise<any>
			log$({ level, msg }): Promise<any>
			debug(msg): Promise<any>
			debug$({ msg }): Promise<any>
			info(msg): Promise<any>
			info$({ msg }): Promise<any>
			warn(msg): Promise<any>
			warn$({ msg }): Promise<any>
			error(msg): Promise<any>
			error$({ msg }): Promise<any>
			fatal(msg): Promise<any>
			fatal$({ msg }): Promise<any>
		}
		let DEBUG: Promise<any>
		let INFO: Promise<any>
		let WARN: Promise<any>
		let ERROR: Promise<any>
		let FATAL: Promise<any>
	}
	module msvc9compiler {
		var _

		/**
		 * Return the version of MSVC that was used to build Python.
		 * 
		 *     For Python 2.3 and up, the version number is included in
		 *     sys.version.  For earlier versions, assume the compiler is MSVC 6.
		 *     
		 */
		function get_build_version(): Promise<any>
		function get_build_version$($: {}): Promise<any>

		/**
		 * Return a list of normalized paths with duplicates removed.
		 * 
		 *     The current order of paths is maintained.
		 *     
		 */
		function normalize_and_reduce_paths(paths): Promise<any>
		function normalize_and_reduce_paths$({ paths }): Promise<any>

		/**
		 * Remove duplicate values of an environment variable.
		 *     
		 */
		function removeDuplicates(variable): Promise<any>
		function removeDuplicates$({ variable }): Promise<any>

		/**
		 * Find the vcvarsall.bat file
		 * 
		 *     At first it tries to find the productdir of VS 2008 in the registry. If
		 *     that fails it falls back to the VS90COMNTOOLS env var.
		 *     
		 */
		function find_vcvarsall(version): Promise<any>
		function find_vcvarsall$({ version }): Promise<any>

		/**
		 * Launch vcvarsall.bat and read the settings from its environment
		 *     
		 */
		function query_vcvarsall(version, arch?): Promise<any>
		function query_vcvarsall$({ version, arch }: { version, arch?}): Promise<any>

		/**
		 * Helper class to read values from the registry
		 *     
		 */
		interface IReg {
			get_value(path, key): Promise<any>
			get_value$({ path, key }): Promise<any>

			/**
			 * Return list of registry keys.
			 */
			read_keys(base, key): Promise<any>
			read_keys$({ base, key }): Promise<any>

			/**
			 * Return dict of registry keys and values.
			 * 
			 *         All names are converted to lowercase.
			 *         
			 */
			read_values(base, key): Promise<any>
			read_values$({ base, key }): Promise<any>
			convert_mbcs(): Promise<any>
			convert_mbcs$($: {}): Promise<any>
		}
		function MacroExpander(version): Promise<IMacroExpander>
		function MacroExpander$({ version }): Promise<IMacroExpander>
		interface IMacroExpander {
			set_macro(macro, path, key): Promise<any>
			set_macro$({ macro, path, key }): Promise<any>
			load_macros(version): Promise<any>
			load_macros$({ version }): Promise<any>
			sub(s): Promise<any>
			sub$({ s }): Promise<any>
		}

		/**
		 * Concrete class that implements an interface to Microsoft Visual C++,
		 *        as defined by the CCompiler abstract class.
		 */
		function MSVCCompiler(verbose?, dry_run?, force?): Promise<IMSVCCompiler>
		function MSVCCompiler$({ verbose, dry_run, force }: { verbose?, dry_run?, force?}): Promise<IMSVCCompiler>
		interface IMSVCCompiler {
			initialize(plat_name?): Promise<any>
			initialize$({ plat_name }: { plat_name?}): Promise<any>
			object_filenames(source_filenames, strip_dir?, output_dir?): Promise<any>
			object_filenames$({ source_filenames, strip_dir, output_dir }: { source_filenames, strip_dir?, output_dir?}): Promise<any>
			compile(sources, output_dir?, macros?, include_dirs?, debug?, extra_preargs?, extra_postargs?, depends?): Promise<any>
			compile$({ sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends }: { sources, output_dir?, macros?, include_dirs?, debug?, extra_preargs?, extra_postargs?, depends?}): Promise<any>
			create_static_lib(objects, output_libname, output_dir?, debug?, target_lang?): Promise<any>
			create_static_lib$({ objects, output_libname, output_dir, debug, target_lang }: { objects, output_libname, output_dir?, debug?, target_lang?}): Promise<any>
			link(target_desc, objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?): Promise<any>
			link$({ target_desc, objects, output_filename, output_dir, libraries, library_dirs, runtime_library_dirs, export_symbols, debug, extra_preargs, extra_postargs, build_temp, target_lang }: { target_desc, objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?}): Promise<any>
			manifest_setup_ldargs(output_filename, build_temp, ld_args): Promise<any>
			manifest_setup_ldargs$({ output_filename, build_temp, ld_args }): Promise<any>
			manifest_get_embed_info(target_desc, ld_args): Promise<any>
			manifest_get_embed_info$({ target_desc, ld_args }): Promise<any>
			library_dir_option(dir): Promise<any>
			library_dir_option$({ dir }): Promise<any>
			runtime_library_dir_option(dir): Promise<any>
			runtime_library_dir_option$({ dir }): Promise<any>
			library_option(lib): Promise<any>
			library_option$({ lib }): Promise<any>
			find_library_file(dirs, lib, debug?): Promise<any>
			find_library_file$({ dirs, lib, debug }: { dirs, lib, debug?}): Promise<any>

			/**
			 * Return path to an MSVC executable program.
			 * 
			 *         Tries to find the program in several places: first, one of the
			 *         MSVC program search paths from the registry; next, the directories
			 *         in the PATH environment variable.  If any of those work, return an
			 *         absolute path that is known to exist.  If none of them work, just
			 *         return the original program name, 'exe'.
			 *         
			 */
			find_exe(exe): Promise<any>
			find_exe$({ exe }): Promise<any>
			compiler_type
			executables
			src_extensions
			res_extension
			obj_extension
			static_lib_extension
			shared_lib_extension
			static_lib_format
			shared_lib_format
			exe_extension
		}
		let RegOpenKeyEx: Promise<any>
		let RegEnumKey: Promise<any>
		let RegEnumValue: Promise<any>
		let RegError: Promise<any>
		let HKEYS: Promise<any>
		let NATIVE_WIN64: Promise<any>
		let VS_BASE: Promise<any>
		let WINSDK_BASE: Promise<any>
		let NET_BASE: Promise<any>
		let PLAT_TO_VCVARS: Promise<any>
		let VERSION: Promise<any>
	}
	module msvccompiler {
		var _

		/**
		 * Return list of registry keys.
		 */
		function read_keys(base, key): Promise<any>
		function read_keys$({ base, key }): Promise<any>

		/**
		 * Return dict of registry keys and values.
		 * 
		 *     All names are converted to lowercase.
		 *     
		 */
		function read_values(base, key): Promise<any>
		function read_values$({ base, key }): Promise<any>
		function convert_mbcs(s): Promise<any>
		function convert_mbcs$({ s }): Promise<any>

		/**
		 * Return the version of MSVC that was used to build Python.
		 * 
		 *     For Python 2.3 and up, the version number is included in
		 *     sys.version.  For earlier versions, assume the compiler is MSVC 6.
		 *     
		 */
		function get_build_version(): Promise<any>
		function get_build_version$($: {}): Promise<any>

		/**
		 * Return the processor architecture.
		 * 
		 *     Possible results are "Intel" or "AMD64".
		 *     
		 */
		function get_build_architecture(): Promise<any>
		function get_build_architecture$($: {}): Promise<any>

		/**
		 * Return a list of normalized paths with duplicates removed.
		 * 
		 *     The current order of paths is maintained.
		 *     
		 */
		function normalize_and_reduce_paths(paths): Promise<any>
		function normalize_and_reduce_paths$({ paths }): Promise<any>
		function MacroExpander(version): Promise<IMacroExpander>
		function MacroExpander$({ version }): Promise<IMacroExpander>
		interface IMacroExpander {
			set_macro(macro, path, key): Promise<any>
			set_macro$({ macro, path, key }): Promise<any>
			load_macros(version): Promise<any>
			load_macros$({ version }): Promise<any>
			sub(s): Promise<any>
			sub$({ s }): Promise<any>
		}

		/**
		 * Concrete class that implements an interface to Microsoft Visual C++,
		 *        as defined by the CCompiler abstract class.
		 */
		function MSVCCompiler(verbose?, dry_run?, force?): Promise<IMSVCCompiler>
		function MSVCCompiler$({ verbose, dry_run, force }: { verbose?, dry_run?, force?}): Promise<IMSVCCompiler>
		interface IMSVCCompiler {
			initialize(): Promise<any>
			initialize$($: {}): Promise<any>
			object_filenames(source_filenames, strip_dir?, output_dir?): Promise<any>
			object_filenames$({ source_filenames, strip_dir, output_dir }: { source_filenames, strip_dir?, output_dir?}): Promise<any>
			compile(sources, output_dir?, macros?, include_dirs?, debug?, extra_preargs?, extra_postargs?, depends?): Promise<any>
			compile$({ sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends }: { sources, output_dir?, macros?, include_dirs?, debug?, extra_preargs?, extra_postargs?, depends?}): Promise<any>
			create_static_lib(objects, output_libname, output_dir?, debug?, target_lang?): Promise<any>
			create_static_lib$({ objects, output_libname, output_dir, debug, target_lang }: { objects, output_libname, output_dir?, debug?, target_lang?}): Promise<any>
			link(target_desc, objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?): Promise<any>
			link$({ target_desc, objects, output_filename, output_dir, libraries, library_dirs, runtime_library_dirs, export_symbols, debug, extra_preargs, extra_postargs, build_temp, target_lang }: { target_desc, objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?}): Promise<any>
			library_dir_option(dir): Promise<any>
			library_dir_option$({ dir }): Promise<any>
			runtime_library_dir_option(dir): Promise<any>
			runtime_library_dir_option$({ dir }): Promise<any>
			library_option(lib): Promise<any>
			library_option$({ lib }): Promise<any>
			find_library_file(dirs, lib, debug?): Promise<any>
			find_library_file$({ dirs, lib, debug }: { dirs, lib, debug?}): Promise<any>

			/**
			 * Return path to an MSVC executable program.
			 * 
			 *         Tries to find the program in several places: first, one of the
			 *         MSVC program search paths from the registry; next, the directories
			 *         in the PATH environment variable.  If any of those work, return an
			 *         absolute path that is known to exist.  If none of them work, just
			 *         return the original program name, 'exe'.
			 *         
			 */
			find_exe(exe): Promise<any>
			find_exe$({ exe }): Promise<any>

			/**
			 * Get a list of devstudio directories (include, lib or path).
			 * 
			 *         Return a list of strings.  The list will be empty if unable to
			 *         access the registry or appropriate registry keys not found.
			 *         
			 */
			get_msvc_paths(path, platform?): Promise<any>
			get_msvc_paths$({ path, platform }: { path, platform?}): Promise<any>

			/**
			 * Set environment variable 'name' to an MSVC path type value.
			 * 
			 *         This is equivalent to a SET command prior to execution of spawned
			 *         commands.
			 *         
			 */
			set_path_env_var(name): Promise<any>
			set_path_env_var$({ name }): Promise<any>
			compiler_type
			executables
			src_extensions
			res_extension
			obj_extension
			static_lib_extension
			shared_lib_extension
			static_lib_format
			shared_lib_format
			exe_extension
		}
		let hkey_mod: Promise<any>
		let RegOpenKeyEx: Promise<any>
		let RegEnumKey: Promise<any>
		let RegEnumValue: Promise<any>
		let RegError: Promise<any>
		let HKEYS: Promise<any>
		let OldMSVCCompiler: Promise<any>
	}
	module spawn {
		var _

		/**
		 * Run another program, specified as a command list 'cmd', in a new process.
		 * 
		 *     'cmd' is just the argument list for the new process, ie.
		 *     cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
		 *     There is no way to run a program with a name different from that of its
		 *     executable.
		 * 
		 *     If 'search_path' is true (the default), the system's executable
		 *     search path will be used to find the program; otherwise, cmd[0]
		 *     must be the exact path to the executable.  If 'dry_run' is true,
		 *     the command will not actually be run.
		 * 
		 *     Raise DistutilsExecError if running the program fails in any way; just
		 *     return on success.
		 *     
		 */
		function spawn(cmd, search_path?, verbose?, dry_run?): Promise<any>
		function spawn$({ cmd, search_path, verbose, dry_run }: { cmd, search_path?, verbose?, dry_run?}): Promise<any>

		/**
		 * Tries to find 'executable' in the directories listed in 'path'.
		 * 
		 *     A string listing directories separated by 'os.pathsep'; defaults to
		 *     os.environ['PATH'].  Returns the complete filename or None if not found.
		 *     
		 */
		function find_executable(executable, path?): Promise<any>
		function find_executable$({ executable, path }: { executable, path?}): Promise<any>
	}
	module sysconfig {
		var _
		function parse_config_h(fp, g?): Promise<any>
		function parse_config_h$({ fp, g }: { fp, g?}): Promise<any>

		/**
		 * Parse a Makefile-style file.
		 *     A dictionary containing name/value pairs is returned.  If an
		 *     optional dictionary is passed in as the second argument, it is
		 *     used instead of a new dictionary.
		 *     
		 */
		function parse_makefile(fn, g?): Promise<any>
		function parse_makefile$({ fn, g }: { fn, g?}): Promise<any>

		/**
		 * Do any platform-specific customization of a CCompiler instance.
		 * 
		 *     Mainly needed on Unix, so we can plug in the information that
		 *     varies across Unices and is stored in Python's Makefile.
		 *     
		 */
		function customize_compiler(compiler): Promise<any>
		function customize_compiler$({ compiler }): Promise<any>

		/**
		 * Return the directory containing installed Python header files.
		 * 
		 *     If 'plat_specific' is false (the default), this is the path to the
		 *     non-platform-specific header files, i.e. Python.h and so on;
		 *     otherwise, this is the path to platform-specific header files
		 *     (namely pyconfig.h).
		 * 
		 *     If 'prefix' is supplied, use it instead of sys.base_prefix or
		 *     sys.base_exec_prefix -- i.e., ignore 'plat_specific'.
		 *     
		 */
		function get_python_inc(plat_specific?, prefix?): Promise<any>
		function get_python_inc$({ plat_specific, prefix }: { plat_specific?, prefix?}): Promise<any>

		/**
		 * Return the directory containing the Python library (standard or
		 *     site additions).
		 * 
		 *     If 'plat_specific' is true, return the directory containing
		 *     platform-specific modules, i.e. any module from a non-pure-Python
		 *     module distribution; otherwise, return the platform-shared library
		 *     directory.  If 'standard_lib' is true, return the directory
		 *     containing standard Python library modules; otherwise, return the
		 *     directory for site-specific modules.
		 * 
		 *     If 'prefix' is supplied, use it instead of sys.base_prefix or
		 *     sys.base_exec_prefix -- i.e., ignore 'plat_specific'.
		 *     
		 */
		function get_python_lib(plat_specific?, standard_lib?, prefix?): Promise<any>
		function get_python_lib$({ plat_specific, standard_lib, prefix }: { plat_specific?, standard_lib?, prefix?}): Promise<any>
		let build_flags: Promise<any>
	}
	module text_file {
		var _

		/**
		 * Provides a file-like object that takes care of all the things you
		 *        commonly want to do when processing a text file that has some
		 *        line-by-line syntax: strip comments (as long as "#" is your
		 *        comment character), skip blank lines, join adjacent lines by
		 *        escaping the newline (ie. backslash at end of line), strip
		 *        leading and/or trailing whitespace.  All of these are optional
		 *        and independently controllable.
		 * 
		 *        Provides a 'warn()' method so you can generate warning messages that
		 *        report physical line number, even if the logical line in question
		 *        spans multiple physical lines.  Also provides 'unreadline()' for
		 *        implementing line-at-a-time lookahead.
		 * 
		 *        Constructor is called as:
		 * 
		 *            TextFile (filename=None, file=None, **options)
		 * 
		 *        It bombs (RuntimeError) if both 'filename' and 'file' are None;
		 *        'filename' should be a string, and 'file' a file object (or
		 *        something that provides 'readline()' and 'close()' methods).  It is
		 *        recommended that you supply at least 'filename', so that TextFile
		 *        can include it in warning messages.  If 'file' is not supplied,
		 *        TextFile creates its own using 'io.open()'.
		 * 
		 *        The options are all boolean, and affect the value returned by
		 *        'readline()':
		 *          strip_comments [default: true]
		 *            strip from "#" to end-of-line, as well as any whitespace
		 *            leading up to the "#" -- unless it is escaped by a backslash
		 *          lstrip_ws [default: false]
		 *            strip leading whitespace from each line before returning it
		 *          rstrip_ws [default: true]
		 *            strip trailing whitespace (including line terminator!) from
		 *            each line before returning it
		 *          skip_blanks [default: true}
		 *            skip lines that are empty *after* stripping comments and
		 *            whitespace.  (If both lstrip_ws and rstrip_ws are false,
		 *            then some lines may consist of solely whitespace: these will
		 *            *not* be skipped, even if 'skip_blanks' is true.)
		 *          join_lines [default: false]
		 *            if a backslash is the last non-newline character on a line
		 *            after stripping comments and whitespace, join the following line
		 *            to it to form one "logical line"; if N consecutive lines end
		 *            with a backslash, then N+1 physical lines will be joined to
		 *            form one logical line.
		 *          collapse_join [default: false]
		 *            strip leading whitespace from lines that are joined to their
		 *            predecessor; only matters if (join_lines and not lstrip_ws)
		 *          errors [default: 'strict']
		 *            error handler used to decode the file content
		 * 
		 *        Note that since 'rstrip_ws' can strip the trailing newline, the
		 *        semantics of 'readline()' must differ from those of the builtin file
		 *        object's 'readline()' method!  In particular, 'readline()' returns
		 *        None for end-of-file: an empty string might just be a blank line (or
		 *        an all-whitespace line), if 'rstrip_ws' is true but 'skip_blanks' is
		 *        not.
		 */

		/**
		 * Construct a new TextFile object.  At least one of 'filename'
		 *            (a string) and 'file' (a file-like object) must be supplied.
		 *            They keyword argument options are described above and affect
		 *            the values returned by 'readline()'.
		 */
		function TextFile(filename?, file?): Promise<ITextFile>
		function TextFile$({ filename, file }: { filename?, file?}): Promise<ITextFile>
		interface ITextFile {

			/**
			 * Open a new file named 'filename'.  This overrides both the
			 *            'filename' and 'file' arguments to the constructor.
			 */
			open(filename): Promise<any>
			open$({ filename }): Promise<any>

			/**
			 * Close the current file and forget everything we know about it
			 *            (filename, current line number).
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>
			gen_error(msg, line?): Promise<any>
			gen_error$({ msg, line }: { msg, line?}): Promise<any>
			error(msg, line?): Promise<any>
			error$({ msg, line }: { msg, line?}): Promise<any>

			/**
			 * Print (to stderr) a warning message tied to the current logical
			 *            line in the current file.  If the current logical line in the
			 *            file spans multiple physical lines, the warning refers to the
			 *            whole range, eg. "lines 3-5".  If 'line' supplied, it overrides
			 *            the current line number; it may be a list or tuple to indicate a
			 *            range of physical lines, or an integer for a single physical
			 *            line.
			 */
			warn(msg, line?): Promise<any>
			warn$({ msg, line }: { msg, line?}): Promise<any>

			/**
			 * Read and return a single logical line from the current file (or
			 *            from an internal buffer if lines have previously been "unread"
			 *            with 'unreadline()').  If the 'join_lines' option is true, this
			 *            may involve reading multiple physical lines concatenated into a
			 *            single string.  Updates the current line number, so calling
			 *            'warn()' after 'readline()' emits a warning about the physical
			 *            line(s) just read.  Returns None on end-of-file, since the empty
			 *            string can occur if 'rstrip_ws' is true but 'strip_blanks' is
			 *            not.
			 */
			readline(): Promise<any>
			readline$($: {}): Promise<any>

			/**
			 * Read and return the list of all logical lines remaining in the
			 *            current file.
			 */
			readlines(): Promise<any>
			readlines$($: {}): Promise<any>

			/**
			 * Push 'line' (a string) onto an internal buffer that will be
			 *            checked by future 'readline()' calls.  Handy for implementing
			 *            a parser with line-at-a-time lookahead.
			 */
			unreadline(line): Promise<any>
			unreadline$({ line }): Promise<any>
			default_options
		}
	}
	module unixccompiler {
		var _
		interface IUnixCCompiler {
			preprocess(source, output_file?, macros?, include_dirs?, extra_preargs?, extra_postargs?): Promise<any>
			preprocess$({ source, output_file, macros, include_dirs, extra_preargs, extra_postargs }: { source, output_file?, macros?, include_dirs?, extra_preargs?, extra_postargs?}): Promise<any>
			create_static_lib(objects, output_libname, output_dir?, debug?, target_lang?): Promise<any>
			create_static_lib$({ objects, output_libname, output_dir, debug, target_lang }: { objects, output_libname, output_dir?, debug?, target_lang?}): Promise<any>
			link(target_desc, objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?): Promise<any>
			link$({ target_desc, objects, output_filename, output_dir, libraries, library_dirs, runtime_library_dirs, export_symbols, debug, extra_preargs, extra_postargs, build_temp, target_lang }: { target_desc, objects, output_filename, output_dir?, libraries?, library_dirs?, runtime_library_dirs?, export_symbols?, debug?, extra_preargs?, extra_postargs?, build_temp?, target_lang?}): Promise<any>
			library_dir_option(dir): Promise<any>
			library_dir_option$({ dir }): Promise<any>
			runtime_library_dir_option(dir): Promise<any>
			runtime_library_dir_option$({ dir }): Promise<any>
			library_option(lib): Promise<any>
			library_option$({ lib }): Promise<any>
			find_library_file(dirs, lib, debug?): Promise<any>
			find_library_file$({ dirs, lib, debug }: { dirs, lib, debug?}): Promise<any>
			compiler_type
			executables
			src_extensions
			obj_extension
			static_lib_extension
			shared_lib_extension
			dylib_lib_extension
			xcode_stub_lib_extension
			static_lib_format
			shared_lib_format
			dylib_lib_format
			xcode_stub_lib_format
		}
	}
	module util {
		var _

		/**
		 * Return a string that identifies the current platform.  This is used mainly to
		 *     distinguish platform-specific build directories and platform-specific built
		 *     distributions.  Typically includes the OS name and version and the
		 *     architecture (as supplied by 'os.uname()'), although the exact information
		 *     included depends on the OS; eg. on Linux, the kernel version isn't
		 *     particularly important.
		 * 
		 *     Examples of returned values:
		 *        linux-i586
		 *        linux-alpha (?)
		 *        solaris-2.6-sun4u
		 * 
		 *     Windows will return one of:
		 *        win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)
		 *        win32 (all others - specifically, sys.platform is returned)
		 * 
		 *     For other non-POSIX platforms, currently just returns 'sys.platform'.
		 * 
		 *     
		 */
		function get_host_platform(): Promise<any>
		function get_host_platform$($: {}): Promise<any>
		function get_platform(): Promise<any>
		function get_platform$($: {}): Promise<any>

		/**
		 * Return 'pathname' as a name that will work on the native filesystem,
		 *     i.e. split it on '/' and put it back together again using the current
		 *     directory separator.  Needed because filenames in the setup script are
		 *     always supplied in Unix style, and have to be converted to the local
		 *     convention before we can actually use them in the filesystem.  Raises
		 *     ValueError on non-Unix-ish systems if 'pathname' either starts or
		 *     ends with a slash.
		 *     
		 */
		function convert_path(pathname): Promise<any>
		function convert_path$({ pathname }): Promise<any>

		/**
		 * Return 'pathname' with 'new_root' prepended.  If 'pathname' is
		 *     relative, this is equivalent to "os.path.join(new_root,pathname)".
		 *     Otherwise, it requires making 'pathname' relative and then joining the
		 *     two, which is tricky on DOS/Windows and Mac OS.
		 *     
		 */
		function change_root(new_root, pathname): Promise<any>
		function change_root$({ new_root, pathname }): Promise<any>

		/**
		 * Ensure that 'os.environ' has all the environment variables we
		 *     guarantee that users can use in config files, command-line options,
		 *     etc.  Currently this includes:
		 *       HOME - user's home directory (Unix only)
		 *       PLAT - description of the current platform, including hardware
		 *              and OS (see 'get_platform()')
		 *     
		 */
		function check_environ(): Promise<any>
		function check_environ$($: {}): Promise<any>

		/**
		 * Perform shell/Perl-style variable substitution on 'string'.  Every
		 *     occurrence of '$' followed by a name is considered a variable, and
		 *     variable is substituted by the value found in the 'local_vars'
		 *     dictionary, or in 'os.environ' if it's not in 'local_vars'.
		 *     'os.environ' is first checked/augmented to guarantee that it contains
		 *     certain values: see 'check_environ()'.  Raise ValueError for any
		 *     variables not found in either 'local_vars' or 'os.environ'.
		 *     
		 */
		function subst_vars(s, local_vars): Promise<any>
		function subst_vars$({ s, local_vars }): Promise<any>
		function grok_environment_error(exc, prefix?): Promise<any>
		function grok_environment_error$({ exc, prefix }: { exc, prefix?}): Promise<any>

		/**
		 * Split a string up according to Unix shell-like rules for quotes and
		 *     backslashes.  In short: words are delimited by spaces, as long as those
		 *     spaces are not escaped by a backslash, or inside a quoted string.
		 *     Single and double quotes are equivalent, and the quote characters can
		 *     be backslash-escaped.  The backslash is stripped from any two-character
		 *     escape sequence, leaving only the escaped character.  The quote
		 *     characters are stripped from any quoted string.  Returns a list of
		 *     words.
		 *     
		 */
		function split_quoted(s): Promise<any>
		function split_quoted$({ s }): Promise<any>

		/**
		 * Perform some action that affects the outside world (eg.  by
		 *     writing to the filesystem).  Such actions are special because they
		 *     are disabled by the 'dry_run' flag.  This method takes care of all
		 *     that bureaucracy for you; all you have to do is supply the
		 *     function to call and an argument tuple for it (to embody the
		 *     "external action" being performed), and an optional message to
		 *     print.
		 *     
		 */
		function execute(func, args, msg?, verbose?, dry_run?): Promise<any>
		function execute$({ func, args, msg, verbose, dry_run }: { func, args, msg?, verbose?, dry_run?}): Promise<any>

		/**
		 * Convert a string representation of truth to true (1) or false (0).
		 * 
		 *     True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values
		 *     are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if
		 *     'val' is anything else.
		 *     
		 */
		function strtobool(val): Promise<any>
		function strtobool$({ val }): Promise<any>

		/**
		 * Byte-compile a collection of Python source files to .pyc
		 *     files in a __pycache__ subdirectory.  'py_files' is a list
		 *     of files to compile; any files that don't end in ".py" are silently
		 *     skipped.  'optimize' must be one of the following:
		 *       0 - don't optimize
		 *       1 - normal optimization (like "python -O")
		 *       2 - extra optimization (like "python -OO")
		 *     If 'force' is true, all files are recompiled regardless of
		 *     timestamps.
		 * 
		 *     The source filename encoded in each bytecode file defaults to the
		 *     filenames listed in 'py_files'; you can modify these with 'prefix' and
		 *     'basedir'.  'prefix' is a string that will be stripped off of each
		 *     source filename, and 'base_dir' is a directory name that will be
		 *     prepended (after 'prefix' is stripped).  You can supply either or both
		 *     (or neither) of 'prefix' and 'base_dir', as you wish.
		 * 
		 *     If 'dry_run' is true, doesn't actually do anything that would
		 *     affect the filesystem.
		 * 
		 *     Byte-compilation is either done directly in this interpreter process
		 *     with the standard py_compile module, or indirectly by writing a
		 *     temporary script and executing it.  Normally, you should let
		 *     'byte_compile()' figure out to use direct compilation or not (see
		 *     the source for details).  The 'direct' flag is used by the script
		 *     generated in indirect mode; unless you know what you're doing, leave
		 *     it set to None.
		 *     
		 */
		function byte_compile(py_files, optimize?, force?, prefix?, base_dir?, verbose?, dry_run?, direct?): Promise<any>
		function byte_compile$({ py_files, optimize, force, prefix, base_dir, verbose, dry_run, direct }: { py_files, optimize?, force?, prefix?, base_dir?, verbose?, dry_run?, direct?}): Promise<any>

		/**
		 * Return a version of the string escaped for inclusion in an
		 *     RFC-822 header, by ensuring there are 8 spaces space after each newline.
		 *     
		 */
		function rfc822_escape(header): Promise<any>
		function rfc822_escape$({ header }): Promise<any>

		/**
		 * Invoke 2to3 on a list of Python files.
		 *     The files should all come from the build area, as the
		 *     modification is done in-place. To reduce the build time,
		 *     only files modified since the last invocation of this
		 *     function should be passed in the files argument.
		 */
		function run_2to3(files, fixer_names?, options?, explicit?): Promise<any>
		function run_2to3$({ files, fixer_names, options, explicit }: { files, fixer_names?, options?, explicit?}): Promise<any>

		/**
		 * Recursively copy a directory, only copying new and changed files,
		 *     running run_2to3 over all newly copied Python modules afterward.
		 * 
		 *     If you give a template string, it's parsed like a MANIFEST.in.
		 *     
		 */
		function copydir_run_2to3(src, dest, template?, fixer_names?, options?, explicit?): Promise<any>
		function copydir_run_2to3$({ src, dest, template, fixer_names, options, explicit }: { src, dest, template?, fixer_names?, options?, explicit?}): Promise<any>

		/**
		 * Mixin class for commands that run 2to3.
		 *     To configure 2to3, setup scripts may either change
		 *     the class variables, or inherit from individual commands
		 *     to override how 2to3 is invoked.
		 */
		interface IMixin2to3 {
			run_2to3(files): Promise<any>
			run_2to3$({ files }): Promise<any>
			fixer_names
			options
			explicit
		}
	}
	module version {
		var _

		/**
		 * Abstract base class for version numbering classes.  Just provides
		 *     constructor (__init__) and reproducer (__repr__), because those
		 *     seem to be the same for all version numbering classes; and route
		 *     rich comparisons to _cmp.
		 *     
		 */
		function Version(vstring?): Promise<IVersion>
		function Version$({ vstring }: { vstring?}): Promise<IVersion>
		interface IVersion {
		}

		/**
		 * Version numbering for anal retentives and software idealists.
		 *     Implements the standard interface for version number classes as
		 *     described above.  A version number consists of two or three
		 *     dot-separated numeric components, with an optional "pre-release" tag
		 *     on the end.  The pre-release tag consists of the letter 'a' or 'b'
		 *     followed by a number.  If the numeric components of two version
		 *     numbers are equal, then one with a pre-release tag will always
		 *     be deemed earlier (lesser) than one without.
		 * 
		 *     The following are valid version numbers (shown in the order that
		 *     would be obtained by sorting according to the supplied cmp function):
		 * 
		 *         0.4       0.4.0  (these two are equivalent)
		 *         0.4.1
		 *         0.5a1
		 *         0.5b3
		 *         0.5
		 *         0.9.6
		 *         1.0
		 *         1.0.4a3
		 *         1.0.4b1
		 *         1.0.4
		 * 
		 *     The following are examples of invalid version numbers:
		 * 
		 *         1
		 *         2.7.2.2
		 *         1.3.a4
		 *         1.3pl1
		 *         1.3c4
		 * 
		 *     The rationale for this version numbering system will be explained
		 *     in the distutils documentation.
		 *     
		 */
		interface IStrictVersion extends IVersion {
			parse(vstring): Promise<any>
			parse$({ vstring }): Promise<any>
			version_re
		}

		/**
		 * Version numbering for anarchists and software realists.
		 *     Implements the standard interface for version number classes as
		 *     described above.  A version number consists of a series of numbers,
		 *     separated by either periods or strings of letters.  When comparing
		 *     version numbers, the numeric components will be compared
		 *     numerically, and the alphabetic components lexically.  The following
		 *     are all valid version numbers, in no particular order:
		 * 
		 *         1.5.1
		 *         1.5.2b2
		 *         161
		 *         3.10a
		 *         8.02
		 *         3.4j
		 *         1996.07.12
		 *         3.2.pl0
		 *         3.1.1.6
		 *         2g6
		 *         11g
		 *         0.960923
		 *         2.2beta29
		 *         1.13++
		 *         5.5.kw
		 *         2.0b1pl0
		 * 
		 *     In fact, there is no such thing as an invalid version number under
		 *     this scheme; the rules for comparison are simple and predictable,
		 *     but may not always give the results you want (for some definition
		 *     of "want").
		 *     
		 */
		function LooseVersion(vstring?): Promise<ILooseVersion>
		function LooseVersion$({ vstring }: { vstring?}): Promise<ILooseVersion>
		interface ILooseVersion extends IVersion {
			parse(vstring): Promise<any>
			parse$({ vstring }): Promise<any>
			component_re
		}
	}
	module versionpredicate {
		var _

		/**
		 * Parse a single version comparison.
		 * 
		 *     Return (comparison string, StrictVersion)
		 *     
		 */
		function splitUp(pred): Promise<any>
		function splitUp$({ pred }): Promise<any>

		/**
		 * Return the name and optional version number of a provision.
		 * 
		 *     The version number, if given, will be returned as a `StrictVersion`
		 *     instance, otherwise it will be `None`.
		 * 
		 *     >>> split_provision('mypkg')
		 *     ('mypkg', None)
		 *     >>> split_provision(' mypkg( 1.2 ) ')
		 *     ('mypkg', StrictVersion ('1.2'))
		 *     
		 */
		function split_provision(value): Promise<any>
		function split_provision$({ value }): Promise<any>

		/**
		 * Parse and test package version predicates.
		 * 
		 *     >>> v = VersionPredicate('pyepat.abc (>1.0, <3333.3a1, !=1555.1b3)')
		 * 
		 *     The `name` attribute provides the full dotted name that is given::
		 * 
		 *     >>> v.name
		 *     'pyepat.abc'
		 * 
		 *     The str() of a `VersionPredicate` provides a normalized
		 *     human-readable version of the expression::
		 * 
		 *     >>> print(v)
		 *     pyepat.abc (> 1.0, < 3333.3a1, != 1555.1b3)
		 * 
		 *     The `satisfied_by()` method can be used to determine with a given
		 *     version number is included in the set described by the version
		 *     restrictions::
		 * 
		 *     >>> v.satisfied_by('1.1')
		 *     True
		 *     >>> v.satisfied_by('1.4')
		 *     True
		 *     >>> v.satisfied_by('1.0')
		 *     False
		 *     >>> v.satisfied_by('4444.4')
		 *     False
		 *     >>> v.satisfied_by('1555.1b3')
		 *     False
		 * 
		 *     `VersionPredicate` is flexible in accepting extra whitespace::
		 * 
		 *     >>> v = VersionPredicate(' pat( ==  0.1  )  ')
		 *     >>> v.name
		 *     'pat'
		 *     >>> v.satisfied_by('0.1')
		 *     True
		 *     >>> v.satisfied_by('0.2')
		 *     False
		 * 
		 *     If any version numbers passed in do not conform to the
		 *     restrictions of `StrictVersion`, a `ValueError` is raised::
		 * 
		 *     >>> v = VersionPredicate('p1.p2.p3.p4(>=1.0, <=1.3a1, !=1.2zb3)')
		 *     Traceback (most recent call last):
		 *       ...
		 *     ValueError: invalid version number '1.2zb3'
		 * 
		 *     It the module or package name given does not conform to what's
		 *     allowed as a legal module or package name, `ValueError` is
		 *     raised::
		 * 
		 *     >>> v = VersionPredicate('foo-bar')
		 *     Traceback (most recent call last):
		 *       ...
		 *     ValueError: expected parenthesized list: '-bar'
		 * 
		 *     >>> v = VersionPredicate('foo bar (12.21)')
		 *     Traceback (most recent call last):
		 *       ...
		 *     ValueError: expected parenthesized list: 'bar (12.21)'
		 * 
		 *     
		 */

		/**
		 * Parse a version predicate string.
		 *         
		 */
		function VersionPredicate(versionPredicateStr): Promise<IVersionPredicate>
		function VersionPredicate$({ versionPredicateStr }): Promise<IVersionPredicate>
		interface IVersionPredicate {

			/**
			 * True if version is compatible with all the predicates in self.
			 *         The parameter version must be acceptable to the StrictVersion
			 *         constructor.  It may be either a string or StrictVersion.
			 *         
			 */
			satisfied_by(version): Promise<any>
			satisfied_by$({ version }): Promise<any>
		}
		let re_validPackage: Promise<any>
		let re_paren: Promise<any>
		let re_splitComparison: Promise<any>
		let compmap: Promise<any>
	}
}
declare module email {
	var _

	/**
	 * Parse a string into a Message object model.
	 * 
	 *     Optional _class and strict are passed to the Parser constructor.
	 *     
	 */
	function message_from_string(s): Promise<any>
	function message_from_string$({ s }): Promise<any>

	/**
	 * Parse a bytes string into a Message object model.
	 * 
	 *     Optional _class and strict are passed to the Parser constructor.
	 *     
	 */
	function message_from_bytes(s): Promise<any>
	function message_from_bytes$({ s }): Promise<any>

	/**
	 * Read a file and parse its contents into a Message object model.
	 * 
	 *     Optional _class and strict are passed to the Parser constructor.
	 *     
	 */
	function message_from_file(fp): Promise<any>
	function message_from_file$({ fp }): Promise<any>

	/**
	 * Read a binary file and parse its contents into a Message object model.
	 * 
	 *     Optional _class and strict are passed to the Parser constructor.
	 *     
	 */
	function message_from_binary_file(fp): Promise<any>
	function message_from_binary_file$({ fp }): Promise<any>
	module _encoded_words {
		var _
		function decode_q(encoded): Promise<any>
		function decode_q$({ encoded }): Promise<any>
		function encode_q(bstring): Promise<any>
		function encode_q$({ bstring }): Promise<any>
		function len_q(bstring): Promise<any>
		function len_q$({ bstring }): Promise<any>
		function decode_b(encoded): Promise<any>
		function decode_b$({ encoded }): Promise<any>
		function encode_b(bstring): Promise<any>
		function encode_b$({ bstring }): Promise<any>
		function len_b(bstring): Promise<any>
		function len_b$({ bstring }): Promise<any>

		/**
		 * Decode encoded word and return (string, charset, lang, defects) tuple.
		 * 
		 *     An RFC 2047/2243 encoded word has the form:
		 * 
		 *         =?charset*lang?cte?encoded_string?=
		 * 
		 *     where '*lang' may be omitted but the other parts may not be.
		 * 
		 *     This function expects exactly such a string (that is, it does not check the
		 *     syntax and may raise errors if the string is not well formed), and returns
		 *     the encoded_string decoded first from its Content Transfer Encoding and
		 *     then from the resulting bytes into unicode using the specified charset.  If
		 *     the cte-decoded string does not successfully decode using the specified
		 *     character set, a defect is added to the defects list and the unknown octets
		 *     are replaced by the unicode 'unknown' character \uFDFF.
		 * 
		 *     The specified charset and language are returned.  The default for language,
		 *     which is rarely if ever encountered, is the empty string.
		 * 
		 *     
		 */
		function decode(ew): Promise<any>
		function decode$({ ew }): Promise<any>

		/**
		 * Encode string using the CTE encoding that produces the shorter result.
		 * 
		 *     Produces an RFC 2047/2243 encoded word of the form:
		 * 
		 *         =?charset*lang?cte?encoded_string?=
		 * 
		 *     where '*lang' is omitted unless the 'lang' parameter is given a value.
		 *     Optional argument charset (defaults to utf-8) specifies the charset to use
		 *     to encode the string to binary before CTE encoding it.  Optional argument
		 *     'encoding' is the cte specifier for the encoding that should be used ('q'
		 *     or 'b'); if it is None (the default) the encoding which produces the
		 *     shortest encoded sequence is used, except that 'q' is preferred if it is up
		 *     to five characters longer.  Optional argument 'lang' (default '') gives the
		 *     RFC 2243 language string to specify in the encoded word.
		 * 
		 *     
		 */
		function encode(string, charset?, encoding?, lang?): Promise<any>
		function encode$({ string, charset, encoding, lang }: { string, charset?, encoding?, lang?}): Promise<any>
		interface I_QByteMap {
			safe
		}
	}
	module _header_value_parser {
		var _
		function quote_string(value): Promise<any>
		function quote_string$({ value }): Promise<any>

		/**
		 * FWS = 1*WSP
		 * 
		 *     This isn't the RFC definition.  We're using fws to represent tokens where
		 *     folding can be done, but when we are parsing the *un*folding has already
		 *     been done so we don't need to watch out for CRLF.
		 * 
		 *     
		 */
		function get_fws(value): Promise<any>
		function get_fws$({ value }): Promise<any>

		/**
		 *  encoded-word = "=?" charset "?" encoding "?" encoded-text "?="
		 * 
		 *     
		 */
		function get_encoded_word(value): Promise<any>
		function get_encoded_word$({ value }): Promise<any>

		/**
		 * unstructured = (*([FWS] vchar) *WSP) / obs-unstruct
		 *        obs-unstruct = *((*LF *CR *(obs-utext) *LF *CR)) / FWS)
		 *        obs-utext = %d0 / obs-NO-WS-CTL / LF / CR
		 * 
		 *        obs-NO-WS-CTL is control characters except WSP/CR/LF.
		 * 
		 *     So, basically, we have printable runs, plus control characters or nulls in
		 *     the obsolete syntax, separated by whitespace.  Since RFC 2047 uses the
		 *     obsolete syntax in its specification, but requires whitespace on either
		 *     side of the encoded words, I can see no reason to need to separate the
		 *     non-printable-non-whitespace from the printable runs if they occur, so we
		 *     parse this into xtext tokens separated by WSP tokens.
		 * 
		 *     Because an 'unstructured' value must by definition constitute the entire
		 *     value, this 'get' routine does not return a remaining value, only the
		 *     parsed TokenList.
		 * 
		 *     
		 */
		function get_unstructured(value): Promise<any>
		function get_unstructured$({ value }): Promise<any>

		/**
		 * ctext = <printable ascii except \ ( )>
		 * 
		 *     This is not the RFC ctext, since we are handling nested comments in comment
		 *     and unquoting quoted-pairs here.  We allow anything except the '()'
		 *     characters, but if we find any ASCII other than the RFC defined printable
		 *     ASCII, a NonPrintableDefect is added to the token's defects list.  Since
		 *     quoted pairs are converted to their unquoted values, what is returned is
		 *     a 'ptext' token.  In this case it is a WhiteSpaceTerminal, so it's value
		 *     is ' '.
		 * 
		 *     
		 */
		function get_qp_ctext(value): Promise<any>
		function get_qp_ctext$({ value }): Promise<any>

		/**
		 * qcontent = qtext / quoted-pair
		 * 
		 *     We allow anything except the DQUOTE character, but if we find any ASCII
		 *     other than the RFC defined printable ASCII, a NonPrintableDefect is
		 *     added to the token's defects list.  Any quoted pairs are converted to their
		 *     unquoted values, so what is returned is a 'ptext' token.  In this case it
		 *     is a ValueTerminal.
		 * 
		 *     
		 */
		function get_qcontent(value): Promise<any>
		function get_qcontent$({ value }): Promise<any>

		/**
		 * atext = <matches _atext_matcher>
		 * 
		 *     We allow any non-ATOM_ENDS in atext, but add an InvalidATextDefect to
		 *     the token's defects list if we find non-atext characters.
		 *     
		 */
		function get_atext(value): Promise<any>
		function get_atext$({ value }): Promise<any>

		/**
		 * bare-quoted-string = DQUOTE *([FWS] qcontent) [FWS] DQUOTE
		 * 
		 *     A quoted-string without the leading or trailing white space.  Its
		 *     value is the text between the quote marks, with whitespace
		 *     preserved and quoted pairs decoded.
		 *     
		 */
		function get_bare_quoted_string(value): Promise<any>
		function get_bare_quoted_string$({ value }): Promise<any>

		/**
		 * comment = "(" *([FWS] ccontent) [FWS] ")"
		 *        ccontent = ctext / quoted-pair / comment
		 * 
		 *     We handle nested comments here, and quoted-pair in our qp-ctext routine.
		 *     
		 */
		function get_comment(value): Promise<any>
		function get_comment$({ value }): Promise<any>

		/**
		 * CFWS = (1*([FWS] comment) [FWS]) / FWS
		 * 
		 *     
		 */
		function get_cfws(value): Promise<any>
		function get_cfws$({ value }): Promise<any>

		/**
		 * quoted-string = [CFWS] <bare-quoted-string> [CFWS]
		 * 
		 *     'bare-quoted-string' is an intermediate class defined by this
		 *     parser and not by the RFC grammar.  It is the quoted string
		 *     without any attached CFWS.
		 *     
		 */
		function get_quoted_string(value): Promise<any>
		function get_quoted_string$({ value }): Promise<any>

		/**
		 * atom = [CFWS] 1*atext [CFWS]
		 * 
		 *     An atom could be an rfc2047 encoded word.
		 *     
		 */
		function get_atom(value): Promise<any>
		function get_atom$({ value }): Promise<any>

		/**
		 *  dot-text = 1*atext *("." 1*atext)
		 * 
		 *     
		 */
		function get_dot_atom_text(value): Promise<any>
		function get_dot_atom_text$({ value }): Promise<any>

		/**
		 *  dot-atom = [CFWS] dot-atom-text [CFWS]
		 * 
		 *     Any place we can have a dot atom, we could instead have an rfc2047 encoded
		 *     word.
		 *     
		 */
		function get_dot_atom(value): Promise<any>
		function get_dot_atom$({ value }): Promise<any>

		/**
		 * word = atom / quoted-string
		 * 
		 *     Either atom or quoted-string may start with CFWS.  We have to peel off this
		 *     CFWS first to determine which type of word to parse.  Afterward we splice
		 *     the leading CFWS, if any, into the parsed sub-token.
		 * 
		 *     If neither an atom or a quoted-string is found before the next special, a
		 *     HeaderParseError is raised.
		 * 
		 *     The token returned is either an Atom or a QuotedString, as appropriate.
		 *     This means the 'word' level of the formal grammar is not represented in the
		 *     parse tree; this is because having that extra layer when manipulating the
		 *     parse tree is more confusing than it is helpful.
		 * 
		 *     
		 */
		function get_word(value): Promise<any>
		function get_word$({ value }): Promise<any>

		/**
		 *  phrase = 1*word / obs-phrase
		 *         obs-phrase = word *(word / "." / CFWS)
		 * 
		 *     This means a phrase can be a sequence of words, periods, and CFWS in any
		 *     order as long as it starts with at least one word.  If anything other than
		 *     words is detected, an ObsoleteHeaderDefect is added to the token's defect
		 *     list.  We also accept a phrase that starts with CFWS followed by a dot;
		 *     this is registered as an InvalidHeaderDefect, since it is not supported by
		 *     even the obsolete grammar.
		 * 
		 *     
		 */
		function get_phrase(value): Promise<any>
		function get_phrase$({ value }): Promise<any>

		/**
		 *  local-part = dot-atom / quoted-string / obs-local-part
		 * 
		 *     
		 */
		function get_local_part(value): Promise<any>
		function get_local_part$({ value }): Promise<any>

		/**
		 *  obs-local-part = word *("." word)
		 *     
		 */
		function get_obs_local_part(value): Promise<any>
		function get_obs_local_part$({ value }): Promise<any>

		/**
		 *  dtext = <printable ascii except \ [ ]> / obs-dtext
		 *         obs-dtext = obs-NO-WS-CTL / quoted-pair
		 * 
		 *     We allow anything except the excluded characters, but if we find any
		 *     ASCII other than the RFC defined printable ASCII, a NonPrintableDefect is
		 *     added to the token's defects list.  Quoted pairs are converted to their
		 *     unquoted values, so what is returned is a ptext token, in this case a
		 *     ValueTerminal.  If there were quoted-printables, an ObsoleteHeaderDefect is
		 *     added to the returned token's defect list.
		 * 
		 *     
		 */
		function get_dtext(value): Promise<any>
		function get_dtext$({ value }): Promise<any>

		/**
		 *  domain-literal = [CFWS] "[" *([FWS] dtext) [FWS] "]" [CFWS]
		 * 
		 *     
		 */
		function get_domain_literal(value): Promise<any>
		function get_domain_literal$({ value }): Promise<any>

		/**
		 *  domain = dot-atom / domain-literal / obs-domain
		 *         obs-domain = atom *("." atom))
		 * 
		 *     
		 */
		function get_domain(value): Promise<any>
		function get_domain$({ value }): Promise<any>

		/**
		 *  addr-spec = local-part "@" domain
		 * 
		 *     
		 */
		function get_addr_spec(value): Promise<any>
		function get_addr_spec$({ value }): Promise<any>

		/**
		 *  obs-route = obs-domain-list ":"
		 *         obs-domain-list = *(CFWS / ",") "@" domain *("," [CFWS] ["@" domain])
		 * 
		 *         Returns an obs-route token with the appropriate sub-tokens (that is,
		 *         there is no obs-domain-list in the parse tree).
		 *     
		 */
		function get_obs_route(value): Promise<any>
		function get_obs_route$({ value }): Promise<any>

		/**
		 *  angle-addr = [CFWS] "<" addr-spec ">" [CFWS] / obs-angle-addr
		 *         obs-angle-addr = [CFWS] "<" obs-route addr-spec ">" [CFWS]
		 * 
		 *     
		 */
		function get_angle_addr(value): Promise<any>
		function get_angle_addr$({ value }): Promise<any>

		/**
		 *  display-name = phrase
		 * 
		 *     Because this is simply a name-rule, we don't return a display-name
		 *     token containing a phrase, but rather a display-name token with
		 *     the content of the phrase.
		 * 
		 *     
		 */
		function get_display_name(value): Promise<any>
		function get_display_name$({ value }): Promise<any>

		/**
		 *  name-addr = [display-name] angle-addr
		 * 
		 *     
		 */
		function get_name_addr(value): Promise<any>
		function get_name_addr$({ value }): Promise<any>

		/**
		 *  mailbox = name-addr / addr-spec
		 * 
		 *     
		 */
		function get_mailbox(value): Promise<any>
		function get_mailbox$({ value }): Promise<any>

		/**
		 *  Read everything up to one of the chars in endchars.
		 * 
		 *     This is outside the formal grammar.  The InvalidMailbox TokenList that is
		 *     returned acts like a Mailbox, but the data attributes are None.
		 * 
		 *     
		 */
		function get_invalid_mailbox(value, endchars): Promise<any>
		function get_invalid_mailbox$({ value, endchars }): Promise<any>

		/**
		 *  mailbox-list = (mailbox *("," mailbox)) / obs-mbox-list
		 *         obs-mbox-list = *([CFWS] ",") mailbox *("," [mailbox / CFWS])
		 * 
		 *     For this routine we go outside the formal grammar in order to improve error
		 *     handling.  We recognize the end of the mailbox list only at the end of the
		 *     value or at a ';' (the group terminator).  This is so that we can turn
		 *     invalid mailboxes into InvalidMailbox tokens and continue parsing any
		 *     remaining valid mailboxes.  We also allow all mailbox entries to be null,
		 *     and this condition is handled appropriately at a higher level.
		 * 
		 *     
		 */
		function get_mailbox_list(value): Promise<any>
		function get_mailbox_list$({ value }): Promise<any>

		/**
		 *  group-list = mailbox-list / CFWS / obs-group-list
		 *         obs-group-list = 1*([CFWS] ",") [CFWS]
		 * 
		 *     
		 */
		function get_group_list(value): Promise<any>
		function get_group_list$({ value }): Promise<any>

		/**
		 *  group = display-name ":" [group-list] ";" [CFWS]
		 * 
		 *     
		 */
		function get_group(value): Promise<any>
		function get_group$({ value }): Promise<any>

		/**
		 *  address = mailbox / group
		 * 
		 *     Note that counter-intuitively, an address can be either a single address or
		 *     a list of addresses (a group).  This is why the returned Address object has
		 *     a 'mailboxes' attribute which treats a single address as a list of length
		 *     one.  When you need to differentiate between to two cases, extract the single
		 *     element, which is either a mailbox or a group token.
		 * 
		 *     
		 */
		function get_address(value): Promise<any>
		function get_address$({ value }): Promise<any>

		/**
		 *  address_list = (address *("," address)) / obs-addr-list
		 *         obs-addr-list = *([CFWS] ",") address *("," [address / CFWS])
		 * 
		 *     We depart from the formal grammar here by continuing to parse until the end
		 *     of the input, assuming the input to be entirely composed of an
		 *     address-list.  This is always true in email parsing, and allows us
		 *     to skip invalid addresses to parse additional valid ones.
		 * 
		 *     
		 */
		function get_address_list(value): Promise<any>
		function get_address_list$({ value }): Promise<any>

		/**
		 *  no-fold-literal = "[" *dtext "]"
		 *     
		 */
		function get_no_fold_literal(value): Promise<any>
		function get_no_fold_literal$({ value }): Promise<any>

		/**
		 * msg-id = [CFWS] "<" id-left '@' id-right  ">" [CFWS]
		 *        id-left = dot-atom-text / obs-id-left
		 *        id-right = dot-atom-text / no-fold-literal / obs-id-right
		 *        no-fold-literal = "[" *dtext "]"
		 *     
		 */
		function get_msg_id(value): Promise<any>
		function get_msg_id$({ value }): Promise<any>

		/**
		 * message-id      =   "Message-ID:" msg-id CRLF
		 *     
		 */
		function parse_message_id(value): Promise<any>
		function parse_message_id$({ value }): Promise<any>

		/**
		 *  mime-version = [CFWS] 1*digit [CFWS] "." [CFWS] 1*digit [CFWS]
		 * 
		 *     
		 */
		function parse_mime_version(value): Promise<any>
		function parse_mime_version$({ value }): Promise<any>

		/**
		 *  Read everything up to the next ';'.
		 * 
		 *     This is outside the formal grammar.  The InvalidParameter TokenList that is
		 *     returned acts like a Parameter, but the data attributes are None.
		 * 
		 *     
		 */
		function get_invalid_parameter(value): Promise<any>
		function get_invalid_parameter$({ value }): Promise<any>

		/**
		 * ttext = <matches _ttext_matcher>
		 * 
		 *     We allow any non-TOKEN_ENDS in ttext, but add defects to the token's
		 *     defects list if we find non-ttext characters.  We also register defects for
		 *     *any* non-printables even though the RFC doesn't exclude all of them,
		 *     because we follow the spirit of RFC 5322.
		 * 
		 *     
		 */
		function get_ttext(value): Promise<any>
		function get_ttext$({ value }): Promise<any>

		/**
		 * token = [CFWS] 1*ttext [CFWS]
		 * 
		 *     The RFC equivalent of ttext is any US-ASCII chars except space, ctls, or
		 *     tspecials.  We also exclude tabs even though the RFC doesn't.
		 * 
		 *     The RFC implies the CFWS but is not explicit about it in the BNF.
		 * 
		 *     
		 */
		function get_token(value): Promise<any>
		function get_token$({ value }): Promise<any>

		/**
		 * attrtext = 1*(any non-ATTRIBUTE_ENDS character)
		 * 
		 *     We allow any non-ATTRIBUTE_ENDS in attrtext, but add defects to the
		 *     token's defects list if we find non-attrtext characters.  We also register
		 *     defects for *any* non-printables even though the RFC doesn't exclude all of
		 *     them, because we follow the spirit of RFC 5322.
		 * 
		 *     
		 */
		function get_attrtext(value): Promise<any>
		function get_attrtext$({ value }): Promise<any>

		/**
		 *  [CFWS] 1*attrtext [CFWS]
		 * 
		 *     This version of the BNF makes the CFWS explicit, and as usual we use a
		 *     value terminal for the actual run of characters.  The RFC equivalent of
		 *     attrtext is the token characters, with the subtraction of '*', "'", and '%'.
		 *     We include tab in the excluded set just as we do for token.
		 * 
		 *     
		 */
		function get_attribute(value): Promise<any>
		function get_attribute$({ value }): Promise<any>

		/**
		 * attrtext = 1*(any non-ATTRIBUTE_ENDS character plus '%')
		 * 
		 *     This is a special parsing routine so that we get a value that
		 *     includes % escapes as a single string (which we decode as a single
		 *     string later).
		 * 
		 *     
		 */
		function get_extended_attrtext(value): Promise<any>
		function get_extended_attrtext$({ value }): Promise<any>

		/**
		 *  [CFWS] 1*extended_attrtext [CFWS]
		 * 
		 *     This is like the non-extended version except we allow % characters, so that
		 *     we can pick up an encoded value as a single string.
		 * 
		 *     
		 */
		function get_extended_attribute(value): Promise<any>
		function get_extended_attribute$({ value }): Promise<any>

		/**
		 *  '*' digits
		 * 
		 *     The formal BNF is more complicated because leading 0s are not allowed.  We
		 *     check for that and add a defect.  We also assume no CFWS is allowed between
		 *     the '*' and the digits, though the RFC is not crystal clear on that.
		 *     The caller should already have dealt with leading CFWS.
		 * 
		 *     
		 */
		function get_section(value): Promise<any>
		function get_section$({ value }): Promise<any>

		/**
		 *  quoted-string / attribute
		 * 
		 *     
		 */
		function get_value(value): Promise<any>
		function get_value$({ value }): Promise<any>

		/**
		 *  attribute [section] ["*"] [CFWS] "=" value
		 * 
		 *     The CFWS is implied by the RFC but not made explicit in the BNF.  This
		 *     simplified form of the BNF from the RFC is made to conform with the RFC BNF
		 *     through some extra checks.  We do it this way because it makes both error
		 *     recovery and working with the resulting parse tree easier.
		 *     
		 */
		function get_parameter(value): Promise<any>
		function get_parameter$({ value }): Promise<any>

		/**
		 *  parameter *( ";" parameter )
		 * 
		 *     That BNF is meant to indicate this routine should only be called after
		 *     finding and handling the leading ';'.  There is no corresponding rule in
		 *     the formal RFC grammar, but it is more convenient for us for the set of
		 *     parameters to be treated as its own TokenList.
		 * 
		 *     This is 'parse' routine because it consumes the remaining value, but it
		 *     would never be called to parse a full header.  Instead it is called to
		 *     parse everything after the non-parameter value of a specific MIME header.
		 * 
		 *     
		 */
		function parse_mime_parameters(value): Promise<any>
		function parse_mime_parameters$({ value }): Promise<any>

		/**
		 *  maintype "/" subtype *( ";" parameter )
		 * 
		 *     The maintype and substype are tokens.  Theoretically they could
		 *     be checked against the official IANA list + x-token, but we
		 *     don't do that.
		 *     
		 */
		function parse_content_type_header(value): Promise<any>
		function parse_content_type_header$({ value }): Promise<any>

		/**
		 *  disposition-type *( ";" parameter )
		 * 
		 *     
		 */
		function parse_content_disposition_header(value): Promise<any>
		function parse_content_disposition_header$({ value }): Promise<any>

		/**
		 *  mechanism
		 * 
		 *     
		 */
		function parse_content_transfer_encoding_header(value): Promise<any>
		function parse_content_transfer_encoding_header$({ value }): Promise<any>
		function TokenList(): Promise<ITokenList>
		function TokenList$({ }): Promise<ITokenList>
		interface ITokenList {
			value(): Promise<any>
			value$($: {}): Promise<any>
			all_defects(): Promise<any>
			all_defects$($: {}): Promise<any>
			startswith_fws(): Promise<any>
			startswith_fws$($: {}): Promise<any>

			/**
			 * True if all top level tokens of this part may be RFC2047 encoded.
			 */
			as_ew_allowed(): Promise<any>
			as_ew_allowed$($: {}): Promise<any>
			comments(): Promise<any>
			comments$($: {}): Promise<any>
			fold(): Promise<any>
			fold$($: {}): Promise<any>
			pprint(indent?): Promise<any>
			pprint$({ indent }: { indent?}): Promise<any>
			ppstr(indent?): Promise<any>
			ppstr$({ indent }: { indent?}): Promise<any>
			token_type
			syntactic_break
			ew_combine_allowed
		}
		interface IWhiteSpaceTokenList extends ITokenList {
			value(): Promise<any>
			value$($: {}): Promise<any>
			comments(): Promise<any>
			comments$($: {}): Promise<any>
		}
		interface IUnstructuredTokenList extends ITokenList {
		}
		interface IPhrase extends ITokenList {
		}
		interface IWord extends ITokenList {
		}
		interface ICFWSList extends IWhiteSpaceTokenList {
		}
		interface IAtom extends ITokenList {
		}
		interface IToken extends ITokenList {
			encode_as_ew
		}
		interface IEncodedWord extends ITokenList {
			cte
			charset
			lang
		}
		interface IQuotedString extends ITokenList {
			content(): Promise<any>
			content$($: {}): Promise<any>
			quoted_value(): Promise<any>
			quoted_value$($: {}): Promise<any>
			stripped_value(): Promise<any>
			stripped_value$($: {}): Promise<any>
		}
		interface IBareQuotedString extends IQuotedString {
			value(): Promise<any>
			value$($: {}): Promise<any>
		}
		interface IComment extends IWhiteSpaceTokenList {
			quote(value): Promise<any>
			quote$({ value }): Promise<any>
			content(): Promise<any>
			content$($: {}): Promise<any>
			comments(): Promise<any>
			comments$($: {}): Promise<any>
		}
		interface IAddressList extends ITokenList {
			addresses(): Promise<any>
			addresses$($: {}): Promise<any>
			mailboxes(): Promise<any>
			mailboxes$($: {}): Promise<any>
			all_mailboxes(): Promise<any>
			all_mailboxes$($: {}): Promise<any>
		}
		interface IAddress extends ITokenList {
			display_name(): Promise<any>
			display_name$($: {}): Promise<any>
			mailboxes(): Promise<any>
			mailboxes$($: {}): Promise<any>
			all_mailboxes(): Promise<any>
			all_mailboxes$($: {}): Promise<any>
		}
		interface IMailboxList extends ITokenList {
			mailboxes(): Promise<any>
			mailboxes$($: {}): Promise<any>
			all_mailboxes(): Promise<any>
			all_mailboxes$($: {}): Promise<any>
		}
		interface IGroupList extends ITokenList {
			mailboxes(): Promise<any>
			mailboxes$($: {}): Promise<any>
			all_mailboxes(): Promise<any>
			all_mailboxes$($: {}): Promise<any>
		}
		interface IGroup extends ITokenList {
			mailboxes(): Promise<any>
			mailboxes$($: {}): Promise<any>
			all_mailboxes(): Promise<any>
			all_mailboxes$($: {}): Promise<any>
			display_name(): Promise<any>
			display_name$($: {}): Promise<any>
		}
		interface INameAddr extends ITokenList {
			display_name(): Promise<any>
			display_name$($: {}): Promise<any>
			local_part(): Promise<any>
			local_part$($: {}): Promise<any>
			domain(): Promise<any>
			domain$($: {}): Promise<any>
			route(): Promise<any>
			route$($: {}): Promise<any>
			addr_spec(): Promise<any>
			addr_spec$($: {}): Promise<any>
		}
		interface IAngleAddr extends ITokenList {
			local_part(): Promise<any>
			local_part$($: {}): Promise<any>
			domain(): Promise<any>
			domain$($: {}): Promise<any>
			route(): Promise<any>
			route$($: {}): Promise<any>
			addr_spec(): Promise<any>
			addr_spec$($: {}): Promise<any>
		}
		interface IObsRoute extends ITokenList {
			domains(): Promise<any>
			domains$($: {}): Promise<any>
		}
		interface IMailbox extends ITokenList {
			display_name(): Promise<any>
			display_name$($: {}): Promise<any>
			local_part(): Promise<any>
			local_part$($: {}): Promise<any>
			domain(): Promise<any>
			domain$($: {}): Promise<any>
			route(): Promise<any>
			route$($: {}): Promise<any>
			addr_spec(): Promise<any>
			addr_spec$($: {}): Promise<any>
		}
		interface IInvalidMailbox extends ITokenList {
			display_name(): Promise<any>
			display_name$($: {}): Promise<any>
		}
		interface IDomain extends ITokenList {
			domain(): Promise<any>
			domain$($: {}): Promise<any>
		}
		interface IDotAtom extends ITokenList {
		}
		interface IDotAtomText extends ITokenList {
		}
		interface INoFoldLiteral extends ITokenList {
		}
		interface IAddrSpec extends ITokenList {
			local_part(): Promise<any>
			local_part$($: {}): Promise<any>
			domain(): Promise<any>
			domain$($: {}): Promise<any>
			value(): Promise<any>
			value$($: {}): Promise<any>
			addr_spec(): Promise<any>
			addr_spec$($: {}): Promise<any>
		}
		interface IObsLocalPart extends ITokenList {
		}
		interface IDisplayName extends IPhrase {
			display_name(): Promise<any>
			display_name$($: {}): Promise<any>
			value(): Promise<any>
			value$($: {}): Promise<any>
		}
		interface ILocalPart extends ITokenList {
			value(): Promise<any>
			value$($: {}): Promise<any>
			local_part(): Promise<any>
			local_part$($: {}): Promise<any>
		}
		interface IDomainLiteral extends ITokenList {
			domain(): Promise<any>
			domain$($: {}): Promise<any>
			ip(): Promise<any>
			ip$($: {}): Promise<any>
		}
		interface IMIMEVersion extends ITokenList {
			major
			minor
		}
		interface IParameter extends ITokenList {
			section_number(): Promise<any>
			section_number$($: {}): Promise<any>
			param_value(): Promise<any>
			param_value$($: {}): Promise<any>
			sectioned
			extended
		}
		interface IInvalidParameter extends IParameter {
		}
		interface IAttribute extends ITokenList {
			stripped_value(): Promise<any>
			stripped_value$($: {}): Promise<any>
		}
		interface ISection extends ITokenList {
			number
		}
		interface IValue extends ITokenList {
			stripped_value(): Promise<any>
			stripped_value$($: {}): Promise<any>
		}
		interface IMimeParameters extends ITokenList {
			params(): Promise<any>
			params$($: {}): Promise<any>
		}
		interface IParameterizedHeaderValue extends ITokenList {
			params(): Promise<any>
			params$($: {}): Promise<any>
		}
		interface IContentType extends IParameterizedHeaderValue {
			maintype
			subtype
		}
		interface IContentDisposition extends IParameterizedHeaderValue {
			content_disposition
		}
		interface IContentTransferEncoding extends ITokenList {
		}
		interface IHeaderLabel extends ITokenList {
		}
		interface IMsgID extends ITokenList {
			fold(policy): Promise<any>
			fold$({ policy }): Promise<any>
		}
		interface IMessageID extends IMsgID {
		}
		interface IInvalidMessageID extends IMessageID {
		}
		interface IHeader extends ITokenList {
		}
		interface ITerminal {
			pprint(): Promise<any>
			pprint$($: {}): Promise<any>
			all_defects(): Promise<any>
			all_defects$($: {}): Promise<any>
			pop_trailing_ws(): Promise<any>
			pop_trailing_ws$($: {}): Promise<any>
			comments(): Promise<any>
			comments$($: {}): Promise<any>
		}
		interface IWhiteSpaceTerminal extends ITerminal {
			value(): Promise<any>
			value$($: {}): Promise<any>
			startswith_fws(): Promise<any>
			startswith_fws$($: {}): Promise<any>
		}
		interface IValueTerminal extends ITerminal {
			value(): Promise<any>
			value$($: {}): Promise<any>
			startswith_fws(): Promise<any>
			startswith_fws$($: {}): Promise<any>
		}
		interface IEWWhiteSpaceTerminal extends IWhiteSpaceTerminal {
			value(): Promise<any>
			value$($: {}): Promise<any>
		}

		/**
		 * Invalid encoded word found while parsing headers.
		 */
		interface I_InvalidEwError {
		}
		let WSP: Promise<any>
		let CFWS_LEADER: Promise<any>
		let SPECIALS: Promise<any>
		let ATOM_ENDS: Promise<any>
		let DOT_ATOM_ENDS: Promise<any>
		let PHRASE_ENDS: Promise<any>
		let TSPECIALS: Promise<any>
		let TOKEN_ENDS: Promise<any>
		let ASPECIALS: Promise<any>
		let ATTRIBUTE_ENDS: Promise<any>
		let EXTENDED_ATTRIBUTE_ENDS: Promise<any>
		let rfc2047_matcher: Promise<any>
		let DOT: Promise<any>
		let ListSeparator: Promise<any>
		let RouteComponentMarker: Promise<any>
	}
	module _parseaddr {
		var _

		/**
		 * Convert a date string to a time tuple.
		 * 
		 *     Accounts for military timezones.
		 *     
		 */
		function parsedate_tz(data): Promise<any>
		function parsedate_tz$({ data }): Promise<any>

		/**
		 * Convert a time string to a time tuple.
		 */
		function parsedate(data): Promise<any>
		function parsedate$({ data }): Promise<any>

		/**
		 * Turn a 10-tuple as returned by parsedate_tz() into a POSIX timestamp.
		 */
		function mktime_tz(data): Promise<any>
		function mktime_tz$({ data }): Promise<any>

		/**
		 * Prepare string to be used in a quoted string.
		 * 
		 *     Turns backslash and double quote characters into quoted pairs.  These
		 *     are the only characters that need to be quoted inside a quoted string.
		 *     Does not add the surrounding double quotes.
		 *     
		 */
		function quote(str): Promise<any>
		function quote$({ str }): Promise<any>

		/**
		 * Address parser class by Ben Escoto.
		 * 
		 *     To understand what this class does, it helps to have a copy of RFC 2822 in
		 *     front of you.
		 * 
		 *     Note: this class interface is deprecated and may be removed in the future.
		 *     Use email.utils.AddressList instead.
		 *     
		 */

		/**
		 * Initialize a new instance.
		 * 
		 *         `field' is an unparsed address header field, containing
		 *         one or more addresses.
		 *         
		 */
		function AddrlistClass(field): Promise<IAddrlistClass>
		function AddrlistClass$({ field }): Promise<IAddrlistClass>
		interface IAddrlistClass {

			/**
			 * Skip white space and extract comments.
			 */
			gotonext(): Promise<any>
			gotonext$($: {}): Promise<any>

			/**
			 * Parse all addresses.
			 * 
			 *         Returns a list containing all of the addresses.
			 *         
			 */
			getaddrlist(): Promise<any>
			getaddrlist$($: {}): Promise<any>

			/**
			 * Parse the next address.
			 */
			getaddress(): Promise<any>
			getaddress$($: {}): Promise<any>

			/**
			 * Parse a route address (Return-path value).
			 * 
			 *         This method just skips all the route stuff and returns the addrspec.
			 *         
			 */
			getrouteaddr(): Promise<any>
			getrouteaddr$($: {}): Promise<any>

			/**
			 * Parse an RFC 2822 addr-spec.
			 */
			getaddrspec(): Promise<any>
			getaddrspec$($: {}): Promise<any>

			/**
			 * Get the complete domain name from an address.
			 */
			getdomain(): Promise<any>
			getdomain$($: {}): Promise<any>

			/**
			 * Parse a header fragment delimited by special characters.
			 * 
			 *         `beginchar' is the start character for the fragment.
			 *         If self is not looking at an instance of `beginchar' then
			 *         getdelimited returns the empty string.
			 * 
			 *         `endchars' is a sequence of allowable end-delimiting characters.
			 *         Parsing stops when one of these is encountered.
			 * 
			 *         If `allowcomments' is non-zero, embedded RFC 2822 comments are allowed
			 *         within the parsed fragment.
			 *         
			 */
			getdelimited(beginchar, endchars, allowcomments?: boolean): Promise<any>
			getdelimited$({ beginchar, endchars, allowcomments }: { beginchar, endchars, allowcomments?}): Promise<any>

			/**
			 * Get a quote-delimited fragment from self's field.
			 */
			getquote(): Promise<any>
			getquote$($: {}): Promise<any>

			/**
			 * Get a parenthesis-delimited fragment from self's field.
			 */
			getcomment(): Promise<any>
			getcomment$($: {}): Promise<any>

			/**
			 * Parse an RFC 2822 domain-literal.
			 */
			getdomainliteral(): Promise<any>
			getdomainliteral$($: {}): Promise<any>

			/**
			 * Parse an RFC 2822 atom.
			 * 
			 *         Optional atomends specifies a different set of end token delimiters
			 *         (the default is to use self.atomends).  This is used e.g. in
			 *         getphraselist() since phrase endings must not include the `.' (which
			 *         is legal in phrases).
			 */
			getatom(atomends?): Promise<any>
			getatom$({ atomends }: { atomends?}): Promise<any>

			/**
			 * Parse a sequence of RFC 2822 phrases.
			 * 
			 *         A phrase is a sequence of words, which are in turn either RFC 2822
			 *         atoms or quoted-strings.  Phrases are canonicalized by squeezing all
			 *         runs of continuous whitespace into one space.
			 *         
			 */
			getphraselist(): Promise<any>
			getphraselist$($: {}): Promise<any>
		}

		/**
		 * An AddressList encapsulates a list of parsed RFC 2822 addresses.
		 */
		function AddressList(field): Promise<IAddressList>
		function AddressList$({ field }): Promise<IAddressList>
		interface IAddressList extends IAddrlistClass {
		}
		let SPACE: Promise<any>
		let EMPTYSTRING: Promise<any>
		let COMMASPACE: Promise<any>
	}
	module _policybase {
		var _

		/**
		 * Policy Object basic framework.
		 * 
		 *     This class is useless unless subclassed.  A subclass should define
		 *     class attributes with defaults for any values that are to be
		 *     managed by the Policy object.  The constructor will then allow
		 *     non-default values to be set for these attributes at instance
		 *     creation time.  The instance will be callable, taking these same
		 *     attributes keyword arguments, and returning a new instance
		 *     identical to the called instance except for those values changed
		 *     by the keyword arguments.  Instances may be added, yielding new
		 *     instances with any non-default values from the right hand
		 *     operand overriding those in the left hand operand.  That is,
		 * 
		 *         A + B == A(<non-default values of B>)
		 * 
		 *     The repr of an instance can be used to reconstruct the object
		 *     if and only if the repr of the values can be used to reconstruct
		 *     those values.
		 * 
		 *     
		 */
		interface I_PolicyBase {

			/**
			 * Return a new instance with specified attributes changed.
			 * 
			 *         The new instance has the same attribute values as the current object,
			 *         except for the changes passed in as keyword arguments.
			 * 
			 *         
			 */
			clone(): Promise<any>
			clone$($: {}): Promise<any>
		}

		/**
		 * Controls for how messages are interpreted and formatted.
		 * 
		 *     Most of the classes and many of the methods in the email package accept
		 *     Policy objects as parameters.  A Policy object contains a set of values and
		 *     functions that control how input is interpreted and how output is rendered.
		 *     For example, the parameter 'raise_on_defect' controls whether or not an RFC
		 *     violation results in an error being raised or not, while 'max_line_length'
		 *     controls the maximum length of output lines when a Message is serialized.
		 * 
		 *     Any valid attribute may be overridden when a Policy is created by passing
		 *     it as a keyword argument to the constructor.  Policy objects are immutable,
		 *     but a new Policy object can be created with only certain values changed by
		 *     calling the Policy instance with keyword arguments.  Policy objects can
		 *     also be added, producing a new Policy object in which the non-default
		 *     attributes set in the right hand operand overwrite those specified in the
		 *     left operand.
		 * 
		 *     Settable attributes:
		 * 
		 *     raise_on_defect     -- If true, then defects should be raised as errors.
		 *                            Default: False.
		 * 
		 *     linesep             -- string containing the value to use as separation
		 *                            between output lines.  Default '\n'.
		 * 
		 *     cte_type            -- Type of allowed content transfer encodings
		 * 
		 *                            7bit  -- ASCII only
		 *                            8bit  -- Content-Transfer-Encoding: 8bit is allowed
		 * 
		 *                            Default: 8bit.  Also controls the disposition of
		 *                            (RFC invalid) binary data in headers; see the
		 *                            documentation of the binary_fold method.
		 * 
		 *     max_line_length     -- maximum length of lines, excluding 'linesep',
		 *                            during serialization.  None or 0 means no line
		 *                            wrapping is done.  Default is 78.
		 * 
		 *     mangle_from_        -- a flag that, when True escapes From_ lines in the
		 *                            body of the message by putting a `>' in front of
		 *                            them. This is used when the message is being
		 *                            serialized by a generator. Default: True.
		 * 
		 *     message_factory     -- the class to use to create new message objects.
		 *                            If the value is None, the default is Message.
		 * 
		 *     
		 */
		interface IPolicy extends I_PolicyBase {

			/**
			 * Based on policy, either raise defect or call register_defect.
			 * 
			 *             handle_defect(obj, defect)
			 * 
			 *         defect should be a Defect subclass, but in any case must be an
			 *         Exception subclass.  obj is the object on which the defect should be
			 *         registered if it is not raised.  If the raise_on_defect is True, the
			 *         defect is raised as an error, otherwise the object and the defect are
			 *         passed to register_defect.
			 * 
			 *         This method is intended to be called by parsers that discover defects.
			 *         The email package parsers always call it with Defect instances.
			 * 
			 *         
			 */
			handle_defect(obj, defect): Promise<any>
			handle_defect$({ obj, defect }): Promise<any>

			/**
			 * Record 'defect' on 'obj'.
			 * 
			 *         Called by handle_defect if raise_on_defect is False.  This method is
			 *         part of the Policy API so that Policy subclasses can implement custom
			 *         defect handling.  The default implementation calls the append method of
			 *         the defects attribute of obj.  The objects used by the email package by
			 *         default that get passed to this method will always have a defects
			 *         attribute with an append method.
			 * 
			 *         
			 */
			register_defect(obj, defect): Promise<any>
			register_defect$({ obj, defect }): Promise<any>

			/**
			 * Return the maximum allowed number of headers named 'name'.
			 * 
			 *         Called when a header is added to a Message object.  If the returned
			 *         value is not 0 or None, and there are already a number of headers with
			 *         the name 'name' equal to the value returned, a ValueError is raised.
			 * 
			 *         Because the default behavior of Message's __setitem__ is to append the
			 *         value to the list of headers, it is easy to create duplicate headers
			 *         without realizing it.  This method allows certain headers to be limited
			 *         in the number of instances of that header that may be added to a
			 *         Message programmatically.  (The limit is not observed by the parser,
			 *         which will faithfully produce as many headers as exist in the message
			 *         being parsed.)
			 * 
			 *         The default implementation returns None for all header names.
			 *         
			 */
			header_max_count(name): Promise<any>
			header_max_count$({ name }): Promise<any>

			/**
			 * Given a list of linesep terminated strings constituting the lines of
			 *         a single header, return the (name, value) tuple that should be stored
			 *         in the model.  The input lines should retain their terminating linesep
			 *         characters.  The lines passed in by the email package may contain
			 *         surrogateescaped binary data.
			 *         
			 */
			header_source_parse(sourcelines): Promise<any>
			header_source_parse$({ sourcelines }): Promise<any>

			/**
			 * Given the header name and the value provided by the application
			 *         program, return the (name, value) that should be stored in the model.
			 *         
			 */
			header_store_parse(name, value): Promise<any>
			header_store_parse$({ name, value }): Promise<any>

			/**
			 * Given the header name and the value from the model, return the value
			 *         to be returned to the application program that is requesting that
			 *         header.  The value passed in by the email package may contain
			 *         surrogateescaped binary data if the lines were parsed by a BytesParser.
			 *         The returned value should not contain any surrogateescaped data.
			 * 
			 *         
			 */
			header_fetch_parse(name, value): Promise<any>
			header_fetch_parse$({ name, value }): Promise<any>

			/**
			 * Given the header name and the value from the model, return a string
			 *         containing linesep characters that implement the folding of the header
			 *         according to the policy controls.  The value passed in by the email
			 *         package may contain surrogateescaped binary data if the lines were
			 *         parsed by a BytesParser.  The returned value should not contain any
			 *         surrogateescaped data.
			 * 
			 *         
			 */
			fold(name, value): Promise<any>
			fold$({ name, value }): Promise<any>

			/**
			 * Given the header name and the value from the model, return binary
			 *         data containing linesep characters that implement the folding of the
			 *         header according to the policy controls.  The value passed in by the
			 *         email package may contain surrogateescaped binary data.
			 * 
			 *         
			 */
			fold_binary(name, value): Promise<any>
			fold_binary$({ name, value }): Promise<any>
			raise_on_defect
			linesep
			cte_type
			max_line_length
			mangle_from_
			message_factory
		}

		/**
		 * +
		 *     This particular policy is the backward compatibility Policy.  It
		 *     replicates the behavior of the email package version 5.1.
		 *     
		 */
		interface ICompat32 extends IPolicy {

			/**
			 * +
			 *         The name is parsed as everything up to the ':' and returned unmodified.
			 *         The value is determined by stripping leading whitespace off the
			 *         remainder of the first line, joining all subsequent lines together, and
			 *         stripping any trailing carriage return or linefeed characters.
			 * 
			 *         
			 */
			header_source_parse(sourcelines): Promise<any>
			header_source_parse$({ sourcelines }): Promise<any>

			/**
			 * +
			 *         The name and value are returned unmodified.
			 *         
			 */
			header_store_parse(name, value): Promise<any>
			header_store_parse$({ name, value }): Promise<any>

			/**
			 * +
			 *         If the value contains binary data, it is converted into a Header object
			 *         using the unknown-8bit charset.  Otherwise it is returned unmodified.
			 *         
			 */
			header_fetch_parse(name, value): Promise<any>
			header_fetch_parse$({ name, value }): Promise<any>

			/**
			 * +
			 *         Headers are folded using the Header folding algorithm, which preserves
			 *         existing line breaks in the value, and wraps each resulting line to the
			 *         max_line_length.  Non-ASCII binary data are CTE encoded using the
			 *         unknown-8bit charset.
			 * 
			 *         
			 */
			fold(name, value): Promise<any>
			fold$({ name, value }): Promise<any>

			/**
			 * +
			 *         Headers are folded using the Header folding algorithm, which preserves
			 *         existing line breaks in the value, and wraps each resulting line to the
			 *         max_line_length.  If cte_type is 7bit, non-ascii binary data is CTE
			 *         encoded using the unknown-8bit charset.  Otherwise the original source
			 *         header is used, with its existing line breaks and/or binary data.
			 * 
			 *         
			 */
			fold_binary(name, value): Promise<any>
			fold_binary$({ name, value }): Promise<any>
		}
		let compat32: Promise<any>
	}
	module base64mime {
		var _

		/**
		 * Return the length of s when it is encoded with base64.
		 */
		function header_length(bytearray): Promise<any>
		function header_length$({ bytearray }): Promise<any>

		/**
		 * Encode a single header line with Base64 encoding in a given charset.
		 * 
		 *     charset names the character set to use to encode the header.  It defaults
		 *     to iso-8859-1.  Base64 encoding is defined in RFC 2045.
		 *     
		 */
		function header_encode(header_bytes, charset?): Promise<any>
		function header_encode$({ header_bytes, charset }: { header_bytes, charset?}): Promise<any>

		/**
		 * Encode a string with base64.
		 * 
		 *     Each line will be wrapped at, at most, maxlinelen characters (defaults to
		 *     76 characters).
		 * 
		 *     Each line of encoded text will end with eol, which defaults to "\n".  Set
		 *     this to "\r\n" if you will be using the result of this function directly
		 *     in an email.
		 *     
		 */
		function body_encode(s, maxlinelen?, eol?): Promise<any>
		function body_encode$({ s, maxlinelen, eol }: { s, maxlinelen?, eol?}): Promise<any>

		/**
		 * Decode a raw base64 string, returning a bytes object.
		 * 
		 *     This function does not parse a full MIME header value encoded with
		 *     base64 (like =?iso-8859-1?b?bmloISBuaWgh?=) -- please use the high
		 *     level email.header class for that functionality.
		 *     
		 */
		function decode(string): Promise<any>
		function decode$({ string }): Promise<any>
		let CRLF: Promise<any>
		let NL: Promise<any>
		let EMPTYSTRING: Promise<any>
		let MISC_LEN: Promise<any>
		let body_decode: Promise<any>
		let decodestring: Promise<any>
	}
	module charset {
		var _

		/**
		 * Add character set properties to the global registry.
		 * 
		 *     charset is the input character set, and must be the canonical name of a
		 *     character set.
		 * 
		 *     Optional header_enc and body_enc is either Charset.QP for
		 *     quoted-printable, Charset.BASE64 for base64 encoding, Charset.SHORTEST for
		 *     the shortest of qp or base64 encoding, or None for no encoding.  SHORTEST
		 *     is only valid for header_enc.  It describes how message headers and
		 *     message bodies in the input charset are to be encoded.  Default is no
		 *     encoding.
		 * 
		 *     Optional output_charset is the character set that the output should be
		 *     in.  Conversions will proceed from input charset, to Unicode, to the
		 *     output charset when the method Charset.convert() is called.  The default
		 *     is to output in the same character set as the input.
		 * 
		 *     Both input_charset and output_charset must have Unicode codec entries in
		 *     the module's charset-to-codec mapping; use add_codec(charset, codecname)
		 *     to add codecs the module does not know about.  See the codecs module's
		 *     documentation for more information.
		 *     
		 */
		function add_charset(charset, header_enc?, body_enc?, output_charset?): Promise<any>
		function add_charset$({ charset, header_enc, body_enc, output_charset }: { charset, header_enc?, body_enc?, output_charset?}): Promise<any>

		/**
		 * Add a character set alias.
		 * 
		 *     alias is the alias name, e.g. latin-1
		 *     canonical is the character set's canonical name, e.g. iso-8859-1
		 *     
		 */
		function add_alias(alias, canonical): Promise<any>
		function add_alias$({ alias, canonical }): Promise<any>

		/**
		 * Add a codec that map characters in the given charset to/from Unicode.
		 * 
		 *     charset is the canonical name of a character set.  codecname is the name
		 *     of a Python codec, as appropriate for the second argument to the unicode()
		 *     built-in, or to the encode() method of a Unicode string.
		 *     
		 */
		function add_codec(charset, codecname): Promise<any>
		function add_codec$({ charset, codecname }): Promise<any>

		/**
		 * Map character sets to their email properties.
		 * 
		 *     This class provides information about the requirements imposed on email
		 *     for a specific character set.  It also provides convenience routines for
		 *     converting between character sets, given the availability of the
		 *     applicable codecs.  Given a character set, it will do its best to provide
		 *     information on how to use that character set in an email in an
		 *     RFC-compliant way.
		 * 
		 *     Certain character sets must be encoded with quoted-printable or base64
		 *     when used in email headers or bodies.  Certain character sets must be
		 *     converted outright, and are not allowed in email.  Instances of this
		 *     module expose the following information about a character set:
		 * 
		 *     input_charset: The initial character set specified.  Common aliases
		 *                    are converted to their `official' email names (e.g. latin_1
		 *                    is converted to iso-8859-1).  Defaults to 7-bit us-ascii.
		 * 
		 *     header_encoding: If the character set must be encoded before it can be
		 *                      used in an email header, this attribute will be set to
		 *                      Charset.QP (for quoted-printable), Charset.BASE64 (for
		 *                      base64 encoding), or Charset.SHORTEST for the shortest of
		 *                      QP or BASE64 encoding.  Otherwise, it will be None.
		 * 
		 *     body_encoding: Same as header_encoding, but describes the encoding for the
		 *                    mail message's body, which indeed may be different than the
		 *                    header encoding.  Charset.SHORTEST is not allowed for
		 *                    body_encoding.
		 * 
		 *     output_charset: Some character sets must be converted before they can be
		 *                     used in email headers or bodies.  If the input_charset is
		 *                     one of them, this attribute will contain the name of the
		 *                     charset output will be converted to.  Otherwise, it will
		 *                     be None.
		 * 
		 *     input_codec: The name of the Python codec used to convert the
		 *                  input_charset to Unicode.  If no conversion codec is
		 *                  necessary, this attribute will be None.
		 * 
		 *     output_codec: The name of the Python codec used to convert Unicode
		 *                   to the output_charset.  If no conversion codec is necessary,
		 *                   this attribute will have the same value as the input_codec.
		 *     
		 */
		function Charset(input_charset?): Promise<ICharset>
		function Charset$({ input_charset }: { input_charset?}): Promise<ICharset>
		interface ICharset {

			/**
			 * Return the content-transfer-encoding used for body encoding.
			 * 
			 *         This is either the string `quoted-printable' or `base64' depending on
			 *         the encoding used, or it is a function in which case you should call
			 *         the function with a single argument, the Message object being
			 *         encoded.  The function should then set the Content-Transfer-Encoding
			 *         header itself to whatever is appropriate.
			 * 
			 *         Returns "quoted-printable" if self.body_encoding is QP.
			 *         Returns "base64" if self.body_encoding is BASE64.
			 *         Returns conversion function otherwise.
			 *         
			 */
			get_body_encoding(): Promise<any>
			get_body_encoding$($: {}): Promise<any>

			/**
			 * Return the output character set.
			 * 
			 *         This is self.output_charset if that is not None, otherwise it is
			 *         self.input_charset.
			 *         
			 */
			get_output_charset(): Promise<any>
			get_output_charset$($: {}): Promise<any>

			/**
			 * Header-encode a string by converting it first to bytes.
			 * 
			 *         The type of encoding (base64 or quoted-printable) will be based on
			 *         this charset's `header_encoding`.
			 * 
			 *         :param string: A unicode string for the header.  It must be possible
			 *             to encode this string to bytes using the character set's
			 *             output codec.
			 *         :return: The encoded string, with RFC 2047 chrome.
			 *         
			 */
			header_encode(string): Promise<any>
			header_encode$({ string }): Promise<any>

			/**
			 * Header-encode a string by converting it first to bytes.
			 * 
			 *         This is similar to `header_encode()` except that the string is fit
			 *         into maximum line lengths as given by the argument.
			 * 
			 *         :param string: A unicode string for the header.  It must be possible
			 *             to encode this string to bytes using the character set's
			 *             output codec.
			 *         :param maxlengths: Maximum line length iterator.  Each element
			 *             returned from this iterator will provide the next maximum line
			 *             length.  This parameter is used as an argument to built-in next()
			 *             and should never be exhausted.  The maximum line lengths should
			 *             not count the RFC 2047 chrome.  These line lengths are only a
			 *             hint; the splitter does the best it can.
			 *         :return: Lines of encoded strings, each with RFC 2047 chrome.
			 *         
			 */
			header_encode_lines(string, maxlengths): Promise<any>
			header_encode_lines$({ string, maxlengths }): Promise<any>

			/**
			 * Body-encode a string by converting it first to bytes.
			 * 
			 *         The type of encoding (base64 or quoted-printable) will be based on
			 *         self.body_encoding.  If body_encoding is None, we assume the
			 *         output charset is a 7bit encoding, so re-encoding the decoded
			 *         string using the ascii codec produces the correct string version
			 *         of the content.
			 *         
			 */
			body_encode(string): Promise<any>
			body_encode$({ string }): Promise<any>
		}
		let QP: Promise<any>
		let BASE64: Promise<any>
		let SHORTEST: Promise<any>
		let RFC2047_CHROME_LEN: Promise<any>
		let DEFAULT_CHARSET: Promise<any>
		let UNKNOWN8BIT: Promise<any>
		let EMPTYSTRING: Promise<any>
		let CHARSETS: Promise<any>
		let ALIASES: Promise<any>
		let CODEC_MAP: Promise<any>
	}
	module contentmanager {
		var _
		function get_text_content(msg, errors?): Promise<any>
		function get_text_content$({ msg, errors }: { msg, errors?}): Promise<any>
		function get_non_text_content(msg): Promise<any>
		function get_non_text_content$({ msg }): Promise<any>
		function get_message_content(msg): Promise<any>
		function get_message_content$({ msg }): Promise<any>
		function get_and_fixup_unknown_message_content(msg): Promise<any>
		function get_and_fixup_unknown_message_content$({ msg }): Promise<any>
		function set_text_content(msg, string, subtype?, charset?, cte?, disposition?, filename?, cid?, params?, headers?): Promise<any>
		function set_text_content$({ msg, string, subtype, charset, cte, disposition, filename, cid, params, headers }: { msg, string, subtype?, charset?, cte?, disposition?, filename?, cid?, params?, headers?}): Promise<any>
		function set_message_content(msg, message, subtype?, cte?, disposition?, filename?, cid?, params?, headers?): Promise<any>
		function set_message_content$({ msg, message, subtype, cte, disposition, filename, cid, params, headers }: { msg, message, subtype?, cte?, disposition?, filename?, cid?, params?, headers?}): Promise<any>
		function set_bytes_content(msg, data, maintype, subtype, cte?, disposition?, filename?, cid?, params?, headers?): Promise<any>
		function set_bytes_content$({ msg, data, maintype, subtype, cte, disposition, filename, cid, params, headers }: { msg, data, maintype, subtype, cte?, disposition?, filename?, cid?, params?, headers?}): Promise<any>
		function ContentManager(): Promise<IContentManager>
		function ContentManager$({ }): Promise<IContentManager>
		interface IContentManager {
			add_get_handler(key, handler): Promise<any>
			add_get_handler$({ key, handler }): Promise<any>
			get_content(msg): Promise<any>
			get_content$({ msg }): Promise<any>
			add_set_handler(typekey, handler): Promise<any>
			add_set_handler$({ typekey, handler }): Promise<any>
			set_content(msg, obj): Promise<any>
			set_content$({ msg, obj }): Promise<any>
		}
		let raw_data_manager: Promise<any>
	}
	module encoders {
		var _

		/**
		 * Encode the message's payload in Base64.
		 * 
		 *     Also, add an appropriate Content-Transfer-Encoding header.
		 *     
		 */
		function encode_base64(msg): Promise<any>
		function encode_base64$({ msg }): Promise<any>

		/**
		 * Encode the message's payload in quoted-printable.
		 * 
		 *     Also, add an appropriate Content-Transfer-Encoding header.
		 *     
		 */
		function encode_quopri(msg): Promise<any>
		function encode_quopri$({ msg }): Promise<any>

		/**
		 * Set the Content-Transfer-Encoding header to 7bit or 8bit.
		 */
		function encode_7or8bit(msg): Promise<any>
		function encode_7or8bit$({ msg }): Promise<any>

		/**
		 * Do nothing.
		 */
		function encode_noop(msg): Promise<any>
		function encode_noop$({ msg }): Promise<any>
	}
	module errors {
		var _

		/**
		 * Base class for errors in the email package.
		 */
		interface IMessageError {
		}

		/**
		 * Base class for message parsing errors.
		 */
		interface IMessageParseError extends IMessageError {
		}

		/**
		 * Error while parsing headers.
		 */
		interface IHeaderParseError extends IMessageParseError {
		}

		/**
		 * Couldn't find terminating boundary.
		 */
		interface IBoundaryError extends IMessageParseError {
		}

		/**
		 * Conversion to a multipart is prohibited.
		 */
		interface IMultipartConversionError extends IMessageError {
		}

		/**
		 * An illegal charset was given.
		 */
		interface ICharsetError extends IMessageError {
		}

		/**
		 * Base class for a message defect.
		 */
		function MessageDefect(line?): Promise<IMessageDefect>
		function MessageDefect$({ line }: { line?}): Promise<IMessageDefect>
		interface IMessageDefect {
		}

		/**
		 * A message claimed to be a multipart but had no boundary parameter.
		 */
		interface INoBoundaryInMultipartDefect extends IMessageDefect {
		}

		/**
		 * The claimed start boundary was never found.
		 */
		interface IStartBoundaryNotFoundDefect extends IMessageDefect {
		}

		/**
		 * A start boundary was found, but not the corresponding close boundary.
		 */
		interface ICloseBoundaryNotFoundDefect extends IMessageDefect {
		}

		/**
		 * A message had a continuation line as its first header line.
		 */
		interface IFirstHeaderLineIsContinuationDefect extends IMessageDefect {
		}

		/**
		 * A 'Unix-from' header was found in the middle of a header block.
		 */
		interface IMisplacedEnvelopeHeaderDefect extends IMessageDefect {
		}

		/**
		 * Found line with no leading whitespace and no colon before blank line.
		 */
		interface IMissingHeaderBodySeparatorDefect extends IMessageDefect {
		}

		/**
		 * A message claimed to be a multipart but no subparts were found.
		 */
		interface IMultipartInvariantViolationDefect extends IMessageDefect {
		}

		/**
		 * An invalid content transfer encoding was set on the multipart itself.
		 */
		interface IInvalidMultipartContentTransferEncodingDefect extends IMessageDefect {
		}

		/**
		 * Header contained bytes that could not be decoded
		 */
		interface IUndecodableBytesDefect extends IMessageDefect {
		}

		/**
		 * base64 encoded sequence had an incorrect length
		 */
		interface IInvalidBase64PaddingDefect extends IMessageDefect {
		}

		/**
		 * base64 encoded sequence had characters not in base64 alphabet
		 */
		interface IInvalidBase64CharactersDefect extends IMessageDefect {
		}

		/**
		 * base64 encoded sequence had invalid length (1 mod 4)
		 */
		interface IInvalidBase64LengthDefect extends IMessageDefect {
		}

		/**
		 * Base class for a header defect.
		 */
		function HeaderDefect(): Promise<IHeaderDefect>
		function HeaderDefect$({ }): Promise<IHeaderDefect>
		interface IHeaderDefect extends IMessageDefect {
		}

		/**
		 * Header is not valid, message gives details.
		 */
		interface IInvalidHeaderDefect extends IHeaderDefect {
		}

		/**
		 * A header that must have a value had none
		 */
		interface IHeaderMissingRequiredValue extends IHeaderDefect {
		}

		/**
		 * ASCII characters outside the ascii-printable range found
		 */
		function NonPrintableDefect(non_printables): Promise<INonPrintableDefect>
		function NonPrintableDefect$({ non_printables }): Promise<INonPrintableDefect>
		interface INonPrintableDefect extends IHeaderDefect {
		}

		/**
		 * Header uses syntax declared obsolete by RFC 5322
		 */
		interface IObsoleteHeaderDefect extends IHeaderDefect {
		}

		/**
		 * local_part contains non-ASCII characters
		 */
		interface INonASCIILocalPartDefect extends IHeaderDefect {
		}

		/**
		 * Header has unparseable or invalid date
		 */
		interface IInvalidDateDefect extends IHeaderDefect {
		}
		let MalformedHeaderDefect: Promise<any>
	}
	module feedparser {
		var _

		/**
		 * A file-ish object that can have new data loaded into it.
		 * 
		 *     You can also push and pop line-matching predicates onto a stack.  When the
		 *     current predicate matches the current line, a false EOF response
		 *     (i.e. empty string) is returned instead.  This lets the parser adhere to a
		 *     simple abstraction -- it parses until EOF closes the current message.
		 *     
		 */
		function BufferedSubFile(): Promise<IBufferedSubFile>
		function BufferedSubFile$({ }): Promise<IBufferedSubFile>
		interface IBufferedSubFile {
			push_eof_matcher(pred): Promise<any>
			push_eof_matcher$({ pred }): Promise<any>
			pop_eof_matcher(): Promise<any>
			pop_eof_matcher$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			readline(): Promise<any>
			readline$($: {}): Promise<any>
			unreadline(line): Promise<any>
			unreadline$({ line }): Promise<any>

			/**
			 * Push some new data into this object.
			 */
			push(data): Promise<any>
			push$({ data }): Promise<any>
			pushlines(lines): Promise<any>
			pushlines$({ lines }): Promise<any>
		}

		/**
		 * A feed-style parser of email.
		 */

		/**
		 * _factory is called with no arguments to create a new message obj
		 * 
		 *         The policy keyword specifies a policy object that controls a number of
		 *         aspects of the parser's operation.  The default policy maintains
		 *         backward compatibility.
		 * 
		 *         
		 */
		function FeedParser(_factory?): Promise<IFeedParser>
		function FeedParser$({ _factory }: { _factory?}): Promise<IFeedParser>
		interface IFeedParser {

			/**
			 * Push more data into the parser.
			 */
			feed(data): Promise<any>
			feed$({ data }): Promise<any>

			/**
			 * Parse all remaining data and return the root message object.
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>
		}

		/**
		 * Like FeedParser, but feed accepts bytes.
		 */
		interface IBytesFeedParser extends IFeedParser {
			feed(data): Promise<any>
			feed$({ data }): Promise<any>
		}
		let NLCRE: Promise<any>
		let NLCRE_bol: Promise<any>
		let NLCRE_eol: Promise<any>
		let NLCRE_crack: Promise<any>
		let headerRE: Promise<any>
		let EMPTYSTRING: Promise<any>
		let NL: Promise<any>
		let NeedMoreData: Promise<any>
	}
	module generator {
		var _

		/**
		 * Generates output from a Message object tree.
		 * 
		 *     This basic generator writes the message to the given file object as plain
		 *     text.
		 *     
		 */

		/**
		 * Create the generator for message flattening.
		 * 
		 *         outfp is the output file-like object for writing the message to.  It
		 *         must have a write() method.
		 * 
		 *         Optional mangle_from_ is a flag that, when True (the default if policy
		 *         is not set), escapes From_ lines in the body of the message by putting
		 *         a `>' in front of them.
		 * 
		 *         Optional maxheaderlen specifies the longest length for a non-continued
		 *         header.  When a header line is longer (in characters, with tabs
		 *         expanded to 8 spaces) than maxheaderlen, the header will split as
		 *         defined in the Header class.  Set maxheaderlen to zero to disable
		 *         header wrapping.  The default is 78, as recommended (but not required)
		 *         by RFC 2822.
		 * 
		 *         The policy keyword specifies a policy object that controls a number of
		 *         aspects of the generator's operation.  If no policy is specified,
		 *         the policy associated with the Message object passed to the
		 *         flatten method is used.
		 * 
		 *         
		 */
		function Generator(outfp, mangle_from_?, maxheaderlen?): Promise<IGenerator>
		function Generator$({ outfp, mangle_from_, maxheaderlen }: { outfp, mangle_from_?, maxheaderlen?}): Promise<IGenerator>
		interface IGenerator {
			write(s): Promise<any>
			write$({ s }): Promise<any>

			/**
			 * Print the message object tree rooted at msg to the output file
			 *         specified when the Generator instance was created.
			 * 
			 *         unixfrom is a flag that forces the printing of a Unix From_ delimiter
			 *         before the first object in the message tree.  If the original message
			 *         has no From_ delimiter, a `standard' one is crafted.  By default, this
			 *         is False to inhibit the printing of any From_ delimiter.
			 * 
			 *         Note that for subobjects, no From_ line is printed.
			 * 
			 *         linesep specifies the characters used to indicate a new line in
			 *         the output.  The default value is determined by the policy specified
			 *         when the Generator instance was created or, if none was specified,
			 *         from the policy associated with the msg.
			 * 
			 *         
			 */
			flatten(msg, unixfrom?: boolean, linesep?): Promise<any>
			flatten$({ msg, unixfrom, linesep }: { msg, unixfrom?, linesep?}): Promise<any>

			/**
			 * Clone this generator with the exact same options.
			 */
			clone(fp): Promise<any>
			clone$({ fp }): Promise<any>
		}

		/**
		 * Generates a bytes version of a Message object tree.
		 * 
		 *     Functionally identical to the base Generator except that the output is
		 *     bytes and not string.  When surrogates were used in the input to encode
		 *     bytes, these are decoded back to bytes for output.  If the policy has
		 *     cte_type set to 7bit, then the message is transformed such that the
		 *     non-ASCII bytes are properly content transfer encoded, using the charset
		 *     unknown-8bit.
		 * 
		 *     The outfp object must accept bytes in its write method.
		 *     
		 */
		interface IBytesGenerator extends IGenerator {
			write(s): Promise<any>
			write$({ s }): Promise<any>
		}

		/**
		 * Generates a text representation of a message.
		 * 
		 *     Like the Generator base class, except that non-text parts are substituted
		 *     with a format string representing the part.
		 *     
		 */

		/**
		 * Like Generator.__init__() except that an additional optional
		 *         argument is allowed.
		 * 
		 *         Walks through all subparts of a message.  If the subpart is of main
		 *         type `text', then it prints the decoded payload of the subpart.
		 * 
		 *         Otherwise, fmt is a format string that is used instead of the message
		 *         payload.  fmt is expanded with the following keywords (in
		 *         %(keyword)s format):
		 * 
		 *         type       : Full MIME type of the non-text part
		 *         maintype   : Main MIME type of the non-text part
		 *         subtype    : Sub-MIME type of the non-text part
		 *         filename   : Filename of the non-text part
		 *         description: Description associated with the non-text part
		 *         encoding   : Content transfer encoding of the non-text part
		 * 
		 *         The default value for fmt is None, meaning
		 * 
		 *         [Non-text (%(type)s) part of message omitted, filename %(filename)s]
		 *         
		 */
		function DecodedGenerator(outfp, mangle_from_?, maxheaderlen?, fmt?): Promise<IDecodedGenerator>
		function DecodedGenerator$({ outfp, mangle_from_, maxheaderlen, fmt }: { outfp, mangle_from_?, maxheaderlen?, fmt?}): Promise<IDecodedGenerator>
		interface IDecodedGenerator extends IGenerator {
		}
		let UNDERSCORE: Promise<any>
		let NL: Promise<any>
		let NLCRE: Promise<any>
		let fcre: Promise<any>
	}
	module header {
		var _

		/**
		 * Decode a message header value without converting charset.
		 * 
		 *     Returns a list of (string, charset) pairs containing each of the decoded
		 *     parts of the header.  Charset is None for non-encoded parts of the header,
		 *     otherwise a lower-case string containing the name of the character set
		 *     specified in the encoded string.
		 * 
		 *     header may be a string that may or may not contain RFC2047 encoded words,
		 *     or it may be a Header object.
		 * 
		 *     An email.errors.HeaderParseError may be raised when certain decoding error
		 *     occurs (e.g. a base64 decoding exception).
		 *     
		 */
		function decode_header(header): Promise<any>
		function decode_header$({ header }): Promise<any>

		/**
		 * Create a Header from a sequence of pairs as returned by decode_header()
		 * 
		 *     decode_header() takes a header value string and returns a sequence of
		 *     pairs of the format (decoded_string, charset) where charset is the string
		 *     name of the character set.
		 * 
		 *     This function takes one of those sequence of pairs and returns a Header
		 *     instance.  Optional maxlinelen, header_name, and continuation_ws are as in
		 *     the Header constructor.
		 *     
		 */
		function make_header(decoded_seq, maxlinelen?, header_name?, continuation_ws?): Promise<any>
		function make_header$({ decoded_seq, maxlinelen, header_name, continuation_ws }: { decoded_seq, maxlinelen?, header_name?, continuation_ws?}): Promise<any>

		/**
		 * Create a MIME-compliant header that can contain many character sets.
		 * 
		 *         Optional s is the initial header value.  If None, the initial header
		 *         value is not set.  You can later append to the header with .append()
		 *         method calls.  s may be a byte string or a Unicode string, but see the
		 *         .append() documentation for semantics.
		 * 
		 *         Optional charset serves two purposes: it has the same meaning as the
		 *         charset argument to the .append() method.  It also sets the default
		 *         character set for all subsequent .append() calls that omit the charset
		 *         argument.  If charset is not provided in the constructor, the us-ascii
		 *         charset is used both as s's initial charset and as the default for
		 *         subsequent .append() calls.
		 * 
		 *         The maximum line length can be specified explicitly via maxlinelen. For
		 *         splitting the first line to a shorter value (to account for the field
		 *         header which isn't included in s, e.g. `Subject') pass in the name of
		 *         the field in header_name.  The default maxlinelen is 78 as recommended
		 *         by RFC 2822.
		 * 
		 *         continuation_ws must be RFC 2822 compliant folding whitespace (usually
		 *         either a space or a hard tab) which will be prepended to continuation
		 *         lines.
		 * 
		 *         errors is passed through to the .append() call.
		 *         
		 */
		function Header(s?, charset?, maxlinelen?, header_name?, continuation_ws?, errors?): Promise<IHeader>
		function Header$({ s, charset, maxlinelen, header_name, continuation_ws, errors }: { s?, charset?, maxlinelen?, header_name?, continuation_ws?, errors?}): Promise<IHeader>
		interface IHeader {

			/**
			 * Append a string to the MIME header.
			 * 
			 *         Optional charset, if given, should be a Charset instance or the name
			 *         of a character set (which will be converted to a Charset instance).  A
			 *         value of None (the default) means that the charset given in the
			 *         constructor is used.
			 * 
			 *         s may be a byte string or a Unicode string.  If it is a byte string
			 *         (i.e. isinstance(s, str) is false), then charset is the encoding of
			 *         that byte string, and a UnicodeError will be raised if the string
			 *         cannot be decoded with that charset.  If s is a Unicode string, then
			 *         charset is a hint specifying the character set of the characters in
			 *         the string.  In either case, when producing an RFC 2822 compliant
			 *         header using RFC 2047 rules, the string will be encoded using the
			 *         output codec of the charset.  If the string cannot be encoded to the
			 *         output codec, a UnicodeError will be raised.
			 * 
			 *         Optional `errors' is passed as the errors argument to the decode
			 *         call if s is a byte string.
			 *         
			 */
			append(s, charset?, errors?): Promise<any>
			append$({ s, charset, errors }: { s, charset?, errors?}): Promise<any>

			/**
			 * Encode a message header into an RFC-compliant format.
			 * 
			 *         There are many issues involved in converting a given string for use in
			 *         an email header.  Only certain character sets are readable in most
			 *         email clients, and as header strings can only contain a subset of
			 *         7-bit ASCII, care must be taken to properly convert and encode (with
			 *         Base64 or quoted-printable) header strings.  In addition, there is a
			 *         75-character length limit on any given encoded header field, so
			 *         line-wrapping must be performed, even with double-byte character sets.
			 * 
			 *         Optional maxlinelen specifies the maximum length of each generated
			 *         line, exclusive of the linesep string.  Individual lines may be longer
			 *         than maxlinelen if a folding point cannot be found.  The first line
			 *         will be shorter by the length of the header name plus ": " if a header
			 *         name was specified at Header construction time.  The default value for
			 *         maxlinelen is determined at header construction time.
			 * 
			 *         Optional splitchars is a string containing characters which should be
			 *         given extra weight by the splitting algorithm during normal header
			 *         wrapping.  This is in very rough support of RFC 2822's `higher level
			 *         syntactic breaks':  split points preceded by a splitchar are preferred
			 *         during line splitting, with the characters preferred in the order in
			 *         which they appear in the string.  Space and tab may be included in the
			 *         string to indicate whether preference should be given to one over the
			 *         other as a split point when other split chars do not appear in the line
			 *         being split.  Splitchars does not affect RFC 2047 encoded lines.
			 * 
			 *         Optional linesep is a string to be used to separate the lines of
			 *         the value.  The default value is the most useful for typical
			 *         Python applications, but it can be set to \r\n to produce RFC-compliant
			 *         line separators when needed.
			 *         
			 */
			encode(splitchars?, maxlinelen?, linesep?): Promise<any>
			encode$({ splitchars, maxlinelen, linesep }: { splitchars?, maxlinelen?, linesep?}): Promise<any>
		}
		interface I_ValueFormatter {
			newline(): Promise<any>
			newline$($: {}): Promise<any>
			add_transition(): Promise<any>
			add_transition$($: {}): Promise<any>
			feed(fws, string, charset): Promise<any>
			feed$({ fws, string, charset }): Promise<any>
		}
		interface I_Accumulator {
			push(fws, string): Promise<any>
			push$({ fws, string }): Promise<any>
			pop_from(i?): Promise<any>
			pop_from$({ i }: { i?}): Promise<any>
			pop(): Promise<any>
			pop$($: {}): Promise<any>
			reset(startval?): Promise<any>
			reset$({ startval }: { startval?}): Promise<any>
			is_onlyws(): Promise<any>
			is_onlyws$($: {}): Promise<any>
			part_count(): Promise<any>
			part_count$($: {}): Promise<any>
		}
		let Charset: Promise<any>
		let NL: Promise<any>
		let SPACE: Promise<any>
		let BSPACE: Promise<any>
		let SPACE8: Promise<any>
		let EMPTYSTRING: Promise<any>
		let MAXLINELEN: Promise<any>
		let FWS: Promise<any>
		let USASCII: Promise<any>
		let UTF8: Promise<any>
		let ecre: Promise<any>
		let fcre: Promise<any>
	}
	module headerregistry {
		var _

		/**
		 * Create an object representing a full email address.
		 * 
		 *         An address can have a 'display_name', a 'username', and a 'domain'.  In
		 *         addition to specifying the username and domain separately, they may be
		 *         specified together by using the addr_spec keyword *instead of* the
		 *         username and domain keywords.  If an addr_spec string is specified it
		 *         must be properly quoted according to RFC 5322 rules; an error will be
		 *         raised if it is not.
		 * 
		 *         An Address object has display_name, username, domain, and addr_spec
		 *         attributes, all of which are read-only.  The addr_spec and the string
		 *         value of the object are both quoted according to RFC5322 rules, but
		 *         without any Content Transfer Encoding.
		 * 
		 *         
		 */
		function Address(display_name?, username?, domain?, addr_spec?): Promise<IAddress>
		function Address$({ display_name, username, domain, addr_spec }: { display_name?, username?, domain?, addr_spec?}): Promise<IAddress>
		interface IAddress {
			display_name(): Promise<any>
			display_name$($: {}): Promise<any>
			username(): Promise<any>
			username$($: {}): Promise<any>
			domain(): Promise<any>
			domain$($: {}): Promise<any>

			/**
			 * The addr_spec (username@domain) portion of the address, quoted
			 *         according to RFC 5322 rules, but with no Content Transfer Encoding.
			 *         
			 */
			addr_spec(): Promise<any>
			addr_spec$($: {}): Promise<any>
		}

		/**
		 * Create an object representing an address group.
		 * 
		 *         An address group consists of a display_name followed by colon and a
		 *         list of addresses (see Address) terminated by a semi-colon.  The Group
		 *         is created by specifying a display_name and a possibly empty list of
		 *         Address objects.  A Group can also be used to represent a single
		 *         address that is not in a group, which is convenient when manipulating
		 *         lists that are a combination of Groups and individual Addresses.  In
		 *         this case the display_name should be set to None.  In particular, the
		 *         string representation of a Group whose display_name is None is the same
		 *         as the Address object, if there is one and only one Address object in
		 *         the addresses list.
		 * 
		 *         
		 */
		function Group(display_name?, addresses?): Promise<IGroup>
		function Group$({ display_name, addresses }: { display_name?, addresses?}): Promise<IGroup>
		interface IGroup {
			display_name(): Promise<any>
			display_name$($: {}): Promise<any>
			addresses(): Promise<any>
			addresses$($: {}): Promise<any>
		}

		/**
		 * Base class for message headers.
		 * 
		 *     Implements generic behavior and provides tools for subclasses.
		 * 
		 *     A subclass must define a classmethod named 'parse' that takes an unfolded
		 *     value string and a dictionary as its arguments.  The dictionary will
		 *     contain one key, 'defects', initialized to an empty list.  After the call
		 *     the dictionary must contain two additional keys: parse_tree, set to the
		 *     parse tree obtained from parsing the header, and 'decoded', set to the
		 *     string value of the idealized representation of the data from the value.
		 *     (That is, encoded words are decoded, and values that have canonical
		 *     representations are so represented.)
		 * 
		 *     The defects key is intended to collect parsing defects, which the message
		 *     parser will subsequently dispose of as appropriate.  The parser should not,
		 *     insofar as practical, raise any errors.  Defects should be added to the
		 *     list instead.  The standard header parsers register defects for RFC
		 *     compliance issues, for obsolete RFC syntax, and for unrecoverable parsing
		 *     errors.
		 * 
		 *     The parse method may add additional keys to the dictionary.  In this case
		 *     the subclass must define an 'init' method, which will be passed the
		 *     dictionary as its keyword arguments.  The method should use (usually by
		 *     setting them as the value of similarly named attributes) and remove all the
		 *     extra keys added by its parse method, and then use super to call its parent
		 *     class with the remaining arguments and keywords.
		 * 
		 *     The subclass should also make sure that a 'max_count' attribute is defined
		 *     that is either None or 1. XXX: need to better define this API.
		 * 
		 *     
		 */
		interface IBaseHeader {
			init(name): Promise<any>
			init$({ name }): Promise<any>
			name(): Promise<any>
			name$($: {}): Promise<any>
			defects(): Promise<any>
			defects$($: {}): Promise<any>

			/**
			 * Fold header according to policy.
			 * 
			 *         The parsed representation of the header is folded according to
			 *         RFC5322 rules, as modified by the policy.  If the parse tree
			 *         contains surrogateescaped bytes, the bytes are CTE encoded using
			 *         the charset 'unknown-8bit".
			 * 
			 *         Any non-ASCII characters in the parse tree are CTE encoded using
			 *         charset utf-8. XXX: make this a policy setting.
			 * 
			 *         The returned value is an ASCII-only string possibly containing linesep
			 *         characters, and ending with a linesep character.  The string includes
			 *         the header name and the ': ' separator.
			 * 
			 *         
			 */
			fold(): Promise<any>
			fold$($: {}): Promise<any>
		}
		interface IUnstructuredHeader {
			parse(value, kwds): Promise<any>
			parse$({ value, kwds }): Promise<any>
			max_count
			value_parser
		}
		interface IUniqueUnstructuredHeader extends IUnstructuredHeader {
		}

		/**
		 * Header whose value consists of a single timestamp.
		 * 
		 *     Provides an additional attribute, datetime, which is either an aware
		 *     datetime using a timezone, or a naive datetime if the timezone
		 *     in the input string is -0000.  Also accepts a datetime as input.
		 *     The 'value' attribute is the normalized form of the timestamp,
		 *     which means it is the output of format_datetime on the datetime.
		 *     
		 */
		interface IDateHeader {
			parse(value, kwds): Promise<any>
			parse$({ value, kwds }): Promise<any>
			init(): Promise<any>
			init$($: {}): Promise<any>
			datetime(): Promise<any>
			datetime$($: {}): Promise<any>
		}
		interface IUniqueDateHeader extends IDateHeader {
		}
		interface IAddressHeader {
			value_parser(): Promise<any>
			value_parser$($: {}): Promise<any>
			parse(value, kwds): Promise<any>
			parse$({ value, kwds }): Promise<any>
			init(): Promise<any>
			init$($: {}): Promise<any>
			groups(): Promise<any>
			groups$($: {}): Promise<any>
			addresses(): Promise<any>
			addresses$($: {}): Promise<any>
		}
		interface IUniqueAddressHeader extends IAddressHeader {
		}
		interface ISingleAddressHeader extends IAddressHeader {
			address(): Promise<any>
			address$($: {}): Promise<any>
		}
		interface IUniqueSingleAddressHeader extends ISingleAddressHeader {
		}
		interface IMIMEVersionHeader {
			parse(value, kwds): Promise<any>
			parse$({ value, kwds }): Promise<any>
			init(): Promise<any>
			init$($: {}): Promise<any>
			major(): Promise<any>
			major$($: {}): Promise<any>
			minor(): Promise<any>
			minor$($: {}): Promise<any>
			version(): Promise<any>
			version$($: {}): Promise<any>
		}
		interface IParameterizedMIMEHeader {
			parse(value, kwds): Promise<any>
			parse$({ value, kwds }): Promise<any>
			init(): Promise<any>
			init$($: {}): Promise<any>
			params(): Promise<any>
			params$($: {}): Promise<any>
		}
		interface IContentTypeHeader extends IParameterizedMIMEHeader {
			init(): Promise<any>
			init$($: {}): Promise<any>
			maintype(): Promise<any>
			maintype$($: {}): Promise<any>
			subtype(): Promise<any>
			subtype$($: {}): Promise<any>
			content_type(): Promise<any>
			content_type$($: {}): Promise<any>
		}
		interface IContentDispositionHeader extends IParameterizedMIMEHeader {
			init(): Promise<any>
			init$($: {}): Promise<any>
			content_disposition(): Promise<any>
			content_disposition$($: {}): Promise<any>
		}
		interface IContentTransferEncodingHeader {
			parse(value, kwds): Promise<any>
			parse$({ value, kwds }): Promise<any>
			init(): Promise<any>
			init$($: {}): Promise<any>
			cte(): Promise<any>
			cte$($: {}): Promise<any>
		}
		interface IMessageIDHeader {
			parse(value, kwds): Promise<any>
			parse$({ value, kwds }): Promise<any>
		}

		/**
		 * A header_factory and header registry.
		 */

		/**
		 * Create a header_factory that works with the Policy API.
		 * 
		 *         base_class is the class that will be the last class in the created
		 *         header class's __bases__ list.  default_class is the class that will be
		 *         used if "name" (see __call__) does not appear in the registry.
		 *         use_default_map controls whether or not the default mapping of names to
		 *         specialized classes is copied in to the registry when the factory is
		 *         created.  The default is True.
		 * 
		 *         
		 */
		function HeaderRegistry(base_class?, default_class?, use_default_map?: boolean): Promise<IHeaderRegistry>
		function HeaderRegistry$({ base_class, default_class, use_default_map }: { base_class?, default_class?, use_default_map?}): Promise<IHeaderRegistry>
		interface IHeaderRegistry {

			/**
			 * Register cls as the specialized class for handling "name" headers.
			 * 
			 *         
			 */
			map_to_type(name, cls): Promise<any>
			map_to_type$({ name, cls }): Promise<any>
		}
	}
	module iterators {
		var _

		/**
		 * Walk over the message tree, yielding each subpart.
		 * 
		 *     The walk is performed in depth-first order.  This method is a
		 *     generator.
		 *     
		 */
		function walk(): Promise<any>
		function walk$({ }): Promise<any>

		/**
		 * Iterate over the parts, returning string payloads line-by-line.
		 * 
		 *     Optional decode (default False) is passed through to .get_payload().
		 *     
		 */
		function body_line_iterator(msg, decode?: boolean): Promise<any>
		function body_line_iterator$({ msg, decode }: { msg, decode?}): Promise<any>

		/**
		 * Iterate over the subparts with a given MIME type.
		 * 
		 *     Use `maintype' as the main MIME type to match against; this defaults to
		 *     "text".  Optional `subtype' is the MIME subtype to match against; if
		 *     omitted, only the main type is matched.
		 *     
		 */
		function typed_subpart_iterator(msg, maintype?, subtype?): Promise<any>
		function typed_subpart_iterator$({ msg, maintype, subtype }: { msg, maintype?, subtype?}): Promise<any>
	}
	module message {
		var _

		/**
		 * Basic message object.
		 * 
		 *     A message object is defined as something that has a bunch of RFC 2822
		 *     headers and a payload.  It may optionally have an envelope header
		 *     (a.k.a. Unix-From or From_ header).  If the message is a container (i.e. a
		 *     multipart or a message/rfc822), then the payload is a list of Message
		 *     objects, otherwise it is a string.
		 * 
		 *     Message objects implement part of the `mapping' interface, which assumes
		 *     there is exactly one occurrence of the header per message.  Some headers
		 *     do in fact appear multiple times (e.g. Received) and for those headers,
		 *     you must use the explicit API to set or get all the headers.  Not all of
		 *     the mapping methods are implemented.
		 *     
		 */
		function Message(policy?): Promise<IMessage>
		function Message$({ policy }: { policy?}): Promise<IMessage>
		interface IMessage {

			/**
			 * Return the entire formatted message as a string.
			 * 
			 *         Optional 'unixfrom', when true, means include the Unix From_ envelope
			 *         header.  For backward compatibility reasons, if maxheaderlen is
			 *         not specified it defaults to 0, so you must override it explicitly
			 *         if you want a different maxheaderlen.  'policy' is passed to the
			 *         Generator instance used to serialize the message; if it is not
			 *         specified the policy associated with the message instance is used.
			 * 
			 *         If the message object contains binary data that is not encoded
			 *         according to RFC standards, the non-compliant data will be replaced by
			 *         unicode "unknown character" code points.
			 *         
			 */
			as_string(unixfrom?: boolean, maxheaderlen?, policy?): Promise<any>
			as_string$({ unixfrom, maxheaderlen, policy }: { unixfrom?, maxheaderlen?, policy?}): Promise<any>

			/**
			 * Return the entire formatted message as a bytes object.
			 * 
			 *         Optional 'unixfrom', when true, means include the Unix From_ envelope
			 *         header.  'policy' is passed to the BytesGenerator instance used to
			 *         serialize the message; if not specified the policy associated with
			 *         the message instance is used.
			 *         
			 */
			as_bytes(unixfrom?: boolean, policy?): Promise<any>
			as_bytes$({ unixfrom, policy }: { unixfrom?, policy?}): Promise<any>

			/**
			 * Return True if the message consists of multiple parts.
			 */
			is_multipart(): Promise<any>
			is_multipart$($: {}): Promise<any>
			set_unixfrom(unixfrom): Promise<any>
			set_unixfrom$({ unixfrom }): Promise<any>
			get_unixfrom(): Promise<any>
			get_unixfrom$($: {}): Promise<any>

			/**
			 * Add the given payload to the current payload.
			 * 
			 *         The current payload will always be a list of objects after this method
			 *         is called.  If you want to set the payload to a scalar object, use
			 *         set_payload() instead.
			 *         
			 */
			attach(payload): Promise<any>
			attach$({ payload }): Promise<any>

			/**
			 * Return a reference to the payload.
			 * 
			 *         The payload will either be a list object or a string.  If you mutate
			 *         the list object, you modify the message's payload in place.  Optional
			 *         i returns that index into the payload.
			 * 
			 *         Optional decode is a flag indicating whether the payload should be
			 *         decoded or not, according to the Content-Transfer-Encoding header
			 *         (default is False).
			 * 
			 *         When True and the message is not a multipart, the payload will be
			 *         decoded if this header's value is `quoted-printable' or `base64'.  If
			 *         some other encoding is used, or the header is missing, or if the
			 *         payload has bogus data (i.e. bogus base64 or uuencoded data), the
			 *         payload is returned as-is.
			 * 
			 *         If the message is a multipart and the decode flag is True, then None
			 *         is returned.
			 *         
			 */
			get_payload(i?, decode?: boolean): Promise<any>
			get_payload$({ i, decode }: { i?, decode?}): Promise<any>

			/**
			 * Set the payload to the given value.
			 * 
			 *         Optional charset sets the message's default character set.  See
			 *         set_charset() for details.
			 *         
			 */
			set_payload(payload, charset?): Promise<any>
			set_payload$({ payload, charset }: { payload, charset?}): Promise<any>

			/**
			 * Set the charset of the payload to a given character set.
			 * 
			 *         charset can be a Charset instance, a string naming a character set, or
			 *         None.  If it is a string it will be converted to a Charset instance.
			 *         If charset is None, the charset parameter will be removed from the
			 *         Content-Type field.  Anything else will generate a TypeError.
			 * 
			 *         The message will be assumed to be of type text/* encoded with
			 *         charset.input_charset.  It will be converted to charset.output_charset
			 *         and encoded properly, if needed, when generating the plain text
			 *         representation of the message.  MIME headers (MIME-Version,
			 *         Content-Type, Content-Transfer-Encoding) will be added as needed.
			 *         
			 */
			set_charset(charset): Promise<any>
			set_charset$({ charset }): Promise<any>

			/**
			 * Return the Charset instance associated with the message's payload.
			 *         
			 */
			get_charset(): Promise<any>
			get_charset$($: {}): Promise<any>

			/**
			 * Return a list of all the message's header field names.
			 * 
			 *         These will be sorted in the order they appeared in the original
			 *         message, or were added to the message, and may contain duplicates.
			 *         Any fields deleted and re-inserted are always appended to the header
			 *         list.
			 *         
			 */
			keys(): Promise<any>
			keys$($: {}): Promise<any>

			/**
			 * Return a list of all the message's header values.
			 * 
			 *         These will be sorted in the order they appeared in the original
			 *         message, or were added to the message, and may contain duplicates.
			 *         Any fields deleted and re-inserted are always appended to the header
			 *         list.
			 *         
			 */
			values(): Promise<any>
			values$($: {}): Promise<any>

			/**
			 * Get all the message's header fields and values.
			 * 
			 *         These will be sorted in the order they appeared in the original
			 *         message, or were added to the message, and may contain duplicates.
			 *         Any fields deleted and re-inserted are always appended to the header
			 *         list.
			 *         
			 */
			items(): Promise<any>
			items$($: {}): Promise<any>

			/**
			 * Get a header value.
			 * 
			 *         Like __getitem__() but return failobj instead of None when the field
			 *         is missing.
			 *         
			 */
			get(name, failobj?): Promise<any>
			get$({ name, failobj }: { name, failobj?}): Promise<any>

			/**
			 * Store name and value in the model without modification.
			 * 
			 *         This is an "internal" API, intended only for use by a parser.
			 *         
			 */
			set_raw(name, value): Promise<any>
			set_raw$({ name, value }): Promise<any>

			/**
			 * Return the (name, value) header pairs without modification.
			 * 
			 *         This is an "internal" API, intended only for use by a generator.
			 *         
			 */
			raw_items(): Promise<any>
			raw_items$($: {}): Promise<any>

			/**
			 * Return a list of all the values for the named field.
			 * 
			 *         These will be sorted in the order they appeared in the original
			 *         message, and may contain duplicates.  Any fields deleted and
			 *         re-inserted are always appended to the header list.
			 * 
			 *         If no such fields exist, failobj is returned (defaults to None).
			 *         
			 */
			get_all(name, failobj?): Promise<any>
			get_all$({ name, failobj }: { name, failobj?}): Promise<any>

			/**
			 * Extended header setting.
			 * 
			 *         name is the header field to add.  keyword arguments can be used to set
			 *         additional parameters for the header field, with underscores converted
			 *         to dashes.  Normally the parameter will be added as key="value" unless
			 *         value is None, in which case only the key will be added.  If a
			 *         parameter value contains non-ASCII characters it can be specified as a
			 *         three-tuple of (charset, language, value), in which case it will be
			 *         encoded according to RFC2231 rules.  Otherwise it will be encoded using
			 *         the utf-8 charset and a language of ''.
			 * 
			 *         Examples:
			 * 
			 *         msg.add_header('content-disposition', 'attachment', filename='bud.gif')
			 *         msg.add_header('content-disposition', 'attachment',
			 *                        filename=('utf-8', '', Fuballer.ppt'))
			 *         msg.add_header('content-disposition', 'attachment',
			 *                        filename='Fuballer.ppt'))
			 *         
			 */
			add_header(_name, _value): Promise<any>
			add_header$({ _name, _value }): Promise<any>

			/**
			 * Replace a header.
			 * 
			 *         Replace the first matching header found in the message, retaining
			 *         header order and case.  If no matching header was found, a KeyError is
			 *         raised.
			 *         
			 */
			replace_header(_name, _value): Promise<any>
			replace_header$({ _name, _value }): Promise<any>

			/**
			 * Return the message's content type.
			 * 
			 *         The returned string is coerced to lower case of the form
			 *         `maintype/subtype'.  If there was no Content-Type header in the
			 *         message, the default type as given by get_default_type() will be
			 *         returned.  Since according to RFC 2045, messages always have a default
			 *         type this will always return a value.
			 * 
			 *         RFC 2045 defines a message's default type to be text/plain unless it
			 *         appears inside a multipart/digest container, in which case it would be
			 *         message/rfc822.
			 *         
			 */
			get_content_type(): Promise<any>
			get_content_type$($: {}): Promise<any>

			/**
			 * Return the message's main content type.
			 * 
			 *         This is the `maintype' part of the string returned by
			 *         get_content_type().
			 *         
			 */
			get_content_maintype(): Promise<any>
			get_content_maintype$($: {}): Promise<any>

			/**
			 * Returns the message's sub-content type.
			 * 
			 *         This is the `subtype' part of the string returned by
			 *         get_content_type().
			 *         
			 */
			get_content_subtype(): Promise<any>
			get_content_subtype$($: {}): Promise<any>

			/**
			 * Return the `default' content type.
			 * 
			 *         Most messages have a default content type of text/plain, except for
			 *         messages that are subparts of multipart/digest containers.  Such
			 *         subparts have a default content type of message/rfc822.
			 *         
			 */
			get_default_type(): Promise<any>
			get_default_type$($: {}): Promise<any>

			/**
			 * Set the `default' content type.
			 * 
			 *         ctype should be either "text/plain" or "message/rfc822", although this
			 *         is not enforced.  The default content type is not stored in the
			 *         Content-Type header.
			 *         
			 */
			set_default_type(ctype): Promise<any>
			set_default_type$({ ctype }): Promise<any>

			/**
			 * Return the message's Content-Type parameters, as a list.
			 * 
			 *         The elements of the returned list are 2-tuples of key/value pairs, as
			 *         split on the `=' sign.  The left hand side of the `=' is the key,
			 *         while the right hand side is the value.  If there is no `=' sign in
			 *         the parameter the value is the empty string.  The value is as
			 *         described in the get_param() method.
			 * 
			 *         Optional failobj is the object to return if there is no Content-Type
			 *         header.  Optional header is the header to search instead of
			 *         Content-Type.  If unquote is True, the value is unquoted.
			 *         
			 */
			get_params(failobj?, header?, unquote?: boolean): Promise<any>
			get_params$({ failobj, header, unquote }: { failobj?, header?, unquote?}): Promise<any>

			/**
			 * Return the parameter value if found in the Content-Type header.
			 * 
			 *         Optional failobj is the object to return if there is no Content-Type
			 *         header, or the Content-Type header has no such parameter.  Optional
			 *         header is the header to search instead of Content-Type.
			 * 
			 *         Parameter keys are always compared case insensitively.  The return
			 *         value can either be a string, or a 3-tuple if the parameter was RFC
			 *         2231 encoded.  When it's a 3-tuple, the elements of the value are of
			 *         the form (CHARSET, LANGUAGE, VALUE).  Note that both CHARSET and
			 *         LANGUAGE can be None, in which case you should consider VALUE to be
			 *         encoded in the us-ascii charset.  You can usually ignore LANGUAGE.
			 *         The parameter value (either the returned string, or the VALUE item in
			 *         the 3-tuple) is always unquoted, unless unquote is set to False.
			 * 
			 *         If your application doesn't care whether the parameter was RFC 2231
			 *         encoded, it can turn the return value into a string as follows:
			 * 
			 *             rawparam = msg.get_param('foo')
			 *             param = email.utils.collapse_rfc2231_value(rawparam)
			 * 
			 *         
			 */
			get_param(param, failobj?, header?, unquote?: boolean): Promise<any>
			get_param$({ param, failobj, header, unquote }: { param, failobj?, header?, unquote?}): Promise<any>

			/**
			 * Set a parameter in the Content-Type header.
			 * 
			 *         If the parameter already exists in the header, its value will be
			 *         replaced with the new value.
			 * 
			 *         If header is Content-Type and has not yet been defined for this
			 *         message, it will be set to "text/plain" and the new parameter and
			 *         value will be appended as per RFC 2045.
			 * 
			 *         An alternate header can be specified in the header argument, and all
			 *         parameters will be quoted as necessary unless requote is False.
			 * 
			 *         If charset is specified, the parameter will be encoded according to RFC
			 *         2231.  Optional language specifies the RFC 2231 language, defaulting
			 *         to the empty string.  Both charset and language should be strings.
			 *         
			 */
			set_param(param, value, header?, requote?: boolean, charset?, language?, replace?: boolean): Promise<any>
			set_param$({ param, value, header, requote, charset, language, replace }: { param, value, header?, requote?, charset?, language?, replace?}): Promise<any>

			/**
			 * Remove the given parameter completely from the Content-Type header.
			 * 
			 *         The header will be re-written in place without the parameter or its
			 *         value. All values will be quoted as necessary unless requote is
			 *         False.  Optional header specifies an alternative to the Content-Type
			 *         header.
			 *         
			 */
			del_param(param, header?, requote?: boolean): Promise<any>
			del_param$({ param, header, requote }: { param, header?, requote?}): Promise<any>

			/**
			 * Set the main type and subtype for the Content-Type header.
			 * 
			 *         type must be a string in the form "maintype/subtype", otherwise a
			 *         ValueError is raised.
			 * 
			 *         This method replaces the Content-Type header, keeping all the
			 *         parameters in place.  If requote is False, this leaves the existing
			 *         header's quoting as is.  Otherwise, the parameters will be quoted (the
			 *         default).
			 * 
			 *         An alternative header can be specified in the header argument.  When
			 *         the Content-Type header is set, we'll always also add a MIME-Version
			 *         header.
			 *         
			 */
			set_type(type, header?, requote?: boolean): Promise<any>
			set_type$({ type, header, requote }: { type, header?, requote?}): Promise<any>

			/**
			 * Return the filename associated with the payload if present.
			 * 
			 *         The filename is extracted from the Content-Disposition header's
			 *         `filename' parameter, and it is unquoted.  If that header is missing
			 *         the `filename' parameter, this method falls back to looking for the
			 *         `name' parameter.
			 *         
			 */
			get_filename(failobj?): Promise<any>
			get_filename$({ failobj }: { failobj?}): Promise<any>

			/**
			 * Return the boundary associated with the payload if present.
			 * 
			 *         The boundary is extracted from the Content-Type header's `boundary'
			 *         parameter, and it is unquoted.
			 *         
			 */
			get_boundary(failobj?): Promise<any>
			get_boundary$({ failobj }: { failobj?}): Promise<any>

			/**
			 * Set the boundary parameter in Content-Type to 'boundary'.
			 * 
			 *         This is subtly different than deleting the Content-Type header and
			 *         adding a new one with a new boundary parameter via add_header().  The
			 *         main difference is that using the set_boundary() method preserves the
			 *         order of the Content-Type header in the original message.
			 * 
			 *         HeaderParseError is raised if the message has no Content-Type header.
			 *         
			 */
			set_boundary(boundary): Promise<any>
			set_boundary$({ boundary }): Promise<any>

			/**
			 * Return the charset parameter of the Content-Type header.
			 * 
			 *         The returned string is always coerced to lower case.  If there is no
			 *         Content-Type header, or if that header has no charset parameter,
			 *         failobj is returned.
			 *         
			 */
			get_content_charset(failobj?): Promise<any>
			get_content_charset$({ failobj }: { failobj?}): Promise<any>

			/**
			 * Return a list containing the charset(s) used in this message.
			 * 
			 *         The returned list of items describes the Content-Type headers'
			 *         charset parameter for this message and all the subparts in its
			 *         payload.
			 * 
			 *         Each item will either be a string (the value of the charset parameter
			 *         in the Content-Type header of that part) or the value of the
			 *         'failobj' parameter (defaults to None), if the part does not have a
			 *         main MIME type of "text", or the charset is not defined.
			 * 
			 *         The list will contain one string for each part of the message, plus
			 *         one for the container message (i.e. self), so that a non-multipart
			 *         message will still return a list of length 1.
			 *         
			 */
			get_charsets(failobj?): Promise<any>
			get_charsets$({ failobj }: { failobj?}): Promise<any>

			/**
			 * Return the message's content-disposition if it exists, or None.
			 * 
			 *         The return values can be either 'inline', 'attachment' or None
			 *         according to the rfc2183.
			 *         
			 */
			get_content_disposition(): Promise<any>
			get_content_disposition$($: {}): Promise<any>
		}
		function MIMEPart(policy?): Promise<IMIMEPart>
		function MIMEPart$({ policy }: { policy?}): Promise<IMIMEPart>
		interface IMIMEPart extends IMessage {

			/**
			 * Return the entire formatted message as a string.
			 * 
			 *         Optional 'unixfrom', when true, means include the Unix From_ envelope
			 *         header.  maxheaderlen is retained for backward compatibility with the
			 *         base Message class, but defaults to None, meaning that the policy value
			 *         for max_line_length controls the header maximum length.  'policy' is
			 *         passed to the Generator instance used to serialize the message; if it
			 *         is not specified the policy associated with the message instance is
			 *         used.
			 *         
			 */
			as_string(unixfrom?: boolean, maxheaderlen?, policy?): Promise<any>
			as_string$({ unixfrom, maxheaderlen, policy }: { unixfrom?, maxheaderlen?, policy?}): Promise<any>
			is_attachment(): Promise<any>
			is_attachment$($: {}): Promise<any>

			/**
			 * Return best candidate mime part for display as 'body' of message.
			 * 
			 *         Do a depth first search, starting with self, looking for the first part
			 *         matching each of the items in preferencelist, and return the part
			 *         corresponding to the first item that has a match, or None if no items
			 *         have a match.  If 'related' is not included in preferencelist, consider
			 *         the root part of any multipart/related encountered as a candidate
			 *         match.  Ignore parts with 'Content-Disposition: attachment'.
			 *         
			 */
			get_body(preferencelist?): Promise<any>
			get_body$({ preferencelist }: { preferencelist?}): Promise<any>

			/**
			 * Return an iterator over the non-main parts of a multipart.
			 * 
			 *         Skip the first of each occurrence of text/plain, text/html,
			 *         multipart/related, or multipart/alternative in the multipart (unless
			 *         they have a 'Content-Disposition: attachment' header) and include all
			 *         remaining subparts in the returned iterator.  When applied to a
			 *         multipart/related, return all parts except the root part.  Return an
			 *         empty iterator when applied to a multipart/alternative or a
			 *         non-multipart.
			 *         
			 */
			iter_attachments(): Promise<any>
			iter_attachments$($: {}): Promise<any>

			/**
			 * Return an iterator over all immediate subparts of a multipart.
			 * 
			 *         Return an empty iterator for a non-multipart.
			 *         
			 */
			iter_parts(): Promise<any>
			iter_parts$($: {}): Promise<any>
			get_content(): Promise<any>
			get_content$($: {}): Promise<any>
			set_content(): Promise<any>
			set_content$($: {}): Promise<any>
			make_related(boundary?): Promise<any>
			make_related$({ boundary }: { boundary?}): Promise<any>
			make_alternative(boundary?): Promise<any>
			make_alternative$({ boundary }: { boundary?}): Promise<any>
			make_mixed(boundary?): Promise<any>
			make_mixed$({ boundary }: { boundary?}): Promise<any>
			add_related(): Promise<any>
			add_related$($: {}): Promise<any>
			add_alternative(): Promise<any>
			add_alternative$($: {}): Promise<any>
			add_attachment(): Promise<any>
			add_attachment$($: {}): Promise<any>
			clear(): Promise<any>
			clear$($: {}): Promise<any>
			clear_content(): Promise<any>
			clear_content$($: {}): Promise<any>
		}
		interface IEmailMessage extends IMIMEPart {
			set_content(): Promise<any>
			set_content$($: {}): Promise<any>
		}
		let Charset: Promise<any>
		let SEMISPACE: Promise<any>
		let tspecials: Promise<any>
	}
	module mime {
		var _
		module application {
			var _

			/**
			 * Class for generating application/* MIME documents.
			 */

			/**
			 * Create an application/* type MIME document.
			 * 
			 *         _data is a string containing the raw application data.
			 * 
			 *         _subtype is the MIME content type subtype, defaulting to
			 *         'octet-stream'.
			 * 
			 *         _encoder is a function which will perform the actual encoding for
			 *         transport of the application data, defaulting to base64 encoding.
			 * 
			 *         Any additional keyword arguments are passed to the base class
			 *         constructor, which turns them into parameters on the Content-Type
			 *         header.
			 *         
			 */
			function MIMEApplication(_data, _subtype?, _encoder?): Promise<IMIMEApplication>
			function MIMEApplication$({ _data, _subtype, _encoder }: { _data, _subtype?, _encoder?}): Promise<IMIMEApplication>
			interface IMIMEApplication {
			}
		}
		module audio {
			var _

			/**
			 * Class for generating audio/* MIME documents.
			 */

			/**
			 * Create an audio/* type MIME document.
			 * 
			 *         _audiodata is a string containing the raw audio data.  If this data
			 *         can be decoded by the standard Python `sndhdr' module, then the
			 *         subtype will be automatically included in the Content-Type header.
			 *         Otherwise, you can specify  the specific audio subtype via the
			 *         _subtype parameter.  If _subtype is not given, and no subtype can be
			 *         guessed, a TypeError is raised.
			 * 
			 *         _encoder is a function which will perform the actual encoding for
			 *         transport of the image data.  It takes one argument, which is this
			 *         Image instance.  It should use get_payload() and set_payload() to
			 *         change the payload to the encoded form.  It should also add any
			 *         Content-Transfer-Encoding or other headers to the message as
			 *         necessary.  The default encoding is Base64.
			 * 
			 *         Any additional keyword arguments are passed to the base class
			 *         constructor, which turns them into parameters on the Content-Type
			 *         header.
			 *         
			 */
			function MIMEAudio(_audiodata, _subtype?, _encoder?): Promise<IMIMEAudio>
			function MIMEAudio$({ _audiodata, _subtype, _encoder }: { _audiodata, _subtype?, _encoder?}): Promise<IMIMEAudio>
			interface IMIMEAudio {
			}
		}
		module base {
			var _

			/**
			 * Base class for MIME specializations.
			 */

			/**
			 * This constructor adds a Content-Type: and a MIME-Version: header.
			 * 
			 *         The Content-Type: header is taken from the _maintype and _subtype
			 *         arguments.  Additional parameters for this header are taken from the
			 *         keyword arguments.
			 *         
			 */
			function MIMEBase(_maintype, _subtype): Promise<IMIMEBase>
			function MIMEBase$({ _maintype, _subtype }): Promise<IMIMEBase>
			interface IMIMEBase {
			}
		}
		module image {
			var _

			/**
			 * Class for generating image/* type MIME documents.
			 */

			/**
			 * Create an image/* type MIME document.
			 * 
			 *         _imagedata is a string containing the raw image data.  If this data
			 *         can be decoded by the standard Python `imghdr' module, then the
			 *         subtype will be automatically included in the Content-Type header.
			 *         Otherwise, you can specify the specific image subtype via the _subtype
			 *         parameter.
			 * 
			 *         _encoder is a function which will perform the actual encoding for
			 *         transport of the image data.  It takes one argument, which is this
			 *         Image instance.  It should use get_payload() and set_payload() to
			 *         change the payload to the encoded form.  It should also add any
			 *         Content-Transfer-Encoding or other headers to the message as
			 *         necessary.  The default encoding is Base64.
			 * 
			 *         Any additional keyword arguments are passed to the base class
			 *         constructor, which turns them into parameters on the Content-Type
			 *         header.
			 *         
			 */
			function MIMEImage(_imagedata, _subtype?, _encoder?): Promise<IMIMEImage>
			function MIMEImage$({ _imagedata, _subtype, _encoder }: { _imagedata, _subtype?, _encoder?}): Promise<IMIMEImage>
			interface IMIMEImage {
			}
		}
		module message {
			var _

			/**
			 * Class representing message/* MIME documents.
			 */

			/**
			 * Create a message/* type MIME document.
			 * 
			 *         _msg is a message object and must be an instance of Message, or a
			 *         derived class of Message, otherwise a TypeError is raised.
			 * 
			 *         Optional _subtype defines the subtype of the contained message.  The
			 *         default is "rfc822" (this is defined by the MIME standard, even though
			 *         the term "rfc822" is technically outdated by RFC 2822).
			 *         
			 */
			function MIMEMessage(_msg, _subtype?): Promise<IMIMEMessage>
			function MIMEMessage$({ _msg, _subtype }: { _msg, _subtype?}): Promise<IMIMEMessage>
			interface IMIMEMessage {
			}
		}
		module multipart {
			var _

			/**
			 * Base class for MIME multipart/* type messages.
			 */

			/**
			 * Creates a multipart/* type message.
			 * 
			 *         By default, creates a multipart/mixed message, with proper
			 *         Content-Type and MIME-Version headers.
			 * 
			 *         _subtype is the subtype of the multipart content type, defaulting to
			 *         `mixed'.
			 * 
			 *         boundary is the multipart boundary string.  By default it is
			 *         calculated as needed.
			 * 
			 *         _subparts is a sequence of initial subparts for the payload.  It
			 *         must be an iterable object, such as a list.  You can always
			 *         attach new subparts to the message by using the attach() method.
			 * 
			 *         Additional parameters for the Content-Type header are taken from the
			 *         keyword arguments (or passed into the _params argument).
			 *         
			 */
			function MIMEMultipart(_subtype?, boundary?, _subparts?): Promise<IMIMEMultipart>
			function MIMEMultipart$({ _subtype, boundary, _subparts }: { _subtype?, boundary?, _subparts?}): Promise<IMIMEMultipart>
			interface IMIMEMultipart {
			}
		}
		module nonmultipart {
			var _

			/**
			 * Base class for MIME non-multipart type messages.
			 */
			interface IMIMENonMultipart {
				attach(payload): Promise<any>
				attach$({ payload }): Promise<any>
			}
		}
		module text {
			var _

			/**
			 * Class for generating text/* type MIME documents.
			 */

			/**
			 * Create a text/* type MIME document.
			 * 
			 *         _text is the string for this message object.
			 * 
			 *         _subtype is the MIME sub content type, defaulting to "plain".
			 * 
			 *         _charset is the character set parameter added to the Content-Type
			 *         header.  This defaults to "us-ascii".  Note that as a side-effect, the
			 *         Content-Transfer-Encoding header will also be set.
			 *         
			 */
			function MIMEText(_text, _subtype?, _charset?): Promise<IMIMEText>
			function MIMEText$({ _text, _subtype, _charset }: { _text, _subtype?, _charset?}): Promise<IMIMEText>
			interface IMIMEText {
			}
		}
	}
	module parser {
		var _

		/**
		 * Parser of RFC 2822 and MIME email messages.
		 * 
		 *         Creates an in-memory object tree representing the email message, which
		 *         can then be manipulated and turned over to a Generator to return the
		 *         textual representation of the message.
		 * 
		 *         The string must be formatted as a block of RFC 2822 headers and header
		 *         continuation lines, optionally preceded by a `Unix-from' header.  The
		 *         header block is terminated either by the end of the string or by a
		 *         blank line.
		 * 
		 *         _class is the class to instantiate for new message objects when they
		 *         must be created.  This class must have a constructor that can take
		 *         zero arguments.  Default is Message.Message.
		 * 
		 *         The policy keyword specifies a policy object that controls a number of
		 *         aspects of the parser's operation.  The default policy maintains
		 *         backward compatibility.
		 * 
		 *         
		 */
		function Parser(_class?): Promise<IParser>
		function Parser$({ _class }: { _class?}): Promise<IParser>
		interface IParser {

			/**
			 * Create a message structure from the data in a file.
			 * 
			 *         Reads all the data from the file and returns the root of the message
			 *         structure.  Optional headersonly is a flag specifying whether to stop
			 *         parsing after reading the headers or not.  The default is False,
			 *         meaning it parses the entire contents of the file.
			 *         
			 */
			parse(fp, headersonly?: boolean): Promise<any>
			parse$({ fp, headersonly }: { fp, headersonly?}): Promise<any>

			/**
			 * Create a message structure from a string.
			 * 
			 *         Returns the root of the message structure.  Optional headersonly is a
			 *         flag specifying whether to stop parsing after reading the headers or
			 *         not.  The default is False, meaning it parses the entire contents of
			 *         the file.
			 *         
			 */
			parsestr(text, headersonly?: boolean): Promise<any>
			parsestr$({ text, headersonly }: { text, headersonly?}): Promise<any>
		}
		interface IHeaderParser extends IParser {
			parse(fp, headersonly?: boolean): Promise<any>
			parse$({ fp, headersonly }: { fp, headersonly?}): Promise<any>
			parsestr(text, headersonly?: boolean): Promise<any>
			parsestr$({ text, headersonly }: { text, headersonly?}): Promise<any>
		}

		/**
		 * Parser of binary RFC 2822 and MIME email messages.
		 * 
		 *         Creates an in-memory object tree representing the email message, which
		 *         can then be manipulated and turned over to a Generator to return the
		 *         textual representation of the message.
		 * 
		 *         The input must be formatted as a block of RFC 2822 headers and header
		 *         continuation lines, optionally preceded by a `Unix-from' header.  The
		 *         header block is terminated either by the end of the input or by a
		 *         blank line.
		 * 
		 *         _class is the class to instantiate for new message objects when they
		 *         must be created.  This class must have a constructor that can take
		 *         zero arguments.  Default is Message.Message.
		 *         
		 */
		function BytesParser(): Promise<IBytesParser>
		function BytesParser$({ }): Promise<IBytesParser>
		interface IBytesParser {

			/**
			 * Create a message structure from the data in a binary file.
			 * 
			 *         Reads all the data from the file and returns the root of the message
			 *         structure.  Optional headersonly is a flag specifying whether to stop
			 *         parsing after reading the headers or not.  The default is False,
			 *         meaning it parses the entire contents of the file.
			 *         
			 */
			parse(fp, headersonly?: boolean): Promise<any>
			parse$({ fp, headersonly }: { fp, headersonly?}): Promise<any>

			/**
			 * Create a message structure from a byte string.
			 * 
			 *         Returns the root of the message structure.  Optional headersonly is a
			 *         flag specifying whether to stop parsing after reading the headers or
			 *         not.  The default is False, meaning it parses the entire contents of
			 *         the file.
			 *         
			 */
			parsebytes(text, headersonly?: boolean): Promise<any>
			parsebytes$({ text, headersonly }: { text, headersonly?}): Promise<any>
		}
		interface IBytesHeaderParser extends IBytesParser {
			parse(fp, headersonly?: boolean): Promise<any>
			parse$({ fp, headersonly }: { fp, headersonly?}): Promise<any>
			parsebytes(text, headersonly?: boolean): Promise<any>
			parsebytes$({ text, headersonly }: { text, headersonly?}): Promise<any>
		}
	}
	module policy {
		var _

		/**
		 * +
		 *     PROVISIONAL
		 * 
		 *     The API extensions enabled by this policy are currently provisional.
		 *     Refer to the documentation for details.
		 * 
		 *     This policy adds new header parsing and folding algorithms.  Instead of
		 *     simple strings, headers are custom objects with custom attributes
		 *     depending on the type of the field.  The folding algorithm fully
		 *     implements RFCs 2047 and 5322.
		 * 
		 *     In addition to the settable attributes listed above that apply to
		 *     all Policies, this policy adds the following additional attributes:
		 * 
		 *     utf8                -- if False (the default) message headers will be
		 *                            serialized as ASCII, using encoded words to encode
		 *                            any non-ASCII characters in the source strings.  If
		 *                            True, the message headers will be serialized using
		 *                            utf8 and will not contain encoded words (see RFC
		 *                            6532 for more on this serialization format).
		 * 
		 *     refold_source       -- if the value for a header in the Message object
		 *                            came from the parsing of some source, this attribute
		 *                            indicates whether or not a generator should refold
		 *                            that value when transforming the message back into
		 *                            stream form.  The possible values are:
		 * 
		 *                            none  -- all source values use original folding
		 *                            long  -- source values that have any line that is
		 *                                     longer than max_line_length will be
		 *                                     refolded
		 *                            all  -- all values are refolded.
		 * 
		 *                            The default is 'long'.
		 * 
		 *     header_factory      -- a callable that takes two arguments, 'name' and
		 *                            'value', where 'name' is a header field name and
		 *                            'value' is an unfolded header field value, and
		 *                            returns a string-like object that represents that
		 *                            header.  A default header_factory is provided that
		 *                            understands some of the RFC5322 header field types.
		 *                            (Currently address fields and date fields have
		 *                            special treatment, while all other fields are
		 *                            treated as unstructured.  This list will be
		 *                            completed before the extension is marked stable.)
		 * 
		 *     content_manager     -- an object with at least two methods: get_content
		 *                            and set_content.  When the get_content or
		 *                            set_content method of a Message object is called,
		 *                            it calls the corresponding method of this object,
		 *                            passing it the message object as its first argument,
		 *                            and any arguments or keywords that were passed to
		 *                            it as additional arguments.  The default
		 *                            content_manager is
		 *                            :data:`~email.contentmanager.raw_data_manager`.
		 * 
		 *     
		 */
		function EmailPolicy(): Promise<IEmailPolicy>
		function EmailPolicy$({ }): Promise<IEmailPolicy>
		interface IEmailPolicy {

			/**
			 * +
			 *         The implementation for this class returns the max_count attribute from
			 *         the specialized header class that would be used to construct a header
			 *         of type 'name'.
			 *         
			 */
			header_max_count(name): Promise<any>
			header_max_count$({ name }): Promise<any>

			/**
			 * +
			 *         The name is parsed as everything up to the ':' and returned unmodified.
			 *         The value is determined by stripping leading whitespace off the
			 *         remainder of the first line, joining all subsequent lines together, and
			 *         stripping any trailing carriage return or linefeed characters.  (This
			 *         is the same as Compat32).
			 * 
			 *         
			 */
			header_source_parse(sourcelines): Promise<any>
			header_source_parse$({ sourcelines }): Promise<any>

			/**
			 * +
			 *         The name is returned unchanged.  If the input value has a 'name'
			 *         attribute and it matches the name ignoring case, the value is returned
			 *         unchanged.  Otherwise the name and value are passed to header_factory
			 *         method, and the resulting custom header object is returned as the
			 *         value.  In this case a ValueError is raised if the input value contains
			 *         CR or LF characters.
			 * 
			 *         
			 */
			header_store_parse(name, value): Promise<any>
			header_store_parse$({ name, value }): Promise<any>

			/**
			 * +
			 *         If the value has a 'name' attribute, it is returned to unmodified.
			 *         Otherwise the name and the value with any linesep characters removed
			 *         are passed to the header_factory method, and the resulting custom
			 *         header object is returned.  Any surrogateescaped bytes get turned
			 *         into the unicode unknown-character glyph.
			 * 
			 *         
			 */
			header_fetch_parse(name, value): Promise<any>
			header_fetch_parse$({ name, value }): Promise<any>

			/**
			 * +
			 *         Header folding is controlled by the refold_source policy setting.  A
			 *         value is considered to be a 'source value' if and only if it does not
			 *         have a 'name' attribute (having a 'name' attribute means it is a header
			 *         object of some sort).  If a source value needs to be refolded according
			 *         to the policy, it is converted into a custom header object by passing
			 *         the name and the value with any linesep characters removed to the
			 *         header_factory method.  Folding of a custom header object is done by
			 *         calling its fold method with the current policy.
			 * 
			 *         Source values are split into lines using splitlines.  If the value is
			 *         not to be refolded, the lines are rejoined using the linesep from the
			 *         policy and returned.  The exception is lines containing non-ascii
			 *         binary data.  In that case the value is refolded regardless of the
			 *         refold_source setting, which causes the binary data to be CTE encoded
			 *         using the unknown-8bit charset.
			 * 
			 *         
			 */
			fold(name, value): Promise<any>
			fold$({ name, value }): Promise<any>

			/**
			 * +
			 *         The same as fold if cte_type is 7bit, except that the returned value is
			 *         bytes.
			 * 
			 *         If cte_type is 8bit, non-ASCII binary data is converted back into
			 *         bytes.  Headers with binary data are not refolded, regardless of the
			 *         refold_header setting, since there is no way to know whether the binary
			 *         data consists of single byte characters or multibyte characters.
			 * 
			 *         If utf8 is true, headers are encoded to utf8, otherwise to ascii with
			 *         non-ASCII unicode rendered as encoded words.
			 * 
			 *         
			 */
			fold_binary(name, value): Promise<any>
			fold_binary$({ name, value }): Promise<any>
			message_factory
			utf8
			refold_source
			header_factory
			content_manager
		}
		let linesep_splitter: Promise<any>
		let default$: Promise<any>
		let strict: Promise<any>
		let SMTP: Promise<any>
		let HTTP: Promise<any>
		let SMTPUTF8: Promise<any>
	}
	module quoprimime {
		var _

		/**
		 * Return True if the octet should be escaped with header quopri.
		 */
		function header_check(octet): Promise<any>
		function header_check$({ octet }): Promise<any>

		/**
		 * Return True if the octet should be escaped with body quopri.
		 */
		function body_check(octet): Promise<any>
		function body_check$({ octet }): Promise<any>

		/**
		 * Return a header quoted-printable encoding length.
		 * 
		 *     Note that this does not include any RFC 2047 chrome added by
		 *     `header_encode()`.
		 * 
		 *     :param bytearray: An array of bytes (a.k.a. octets).
		 *     :return: The length in bytes of the byte array when it is encoded with
		 *         quoted-printable for headers.
		 *     
		 */
		function header_length(bytearray): Promise<any>
		function header_length$({ bytearray }): Promise<any>

		/**
		 * Return a body quoted-printable encoding length.
		 * 
		 *     :param bytearray: An array of bytes (a.k.a. octets).
		 *     :return: The length in bytes of the byte array when it is encoded with
		 *         quoted-printable for bodies.
		 *     
		 */
		function body_length(bytearray): Promise<any>
		function body_length$({ bytearray }): Promise<any>

		/**
		 * Turn a string in the form =AB to the ASCII character with value 0xab
		 */
		function unquote(s): Promise<any>
		function unquote$({ s }): Promise<any>
		function quote(c): Promise<any>
		function quote$({ c }): Promise<any>

		/**
		 * Encode a single header line with quoted-printable (like) encoding.
		 * 
		 *     Defined in RFC 2045, this `Q' encoding is similar to quoted-printable, but
		 *     used specifically for email header fields to allow charsets with mostly 7
		 *     bit characters (and some 8 bit) to remain more or less readable in non-RFC
		 *     2045 aware mail clients.
		 * 
		 *     charset names the character set to use in the RFC 2046 header.  It
		 *     defaults to iso-8859-1.
		 *     
		 */
		function header_encode(header_bytes, charset?): Promise<any>
		function header_encode$({ header_bytes, charset }: { header_bytes, charset?}): Promise<any>

		/**
		 * Encode with quoted-printable, wrapping at maxlinelen characters.
		 * 
		 *     Each line of encoded text will end with eol, which defaults to "\n".  Set
		 *     this to "\r\n" if you will be using the result of this function directly
		 *     in an email.
		 * 
		 *     Each line will be wrapped at, at most, maxlinelen characters before the
		 *     eol string (maxlinelen defaults to 76 characters, the maximum value
		 *     permitted by RFC 2045).  Long lines will have the 'soft line break'
		 *     quoted-printable character "=" appended to them, so the decoded text will
		 *     be identical to the original text.
		 * 
		 *     The minimum maxlinelen is 4 to have room for a quoted character ("=XX")
		 *     followed by a soft line break.  Smaller values will generate a
		 *     ValueError.
		 * 
		 *     
		 */
		function body_encode(body, maxlinelen?, eol?): Promise<any>
		function body_encode$({ body, maxlinelen, eol }: { body, maxlinelen?, eol?}): Promise<any>

		/**
		 * Decode a quoted-printable string.
		 * 
		 *     Lines are separated with eol, which defaults to \n.
		 *     
		 */
		function decode(encoded, eol?): Promise<any>
		function decode$({ encoded, eol }: { encoded, eol?}): Promise<any>

		/**
		 * Decode a string encoded with RFC 2045 MIME header `Q' encoding.
		 * 
		 *     This function does not parse a full MIME header value encoded with
		 *     quoted-printable (like =?iso-8859-1?q?Hello_World?=) -- please use
		 *     the high level email.header class for that functionality.
		 *     
		 */
		function header_decode(s): Promise<any>
		function header_decode$({ s }): Promise<any>
		let CRLF: Promise<any>
		let NL: Promise<any>
		let EMPTYSTRING: Promise<any>
		let body_decode: Promise<any>
		let decodestring: Promise<any>
	}
	module utils {
		var _

		/**
		 * The inverse of parseaddr(), this takes a 2-tuple of the form
		 *     (realname, email_address) and returns the string value suitable
		 *     for an RFC 2822 From, To or Cc header.
		 * 
		 *     If the first element of pair is false, then the second element is
		 *     returned unmodified.
		 * 
		 *     The optional charset is the character set that is used to encode
		 *     realname in case realname is not ASCII safe.  Can be an instance of str or
		 *     a Charset-like object which has a header_encode method.  Default is
		 *     'utf-8'.
		 *     
		 */
		function formataddr(pair, charset?): Promise<any>
		function formataddr$({ pair, charset }: { pair, charset?}): Promise<any>

		/**
		 * Return a list of (REALNAME, EMAIL) for each fieldvalue.
		 */
		function getaddresses(fieldvalues): Promise<any>
		function getaddresses$({ fieldvalues }): Promise<any>

		/**
		 * Returns a date string as specified by RFC 2822, e.g.:
		 * 
		 *     Fri, 09 Nov 2001 01:08:47 -0000
		 * 
		 *     Optional timeval if given is a floating point time value as accepted by
		 *     gmtime() and localtime(), otherwise the current time is used.
		 * 
		 *     Optional localtime is a flag that when True, interprets timeval, and
		 *     returns a date relative to the local timezone instead of UTC, properly
		 *     taking daylight savings time into account.
		 * 
		 *     Optional argument usegmt means that the timezone is written out as
		 *     an ascii string, not numeric one (so "GMT" instead of "+0000"). This
		 *     is needed for HTTP, and is only used when localtime==False.
		 *     
		 */
		function formatdate(timeval?, localtime?: boolean, usegmt?: boolean): Promise<any>
		function formatdate$({ timeval, localtime, usegmt }: { timeval?, localtime?, usegmt?}): Promise<any>

		/**
		 * Turn a datetime into a date string as specified in RFC 2822.
		 * 
		 *     If usegmt is True, dt must be an aware datetime with an offset of zero.  In
		 *     this case 'GMT' will be rendered instead of the normal +0000 required by
		 *     RFC2822.  This is to support HTTP headers involving date stamps.
		 *     
		 */
		function format_datetime(dt, usegmt?: boolean): Promise<any>
		function format_datetime$({ dt, usegmt }: { dt, usegmt?}): Promise<any>

		/**
		 * Returns a string suitable for RFC 2822 compliant Message-ID, e.g:
		 * 
		 *     <142480216486.20800.16526388040877946887@nightshade.la.mastaler.com>
		 * 
		 *     Optional idstring if given is a string used to strengthen the
		 *     uniqueness of the message id.  Optional domain if given provides the
		 *     portion of the message id after the '@'.  It defaults to the locally
		 *     defined hostname.
		 *     
		 */
		function make_msgid(idstring?, domain?): Promise<any>
		function make_msgid$({ idstring, domain }: { idstring?, domain?}): Promise<any>
		function parsedate_to_datetime(data): Promise<any>
		function parsedate_to_datetime$({ data }): Promise<any>

		/**
		 * 
		 *     Parse addr into its constituent realname and email address parts.
		 * 
		 *     Return a tuple of realname and email address, unless the parse fails, in
		 *     which case return a 2-tuple of ('', '').
		 *     
		 */
		function parseaddr(addr): Promise<any>
		function parseaddr$({ addr }): Promise<any>

		/**
		 * Remove quotes from a string.
		 */
		function unquote(str): Promise<any>
		function unquote$({ str }): Promise<any>

		/**
		 * Decode string according to RFC 2231
		 */
		function decode_rfc2231(s): Promise<any>
		function decode_rfc2231$({ s }): Promise<any>

		/**
		 * Encode string according to RFC 2231.
		 * 
		 *     If neither charset nor language is given, then s is returned as-is.  If
		 *     charset is given but not language, the string is encoded using the empty
		 *     string for language.
		 *     
		 */
		function encode_rfc2231(s, charset?, language?): Promise<any>
		function encode_rfc2231$({ s, charset, language }: { s, charset?, language?}): Promise<any>

		/**
		 * Decode parameters list according to RFC 2231.
		 * 
		 *     params is a sequence of 2-tuples containing (param name, string value).
		 *     
		 */
		function decode_params(params): Promise<any>
		function decode_params$({ params }): Promise<any>
		function collapse_rfc2231_value(value, errors?, fallback_charset?): Promise<any>
		function collapse_rfc2231_value$({ value, errors, fallback_charset }: { value, errors?, fallback_charset?}): Promise<any>

		/**
		 * Return local time as an aware datetime object.
		 * 
		 *     If called without arguments, return current time.  Otherwise *dt*
		 *     argument should be a datetime instance, and it is converted to the
		 *     local time zone according to the system time zone database.  If *dt* is
		 *     naive (that is, dt.tzinfo is None), it is assumed to be in local time.
		 *     In this case, a positive or zero value for *isdst* causes localtime to
		 *     presume initially that summer time (for example, Daylight Saving Time)
		 *     is or is not (respectively) in effect for the specified time.  A
		 *     negative value for *isdst* causes the localtime() function to attempt
		 *     to divine whether summer time is in effect for the specified time.
		 * 
		 *     
		 */
		function localtime(dt?, isdst?): Promise<any>
		function localtime$({ dt, isdst }: { dt?, isdst?}): Promise<any>
		let COMMASPACE: Promise<any>
		let EMPTYSTRING: Promise<any>
		let UEMPTYSTRING: Promise<any>
		let CRLF: Promise<any>
		let TICK: Promise<any>
		let specialsre: Promise<any>
		let escapesre: Promise<any>
		let rfc2231_continuation: Promise<any>
	}
}
declare module encodings {
	var _

	/**
	 *  Normalize an encoding name.
	 * 
	 *         Normalization works as follows: all non-alphanumeric
	 *         characters except the dot used for Python package names are
	 *         collapsed and replaced with a single underscore, e.g. '  -;#'
	 *         becomes '_'. Leading and trailing underscores are removed.
	 * 
	 *         Note that encoding names should be ASCII only.
	 * 
	 *     
	 */
	function normalize_encoding(encoding): Promise<any>
	function normalize_encoding$({ encoding }): Promise<any>
	function search_function(encoding): Promise<any>
	function search_function$({ encoding }): Promise<any>
	interface ICodecRegistryError {
	}
	module aliases {
		var _
		let aliases: Promise<any>
	}
	module ascii {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamConverter extends IStreamWriter, IStreamReader {
		}
	}
	module base64_codec {
		var _
		function base64_encode(input, errors?): Promise<any>
		function base64_encode$({ input, errors }: { input, errors?}): Promise<any>
		function base64_decode(input, errors?): Promise<any>
		function base64_decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
			charbuffertype
		}
		interface IStreamReader extends ICodec {
		}
	}
	module big5 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module big5hkscs {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module bz2_codec {
		var _
		function bz2_encode(input, errors?): Promise<any>
		function bz2_encode$({ input, errors }: { input, errors?}): Promise<any>
		function bz2_decode(input, errors?): Promise<any>
		function bz2_decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		function IncrementalEncoder(errors?): Promise<IIncrementalEncoder>
		function IncrementalEncoder$({ errors }: { errors?}): Promise<IIncrementalEncoder>
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
			reset(): Promise<any>
			reset$($: {}): Promise<any>
		}
		function IncrementalDecoder(errors?): Promise<IIncrementalDecoder>
		function IncrementalDecoder$({ errors }: { errors?}): Promise<IIncrementalDecoder>
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
			reset(): Promise<any>
			reset$($: {}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
			charbuffertype
		}
		interface IStreamReader extends ICodec {
		}
	}
	module charmap {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		function IncrementalEncoder(errors?, mapping?): Promise<IIncrementalEncoder>
		function IncrementalEncoder$({ errors, mapping }: { errors?, mapping?}): Promise<IIncrementalEncoder>
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		function IncrementalDecoder(errors?, mapping?): Promise<IIncrementalDecoder>
		function IncrementalDecoder$({ errors, mapping }: { errors?, mapping?}): Promise<IIncrementalDecoder>
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		function StreamWriter(stream, errors?, mapping?): Promise<IStreamWriter>
		function StreamWriter$({ stream, errors, mapping }: { stream, errors?, mapping?}): Promise<IStreamWriter>
		interface IStreamWriter extends ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
		}
		function StreamReader(stream, errors?, mapping?): Promise<IStreamReader>
		function StreamReader$({ stream, errors, mapping }: { stream, errors?, mapping?}): Promise<IStreamReader>
		interface IStreamReader extends ICodec {
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
	}
	module cp037 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp1006 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp1026 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp1125 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp1140 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp1250 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp1251 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp1252 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp1253 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp1254 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp1255 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp1256 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp1257 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp1258 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp273 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp424 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp437 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp500 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp720 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp737 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp775 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp850 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp852 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp855 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp856 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp857 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp858 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp860 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp861 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp862 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp863 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp864 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp865 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp866 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp869 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module cp874 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp875 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module cp932 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module cp949 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module cp950 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module euc_jis_2004 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module euc_jisx0213 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module euc_jp {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module euc_kr {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module gb18030 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module gb2312 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module gbk {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module hex_codec {
		var _
		function hex_encode(input, errors?): Promise<any>
		function hex_encode$({ input, errors }: { input, errors?}): Promise<any>
		function hex_decode(input, errors?): Promise<any>
		function hex_decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
			charbuffertype
		}
		interface IStreamReader extends ICodec {
		}
	}
	module hp_roman8 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module hz {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module idna {
		var _
		function nameprep(label): Promise<any>
		function nameprep$({ label }): Promise<any>
		function ToASCII(label): Promise<any>
		function ToASCII$({ label }): Promise<any>
		function ToUnicode(label): Promise<any>
		function ToUnicode$({ label }): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
		}
		interface IIncrementalDecoder {
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let dots: Promise<any>
		let ace_prefix: Promise<any>
		let sace_prefix: Promise<any>
	}
	module iso2022_jp {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module iso2022_jp_1 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module iso2022_jp_2 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module iso2022_jp_2004 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module iso2022_jp_3 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module iso2022_jp_ext {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module iso2022_kr {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module iso8859_1 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module iso8859_10 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module iso8859_11 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module iso8859_13 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module iso8859_14 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module iso8859_15 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module iso8859_16 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module iso8859_2 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module iso8859_3 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module iso8859_4 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module iso8859_5 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module iso8859_6 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module iso8859_7 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module iso8859_8 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module iso8859_9 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module johab {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module koi8_r {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module koi8_t {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module koi8_u {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module kz1048 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module latin_1 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamConverter extends IStreamWriter, IStreamReader {
		}
	}
	module mac_arabic {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_map: Promise<any>
		let decoding_table: Promise<any>
		let encoding_map: Promise<any>
	}
	module mac_croatian {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module mac_cyrillic {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module mac_farsi {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module mac_greek {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module mac_iceland {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module mac_latin2 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module mac_roman {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module mac_romanian {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module mac_turkish {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module mbcs {
		var _
		function decode(input, errors?): Promise<any>
		function decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
		}
		interface IStreamWriter {
		}
		interface IStreamReader {
		}
	}
	module oem {
		var _
		function decode(input, errors?): Promise<any>
		function decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
		}
		interface IStreamWriter {
		}
		interface IStreamReader {
		}
	}
	module palmos {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module ptcp154 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module punycode {
		var _

		/**
		 * 3.1 Basic code point segregation
		 */
		function segregate(str): Promise<any>
		function segregate$({ str }): Promise<any>

		/**
		 * Return the length of str, considering only characters below max.
		 */
		function selective_len(str, max): Promise<any>
		function selective_len$({ str, max }): Promise<any>

		/**
		 * Return a pair (index, pos), indicating the next occurrence of
		 *     char in str. index is the position of the character considering
		 *     only ordinals up to and including char, and pos is the position in
		 *     the full string. index/pos is the starting position in the full
		 *     string.
		 */
		function selective_find(str, char, index, pos): Promise<any>
		function selective_find$({ str, char, index, pos }): Promise<any>

		/**
		 * 3.2 Insertion unsort coding
		 */
		function insertion_unsort(str, extended): Promise<any>
		function insertion_unsort$({ str, extended }): Promise<any>
		function T(j, bias): Promise<any>
		function T$({ j, bias }): Promise<any>

		/**
		 * 3.3 Generalized variable-length integers
		 */
		function generate_generalized_integer(N, bias): Promise<any>
		function generate_generalized_integer$({ N, bias }): Promise<any>
		function adapt(delta, first, numchars): Promise<any>
		function adapt$({ delta, first, numchars }): Promise<any>

		/**
		 * 3.4 Bias adaptation
		 */
		function generate_integers(baselen, deltas): Promise<any>
		function generate_integers$({ baselen, deltas }): Promise<any>
		function punycode_encode(text): Promise<any>
		function punycode_encode$({ text }): Promise<any>

		/**
		 * 3.3 Generalized variable-length integers
		 */
		function decode_generalized_number(extended, extpos, bias, errors): Promise<any>
		function decode_generalized_number$({ extended, extpos, bias, errors }): Promise<any>

		/**
		 * 3.2 Insertion unsort coding
		 */
		function insertion_sort(base, extended, errors): Promise<any>
		function insertion_sort$({ base, extended, errors }): Promise<any>
		function punycode_decode(text, errors): Promise<any>
		function punycode_decode$({ text, errors }): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let digits: Promise<any>
	}
	module quopri_codec {
		var _
		function quopri_encode(input, errors?): Promise<any>
		function quopri_encode$({ input, errors }: { input, errors?}): Promise<any>
		function quopri_decode(input, errors?): Promise<any>
		function quopri_decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
			charbuffertype
		}
		interface IStreamReader extends ICodec {
		}
	}
	module raw_unicode_escape {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
	}
	module rot_13 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		function rot13(infile, outfile): Promise<any>
		function rot13$({ infile, outfile }): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let rot13_map: Promise<any>
	}
	module shift_jis {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module shift_jis_2004 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module shift_jisx0213 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			codec
		}
		interface IIncrementalDecoder {
		}
		interface IStreamReader extends ICodec {
		}
		interface IStreamWriter extends ICodec {
		}
	}
	module tis_620 {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
		let decoding_table: Promise<any>
		let encoding_table: Promise<any>
	}
	module undefined {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
	}
	module unicode_escape {
		var _
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode
			decode
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
		}
		interface IStreamReader extends ICodec {
		}
	}
	module utf_16 {
		var _
		function decode(input, errors?): Promise<any>
		function decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		function IncrementalEncoder(errors?): Promise<IIncrementalEncoder>
		function IncrementalEncoder$({ errors }: { errors?}): Promise<IIncrementalEncoder>
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
			reset(): Promise<any>
			reset$($: {}): Promise<any>
			getstate(): Promise<any>
			getstate$($: {}): Promise<any>
			setstate(state): Promise<any>
			setstate$({ state }): Promise<any>
		}
		function IncrementalDecoder(errors?): Promise<IIncrementalDecoder>
		function IncrementalDecoder$({ errors }: { errors?}): Promise<IIncrementalDecoder>
		interface IIncrementalDecoder {
			reset(): Promise<any>
			reset$($: {}): Promise<any>
			getstate(): Promise<any>
			getstate$($: {}): Promise<any>
			setstate(state): Promise<any>
			setstate$({ state }): Promise<any>
		}
		function StreamWriter(stream, errors?): Promise<IStreamWriter>
		function StreamWriter$({ stream, errors }: { stream, errors?}): Promise<IStreamWriter>
		interface IStreamWriter {
			reset(): Promise<any>
			reset$($: {}): Promise<any>
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IStreamReader {
			reset(): Promise<any>
			reset$($: {}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
	}
	module utf_16_be {
		var _
		function decode(input, errors?): Promise<any>
		function decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
		}
		interface IStreamWriter {
		}
		interface IStreamReader {
		}
	}
	module utf_16_le {
		var _
		function decode(input, errors?): Promise<any>
		function decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
		}
		interface IStreamWriter {
		}
		interface IStreamReader {
		}
	}
	module utf_32 {
		var _
		function decode(input, errors?): Promise<any>
		function decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		function IncrementalEncoder(errors?): Promise<IIncrementalEncoder>
		function IncrementalEncoder$({ errors }: { errors?}): Promise<IIncrementalEncoder>
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
			reset(): Promise<any>
			reset$($: {}): Promise<any>
			getstate(): Promise<any>
			getstate$($: {}): Promise<any>
			setstate(state): Promise<any>
			setstate$({ state }): Promise<any>
		}
		function IncrementalDecoder(errors?): Promise<IIncrementalDecoder>
		function IncrementalDecoder$({ errors }: { errors?}): Promise<IIncrementalDecoder>
		interface IIncrementalDecoder {
			reset(): Promise<any>
			reset$($: {}): Promise<any>
			getstate(): Promise<any>
			getstate$($: {}): Promise<any>
			setstate(state): Promise<any>
			setstate$({ state }): Promise<any>
		}
		function StreamWriter(stream, errors?): Promise<IStreamWriter>
		function StreamWriter$({ stream, errors }: { stream, errors?}): Promise<IStreamWriter>
		interface IStreamWriter {
			reset(): Promise<any>
			reset$($: {}): Promise<any>
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IStreamReader {
			reset(): Promise<any>
			reset$($: {}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
	}
	module utf_32_be {
		var _
		function decode(input, errors?): Promise<any>
		function decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
		}
		interface IStreamWriter {
		}
		interface IStreamReader {
		}
	}
	module utf_32_le {
		var _
		function decode(input, errors?): Promise<any>
		function decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
		}
		interface IStreamWriter {
		}
		interface IStreamReader {
		}
	}
	module utf_7 {
		var _
		function decode(input, errors?): Promise<any>
		function decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
		}
		interface IStreamWriter {
		}
		interface IStreamReader {
		}
	}
	module utf_8 {
		var _
		function decode(input, errors?): Promise<any>
		function decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
		}
		interface IStreamWriter {
		}
		interface IStreamReader {
		}
	}
	module utf_8_sig {
		var _
		function encode(input, errors?): Promise<any>
		function encode$({ input, errors }: { input, errors?}): Promise<any>
		function decode(input, errors?): Promise<any>
		function decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		function IncrementalEncoder(errors?): Promise<IIncrementalEncoder>
		function IncrementalEncoder$({ errors }: { errors?}): Promise<IIncrementalEncoder>
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
			reset(): Promise<any>
			reset$($: {}): Promise<any>
			getstate(): Promise<any>
			getstate$($: {}): Promise<any>
			setstate(state): Promise<any>
			setstate$({ state }): Promise<any>
		}
		function IncrementalDecoder(errors?): Promise<IIncrementalDecoder>
		function IncrementalDecoder$({ errors }: { errors?}): Promise<IIncrementalDecoder>
		interface IIncrementalDecoder {
			reset(): Promise<any>
			reset$($: {}): Promise<any>
			getstate(): Promise<any>
			getstate$($: {}): Promise<any>
			setstate(state): Promise<any>
			setstate$({ state }): Promise<any>
		}
		interface IStreamWriter {
			reset(): Promise<any>
			reset$($: {}): Promise<any>
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IStreamReader {
			reset(): Promise<any>
			reset$($: {}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
	}
	module uu_codec {
		var _
		function uu_encode(input, errors?, filename?, mode?): Promise<any>
		function uu_encode$({ input, errors, filename, mode }: { input, errors?, filename?, mode?}): Promise<any>
		function uu_decode(input, errors?): Promise<any>
		function uu_decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
			charbuffertype
		}
		interface IStreamReader extends ICodec {
		}
	}
	module zlib_codec {
		var _
		function zlib_encode(input, errors?): Promise<any>
		function zlib_encode$({ input, errors }: { input, errors?}): Promise<any>
		function zlib_decode(input, errors?): Promise<any>
		function zlib_decode$({ input, errors }: { input, errors?}): Promise<any>
		function getregentry(): Promise<any>
		function getregentry$($: {}): Promise<any>
		interface ICodec {
			encode(input, errors?): Promise<any>
			encode$({ input, errors }: { input, errors?}): Promise<any>
			decode(input, errors?): Promise<any>
			decode$({ input, errors }: { input, errors?}): Promise<any>
		}
		function IncrementalEncoder(errors?): Promise<IIncrementalEncoder>
		function IncrementalEncoder$({ errors }: { errors?}): Promise<IIncrementalEncoder>
		interface IIncrementalEncoder {
			encode(input, final?: boolean): Promise<any>
			encode$({ input, final }: { input, final?}): Promise<any>
			reset(): Promise<any>
			reset$($: {}): Promise<any>
		}
		function IncrementalDecoder(errors?): Promise<IIncrementalDecoder>
		function IncrementalDecoder$({ errors }: { errors?}): Promise<IIncrementalDecoder>
		interface IIncrementalDecoder {
			decode(input, final?: boolean): Promise<any>
			decode$({ input, final }: { input, final?}): Promise<any>
			reset(): Promise<any>
			reset$($: {}): Promise<any>
		}
		interface IStreamWriter extends ICodec {
			charbuffertype
		}
		interface IStreamReader extends ICodec {
		}
	}
}
declare module ensurepip {
	var _

	/**
	 * 
	 *     Returns a string specifying the bundled version of pip.
	 *     
	 */
	function version(): Promise<any>
	function version$($: {}): Promise<any>

	/**
	 * 
	 *     Bootstrap pip into the current Python installation (or the given root
	 *     directory).
	 * 
	 *     Note that calling this function will alter both sys.path and os.environ.
	 *     
	 */
	function bootstrap(): Promise<any>
	function bootstrap$($: {}): Promise<any>
	module __main__ {
		var _
	}
	module _uninstall {
		var _
	}
}
declare module _enum {
	var _
	function show_flag_values(value): Promise<any>
	function show_flag_values$({ value }): Promise<any>

	/**
	 * 
	 *     Like built-in bin(), except negative values are represented in
	 *     twos-compliment, and the leading bit always indicates sign
	 *     (0=positive, 1=negative).
	 * 
	 *     >>> bin(10)
	 *     '0b0 1010'
	 *     >>> bin(~10)   # ~10 is -11
	 *     '0b1 0101'
	 *     
	 */
	function bin(num, max_bits?): Promise<any>
	function bin$({ num, max_bits }: { num, max_bits?}): Promise<any>

	/**
	 * 
	 *     Class decorator for enumerations ensuring unique member values.
	 *     
	 */
	function unique(enumeration): Promise<any>
	function unique$({ enumeration }): Promise<any>
	function global_enum_repr(): Promise<any>
	function global_enum_repr$({ }): Promise<any>
	function global_flag_repr(): Promise<any>
	function global_flag_repr$({ }): Promise<any>

	/**
	 * 
	 *     decorator that makes the repr() of an enum member reference its module
	 *     instead of its class; also exports all members to the enum's module's
	 *     global namespace
	 *     
	 */
	function global_enum(cls): Promise<any>
	function global_enum$({ cls }): Promise<any>

	/**
	 * 
	 *     Instances are replaced with an appropriate value in Enum class suites.
	 *     
	 */
	interface Iauto {
		value
	}

	/**
	 * 
	 *     This is a descriptor, used to define attributes that act differently
	 *     when accessed through an enum member and through an enum class.
	 *     Instance access is the same as property(), but access to an attribute
	 *     through the enum class will instead look in the class' _member_map_ for
	 *     a corresponding enum member.
	 *     
	 */
	interface Iproperty {
	}

	/**
	 * 
	 *     intermediate step for enum members between class execution and final creation
	 *     
	 */
	interface I_proto_member {
	}

	/**
	 * 
	 *     Track enum member order and ensure member names are not reused.
	 * 
	 *     EnumType will use the names found in self._member_names as the
	 *     enumeration member names.
	 *     
	 */
	interface I_EnumDict {
		update(members): Promise<any>
		update$({ members }): Promise<any>
	}

	/**
	 * 
	 *     Metaclass for Enum
	 *     
	 */
	interface IEnumType {
	}

	/**
	 * 
	 *     Generic enumeration.
	 * 
	 *     Derive from this class to define new enumerations.
	 *     
	 */
	interface IEnum {

		/**
		 * The name of the Enum member.
		 */
		name(): Promise<any>
		name$($: {}): Promise<any>

		/**
		 * The value of the Enum member.
		 */
		value(): Promise<any>
		value$($: {}): Promise<any>
	}

	/**
	 * 
	 *     Enum where members are also (and must be) ints
	 *     
	 */
	interface IIntEnum extends IEnum {
	}

	/**
	 * 
	 *     Enum where members are also (and must be) strings
	 *     
	 */
	interface IStrEnum extends IEnum {
	}

	/**
	 * 
	 *     control how out of range values are handled
	 *     "strict" -> error is raised  [default for Flag]
	 *     "conform" -> extra bits are discarded
	 *     "eject" -> lose flag status [default for IntFlag]
	 *     "keep" -> keep flag status and all bits
	 *     
	 */
	interface IFlagBoundary extends IStrEnum {
		STRICT
		CONFORM
		EJECT
		KEEP
	}

	/**
	 * 
	 *     Support for flags
	 *     
	 */
	interface IFlag extends IEnum {
	}

	/**
	 * 
	 *     Support for integer-based Flags
	 *     
	 */
	interface IIntFlag extends IFlag {
	}

	/**
	 * 
	 *     various conditions to check an enumeration for
	 *     
	 */
	interface IEnumCheck {
		CONTINUOUS
		NAMED_FLAGS
		UNIQUE
	}

	/**
	 * 
	 *     Check an enumeration for various constraints. (see EnumCheck)
	 *     
	 */
	function verify(): Promise<Iverify>
	function verify$({ }): Promise<Iverify>
	interface Iverify {
	}
	let Enum: Promise<any>
	let Flag: Promise<any>
	let EnumMeta: Promise<any>
}
declare module filecmp {
	var _

	/**
	 * Clear the filecmp cache.
	 */
	function clear_cache(): Promise<any>
	function clear_cache$($: {}): Promise<any>

	/**
	 * Compare two files.
	 * 
	 *     Arguments:
	 * 
	 *     f1 -- First file name
	 * 
	 *     f2 -- Second file name
	 * 
	 *     shallow -- Just check stat signature (do not read the files).
	 *                defaults to True.
	 * 
	 *     Return value:
	 * 
	 *     True if the files are the same, False otherwise.
	 * 
	 *     This function uses a cache for past comparisons and the results,
	 *     with cache entries invalidated if their stat information
	 *     changes.  The cache may be cleared by calling clear_cache().
	 * 
	 *     
	 */
	function cmp(f1, f2, shallow?: boolean): Promise<any>
	function cmp$({ f1, f2, shallow }: { f1, f2, shallow?}): Promise<any>

	/**
	 * Compare common files in two directories.
	 * 
	 *     a, b -- directory names
	 *     common -- list of file names found in both directories
	 *     shallow -- if true, do comparison based solely on stat() information
	 * 
	 *     Returns a tuple of three lists:
	 *       files that compare equal
	 *       files that are different
	 *       filenames that aren't regular files.
	 * 
	 *     
	 */
	function cmpfiles(a, b, common, shallow?: boolean): Promise<any>
	function cmpfiles$({ a, b, common, shallow }: { a, b, common, shallow?}): Promise<any>
	function demo(): Promise<any>
	function demo$($: {}): Promise<any>

	/**
	 * A class that manages the comparison of 2 directories.
	 * 
	 *     dircmp(a, b, ignore=None, hide=None)
	 *       A and B are directories.
	 *       IGNORE is a list of names to ignore,
	 *         defaults to DEFAULT_IGNORES.
	 *       HIDE is a list of names to hide,
	 *         defaults to [os.curdir, os.pardir].
	 * 
	 *     High level usage:
	 *       x = dircmp(dir1, dir2)
	 *       x.report() -> prints a report on the differences between dir1 and dir2
	 *        or
	 *       x.report_partial_closure() -> prints report on differences between dir1
	 *             and dir2, and reports on common immediate subdirectories.
	 *       x.report_full_closure() -> like report_partial_closure,
	 *             but fully recursive.
	 * 
	 *     Attributes:
	 *      left_list, right_list: The files in dir1 and dir2,
	 *         filtered by hide and ignore.
	 *      common: a list of names in both dir1 and dir2.
	 *      left_only, right_only: names only in dir1, dir2.
	 *      common_dirs: subdirectories in both dir1 and dir2.
	 *      common_files: files in both dir1 and dir2.
	 *      common_funny: names in both dir1 and dir2 where the type differs between
	 *         dir1 and dir2, or the name is not stat-able.
	 *      same_files: list of identical files.
	 *      diff_files: list of filenames which differ.
	 *      funny_files: list of files which could not be compared.
	 *      subdirs: a dictionary of dircmp instances (or MyDirCmp instances if this
	 *        object is of type MyDirCmp, a subclass of dircmp), keyed by names
	 *        in common_dirs.
	 *      
	 */
	function dircmp(a, b, ignore?, hide?): Promise<Idircmp>
	function dircmp$({ a, b, ignore, hide }: { a, b, ignore?, hide?}): Promise<Idircmp>
	interface Idircmp {
		phase0(): Promise<any>
		phase0$($: {}): Promise<any>
		phase1(): Promise<any>
		phase1$($: {}): Promise<any>
		phase2(): Promise<any>
		phase2$($: {}): Promise<any>
		phase3(): Promise<any>
		phase3$($: {}): Promise<any>
		phase4(): Promise<any>
		phase4$($: {}): Promise<any>
		phase4_closure(): Promise<any>
		phase4_closure$($: {}): Promise<any>
		report(): Promise<any>
		report$($: {}): Promise<any>
		report_partial_closure(): Promise<any>
		report_partial_closure$($: {}): Promise<any>
		report_full_closure(): Promise<any>
		report_full_closure$($: {}): Promise<any>
		methodmap
	}
	let BUFSIZE: Promise<any>
	let DEFAULT_IGNORES: Promise<any>
}
declare module fileinput {
	var _

	/**
	 * Return an instance of the FileInput class, which can be iterated.
	 * 
	 *     The parameters are passed to the constructor of the FileInput class.
	 *     The returned instance, in addition to being an iterator,
	 *     keeps global state for the functions of this module,.
	 *     
	 */
	function input(files?, inplace?: boolean, backup?): Promise<any>
	function input$({ files, inplace, backup }: { files?, inplace?, backup?}): Promise<any>

	/**
	 * Close the sequence.
	 */
	function close(): Promise<any>
	function close$($: {}): Promise<any>

	/**
	 * 
	 *     Close the current file so that the next iteration will read the first
	 *     line from the next file (if any); lines not read from the file will
	 *     not count towards the cumulative line count. The filename is not
	 *     changed until after the first line of the next file has been read.
	 *     Before the first line has been read, this function has no effect;
	 *     it cannot be used to skip the first file. After the last line of the
	 *     last file has been read, this function has no effect.
	 *     
	 */
	function nextfile(): Promise<any>
	function nextfile$($: {}): Promise<any>

	/**
	 * 
	 *     Return the name of the file currently being read.
	 *     Before the first line has been read, returns None.
	 *     
	 */
	function filename(): Promise<any>
	function filename$($: {}): Promise<any>

	/**
	 * 
	 *     Return the cumulative line number of the line that has just been read.
	 *     Before the first line has been read, returns 0. After the last line
	 *     of the last file has been read, returns the line number of that line.
	 *     
	 */
	function lineno(): Promise<any>
	function lineno$($: {}): Promise<any>

	/**
	 * 
	 *     Return the line number in the current file. Before the first line
	 *     has been read, returns 0. After the last line of the last file has
	 *     been read, returns the line number of that line within the file.
	 *     
	 */
	function filelineno(): Promise<any>
	function filelineno$($: {}): Promise<any>

	/**
	 * 
	 *     Return the file number of the current file. When no file is currently
	 *     opened, returns -1.
	 *     
	 */
	function fileno(): Promise<any>
	function fileno$($: {}): Promise<any>

	/**
	 * 
	 *     Returns true the line just read is the first line of its file,
	 *     otherwise returns false.
	 *     
	 */
	function isfirstline(): Promise<any>
	function isfirstline$($: {}): Promise<any>

	/**
	 * 
	 *     Returns true if the last line was read from sys.stdin,
	 *     otherwise returns false.
	 *     
	 */
	function isstdin(): Promise<any>
	function isstdin$($: {}): Promise<any>
	function hook_compressed(filename, mode): Promise<any>
	function hook_compressed$({ filename, mode }): Promise<any>
	function hook_encoded(encoding, errors?): Promise<any>
	function hook_encoded$({ encoding, errors }: { encoding, errors?}): Promise<any>

	/**
	 * FileInput([files[, inplace[, backup]]], *, mode=None, openhook=None)
	 * 
	 *     Class FileInput is the implementation of the module; its methods
	 *     filename(), lineno(), fileline(), isfirstline(), isstdin(), fileno(),
	 *     nextfile() and close() correspond to the functions of the same name
	 *     in the module.
	 *     In addition it has a readline() method which returns the next
	 *     input line, and a __getitem__() method which implements the
	 *     sequence behavior. The sequence must be accessed in strictly
	 *     sequential order; random access and readline() cannot be mixed.
	 *     
	 */
	function FileInput(files?, inplace?: boolean, backup?): Promise<IFileInput>
	function FileInput$({ files, inplace, backup }: { files?, inplace?, backup?}): Promise<IFileInput>
	interface IFileInput {
		close(): Promise<any>
		close$($: {}): Promise<any>
		nextfile(): Promise<any>
		nextfile$($: {}): Promise<any>
		readline(): Promise<any>
		readline$($: {}): Promise<any>
		filename(): Promise<any>
		filename$($: {}): Promise<any>
		lineno(): Promise<any>
		lineno$($: {}): Promise<any>
		filelineno(): Promise<any>
		filelineno$($: {}): Promise<any>
		fileno(): Promise<any>
		fileno$($: {}): Promise<any>
		isfirstline(): Promise<any>
		isfirstline$($: {}): Promise<any>
		isstdin(): Promise<any>
		isstdin$($: {}): Promise<any>
	}
}
declare module fnmatch {
	var _

	/**
	 * Test whether FILENAME matches PATTERN.
	 * 
	 *     Patterns are Unix shell style:
	 * 
	 *     *       matches everything
	 *     ?       matches any single character
	 *     [seq]   matches any character in seq
	 *     [!seq]  matches any char not in seq
	 * 
	 *     An initial period in FILENAME is not special.
	 *     Both FILENAME and PATTERN are first case-normalized
	 *     if the operating system requires it.
	 *     If you don't want this, use fnmatchcase(FILENAME, PATTERN).
	 *     
	 */
	function fnmatch(name, pat): Promise<any>
	function fnmatch$({ name, pat }): Promise<any>

	/**
	 * Construct a list from those elements of the iterable NAMES that match PAT.
	 */
	function filter(names, pat): Promise<any>
	function filter$({ names, pat }): Promise<any>

	/**
	 * Test whether FILENAME matches PATTERN, including case.
	 * 
	 *     This is a version of fnmatch() which doesn't case-normalize
	 *     its arguments.
	 *     
	 */
	function fnmatchcase(name, pat): Promise<any>
	function fnmatchcase$({ name, pat }): Promise<any>

	/**
	 * Translate a shell PATTERN to a regular expression.
	 * 
	 *     There is no way to quote meta-characters.
	 *     
	 */
	function translate(pat): Promise<any>
	function translate$({ pat }): Promise<any>
}
declare module fractions {
	var _

	/**
	 * This class implements rational numbers.
	 * 
	 *     In the two-argument form of the constructor, Fraction(8, 6) will
	 *     produce a rational number equivalent to 4/3. Both arguments must
	 *     be Rational. The numerator defaults to 0 and the denominator
	 *     defaults to 1 so that Fraction(3) == 3 and Fraction() == 0.
	 * 
	 *     Fractions can also be constructed from:
	 * 
	 *       - numeric strings similar to those accepted by the
	 *         float constructor (for example, '-2.3' or '1e10')
	 * 
	 *       - strings of the form '123/456'
	 * 
	 *       - float and Decimal instances
	 * 
	 *       - other Rational instances (including integers)
	 * 
	 *     
	 */
	interface IFraction {

		/**
		 * Converts a finite float to a rational number, exactly.
		 * 
		 *         Beware that Fraction.from_float(0.3) != Fraction(3, 10).
		 * 
		 *         
		 */
		from_float(f): Promise<any>
		from_float$({ f }): Promise<any>

		/**
		 * Converts a finite Decimal instance to a rational number, exactly.
		 */
		from_decimal(dec): Promise<any>
		from_decimal$({ dec }): Promise<any>

		/**
		 * Return the integer ratio as a tuple.
		 * 
		 *         Return a tuple of two integers, whose ratio is equal to the
		 *         Fraction and with a positive denominator.
		 *         
		 */
		as_integer_ratio(): Promise<any>
		as_integer_ratio$($: {}): Promise<any>

		/**
		 * Closest Fraction to self with denominator at most max_denominator.
		 * 
		 *         >>> Fraction('3.141592653589793').limit_denominator(10)
		 *         Fraction(22, 7)
		 *         >>> Fraction('3.141592653589793').limit_denominator(100)
		 *         Fraction(311, 99)
		 *         >>> Fraction(4321, 8765).limit_denominator(10000)
		 *         Fraction(4321, 8765)
		 * 
		 *         
		 */
		limit_denominator(max_denominator?): Promise<any>
		limit_denominator$({ max_denominator }: { max_denominator?}): Promise<any>
		numerator(): Promise<any>
		numerator$($: {}): Promise<any>
		denominator(): Promise<any>
		denominator$($: {}): Promise<any>
	}
}
declare module ftplib {
	var _

	/**
	 * Parse the '150' response for a RETR request.
	 *     Returns the expected transfer size or None; size is not guaranteed to
	 *     be present in the 150 message.
	 *     
	 */
	function parse150(resp): Promise<any>
	function parse150$({ resp }): Promise<any>

	/**
	 * Parse the '227' response for a PASV request.
	 *     Raises error_proto if it does not contain '(h1,h2,h3,h4,p1,p2)'
	 *     Return ('host.addr.as.numbers', port#) tuple.
	 */
	function parse227(resp): Promise<any>
	function parse227$({ resp }): Promise<any>

	/**
	 * Parse the '229' response for an EPSV request.
	 *     Raises error_proto if it does not contain '(|||port|)'
	 *     Return ('host.addr.as.numbers', port#) tuple.
	 */
	function parse229(resp, peer): Promise<any>
	function parse229$({ resp, peer }): Promise<any>

	/**
	 * Parse the '257' response for a MKD or PWD request.
	 *     This is a response to a MKD or PWD request: a directory name.
	 *     Returns the directoryname in the 257 reply.
	 */
	function parse257(resp): Promise<any>
	function parse257$({ resp }): Promise<any>

	/**
	 * Default retrlines callback to print a line.
	 */
	function print_line(line): Promise<any>
	function print_line$({ line }): Promise<any>

	/**
	 * Copy file from one FTP-instance to another.
	 */
	function ftpcp(source, sourcename, target, targetname?, type?): Promise<any>
	function ftpcp$({ source, sourcename, target, targetname, type }: { source, sourcename, target, targetname?, type?}): Promise<any>

	/**
	 * Test program.
	 *     Usage: ftp [-d] [-r[file]] host [-l[dir]] [-d[dir]] [-p] [file] ...
	 * 
	 *     -d dir
	 *     -l list
	 *     -p password
	 *     
	 */
	function test(): Promise<any>
	function test$($: {}): Promise<any>
	interface IError {
	}
	interface Ierror_reply extends IError {
	}
	interface Ierror_temp extends IError {
	}
	interface Ierror_perm extends IError {
	}
	interface Ierror_proto extends IError {
	}

	/**
	 * An FTP client class.
	 * 
	 *     To create a connection, call the class using these arguments:
	 *             host, user, passwd, acct, timeout, source_address, encoding
	 * 
	 *     The first four arguments are all strings, and have default value ''.
	 *     The parameter timeout must be numeric and defaults to None if not
	 *     passed, meaning that no timeout will be set on any ftp socket(s).
	 *     If a timeout is passed, then this is now the default timeout for all ftp
	 *     socket operations for this instance.
	 *     The last parameter is the encoding of filenames, which defaults to utf-8.
	 * 
	 *     Then use self.connect() with optional host and port argument.
	 * 
	 *     To download a file, use ftp.retrlines('RETR ' + filename),
	 *     or ftp.retrbinary() with slightly different arguments.
	 *     To upload a file, use ftp.storlines() or ftp.storbinary(),
	 *     which have an open file as argument (see their definitions
	 *     below for details).
	 *     The download/upload functions first issue appropriate TYPE
	 *     and PORT or PASV commands.
	 *     
	 */

	/**
	 * Initialization method (called by class instantiation).
	 *         Initialize host to localhost, port to standard ftp port.
	 *         Optional arguments are host (for connect()),
	 *         and user, passwd, acct (for login()).
	 *         
	 */
	function FTP(host?, user?, passwd?, acct?, timeout?, source_address?): Promise<IFTP>
	function FTP$({ host, user, passwd, acct, timeout, source_address }: { host?, user?, passwd?, acct?, timeout?, source_address?}): Promise<IFTP>
	interface IFTP {

		/**
		 * Connect to host.  Arguments are:
		 *          - host: hostname to connect to (string, default previous host)
		 *          - port: port to connect to (integer, default previous port)
		 *          - timeout: the timeout to set against the ftp socket(s)
		 *          - source_address: a 2-tuple (host, port) for the socket to bind
		 *            to as its source address before connecting.
		 *         
		 */
		connect(host?, port?, timeout?, source_address?): Promise<any>
		connect$({ host, port, timeout, source_address }: { host?, port?, timeout?, source_address?}): Promise<any>

		/**
		 * Get the welcome message from the server.
		 *         (this is read and squirreled away by connect())
		 */
		getwelcome(): Promise<any>
		getwelcome$($: {}): Promise<any>

		/**
		 * Set the debugging level.
		 *         The required argument level means:
		 *         0: no debugging output (default)
		 *         1: print commands and responses but not body text etc.
		 *         2: also print raw lines read and sent before stripping CR/LF
		 */
		set_debuglevel(level): Promise<any>
		set_debuglevel$({ level }): Promise<any>

		/**
		 * Use passive or active mode for data transfers.
		 *         With a false argument, use the normal PORT mode,
		 *         With a true argument, use the PASV command.
		 */
		set_pasv(val): Promise<any>
		set_pasv$({ val }): Promise<any>
		sanitize(s): Promise<any>
		sanitize$({ s }): Promise<any>
		putline(line): Promise<any>
		putline$({ line }): Promise<any>
		putcmd(line): Promise<any>
		putcmd$({ line }): Promise<any>
		getline(): Promise<any>
		getline$($: {}): Promise<any>
		getmultiline(): Promise<any>
		getmultiline$($: {}): Promise<any>
		getresp(): Promise<any>
		getresp$($: {}): Promise<any>

		/**
		 * Expect a response beginning with '2'.
		 */
		voidresp(): Promise<any>
		voidresp$($: {}): Promise<any>

		/**
		 * Abort a file transfer.  Uses out-of-band data.
		 *         This does not follow the procedure from the RFC to send Telnet
		 *         IP and Synch; that doesn't seem to work with the servers I've
		 *         tried.  Instead, just send the ABOR command as OOB data.
		 */
		abort(): Promise<any>
		abort$($: {}): Promise<any>

		/**
		 * Send a command and return the response.
		 */
		sendcmd(cmd): Promise<any>
		sendcmd$({ cmd }): Promise<any>

		/**
		 * Send a command and expect a response beginning with '2'.
		 */
		voidcmd(cmd): Promise<any>
		voidcmd$({ cmd }): Promise<any>

		/**
		 * Send a PORT command with the current host and the given
		 *         port number.
		 *         
		 */
		sendport(host, port): Promise<any>
		sendport$({ host, port }): Promise<any>

		/**
		 * Send an EPRT command with the current host and the given port number.
		 */
		sendeprt(host, port): Promise<any>
		sendeprt$({ host, port }): Promise<any>

		/**
		 * Create a new socket and send a PORT command for it.
		 */
		makeport(): Promise<any>
		makeport$($: {}): Promise<any>

		/**
		 * Internal: Does the PASV or EPSV handshake -> (address, port)
		 */
		makepasv(): Promise<any>
		makepasv$($: {}): Promise<any>

		/**
		 * Initiate a transfer over the data connection.
		 * 
		 *         If the transfer is active, send a port command and the
		 *         transfer command, and accept the connection.  If the server is
		 *         passive, send a pasv command, connect to it, and start the
		 *         transfer command.  Either way, return the socket for the
		 *         connection and the expected size of the transfer.  The
		 *         expected size may be None if it could not be determined.
		 * 
		 *         Optional `rest' argument can be a string that is sent as the
		 *         argument to a REST command.  This is essentially a server
		 *         marker used to tell the server to skip over any data up to the
		 *         given marker.
		 *         
		 */
		ntransfercmd(cmd, rest?): Promise<any>
		ntransfercmd$({ cmd, rest }: { cmd, rest?}): Promise<any>

		/**
		 * Like ntransfercmd() but returns only the socket.
		 */
		transfercmd(cmd, rest?): Promise<any>
		transfercmd$({ cmd, rest }: { cmd, rest?}): Promise<any>

		/**
		 * Login, default anonymous.
		 */
		login(user?, passwd?, acct?): Promise<any>
		login$({ user, passwd, acct }: { user?, passwd?, acct?}): Promise<any>

		/**
		 * Retrieve data in binary mode.  A new port is created for you.
		 * 
		 *         Args:
		 *           cmd: A RETR command.
		 *           callback: A single parameter callable to be called on each
		 *                     block of data read.
		 *           blocksize: The maximum number of bytes to read from the
		 *                      socket at one time.  [default: 8192]
		 *           rest: Passed to transfercmd().  [default: None]
		 * 
		 *         Returns:
		 *           The response code.
		 *         
		 */
		retrbinary(cmd, callback, blocksize?, rest?): Promise<any>
		retrbinary$({ cmd, callback, blocksize, rest }: { cmd, callback, blocksize?, rest?}): Promise<any>

		/**
		 * Retrieve data in line mode.  A new port is created for you.
		 * 
		 *         Args:
		 *           cmd: A RETR, LIST, or NLST command.
		 *           callback: An optional single parameter callable that is called
		 *                     for each line with the trailing CRLF stripped.
		 *                     [default: print_line()]
		 * 
		 *         Returns:
		 *           The response code.
		 *         
		 */
		retrlines(cmd, callback?): Promise<any>
		retrlines$({ cmd, callback }: { cmd, callback?}): Promise<any>

		/**
		 * Store a file in binary mode.  A new port is created for you.
		 * 
		 *         Args:
		 *           cmd: A STOR command.
		 *           fp: A file-like object with a read(num_bytes) method.
		 *           blocksize: The maximum data size to read from fp and send over
		 *                      the connection at once.  [default: 8192]
		 *           callback: An optional single parameter callable that is called on
		 *                     each block of data after it is sent.  [default: None]
		 *           rest: Passed to transfercmd().  [default: None]
		 * 
		 *         Returns:
		 *           The response code.
		 *         
		 */
		storbinary(cmd, fp, blocksize?, callback?, rest?): Promise<any>
		storbinary$({ cmd, fp, blocksize, callback, rest }: { cmd, fp, blocksize?, callback?, rest?}): Promise<any>

		/**
		 * Store a file in line mode.  A new port is created for you.
		 * 
		 *         Args:
		 *           cmd: A STOR command.
		 *           fp: A file-like object with a readline() method.
		 *           callback: An optional single parameter callable that is called on
		 *                     each line after it is sent.  [default: None]
		 * 
		 *         Returns:
		 *           The response code.
		 *         
		 */
		storlines(cmd, fp, callback?): Promise<any>
		storlines$({ cmd, fp, callback }: { cmd, fp, callback?}): Promise<any>

		/**
		 * Send new account name.
		 */
		acct(password): Promise<any>
		acct$({ password }): Promise<any>

		/**
		 * Return a list of files in a given directory (default the current).
		 */
		nlst(): Promise<any>
		nlst$($: {}): Promise<any>

		/**
		 * List a directory in long form.
		 *         By default list current directory to stdout.
		 *         Optional last argument is callback function; all
		 *         non-empty arguments before it are concatenated to the
		 *         LIST command.  (This *should* only be used for a pathname.)
		 */
		dir(): Promise<any>
		dir$($: {}): Promise<any>

		/**
		 * List a directory in a standardized format by using MLSD
		 *         command (RFC-3659). If path is omitted the current directory
		 *         is assumed. "facts" is a list of strings representing the type
		 *         of information desired (e.g. ["type", "size", "perm"]).
		 * 
		 *         Return a generator object yielding a tuple of two elements
		 *         for every file found in path.
		 *         First element is the file name, the second one is a dictionary
		 *         including a variable number of "facts" depending on the server
		 *         and whether "facts" argument has been provided.
		 *         
		 */
		mlsd(path?, facts?): Promise<any>
		mlsd$({ path, facts }: { path?, facts?}): Promise<any>

		/**
		 * Rename a file.
		 */
		rename(fromname, toname): Promise<any>
		rename$({ fromname, toname }): Promise<any>

		/**
		 * Delete a file.
		 */
		delete(filename): Promise<any>
		delete$({ filename }): Promise<any>

		/**
		 * Change to a directory.
		 */
		cwd(dirname): Promise<any>
		cwd$({ dirname }): Promise<any>

		/**
		 * Retrieve the size of a file.
		 */
		size(filename): Promise<any>
		size$({ filename }): Promise<any>

		/**
		 * Make a directory, return its full pathname.
		 */
		mkd(dirname): Promise<any>
		mkd$({ dirname }): Promise<any>

		/**
		 * Remove a directory.
		 */
		rmd(dirname): Promise<any>
		rmd$({ dirname }): Promise<any>

		/**
		 * Return current working directory.
		 */
		pwd(): Promise<any>
		pwd$($: {}): Promise<any>

		/**
		 * Quit, and close the connection.
		 */
		quit(): Promise<any>
		quit$($: {}): Promise<any>

		/**
		 * Close the connection without assuming anything about it.
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>
		debugging
		host
		port
		maxline
		sock
		file
		welcome
		passiveserver
		trust_server_pasv_ipv4_address
		debug
	}

	/**
	 * A FTP subclass which adds TLS support to FTP as described
	 *         in RFC-4217.
	 * 
	 *         Connect as usual to port 21 implicitly securing the FTP control
	 *         connection before authenticating.
	 * 
	 *         Securing the data connection requires user to explicitly ask
	 *         for it by calling prot_p() method.
	 * 
	 *         Usage example:
	 *         >>> from ftplib import FTP_TLS
	 *         >>> ftps = FTP_TLS('ftp.python.org')
	 *         >>> ftps.login()  # login anonymously previously securing control channel
	 *         '230 Guest login ok, access restrictions apply.'
	 *         >>> ftps.prot_p()  # switch to secure data connection
	 *         '200 Protection level set to P'
	 *         >>> ftps.retrlines('LIST')  # list directory content securely
	 *         total 9
	 *         drwxr-xr-x   8 root     wheel        1024 Jan  3  1994 .
	 *         drwxr-xr-x   8 root     wheel        1024 Jan  3  1994 ..
	 *         drwxr-xr-x   2 root     wheel        1024 Jan  3  1994 bin
	 *         drwxr-xr-x   2 root     wheel        1024 Jan  3  1994 etc
	 *         d-wxrwxr-x   2 ftp      wheel        1024 Sep  5 13:43 incoming
	 *         drwxr-xr-x   2 root     wheel        1024 Nov 17  1993 lib
	 *         drwxr-xr-x   6 1094     wheel        1024 Sep 13 19:07 pub
	 *         drwxr-xr-x   3 root     wheel        1024 Jan  3  1994 usr
	 *         -rw-r--r--   1 root     root          312 Aug  1  1994 welcome.msg
	 *         '226 Transfer complete.'
	 *         >>> ftps.quit()
	 *         '221 Goodbye.'
	 *         >>>
	 *         
	 */
	function FTP_TLS(host?, user?, passwd?, acct?, keyfile?, certfile?, context?, timeout?, source_address?): Promise<IFTP_TLS>
	function FTP_TLS$({ host, user, passwd, acct, keyfile, certfile, context, timeout, source_address }: { host?, user?, passwd?, acct?, keyfile?, certfile?, context?, timeout?, source_address?}): Promise<IFTP_TLS>
	interface IFTP_TLS extends IFTP {
		login(user?, passwd?, acct?, secure?: boolean): Promise<any>
		login$({ user, passwd, acct, secure }: { user?, passwd?, acct?, secure?}): Promise<any>

		/**
		 * Set up secure control connection by using TLS/SSL.
		 */
		auth(): Promise<any>
		auth$($: {}): Promise<any>

		/**
		 * Switch back to a clear-text control connection.
		 */
		ccc(): Promise<any>
		ccc$($: {}): Promise<any>

		/**
		 * Set up secure data connection.
		 */
		prot_p(): Promise<any>
		prot_p$($: {}): Promise<any>

		/**
		 * Set up clear text data connection.
		 */
		prot_c(): Promise<any>
		prot_c$($: {}): Promise<any>
		ntransfercmd(cmd, rest?): Promise<any>
		ntransfercmd$({ cmd, rest }: { cmd, rest?}): Promise<any>
		abort(): Promise<any>
		abort$($: {}): Promise<any>
		ssl_version
	}
	let MSG_OOB: Promise<any>
	let FTP_PORT: Promise<any>
	let MAXLINE: Promise<any>
	let all_errors: Promise<any>
	let CRLF: Promise<any>
	let B_CRLF: Promise<any>
}
declare module functools {
	var _

	/**
	 * Update a wrapper function to look like the wrapped function
	 * 
	 *        wrapper is the function to be updated
	 *        wrapped is the original function
	 *        assigned is a tuple naming the attributes assigned directly
	 *        from the wrapped function to the wrapper function (defaults to
	 *        functools.WRAPPER_ASSIGNMENTS)
	 *        updated is a tuple naming the attributes of the wrapper that
	 *        are updated with the corresponding attribute from the wrapped
	 *        function (defaults to functools.WRAPPER_UPDATES)
	 *     
	 */
	function update_wrapper(wrapper, wrapped, assigned?, updated?): Promise<any>
	function update_wrapper$({ wrapper, wrapped, assigned, updated }: { wrapper, wrapped, assigned?, updated?}): Promise<any>

	/**
	 * Decorator factory to apply update_wrapper() to a wrapper function
	 * 
	 *        Returns a decorator that invokes update_wrapper() with the decorated
	 *        function as the wrapper argument and the arguments to wraps() as the
	 *        remaining arguments. Default arguments are as for update_wrapper().
	 *        This is a convenience function to simplify applying partial() to
	 *        update_wrapper().
	 *     
	 */
	function wraps(wrapped, assigned?, updated?): Promise<any>
	function wraps$({ wrapped, assigned, updated }: { wrapped, assigned?, updated?}): Promise<any>

	/**
	 * Class decorator that fills in missing ordering methods
	 */
	function total_ordering(cls): Promise<any>
	function total_ordering$({ cls }): Promise<any>

	/**
	 * Convert a cmp= function into a key= function
	 */
	function cmp_to_key(mycmp): Promise<any>
	function cmp_to_key$({ mycmp }): Promise<any>

	/**
	 * 
	 *     reduce(function, iterable[, initial]) -> value
	 * 
	 *     Apply a function of two arguments cumulatively to the items of a sequence
	 *     or iterable, from left to right, so as to reduce the iterable to a single
	 *     value.  For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
	 *     ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
	 *     of the iterable in the calculation, and serves as a default when the
	 *     iterable is empty.
	 *     
	 */
	function reduce(func, sequence, initial?): Promise<any>
	function reduce$({ func, sequence, initial }: { func, sequence, initial?}): Promise<any>

	/**
	 * Least-recently-used cache decorator.
	 * 
	 *     If *maxsize* is set to None, the LRU features are disabled and the cache
	 *     can grow without bound.
	 * 
	 *     If *typed* is True, arguments of different types will be cached separately.
	 *     For example, f(3.0) and f(3) will be treated as distinct calls with
	 *     distinct results.
	 * 
	 *     Arguments to the cached function must be hashable.
	 * 
	 *     View the cache statistics named tuple (hits, misses, maxsize, currsize)
	 *     with f.cache_info().  Clear the cache and statistics with f.cache_clear().
	 *     Access the underlying function with f.__wrapped__.
	 * 
	 *     See:  http://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)
	 * 
	 *     
	 */
	function lru_cache(maxsize?, typed?: boolean): Promise<any>
	function lru_cache$({ maxsize, typed }: { maxsize?, typed?}): Promise<any>

	/**
	 * Simple lightweight unbounded cache.  Sometimes called "memoize".
	 */
	function cache(user_function): Promise<any>
	function cache$({ user_function }): Promise<any>

	/**
	 * Single-dispatch generic function decorator.
	 * 
	 *     Transforms a function into a generic function, which can have different
	 *     behaviours depending upon the type of its first argument. The decorated
	 *     function acts as the default implementation, and additional
	 *     implementations can be registered using the register() attribute of the
	 *     generic function.
	 *     
	 */
	function singledispatch(func): Promise<any>
	function singledispatch$({ func }): Promise<any>

	/**
	 * New function with partial application of the given arguments
	 *     and keywords.
	 *     
	 */
	interface Ipartial {
	}

	/**
	 * Method descriptor with partial application of the given arguments
	 *     and keywords.
	 * 
	 *     Supports wrapping existing descriptors and handles non-descriptor
	 *     callables as instance methods.
	 *     
	 */
	function partialmethod(func): Promise<Ipartialmethod>
	function partialmethod$({ func }): Promise<Ipartialmethod>
	interface Ipartialmethod {
	}

	/**
	 *  This class guarantees that hash() will be called no more than once
	 *         per element.  This is important because the lru_cache() will hash
	 *         the key multiple times on a cache miss.
	 * 
	 *     
	 */
	interface I_HashedSeq {
	}

	/**
	 * Single-dispatch generic method descriptor.
	 * 
	 *     Supports wrapping existing descriptors and handles non-descriptor
	 *     callables as instance methods.
	 *     
	 */
	function singledispatchmethod(func): Promise<Isingledispatchmethod>
	function singledispatchmethod$({ func }): Promise<Isingledispatchmethod>
	interface Isingledispatchmethod {

		/**
		 * generic_method.register(cls, func) -> func
		 * 
		 *         Registers a new implementation for the given *cls* on a *generic_method*.
		 *         
		 */
		register(cls, method?): Promise<any>
		register$({ cls, method }: { cls, method?}): Promise<any>
	}
	function cached_property(func): Promise<Icached_property>
	function cached_property$({ func }): Promise<Icached_property>
	interface Icached_property {
	}
	let WRAPPER_ASSIGNMENTS: Promise<any>
	let WRAPPER_UPDATES: Promise<any>
}
declare module genericpath {
	var _

	/**
	 * Test whether a path exists.  Returns False for broken symbolic links
	 */
	function exists(path): Promise<any>
	function exists$({ path }): Promise<any>

	/**
	 * Test whether a path is a regular file
	 */
	function isfile(path): Promise<any>
	function isfile$({ path }): Promise<any>

	/**
	 * Return true if the pathname refers to an existing directory.
	 */
	function isdir(s): Promise<any>
	function isdir$({ s }): Promise<any>

	/**
	 * Return the size of a file, reported by os.stat().
	 */
	function getsize(filename): Promise<any>
	function getsize$({ filename }): Promise<any>

	/**
	 * Return the last modification time of a file, reported by os.stat().
	 */
	function getmtime(filename): Promise<any>
	function getmtime$({ filename }): Promise<any>

	/**
	 * Return the last access time of a file, reported by os.stat().
	 */
	function getatime(filename): Promise<any>
	function getatime$({ filename }): Promise<any>

	/**
	 * Return the metadata change time of a file, reported by os.stat().
	 */
	function getctime(filename): Promise<any>
	function getctime$({ filename }): Promise<any>

	/**
	 * Given a list of pathnames, returns the longest common leading component
	 */
	function commonprefix(m): Promise<any>
	function commonprefix$({ m }): Promise<any>

	/**
	 * Test whether two stat buffers reference the same file
	 */
	function samestat(s1, s2): Promise<any>
	function samestat$({ s1, s2 }): Promise<any>

	/**
	 * Test whether two pathnames reference the same actual file or directory
	 * 
	 *     This is determined by the device number and i-node number and
	 *     raises an exception if an os.stat() call on either pathname fails.
	 *     
	 */
	function samefile(f1, f2): Promise<any>
	function samefile$({ f1, f2 }): Promise<any>

	/**
	 * Test whether two open file objects reference the same file
	 */
	function sameopenfile(fp1, fp2): Promise<any>
	function sameopenfile$({ fp1, fp2 }): Promise<any>
}
declare module getopt {
	var _

	/**
	 * getopt(args, options[, long_options]) -> opts, args
	 * 
	 *     Parses command line options and parameter list.  args is the
	 *     argument list to be parsed, without the leading reference to the
	 *     running program.  Typically, this means "sys.argv[1:]".  shortopts
	 *     is the string of option letters that the script wants to
	 *     recognize, with options that require an argument followed by a
	 *     colon (i.e., the same format that Unix getopt() uses).  If
	 *     specified, longopts is a list of strings with the names of the
	 *     long options which should be supported.  The leading '--'
	 *     characters should not be included in the option name.  Options
	 *     which require an argument should be followed by an equal sign
	 *     ('=').
	 * 
	 *     The return value consists of two elements: the first is a list of
	 *     (option, value) pairs; the second is the list of program arguments
	 *     left after the option list was stripped (this is a trailing slice
	 *     of the first argument).  Each option-and-value pair returned has
	 *     the option as its first element, prefixed with a hyphen (e.g.,
	 *     '-x'), and the option argument as its second element, or an empty
	 *     string if the option has no argument.  The options occur in the
	 *     list in the same order in which they were found, thus allowing
	 *     multiple occurrences.  Long and short options may be mixed.
	 * 
	 *     
	 */
	function getopt(args, shortopts, longopts?): Promise<any>
	function getopt$({ args, shortopts, longopts }: { args, shortopts, longopts?}): Promise<any>

	/**
	 * getopt(args, options[, long_options]) -> opts, args
	 * 
	 *     This function works like getopt(), except that GNU style scanning
	 *     mode is used by default. This means that option and non-option
	 *     arguments may be intermixed. The getopt() function stops
	 *     processing options as soon as a non-option argument is
	 *     encountered.
	 * 
	 *     If the first character of the option string is `+', or if the
	 *     environment variable POSIXLY_CORRECT is set, then option
	 *     processing stops as soon as a non-option argument is encountered.
	 * 
	 *     
	 */
	function gnu_getopt(args, shortopts, longopts?): Promise<any>
	function gnu_getopt$({ args, shortopts, longopts }: { args, shortopts, longopts?}): Promise<any>
	function do_longs(opts, opt, longopts, args): Promise<any>
	function do_longs$({ opts, opt, longopts, args }): Promise<any>
	function long_has_args(opt, longopts): Promise<any>
	function long_has_args$({ opt, longopts }): Promise<any>
	function do_shorts(opts, optstring, shortopts, args): Promise<any>
	function do_shorts$({ opts, optstring, shortopts, args }): Promise<any>
	function short_has_arg(opt, shortopts): Promise<any>
	function short_has_arg$({ opt, shortopts }): Promise<any>
	function GetoptError(msg, opt?): Promise<IGetoptError>
	function GetoptError$({ msg, opt }: { msg, opt?}): Promise<IGetoptError>
	interface IGetoptError {
		opt
		msg
	}
	let error: Promise<any>
}
declare module getpass {
	var _

	/**
	 * Prompt for a password, with echo turned off.
	 * 
	 *     Args:
	 *       prompt: Written on stream to ask for the input.  Default: 'Password: '
	 *       stream: A writable file object to display the prompt.  Defaults to
	 *               the tty.  If no tty is available defaults to sys.stderr.
	 *     Returns:
	 *       The seKr3t input.
	 *     Raises:
	 *       EOFError: If our input tty or stdin was closed.
	 *       GetPassWarning: When we were unable to turn echo off on the input.
	 * 
	 *     Always restores terminal settings before returning.
	 *     
	 */
	function unix_getpass(prompt?, stream?): Promise<any>
	function unix_getpass$({ prompt, stream }: { prompt?, stream?}): Promise<any>

	/**
	 * Prompt for password with echo off, using Windows getwch().
	 */
	function win_getpass(prompt?, stream?): Promise<any>
	function win_getpass$({ prompt, stream }: { prompt?, stream?}): Promise<any>
	function fallback_getpass(prompt?, stream?): Promise<any>
	function fallback_getpass$({ prompt, stream }: { prompt?, stream?}): Promise<any>

	/**
	 * Get the username from the environment or password database.
	 * 
	 *     First try various environment variables, then the password
	 *     database.  This works on Windows as long as USERNAME is set.
	 * 
	 *     
	 */
	function getuser(): Promise<any>
	function getuser$($: {}): Promise<any>
	interface IGetPassWarning {
	}
	let getpass: Promise<any>
}
declare module gettext {
	var _

	/**
	 * Gets a C expression as used in PO files for plural forms and returns a
	 *     Python function that implements an equivalent expression.
	 *     
	 */
	function c2py(plural): Promise<any>
	function c2py$({ plural }): Promise<any>
	function find(domain, localedir?, languages?, all?: boolean): Promise<any>
	function find$({ domain, localedir, languages, all }: { domain, localedir?, languages?, all?}): Promise<any>
	function translation(domain, localedir?, languages?, class_?, fallback?: boolean): Promise<any>
	function translation$({ domain, localedir, languages, class_, fallback }: { domain, localedir?, languages?, class_?, fallback?}): Promise<any>
	function install(domain, localedir?): Promise<any>
	function install$({ domain, localedir }: { domain, localedir?}): Promise<any>
	function textdomain(domain?): Promise<any>
	function textdomain$({ domain }: { domain?}): Promise<any>
	function bindtextdomain(domain, localedir?): Promise<any>
	function bindtextdomain$({ domain, localedir }: { domain, localedir?}): Promise<any>
	function dgettext(domain, message): Promise<any>
	function dgettext$({ domain, message }): Promise<any>
	function dngettext(domain, msgid1, msgid2, n): Promise<any>
	function dngettext$({ domain, msgid1, msgid2, n }): Promise<any>
	function dpgettext(domain, context, message): Promise<any>
	function dpgettext$({ domain, context, message }): Promise<any>
	function dnpgettext(domain, context, msgid1, msgid2, n): Promise<any>
	function dnpgettext$({ domain, context, msgid1, msgid2, n }): Promise<any>
	function gettext(message): Promise<any>
	function gettext$({ message }): Promise<any>
	function ngettext(msgid1, msgid2, n): Promise<any>
	function ngettext$({ msgid1, msgid2, n }): Promise<any>
	function pgettext(context, message): Promise<any>
	function pgettext$({ context, message }): Promise<any>
	function npgettext(context, msgid1, msgid2, n): Promise<any>
	function npgettext$({ context, msgid1, msgid2, n }): Promise<any>
	function NullTranslations(fp?): Promise<INullTranslations>
	function NullTranslations$({ fp }: { fp?}): Promise<INullTranslations>
	interface INullTranslations {
		add_fallback(fallback): Promise<any>
		add_fallback$({ fallback }): Promise<any>
		gettext(message): Promise<any>
		gettext$({ message }): Promise<any>
		ngettext(msgid1, msgid2, n): Promise<any>
		ngettext$({ msgid1, msgid2, n }): Promise<any>
		pgettext(context, message): Promise<any>
		pgettext$({ context, message }): Promise<any>
		npgettext(context, msgid1, msgid2, n): Promise<any>
		npgettext$({ context, msgid1, msgid2, n }): Promise<any>
		info(): Promise<any>
		info$($: {}): Promise<any>
		charset(): Promise<any>
		charset$($: {}): Promise<any>
		install(names?): Promise<any>
		install$({ names }: { names?}): Promise<any>
	}
	interface IGNUTranslations extends INullTranslations {
		gettext(message): Promise<any>
		gettext$({ message }): Promise<any>
		ngettext(msgid1, msgid2, n): Promise<any>
		ngettext$({ msgid1, msgid2, n }): Promise<any>
		pgettext(context, message): Promise<any>
		pgettext$({ context, message }): Promise<any>
		npgettext(context, msgid1, msgid2, n): Promise<any>
		npgettext$({ context, msgid1, msgid2, n }): Promise<any>
		LE_MAGIC
		BE_MAGIC
		CONTEXT
		VERSIONS
	}
	let Catalog: Promise<any>
}
declare module glob {
	var _

	/**
	 * Return a list of paths matching a pathname pattern.
	 * 
	 *     The pattern may contain simple shell-style wildcards a la
	 *     fnmatch. However, unlike fnmatch, filenames starting with a
	 *     dot are special cases that are not matched by '*' and '?'
	 *     patterns.
	 * 
	 *     If recursive is true, the pattern '**' will match any files and
	 *     zero or more directories and subdirectories.
	 *     
	 */
	function glob(pathname): Promise<any>
	function glob$({ pathname }): Promise<any>

	/**
	 * Return an iterator which yields the paths matching a pathname pattern.
	 * 
	 *     The pattern may contain simple shell-style wildcards a la
	 *     fnmatch. However, unlike fnmatch, filenames starting with a
	 *     dot are special cases that are not matched by '*' and '?'
	 *     patterns.
	 * 
	 *     If recursive is true, the pattern '**' will match any files and
	 *     zero or more directories and subdirectories.
	 *     
	 */
	function iglob(pathname): Promise<any>
	function iglob$({ pathname }): Promise<any>
	function glob0(dirname, pattern): Promise<any>
	function glob0$({ dirname, pattern }): Promise<any>
	function glob1(dirname, pattern): Promise<any>
	function glob1$({ dirname, pattern }): Promise<any>
	function has_magic(s): Promise<any>
	function has_magic$({ s }): Promise<any>

	/**
	 * Escape all special characters.
	 *     
	 */
	function escape(pathname): Promise<any>
	function escape$({ pathname }): Promise<any>
	let magic_check: Promise<any>
	let magic_check_bytes: Promise<any>
}
declare module graphlib {
	var _
	interface I_NodeInfo {
	}

	/**
	 * Subclass of ValueError raised by TopologicalSorter.prepare if cycles
	 *     exist in the working graph.
	 * 
	 *     If multiple cycles exist, only one undefined choice among them will be reported
	 *     and included in the exception. The detected cycle can be accessed via the second
	 *     element in the *args* attribute of the exception instance and consists in a list
	 *     of nodes, such that each node is, in the graph, an immediate predecessor of the
	 *     next node in the list. In the reported list, the first and the last node will be
	 *     the same, to make it clear that it is cyclic.
	 *     
	 */
	interface ICycleError {
	}

	/**
	 * Provides functionality to topologically sort a graph of hashable nodes
	 */
	function TopologicalSorter(graph?): Promise<ITopologicalSorter>
	function TopologicalSorter$({ graph }: { graph?}): Promise<ITopologicalSorter>
	interface ITopologicalSorter {

		/**
		 * Add a new node and its predecessors to the graph.
		 * 
		 *         Both the *node* and all elements in *predecessors* must be hashable.
		 * 
		 *         If called multiple times with the same node argument, the set of dependencies
		 *         will be the union of all dependencies passed in.
		 * 
		 *         It is possible to add a node with no dependencies (*predecessors* is not provided)
		 *         as well as provide a dependency twice. If a node that has not been provided before
		 *         is included among *predecessors* it will be automatically added to the graph with
		 *         no predecessors of its own.
		 * 
		 *         Raises ValueError if called after "prepare".
		 *         
		 */
		add(node): Promise<any>
		add$({ node }): Promise<any>

		/**
		 * Mark the graph as finished and check for cycles in the graph.
		 * 
		 *         If any cycle is detected, "CycleError" will be raised, but "get_ready" can
		 *         still be used to obtain as many nodes as possible until cycles block more
		 *         progress. After a call to this function, the graph cannot be modified and
		 *         therefore no more nodes can be added using "add".
		 *         
		 */
		prepare(): Promise<any>
		prepare$($: {}): Promise<any>

		/**
		 * Return a tuple of all the nodes that are ready.
		 * 
		 *         Initially it returns all nodes with no predecessors; once those are marked
		 *         as processed by calling "done", further calls will return all new nodes that
		 *         have all their predecessors already processed. Once no more progress can be made,
		 *         empty tuples are returned.
		 * 
		 *         Raises ValueError if called without calling "prepare" previously.
		 *         
		 */
		get_ready(): Promise<any>
		get_ready$($: {}): Promise<any>

		/**
		 * Return ``True`` if more progress can be made and ``False`` otherwise.
		 * 
		 *         Progress can be made if cycles do not block the resolution and either there
		 *         are still nodes ready that haven't yet been returned by "get_ready" or the
		 *         number of nodes marked "done" is less than the number that have been returned
		 *         by "get_ready".
		 * 
		 *         Raises ValueError if called without calling "prepare" previously.
		 *         
		 */
		is_active(): Promise<any>
		is_active$($: {}): Promise<any>

		/**
		 * Marks a set of nodes returned by "get_ready" as processed.
		 * 
		 *         This method unblocks any successor of each node in *nodes* for being returned
		 *         in the future by a call to "get_ready".
		 * 
		 *         Raises :exec:`ValueError` if any node in *nodes* has already been marked as
		 *         processed by a previous call to this method, if a node was not added to the
		 *         graph by using "add" or if called without calling "prepare" previously or if
		 *         node has not yet been returned by "get_ready".
		 *         
		 */
		done(): Promise<any>
		done$($: {}): Promise<any>

		/**
		 * Returns an iterable of nodes in a topological order.
		 * 
		 *         The particular order that is returned may depend on the specific
		 *         order in which the items were inserted in the graph.
		 * 
		 *         Using this method does not require to call "prepare" or "done". If any
		 *         cycle is detected, :exc:`CycleError` will be raised.
		 *         
		 */
		static_order(): Promise<any>
		static_order$($: {}): Promise<any>
	}
}
declare module gzip {
	var _

	/**
	 * Open a gzip-compressed file in binary or text mode.
	 * 
	 *     The filename argument can be an actual filename (a str or bytes object), or
	 *     an existing file object to read from or write to.
	 * 
	 *     The mode argument can be "r", "rb", "w", "wb", "x", "xb", "a" or "ab" for
	 *     binary mode, or "rt", "wt", "xt" or "at" for text mode. The default mode is
	 *     "rb", and the default compresslevel is 9.
	 * 
	 *     For binary mode, this function is equivalent to the GzipFile constructor:
	 *     GzipFile(filename, mode, compresslevel). In this case, the encoding, errors
	 *     and newline arguments must not be provided.
	 * 
	 *     For text mode, a GzipFile object is created, and wrapped in an
	 *     io.TextIOWrapper instance with the specified encoding, error handling
	 *     behavior, and line ending(s).
	 * 
	 *     
	 */
	function open(filename, mode?, compresslevel?, encoding?, errors?, newline?): Promise<any>
	function open$({ filename, mode, compresslevel, encoding, errors, newline }: { filename, mode?, compresslevel?, encoding?, errors?, newline?}): Promise<any>
	function write32u(output, value): Promise<any>
	function write32u$({ output, value }): Promise<any>

	/**
	 * Compress data in one shot and return the compressed string.
	 *     Optional argument is the compression level, in range of 0-9.
	 *     
	 */
	function compress(data, compresslevel?): Promise<any>
	function compress$({ data, compresslevel }: { data, compresslevel?}): Promise<any>

	/**
	 * Decompress a gzip compressed string in one shot.
	 *     Return the decompressed string.
	 *     
	 */
	function decompress(data): Promise<any>
	function decompress$({ data }): Promise<any>
	function main(): Promise<any>
	function main$($: {}): Promise<any>

	/**
	 * Minimal read-only file object that prepends a string to the contents
	 *     of an actual file. Shouldn't be used outside of gzip.py, as it lacks
	 *     essential functionality.
	 */
	interface I_PaddedFile {
		read(size): Promise<any>
		read$({ size }): Promise<any>
		prepend(prepend?): Promise<any>
		prepend$({ prepend }: { prepend?}): Promise<any>
		seek(off): Promise<any>
		seek$({ off }): Promise<any>
		seekable(): Promise<any>
		seekable$($: {}): Promise<any>
	}

	/**
	 * Exception raised in some cases for invalid gzip files.
	 */
	interface IBadGzipFile {
	}

	/**
	 * The GzipFile class simulates most of the methods of a file object with
	 *     the exception of the truncate() method.
	 * 
	 *     This class only supports opening files in binary mode. If you need to open a
	 *     compressed file in text mode, use the gzip.open() function.
	 * 
	 *     
	 */

	/**
	 * Constructor for the GzipFile class.
	 * 
	 *         At least one of fileobj and filename must be given a
	 *         non-trivial value.
	 * 
	 *         The new class instance is based on fileobj, which can be a regular
	 *         file, an io.BytesIO object, or any other object which simulates a file.
	 *         It defaults to None, in which case filename is opened to provide
	 *         a file object.
	 * 
	 *         When fileobj is not None, the filename argument is only used to be
	 *         included in the gzip file header, which may include the original
	 *         filename of the uncompressed file.  It defaults to the filename of
	 *         fileobj, if discernible; otherwise, it defaults to the empty string,
	 *         and in this case the original filename is not included in the header.
	 * 
	 *         The mode argument can be any of 'r', 'rb', 'a', 'ab', 'w', 'wb', 'x', or
	 *         'xb' depending on whether the file will be read or written.  The default
	 *         is the mode of fileobj if discernible; otherwise, the default is 'rb'.
	 *         A mode of 'r' is equivalent to one of 'rb', and similarly for 'w' and
	 *         'wb', 'a' and 'ab', and 'x' and 'xb'.
	 * 
	 *         The compresslevel argument is an integer from 0 to 9 controlling the
	 *         level of compression; 1 is fastest and produces the least compression,
	 *         and 9 is slowest and produces the most compression. 0 is no compression
	 *         at all. The default is 9.
	 * 
	 *         The mtime argument is an optional numeric timestamp to be written
	 *         to the last modification time field in the stream when compressing.
	 *         If omitted or None, the current time is used.
	 * 
	 *         
	 */
	function GzipFile(filename?, mode?, compresslevel?, fileobj?, mtime?): Promise<IGzipFile>
	function GzipFile$({ filename, mode, compresslevel, fileobj, mtime }: { filename?, mode?, compresslevel?, fileobj?, mtime?}): Promise<IGzipFile>
	interface IGzipFile {
		filename(): Promise<any>
		filename$($: {}): Promise<any>

		/**
		 * Last modification time read from stream, or None
		 */
		mtime(): Promise<any>
		mtime$($: {}): Promise<any>
		write(data): Promise<any>
		write$({ data }): Promise<any>
		read(size?): Promise<any>
		read$({ size }: { size?}): Promise<any>

		/**
		 * Implements BufferedIOBase.read1()
		 * 
		 *         Reads up to a buffer's worth of data if size is negative.
		 */
		read1(size?): Promise<any>
		read1$({ size }: { size?}): Promise<any>
		peek(n): Promise<any>
		peek$({ n }): Promise<any>
		closed(): Promise<any>
		closed$($: {}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
		flush(zlib_mode?): Promise<any>
		flush$({ zlib_mode }: { zlib_mode?}): Promise<any>

		/**
		 * Invoke the underlying file object's fileno() method.
		 * 
		 *         This will raise AttributeError if the underlying file object
		 *         doesn't support fileno().
		 *         
		 */
		fileno(): Promise<any>
		fileno$($: {}): Promise<any>

		/**
		 * Return the uncompressed stream file position indicator to the
		 *         beginning of the file
		 */
		rewind(): Promise<any>
		rewind$($: {}): Promise<any>
		readable(): Promise<any>
		readable$($: {}): Promise<any>
		writable(): Promise<any>
		writable$($: {}): Promise<any>
		seekable(): Promise<any>
		seekable$($: {}): Promise<any>
		seek(offset, whence?): Promise<any>
		seek$({ offset, whence }: { offset, whence?}): Promise<any>
		readline(size?): Promise<any>
		readline$({ size }: { size?}): Promise<any>
		myfileobj
	}
	interface I_GzipReader {
		read(size?): Promise<any>
		read$({ size }: { size?}): Promise<any>
	}
}
declare module hashlib {
	var _
	let algorithms_guaranteed: Promise<any>
	let algorithms_available: Promise<any>
	let new$: Promise<any>
}
declare module heapq {
	var _

	/**
	 * Push item onto heap, maintaining the heap invariant.
	 */
	function heappush(heap, item): Promise<any>
	function heappush$({ heap, item }): Promise<any>

	/**
	 * Pop the smallest item off the heap, maintaining the heap invariant.
	 */
	function heappop(heap): Promise<any>
	function heappop$({ heap }): Promise<any>

	/**
	 * Pop and return the current smallest value, and add the new item.
	 * 
	 *     This is more efficient than heappop() followed by heappush(), and can be
	 *     more appropriate when using a fixed-size heap.  Note that the value
	 *     returned may be larger than item!  That constrains reasonable uses of
	 *     this routine unless written as part of a conditional replacement:
	 * 
	 *         if item > heap[0]:
	 *             item = heapreplace(heap, item)
	 *     
	 */
	function heapreplace(heap, item): Promise<any>
	function heapreplace$({ heap, item }): Promise<any>

	/**
	 * Fast version of a heappush followed by a heappop.
	 */
	function heappushpop(heap, item): Promise<any>
	function heappushpop$({ heap, item }): Promise<any>

	/**
	 * Transform list into a heap, in-place, in O(len(x)) time.
	 */
	function heapify(x): Promise<any>
	function heapify$({ x }): Promise<any>

	/**
	 * Merge multiple sorted inputs into a single sorted output.
	 * 
	 *     Similar to sorted(itertools.chain(*iterables)) but returns a generator,
	 *     does not pull the data into memory all at once, and assumes that each of
	 *     the input streams is already sorted (smallest to largest).
	 * 
	 *     >>> list(merge([1,3,5,7], [0,2,4,8], [5,10,15,20], [], [25]))
	 *     [0, 1, 2, 3, 4, 5, 5, 7, 8, 10, 15, 20, 25]
	 * 
	 *     If *key* is not None, applies a key function to each element to determine
	 *     its sort order.
	 * 
	 *     >>> list(merge(['dog', 'horse'], ['cat', 'fish', 'kangaroo'], key=len))
	 *     ['dog', 'cat', 'fish', 'horse', 'kangaroo']
	 * 
	 *     
	 */
	function merge(): Promise<any>
	function merge$($: {}): Promise<any>

	/**
	 * Find the n smallest elements in a dataset.
	 * 
	 *     Equivalent to:  sorted(iterable, key=key)[:n]
	 *     
	 */
	function nsmallest(n, iterable, key?): Promise<any>
	function nsmallest$({ n, iterable, key }: { n, iterable, key?}): Promise<any>

	/**
	 * Find the n largest elements in a dataset.
	 * 
	 *     Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]
	 *     
	 */
	function nlargest(n, iterable, key?): Promise<any>
	function nlargest$({ n, iterable, key }: { n, iterable, key?}): Promise<any>
}
declare module hmac {
	var _
	function new$({ key, msg, digestmod }: { key, msg?, digestmod?}): Promise<any>

	/**
	 * Fast inline implementation of HMAC.
	 * 
	 *     key: bytes or buffer, The key for the keyed hash object.
	 *     msg: bytes or buffer, Input message.
	 *     digest: A hash name suitable for hashlib.new() for best performance. *OR*
	 *             A hashlib constructor returning a new hash object. *OR*
	 *             A module supporting PEP 247.
	 *     
	 */
	function digest(key, msg, digest): Promise<any>
	function digest$({ key, msg, digest }): Promise<any>

	/**
	 * RFC 2104 HMAC class.  Also complies with RFC 4231.
	 * 
	 *     This supports the API for Cryptographic Hash Functions (PEP 247).
	 *     
	 */

	/**
	 * Create a new HMAC object.
	 * 
	 *         key: bytes or buffer, key for the keyed hash object.
	 *         msg: bytes or buffer, Initial input for the hash or None.
	 *         digestmod: A hash name suitable for hashlib.new(). *OR*
	 *                    A hashlib constructor returning a new hash object. *OR*
	 *                    A module supporting PEP 247.
	 * 
	 *                    Required as of 3.8, despite its position after the optional
	 *                    msg argument.  Passing it as a keyword argument is
	 *                    recommended, though not required for legacy API reasons.
	 *         
	 */
	function HMAC(key, msg?, digestmod?): Promise<IHMAC>
	function HMAC$({ key, msg, digestmod }: { key, msg?, digestmod?}): Promise<IHMAC>
	interface IHMAC {
		name(): Promise<any>
		name$($: {}): Promise<any>

		/**
		 * Feed data from msg into this hashing object.
		 */
		update(msg): Promise<any>
		update$({ msg }): Promise<any>

		/**
		 * Return a separate copy of this hashing object.
		 * 
		 *         An update to this copy won't affect the original object.
		 *         
		 */
		copy(): Promise<any>
		copy$($: {}): Promise<any>

		/**
		 * Return the hash value of this hashing object.
		 * 
		 *         This returns the hmac value as bytes.  The object is
		 *         not altered in any way by this function; you can continue
		 *         updating the object after calling this function.
		 *         
		 */
		digest(): Promise<any>
		digest$($: {}): Promise<any>

		/**
		 * Like digest(), but returns a string of hexadecimal digits instead.
		 *         
		 */
		hexdigest(): Promise<any>
		hexdigest$($: {}): Promise<any>
		blocksize
	}
	let compare_digest: Promise<any>
	let trans_5C: Promise<any>
	let trans_36: Promise<any>
	let digest_size: Promise<any>
}
declare module html {
	var _

	/**
	 * 
	 *     Replace special characters "&", "<" and ">" to HTML-safe sequences.
	 *     If the optional flag quote is true (the default), the quotation mark
	 *     characters, both double quote (") and single quote (') characters are also
	 *     translated.
	 *     
	 */
	function escape(s, quote?: boolean): Promise<any>
	function escape$({ s, quote }: { s, quote?}): Promise<any>

	/**
	 * 
	 *     Convert all named and numeric character references (e.g. &gt;, &#62;,
	 *     &x3e;) in the string s to the corresponding unicode characters.
	 *     This function uses the rules defined by the HTML 5 standard
	 *     for both valid and invalid character references, and the list of
	 *     HTML 5 named character references defined in html.entities.html5.
	 *     
	 */
	function unescape(s): Promise<any>
	function unescape$({ s }): Promise<any>
	module entities {
		var _
		let name2codepoint: Promise<any>
		let html5: Promise<any>
		let codepoint2name: Promise<any>
		let entitydefs: Promise<any>
	}
	module parser {
		var _

		/**
		 * Find tags and other markup and call handler functions.
		 * 
		 *     Usage:
		 *         p = HTMLParser()
		 *         p.feed(data)
		 *         ...
		 *         p.close()
		 * 
		 *     Start tags are handled by calling self.handle_starttag() or
		 *     self.handle_startendtag(); end tags by self.handle_endtag().  The
		 *     data between tags is passed from the parser to the derived class
		 *     by calling self.handle_data() with the data as argument (the data
		 *     may be split up in arbitrary chunks).  If convert_charrefs is
		 *     True the character references are converted automatically to the
		 *     corresponding Unicode character (and self.handle_data() is no
		 *     longer split in chunks), otherwise they are passed by calling
		 *     self.handle_entityref() or self.handle_charref() with the string
		 *     containing respectively the named or numeric reference as the
		 *     argument.
		 *     
		 */

		/**
		 * Initialize and reset this instance.
		 * 
		 *         If convert_charrefs is True (the default), all character references
		 *         are automatically converted to the corresponding Unicode characters.
		 *         
		 */
		function HTMLParser(): Promise<IHTMLParser>
		function HTMLParser$({ }): Promise<IHTMLParser>
		interface IHTMLParser {

			/**
			 * Reset this instance.  Loses all unprocessed data.
			 */
			reset(): Promise<any>
			reset$($: {}): Promise<any>

			/**
			 * Feed data to the parser.
			 * 
			 *         Call this as often as you want, with as little or as much text
			 *         as you want (may include '\n').
			 *         
			 */
			feed(data): Promise<any>
			feed$({ data }): Promise<any>

			/**
			 * Handle any buffered data.
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Return full source of start tag: '<...>'.
			 */
			get_starttag_text(): Promise<any>
			get_starttag_text$($: {}): Promise<any>
			set_cdata_mode(elem): Promise<any>
			set_cdata_mode$({ elem }): Promise<any>
			clear_cdata_mode(): Promise<any>
			clear_cdata_mode$($: {}): Promise<any>
			goahead(end): Promise<any>
			goahead$({ end }): Promise<any>
			parse_html_declaration(i): Promise<any>
			parse_html_declaration$({ i }): Promise<any>
			parse_bogus_comment(i, report?): Promise<any>
			parse_bogus_comment$({ i, report }: { i, report?}): Promise<any>
			parse_pi(i): Promise<any>
			parse_pi$({ i }): Promise<any>
			parse_starttag(i): Promise<any>
			parse_starttag$({ i }): Promise<any>
			check_for_whole_start_tag(i): Promise<any>
			check_for_whole_start_tag$({ i }): Promise<any>
			parse_endtag(i): Promise<any>
			parse_endtag$({ i }): Promise<any>
			handle_startendtag(tag, attrs): Promise<any>
			handle_startendtag$({ tag, attrs }): Promise<any>
			handle_starttag(tag, attrs): Promise<any>
			handle_starttag$({ tag, attrs }): Promise<any>
			handle_endtag(tag): Promise<any>
			handle_endtag$({ tag }): Promise<any>
			handle_charref(name): Promise<any>
			handle_charref$({ name }): Promise<any>
			handle_entityref(name): Promise<any>
			handle_entityref$({ name }): Promise<any>
			handle_data(data): Promise<any>
			handle_data$({ data }): Promise<any>
			handle_comment(data): Promise<any>
			handle_comment$({ data }): Promise<any>
			handle_decl(decl): Promise<any>
			handle_decl$({ decl }): Promise<any>
			handle_pi(data): Promise<any>
			handle_pi$({ data }): Promise<any>
			unknown_decl(data): Promise<any>
			unknown_decl$({ data }): Promise<any>
			CDATA_CONTENT_ELEMENTS
		}
		let interesting_normal: Promise<any>
		let incomplete: Promise<any>
		let entityref: Promise<any>
		let charref: Promise<any>
		let starttagopen: Promise<any>
		let piclose: Promise<any>
		let commentclose: Promise<any>
		let tagfind_tolerant: Promise<any>
		let attrfind_tolerant: Promise<any>
		let locatestarttagend_tolerant: Promise<any>
		let endendtag: Promise<any>
		let endtagfind: Promise<any>
	}
}
declare module http {
	var _

	/**
	 * HTTP status codes and reason phrases
	 * 
	 *     Status codes from the following RFCs are all observed:
	 * 
	 *         * RFC 7231: Hypertext Transfer Protocol (HTTP/1.1), obsoletes 2616
	 *         * RFC 6585: Additional HTTP Status Codes
	 *         * RFC 3229: Delta encoding in HTTP
	 *         * RFC 4918: HTTP Extensions for WebDAV, obsoletes 2518
	 *         * RFC 5842: Binding Extensions to WebDAV
	 *         * RFC 7238: Permanent Redirect
	 *         * RFC 2295: Transparent Content Negotiation in HTTP
	 *         * RFC 2774: An HTTP Extension Framework
	 *         * RFC 7725: An HTTP Status Code to Report Legal Obstacles
	 *         * RFC 7540: Hypertext Transfer Protocol Version 2 (HTTP/2)
	 *         * RFC 2324: Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)
	 *         * RFC 8297: An HTTP Status Code for Indicating Hints
	 *         * RFC 8470: Using Early Data in HTTP
	 *     
	 */
	interface IHTTPStatus {
		CONTINUE
		SWITCHING_PROTOCOLS
		PROCESSING
		EARLY_HINTS
		OK
		CREATED
		ACCEPTED
		NON_AUTHORITATIVE_INFORMATION
		NO_CONTENT
		RESET_CONTENT
		PARTIAL_CONTENT
		MULTI_STATUS
		ALREADY_REPORTED
		IM_USED
		MULTIPLE_CHOICES
		MOVED_PERMANENTLY
		FOUND
		SEE_OTHER
		NOT_MODIFIED
		USE_PROXY
		TEMPORARY_REDIRECT
		PERMANENT_REDIRECT
		BAD_REQUEST
		UNAUTHORIZED
		PAYMENT_REQUIRED
		FORBIDDEN
		NOT_FOUND
		METHOD_NOT_ALLOWED
		NOT_ACCEPTABLE
		PROXY_AUTHENTICATION_REQUIRED
		REQUEST_TIMEOUT
		CONFLICT
		GONE
		LENGTH_REQUIRED
		PRECONDITION_FAILED
		REQUEST_ENTITY_TOO_LARGE
		REQUEST_URI_TOO_LONG
		UNSUPPORTED_MEDIA_TYPE
		REQUESTED_RANGE_NOT_SATISFIABLE
		EXPECTATION_FAILED
		IM_A_TEAPOT
		MISDIRECTED_REQUEST
		UNPROCESSABLE_ENTITY
		LOCKED
		FAILED_DEPENDENCY
		TOO_EARLY
		UPGRADE_REQUIRED
		PRECONDITION_REQUIRED
		TOO_MANY_REQUESTS
		REQUEST_HEADER_FIELDS_TOO_LARGE
		UNAVAILABLE_FOR_LEGAL_REASONS
		INTERNAL_SERVER_ERROR
		NOT_IMPLEMENTED
		BAD_GATEWAY
		SERVICE_UNAVAILABLE
		GATEWAY_TIMEOUT
		HTTP_VERSION_NOT_SUPPORTED
		VARIANT_ALSO_NEGOTIATES
		INSUFFICIENT_STORAGE
		LOOP_DETECTED
		NOT_EXTENDED
		NETWORK_AUTHENTICATION_REQUIRED
	}
	module client {
		var _

		/**
		 * Parses only RFC2822 headers from a file pointer.
		 * 
		 *     email Parser wants to see strings rather than bytes.
		 *     But a TextIOWrapper around self.rfile would buffer too many bytes
		 *     from the stream, bytes which we later need to read as bytes.
		 *     So we read the correct bytes here, as bytes, for email Parser
		 *     to parse.
		 * 
		 *     
		 */
		function parse_headers(fp, _class?): Promise<any>
		function parse_headers$({ fp, _class }: { fp, _class?}): Promise<any>
		interface IHTTPMessage {

			/**
			 * Find all header lines matching a given header name.
			 * 
			 *         Look through the list of headers and find all lines matching a given
			 *         header name (and their continuation lines).  A list of the lines is
			 *         returned, without interpretation.  If the header does not occur, an
			 *         empty list is returned.  If the header occurs multiple times, all
			 *         occurrences are returned.  Case is not important in the header name.
			 * 
			 *         
			 */
			getallmatchingheaders(name): Promise<any>
			getallmatchingheaders$({ name }): Promise<any>
		}
		function HTTPResponse(sock, debuglevel?, method?, url?): Promise<IHTTPResponse>
		function HTTPResponse$({ sock, debuglevel, method, url }: { sock, debuglevel?, method?, url?}): Promise<IHTTPResponse>
		interface IHTTPResponse {
			begin(): Promise<any>
			begin$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			flush(): Promise<any>
			flush$($: {}): Promise<any>

			/**
			 * Always returns True
			 */
			readable(): Promise<any>
			readable$($: {}): Promise<any>

			/**
			 * True if the connection is closed.
			 */
			isclosed(): Promise<any>
			isclosed$($: {}): Promise<any>
			read(amt?): Promise<any>
			read$({ amt }: { amt?}): Promise<any>

			/**
			 * Read up to len(b) bytes into bytearray b and return the number
			 *         of bytes read.
			 *         
			 */
			readinto(b): Promise<any>
			readinto$({ b }): Promise<any>

			/**
			 * Read with at most one underlying system call.  If at least one
			 *         byte is buffered, return that instead.
			 *         
			 */
			read1(n?): Promise<any>
			read1$({ n }: { n?}): Promise<any>
			peek(n?): Promise<any>
			peek$({ n }: { n?}): Promise<any>
			readline(limit?): Promise<any>
			readline$({ limit }: { limit?}): Promise<any>
			fileno(): Promise<any>
			fileno$($: {}): Promise<any>

			/**
			 * Returns the value of the header matching *name*.
			 * 
			 *         If there are multiple matching headers, the values are
			 *         combined into a single string separated by commas and spaces.
			 * 
			 *         If no matching header is found, returns *default* or None if
			 *         the *default* is not specified.
			 * 
			 *         If the headers are unknown, raises http.client.ResponseNotReady.
			 * 
			 *         
			 */
			getheader(name, def?): Promise<any>
			getheader$({ name, def }: { name, def?}): Promise<any>

			/**
			 * Return list of (header, value) tuples.
			 */
			getheaders(): Promise<any>
			getheaders$($: {}): Promise<any>

			/**
			 * Returns an instance of the class mimetools.Message containing
			 *         meta-information associated with the URL.
			 * 
			 *         When the method is HTTP, these headers are those returned by
			 *         the server at the head of the retrieved HTML page (including
			 *         Content-Length and Content-Type).
			 * 
			 *         When the method is FTP, a Content-Length header will be
			 *         present if (as is now usual) the server passed back a file
			 *         length in response to the FTP retrieval request. A
			 *         Content-Type header will be present if the MIME type can be
			 *         guessed.
			 * 
			 *         When the method is local-file, returned headers will include
			 *         a Date representing the file's last-modified time, a
			 *         Content-Length giving file size, and a Content-Type
			 *         containing a guess at the file's type. See also the
			 *         description of the mimetools module.
			 * 
			 *         
			 */
			info(): Promise<any>
			info$($: {}): Promise<any>

			/**
			 * Return the real URL of the page.
			 * 
			 *         In some cases, the HTTP server redirects a client to another
			 *         URL. The urlopen() function handles this transparently, but in
			 *         some cases the caller needs to know which URL the client was
			 *         redirected to. The geturl() method can be used to get at this
			 *         redirected URL.
			 * 
			 *         
			 */
			geturl(): Promise<any>
			geturl$($: {}): Promise<any>

			/**
			 * Return the HTTP status code that was sent with the response,
			 *         or None if the URL is not an HTTP URL.
			 * 
			 *         
			 */
			getcode(): Promise<any>
			getcode$($: {}): Promise<any>
		}
		function HTTPConnection(host, port?, timeout?, source_address?, blocksize?): Promise<IHTTPConnection>
		function HTTPConnection$({ host, port, timeout, source_address, blocksize }: { host, port?, timeout?, source_address?, blocksize?}): Promise<IHTTPConnection>
		interface IHTTPConnection {

			/**
			 * Set up host and port for HTTP CONNECT tunnelling.
			 * 
			 *         In a connection that uses HTTP CONNECT tunneling, the host passed to the
			 *         constructor is used as a proxy server that relays all communication to
			 *         the endpoint passed to `set_tunnel`. This done by sending an HTTP
			 *         CONNECT request to the proxy server when the connection is established.
			 * 
			 *         This method must be called before the HTTP connection has been
			 *         established.
			 * 
			 *         The headers argument should be a mapping of extra HTTP headers to send
			 *         with the CONNECT request.
			 *         
			 */
			set_tunnel(host, port?, headers?): Promise<any>
			set_tunnel$({ host, port, headers }: { host, port?, headers?}): Promise<any>
			set_debuglevel(level): Promise<any>
			set_debuglevel$({ level }): Promise<any>

			/**
			 * Connect to the host and port specified in __init__.
			 */
			connect(): Promise<any>
			connect$($: {}): Promise<any>

			/**
			 * Close the connection to the HTTP server.
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Send `data' to the server.
			 *         ``data`` can be a string object, a bytes object, an array object, a
			 *         file-like object that supports a .read() method, or an iterable object.
			 *         
			 */
			send(data): Promise<any>
			send$({ data }): Promise<any>

			/**
			 * Send a request to the server.
			 * 
			 *         `method' specifies an HTTP request method, e.g. 'GET'.
			 *         `url' specifies the object being requested, e.g. '/index.html'.
			 *         `skip_host' if True does not add automatically a 'Host:' header
			 *         `skip_accept_encoding' if True does not add automatically an
			 *            'Accept-Encoding:' header
			 *         
			 */
			putrequest(method, url, skip_host?: boolean, skip_accept_encoding?: boolean): Promise<any>
			putrequest$({ method, url, skip_host, skip_accept_encoding }: { method, url, skip_host?, skip_accept_encoding?}): Promise<any>

			/**
			 * Send a request header line to the server.
			 * 
			 *         For example: h.putheader('Accept', 'text/html')
			 *         
			 */
			putheader(header): Promise<any>
			putheader$({ header }): Promise<any>

			/**
			 * Indicate that the last header line has been sent to the server.
			 * 
			 *         This method sends the request to the server.  The optional message_body
			 *         argument can be used to pass a message body associated with the
			 *         request.
			 *         
			 */
			endheaders(message_body?): Promise<any>
			endheaders$({ message_body }: { message_body?}): Promise<any>

			/**
			 * Send a complete request to the server.
			 */
			request(method, url, body?, headers?): Promise<any>
			request$({ method, url, body, headers }: { method, url, body?, headers?}): Promise<any>

			/**
			 * Get the response from the server.
			 * 
			 *         If the HTTPConnection is in the correct state, returns an
			 *         instance of HTTPResponse or of whatever object is returned by
			 *         the response_class variable.
			 * 
			 *         If a request has not been sent or if a previous response has
			 *         not be handled, ResponseNotReady is raised.  If the HTTP
			 *         response indicates that the connection should be closed, then
			 *         it will be closed before the response is returned.  When the
			 *         connection is closed, the underlying socket is closed.
			 *         
			 */
			getresponse(): Promise<any>
			getresponse$($: {}): Promise<any>
			response_class
			default_port
			auto_open
			debuglevel
		}

		/**
		 * This class allows communication via SSL.
		 */
		function HTTPSConnection(host, port?, key_file?, cert_file?, timeout?, source_address?): Promise<IHTTPSConnection>
		function HTTPSConnection$({ host, port, key_file, cert_file, timeout, source_address }: { host, port?, key_file?, cert_file?, timeout?, source_address?}): Promise<IHTTPSConnection>
		interface IHTTPSConnection extends IHTTPConnection {

			/**
			 * Connect to a host on a given (SSL) port.
			 */
			connect(): Promise<any>
			connect$($: {}): Promise<any>
		}
		interface IHTTPException {
		}
		interface INotConnected extends IHTTPException {
		}
		interface IInvalidURL extends IHTTPException {
		}
		function UnknownProtocol(version): Promise<IUnknownProtocol>
		function UnknownProtocol$({ version }): Promise<IUnknownProtocol>
		interface IUnknownProtocol extends IHTTPException {
		}
		interface IUnknownTransferEncoding extends IHTTPException {
		}
		interface IUnimplementedFileMode extends IHTTPException {
		}
		function IncompleteRead(partial, expected?): Promise<IIncompleteRead>
		function IncompleteRead$({ partial, expected }: { partial, expected?}): Promise<IIncompleteRead>
		interface IIncompleteRead extends IHTTPException {
		}
		interface IImproperConnectionState extends IHTTPException {
		}
		interface ICannotSendRequest extends IImproperConnectionState {
		}
		interface ICannotSendHeader extends IImproperConnectionState {
		}
		interface IResponseNotReady extends IImproperConnectionState {
		}
		function BadStatusLine(line): Promise<IBadStatusLine>
		function BadStatusLine$({ line }): Promise<IBadStatusLine>
		interface IBadStatusLine extends IHTTPException {
		}
		function LineTooLong(line_type): Promise<ILineTooLong>
		function LineTooLong$({ line_type }): Promise<ILineTooLong>
		interface ILineTooLong extends IHTTPException {
		}
		function RemoteDisconnected(): Promise<IRemoteDisconnected>
		function RemoteDisconnected$({ }): Promise<IRemoteDisconnected>
		interface IRemoteDisconnected extends IBadStatusLine {
		}
		let HTTP_PORT: Promise<any>
		let HTTPS_PORT: Promise<any>
		let responses: Promise<any>
		let error: Promise<any>
	}
	module cookiejar {
		var _

		/**
		 * Return a string representing time in seconds since epoch, t.
		 * 
		 *     If the function is called without an argument, it will use the current
		 *     time.
		 * 
		 *     The format of the returned string is like "YYYY-MM-DD hh:mm:ssZ",
		 *     representing Universal Time (UTC, aka GMT).  An example of this format is:
		 * 
		 *     1994-11-24 08:49:37Z
		 * 
		 *     
		 */
		function time2isoz(t?): Promise<any>
		function time2isoz$({ t }: { t?}): Promise<any>

		/**
		 * Return a string representing time in seconds since epoch, t.
		 * 
		 *     If the function is called without an argument, it will use the current
		 *     time.
		 * 
		 *     The format of the returned string is like this:
		 * 
		 *     Wed, DD-Mon-YYYY HH:MM:SS GMT
		 * 
		 *     
		 */
		function time2netscape(t?): Promise<any>
		function time2netscape$({ t }: { t?}): Promise<any>
		function offset_from_tz_string(tz): Promise<any>
		function offset_from_tz_string$({ tz }): Promise<any>

		/**
		 * Returns time in seconds since epoch of time represented by a string.
		 * 
		 *     Return value is an integer.
		 * 
		 *     None is returned if the format of str is unrecognized, the time is outside
		 *     the representable range, or the timezone string is not recognized.  If the
		 *     string contains no timezone, UTC is assumed.
		 * 
		 *     The timezone in the string may be numerical (like "-0800" or "+0100") or a
		 *     string timezone (like "UTC", "GMT", "BST" or "EST").  Currently, only the
		 *     timezone strings equivalent to UTC (zero offset) are known to the function.
		 * 
		 *     The function loosely parses the following formats:
		 * 
		 *     Wed, 09 Feb 1994 22:23:32 GMT       -- HTTP format
		 *     Tuesday, 08-Feb-94 14:15:29 GMT     -- old rfc850 HTTP format
		 *     Tuesday, 08-Feb-1994 14:15:29 GMT   -- broken rfc850 HTTP format
		 *     09 Feb 1994 22:23:32 GMT            -- HTTP format (no weekday)
		 *     08-Feb-94 14:15:29 GMT              -- rfc850 format (no weekday)
		 *     08-Feb-1994 14:15:29 GMT            -- broken rfc850 format (no weekday)
		 * 
		 *     The parser ignores leading and trailing whitespace.  The time may be
		 *     absent.
		 * 
		 *     If the year is given with only 2 digits, the function will select the
		 *     century that makes the year closest to the current date.
		 * 
		 *     
		 */
		function http2time(text): Promise<any>
		function http2time$({ text }): Promise<any>

		/**
		 * 
		 *     As for http2time, but parses the ISO 8601 formats:
		 * 
		 *     1994-02-03 14:15:29 -0100    -- ISO 8601 format
		 *     1994-02-03 14:15:29          -- zone is optional
		 *     1994-02-03                   -- only date
		 *     1994-02-03T14:15:29          -- Use T as separator
		 *     19940203T141529Z             -- ISO 8601 compact format
		 *     19940203                     -- only date
		 * 
		 *     
		 */
		function iso2time(text): Promise<any>
		function iso2time$({ text }): Promise<any>

		/**
		 * Return unmatched part of re.Match object.
		 */
		function unmatched(match): Promise<any>
		function unmatched$({ match }): Promise<any>

		/**
		 * Parse header values into a list of lists containing key,value pairs.
		 * 
		 *     The function knows how to deal with ",", ";" and "=" as well as quoted
		 *     values after "=".  A list of space separated tokens are parsed as if they
		 *     were separated by ";".
		 * 
		 *     If the header_values passed as argument contains multiple values, then they
		 *     are treated as if they were a single value separated by comma ",".
		 * 
		 *     This means that this function is useful for parsing header fields that
		 *     follow this syntax (BNF as from the HTTP/1.1 specification, but we relax
		 *     the requirement for tokens).
		 * 
		 *       headers           = #header
		 *       header            = (token | parameter) *( [";"] (token | parameter))
		 * 
		 *       token             = 1*<any CHAR except CTLs or separators>
		 *       separators        = "(" | ")" | "<" | ">" | "@"
		 *                         | "," | ";" | ":" | "\" | <">
		 *                         | "/" | "[" | "]" | "?" | "="
		 *                         | "{" | "}" | SP | HT
		 * 
		 *       quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )
		 *       qdtext            = <any TEXT except <">>
		 *       quoted-pair       = "\" CHAR
		 * 
		 *       parameter         = attribute "=" value
		 *       attribute         = token
		 *       value             = token | quoted-string
		 * 
		 *     Each header is represented by a list of key/value pairs.  The value for a
		 *     simple token (not part of a parameter) is None.  Syntactically incorrect
		 *     headers will not necessarily be parsed as you would want.
		 * 
		 *     This is easier to describe with some examples:
		 * 
		 *     >>> split_header_words(['foo="bar"; port="80,81"; discard, bar=baz'])
		 *     [[('foo', 'bar'), ('port', '80,81'), ('discard', None)], [('bar', 'baz')]]
		 *     >>> split_header_words(['text/html; charset="iso-8859-1"'])
		 *     [[('text/html', None), ('charset', 'iso-8859-1')]]
		 *     >>> split_header_words([r'Basic realm="\"foo\bar\""'])
		 *     [[('Basic', None), ('realm', '"foobar"')]]
		 * 
		 *     
		 */
		function split_header_words(header_values): Promise<any>
		function split_header_words$({ header_values }): Promise<any>

		/**
		 * Do the inverse (almost) of the conversion done by split_header_words.
		 * 
		 *     Takes a list of lists of (key, value) pairs and produces a single header
		 *     value.  Attribute values are quoted if needed.
		 * 
		 *     >>> join_header_words([[("text/plain", None), ("charset", "iso-8859-1")]])
		 *     'text/plain; charset="iso-8859-1"'
		 *     >>> join_header_words([[("text/plain", None)], [("charset", "iso-8859-1")]])
		 *     'text/plain, charset="iso-8859-1"'
		 * 
		 *     
		 */
		function join_header_words(lists): Promise<any>
		function join_header_words$({ lists }): Promise<any>
		function strip_quotes(text): Promise<any>
		function strip_quotes$({ text }): Promise<any>

		/**
		 * Ad-hoc parser for Netscape protocol cookie-attributes.
		 * 
		 *     The old Netscape cookie format for Set-Cookie can for instance contain
		 *     an unquoted "," in the expires field, so we have to use this ad-hoc
		 *     parser instead of split_header_words.
		 * 
		 *     XXX This may not make the best possible effort to parse all the crap
		 *     that Netscape Cookie headers contain.  Ronald Tschalar's HTTPClient
		 *     parser is probably better, so could do worse than following that if
		 *     this ever gives any trouble.
		 * 
		 *     Currently, this is also used for parsing RFC 2109 cookies.
		 * 
		 *     
		 */
		function parse_ns_headers(ns_headers): Promise<any>
		function parse_ns_headers$({ ns_headers }): Promise<any>

		/**
		 * Return True if text is a host domain name.
		 */
		function is_HDN(text): Promise<any>
		function is_HDN$({ text }): Promise<any>

		/**
		 * Return True if domain A domain-matches domain B, according to RFC 2965.
		 * 
		 *     A and B may be host domain names or IP addresses.
		 * 
		 *     RFC 2965, section 1:
		 * 
		 *     Host names can be specified either as an IP address or a HDN string.
		 *     Sometimes we compare one host name with another.  (Such comparisons SHALL
		 *     be case-insensitive.)  Host A's name domain-matches host B's if
		 * 
		 *          *  their host name strings string-compare equal; or
		 * 
		 *          * A is a HDN string and has the form NB, where N is a non-empty
		 *             name string, B has the form .B', and B' is a HDN string.  (So,
		 *             x.y.com domain-matches .Y.com but not Y.com.)
		 * 
		 *     Note that domain-match is not a commutative operation: a.b.c.com
		 *     domain-matches .c.com, but not the reverse.
		 * 
		 *     
		 */
		function domain_match(A, B): Promise<any>
		function domain_match$({ A, B }): Promise<any>

		/**
		 * Return True if text is a sort-of-like a host domain name.
		 * 
		 *     For accepting/blocking domains.
		 * 
		 *     
		 */
		function liberal_is_HDN(text): Promise<any>
		function liberal_is_HDN$({ text }): Promise<any>

		/**
		 * For blocking/accepting domains.
		 * 
		 *     A and B may be host domain names or IP addresses.
		 * 
		 *     
		 */
		function user_domain_match(A, B): Promise<any>
		function user_domain_match$({ A, B }): Promise<any>

		/**
		 * Return request-host, as defined by RFC 2965.
		 * 
		 *     Variation from RFC: returned value is lowercased, for convenient
		 *     comparison.
		 * 
		 *     
		 */
		function request_host(request): Promise<any>
		function request_host$({ request }): Promise<any>

		/**
		 * Return a tuple (request-host, effective request-host name).
		 * 
		 *     As defined by RFC 2965, except both are lowercased.
		 * 
		 *     
		 */
		function eff_request_host(request): Promise<any>
		function eff_request_host$({ request }): Promise<any>

		/**
		 * Path component of request-URI, as defined by RFC 2965.
		 */
		function request_path(request): Promise<any>
		function request_path$({ request }): Promise<any>
		function request_port(request): Promise<any>
		function request_port$({ request }): Promise<any>
		function uppercase_escaped_char(match): Promise<any>
		function uppercase_escaped_char$({ match }): Promise<any>

		/**
		 * Escape any invalid characters in HTTP URL, and uppercase all escapes.
		 */
		function escape_path(path): Promise<any>
		function escape_path$({ path }): Promise<any>

		/**
		 * Return reach of host h, as defined by RFC 2965, section 1.
		 * 
		 *     The reach R of a host name H is defined as follows:
		 * 
		 *        *  If
		 * 
		 *           -  H is the host domain name of a host; and,
		 * 
		 *           -  H has the form A.B; and
		 * 
		 *           -  A has no embedded (that is, interior) dots; and
		 * 
		 *           -  B has at least one embedded dot, or B is the string "local".
		 *              then the reach of H is .B.
		 * 
		 *        *  Otherwise, the reach of H is H.
		 * 
		 *     >>> reach("www.acme.com")
		 *     '.acme.com'
		 *     >>> reach("acme.com")
		 *     'acme.com'
		 *     >>> reach("acme.local")
		 *     '.local'
		 * 
		 *     
		 */
		function reach(h): Promise<any>
		function reach$({ h }): Promise<any>

		/**
		 * 
		 * 
		 *     RFC 2965, section 3.3.6:
		 * 
		 *         An unverifiable transaction is to a third-party host if its request-
		 *         host U does not domain-match the reach R of the request-host O in the
		 *         origin transaction.
		 * 
		 *     
		 */
		function is_third_party(request): Promise<any>
		function is_third_party$({ request }): Promise<any>
		function vals_sorted_by_key(adict): Promise<any>
		function vals_sorted_by_key$({ adict }): Promise<any>

		/**
		 * Iterates over nested mapping, depth-first, in sorted order by key.
		 */
		function deepvalues(mapping): Promise<any>
		function deepvalues$({ mapping }): Promise<any>

		/**
		 * Return string representation of Cookie in the LWP cookie file format.
		 * 
		 *     Actually, the format is extended a bit -- see module docstring.
		 * 
		 *     
		 */
		function lwp_cookie_str(cookie): Promise<any>
		function lwp_cookie_str$({ cookie }): Promise<any>

		/**
		 * HTTP Cookie.
		 * 
		 *     This class represents both Netscape and RFC 2965 cookies.
		 * 
		 *     This is deliberately a very simple class.  It just holds attributes.  It's
		 *     possible to construct Cookie instances that don't comply with the cookie
		 *     standards.  CookieJar.make_cookies is the factory function for Cookie
		 *     objects -- it deals with cookie parsing, supplying defaults, and
		 *     normalising to the representation used in this class.  CookiePolicy is
		 *     responsible for checking them to see whether they should be accepted from
		 *     and returned to the server.
		 * 
		 *     Note that the port may be present in the headers, but unspecified ("Port"
		 *     rather than"Port=80", for example); if this is the case, port is None.
		 * 
		 *     
		 */
		function Cookie(version, name, value, port, port_specified, domain, domain_specified, domain_initial_dot, path, path_specified, secure, expires, discard, comment, comment_url, rest, rfc2109?: boolean): Promise<ICookie>
		function Cookie$({ version, name, value, port, port_specified, domain, domain_specified, domain_initial_dot, path, path_specified, secure, expires, discard, comment, comment_url, rest, rfc2109 }: { version, name, value, port, port_specified, domain, domain_specified, domain_initial_dot, path, path_specified, secure, expires, discard, comment, comment_url, rest, rfc2109?}): Promise<ICookie>
		interface ICookie {
			has_nonstandard_attr(name): Promise<any>
			has_nonstandard_attr$({ name }): Promise<any>
			get_nonstandard_attr(name, def?): Promise<any>
			get_nonstandard_attr$({ name, def }: { name, def?}): Promise<any>
			set_nonstandard_attr(name, value): Promise<any>
			set_nonstandard_attr$({ name, value }): Promise<any>
			is_expired(now?): Promise<any>
			is_expired$({ now }: { now?}): Promise<any>
		}

		/**
		 * Defines which cookies get accepted from and returned to server.
		 * 
		 *     May also modify cookies, though this is probably a bad idea.
		 * 
		 *     The subclass DefaultCookiePolicy defines the standard rules for Netscape
		 *     and RFC 2965 cookies -- override that if you want a customized policy.
		 * 
		 *     
		 */
		interface ICookiePolicy {

			/**
			 * Return true if (and only if) cookie should be accepted from server.
			 * 
			 *         Currently, pre-expired cookies never get this far -- the CookieJar
			 *         class deletes such cookies itself.
			 * 
			 *         
			 */
			set_ok(cookie, request): Promise<any>
			set_ok$({ cookie, request }): Promise<any>

			/**
			 * Return true if (and only if) cookie should be returned to server.
			 */
			return_ok(cookie, request): Promise<any>
			return_ok$({ cookie, request }): Promise<any>

			/**
			 * Return false if cookies should not be returned, given cookie domain.
			 *         
			 */
			domain_return_ok(domain, request): Promise<any>
			domain_return_ok$({ domain, request }): Promise<any>

			/**
			 * Return false if cookies should not be returned, given cookie path.
			 *         
			 */
			path_return_ok(path, request): Promise<any>
			path_return_ok$({ path, request }): Promise<any>
		}

		/**
		 * Implements the standard rules for accepting and returning cookies.
		 */

		/**
		 * Constructor arguments should be passed as keyword arguments only.
		 */
		function DefaultCookiePolicy(blocked_domains?, allowed_domains?, netscape?: boolean, rfc2965?: boolean, rfc2109_as_netscape?, hide_cookie2?: boolean, strict_domain?: boolean, strict_rfc2965_unverifiable?: boolean, strict_ns_unverifiable?: boolean, strict_ns_domain?, strict_ns_set_initial_dollar?: boolean, strict_ns_set_path?: boolean, secure_protocols?): Promise<IDefaultCookiePolicy>
		function DefaultCookiePolicy$({ blocked_domains, allowed_domains, netscape, rfc2965, rfc2109_as_netscape, hide_cookie2, strict_domain, strict_rfc2965_unverifiable, strict_ns_unverifiable, strict_ns_domain, strict_ns_set_initial_dollar, strict_ns_set_path, secure_protocols }: { blocked_domains?, allowed_domains?, netscape?, rfc2965?, rfc2109_as_netscape?, hide_cookie2?, strict_domain?, strict_rfc2965_unverifiable?, strict_ns_unverifiable?, strict_ns_domain?, strict_ns_set_initial_dollar?, strict_ns_set_path?, secure_protocols?}): Promise<IDefaultCookiePolicy>
		interface IDefaultCookiePolicy extends ICookiePolicy {

			/**
			 * Return the sequence of blocked domains (as a tuple).
			 */
			blocked_domains(): Promise<any>
			blocked_domains$($: {}): Promise<any>

			/**
			 * Set the sequence of blocked domains.
			 */
			set_blocked_domains(blocked_domains): Promise<any>
			set_blocked_domains$({ blocked_domains }): Promise<any>
			is_blocked(domain): Promise<any>
			is_blocked$({ domain }): Promise<any>

			/**
			 * Return None, or the sequence of allowed domains (as a tuple).
			 */
			allowed_domains(): Promise<any>
			allowed_domains$($: {}): Promise<any>

			/**
			 * Set the sequence of allowed domains, or None.
			 */
			set_allowed_domains(allowed_domains): Promise<any>
			set_allowed_domains$({ allowed_domains }): Promise<any>
			is_not_allowed(domain): Promise<any>
			is_not_allowed$({ domain }): Promise<any>

			/**
			 * 
			 *         If you override .set_ok(), be sure to call this method.  If it returns
			 *         false, so should your subclass (assuming your subclass wants to be more
			 *         strict about which cookies to accept).
			 * 
			 *         
			 */
			set_ok(cookie, request): Promise<any>
			set_ok$({ cookie, request }): Promise<any>
			set_ok_version(cookie, request): Promise<any>
			set_ok_version$({ cookie, request }): Promise<any>
			set_ok_verifiability(cookie, request): Promise<any>
			set_ok_verifiability$({ cookie, request }): Promise<any>
			set_ok_name(cookie, request): Promise<any>
			set_ok_name$({ cookie, request }): Promise<any>
			set_ok_path(cookie, request): Promise<any>
			set_ok_path$({ cookie, request }): Promise<any>
			set_ok_domain(cookie, request): Promise<any>
			set_ok_domain$({ cookie, request }): Promise<any>
			set_ok_port(cookie, request): Promise<any>
			set_ok_port$({ cookie, request }): Promise<any>

			/**
			 * 
			 *         If you override .return_ok(), be sure to call this method.  If it
			 *         returns false, so should your subclass (assuming your subclass wants to
			 *         be more strict about which cookies to return).
			 * 
			 *         
			 */
			return_ok(cookie, request): Promise<any>
			return_ok$({ cookie, request }): Promise<any>
			return_ok_version(cookie, request): Promise<any>
			return_ok_version$({ cookie, request }): Promise<any>
			return_ok_verifiability(cookie, request): Promise<any>
			return_ok_verifiability$({ cookie, request }): Promise<any>
			return_ok_secure(cookie, request): Promise<any>
			return_ok_secure$({ cookie, request }): Promise<any>
			return_ok_expires(cookie, request): Promise<any>
			return_ok_expires$({ cookie, request }): Promise<any>
			return_ok_port(cookie, request): Promise<any>
			return_ok_port$({ cookie, request }): Promise<any>
			return_ok_domain(cookie, request): Promise<any>
			return_ok_domain$({ cookie, request }): Promise<any>
			domain_return_ok(domain, request): Promise<any>
			domain_return_ok$({ domain, request }): Promise<any>
			path_return_ok(path, request): Promise<any>
			path_return_ok$({ path, request }): Promise<any>
			DomainStrictNoDots
			DomainStrictNonDomain
			DomainRFC2965Match
			DomainLiberal
			DomainStrict
		}
		interface IAbsent {
		}

		/**
		 * Collection of HTTP cookies.
		 * 
		 *     You may not need to know about this class: try
		 *     urllib.request.build_opener(HTTPCookieProcessor).open(url).
		 *     
		 */
		function CookieJar(policy?): Promise<ICookieJar>
		function CookieJar$({ policy }: { policy?}): Promise<ICookieJar>
		interface ICookieJar {
			set_policy(policy): Promise<any>
			set_policy$({ policy }): Promise<any>

			/**
			 * Add correct Cookie: header to request (urllib.request.Request object).
			 * 
			 *         The Cookie2 header is also added unless policy.hide_cookie2 is true.
			 * 
			 *         
			 */
			add_cookie_header(request): Promise<any>
			add_cookie_header$({ request }): Promise<any>

			/**
			 * Return sequence of Cookie objects extracted from response object.
			 */
			make_cookies(response, request): Promise<any>
			make_cookies$({ response, request }): Promise<any>

			/**
			 * Set a cookie if policy says it's OK to do so.
			 */
			set_cookie_if_ok(cookie, request): Promise<any>
			set_cookie_if_ok$({ cookie, request }): Promise<any>

			/**
			 * Set a cookie, without checking whether or not it should be set.
			 */
			set_cookie(cookie): Promise<any>
			set_cookie$({ cookie }): Promise<any>

			/**
			 * Extract cookies from response, where allowable given the request.
			 */
			extract_cookies(response, request): Promise<any>
			extract_cookies$({ response, request }): Promise<any>

			/**
			 * Clear some cookies.
			 * 
			 *         Invoking this method without arguments will clear all cookies.  If
			 *         given a single argument, only cookies belonging to that domain will be
			 *         removed.  If given two arguments, cookies belonging to the specified
			 *         path within that domain are removed.  If given three arguments, then
			 *         the cookie with the specified name, path and domain is removed.
			 * 
			 *         Raises KeyError if no matching cookie exists.
			 * 
			 *         
			 */
			clear(domain?, path?, name?): Promise<any>
			clear$({ domain, path, name }: { domain?, path?, name?}): Promise<any>

			/**
			 * Discard all session cookies.
			 * 
			 *         Note that the .save() method won't save session cookies anyway, unless
			 *         you ask otherwise by passing a true ignore_discard argument.
			 * 
			 *         
			 */
			clear_session_cookies(): Promise<any>
			clear_session_cookies$($: {}): Promise<any>

			/**
			 * Discard all expired cookies.
			 * 
			 *         You probably don't need to call this method: expired cookies are never
			 *         sent back to the server (provided you're using DefaultCookiePolicy),
			 *         this method is called by CookieJar itself every so often, and the
			 *         .save() method won't save expired cookies anyway (unless you ask
			 *         otherwise by passing a true ignore_expires argument).
			 * 
			 *         
			 */
			clear_expired_cookies(): Promise<any>
			clear_expired_cookies$($: {}): Promise<any>
			non_word_re
			quote_re
			strict_domain_re
			domain_re
			dots_re
			magic_re
		}
		interface ILoadError {
		}

		/**
		 * CookieJar that can be loaded from and saved to a file.
		 */

		/**
		 * 
		 *         Cookies are NOT loaded from the named file until either the .load() or
		 *         .revert() method is called.
		 * 
		 *         
		 */
		function FileCookieJar(filename?, delayload?: boolean, policy?): Promise<IFileCookieJar>
		function FileCookieJar$({ filename, delayload, policy }: { filename?, delayload?, policy?}): Promise<IFileCookieJar>
		interface IFileCookieJar extends ICookieJar {

			/**
			 * Save cookies to a file.
			 */
			save(filename?, ignore_discard?: boolean, ignore_expires?: boolean): Promise<any>
			save$({ filename, ignore_discard, ignore_expires }: { filename?, ignore_discard?, ignore_expires?}): Promise<any>

			/**
			 * Load cookies from a file.
			 */
			load(filename?, ignore_discard?: boolean, ignore_expires?: boolean): Promise<any>
			load$({ filename, ignore_discard, ignore_expires }: { filename?, ignore_discard?, ignore_expires?}): Promise<any>

			/**
			 * Clear all cookies and reload cookies from a saved file.
			 * 
			 *         Raises LoadError (or OSError) if reversion is not successful; the
			 *         object's state will not be altered if this happens.
			 * 
			 *         
			 */
			revert(filename?, ignore_discard?: boolean, ignore_expires?: boolean): Promise<any>
			revert$({ filename, ignore_discard, ignore_expires }: { filename?, ignore_discard?, ignore_expires?}): Promise<any>
		}

		/**
		 * 
		 *     The LWPCookieJar saves a sequence of "Set-Cookie3" lines.
		 *     "Set-Cookie3" is the format used by the libwww-perl library, not known
		 *     to be compatible with any browser, but which is easy to read and
		 *     doesn't lose information about RFC 2965 cookies.
		 * 
		 *     Additional methods
		 * 
		 *     as_lwp_str(ignore_discard=True, ignore_expired=True)
		 * 
		 *     
		 */
		interface ILWPCookieJar extends IFileCookieJar {

			/**
			 * Return cookies as a string of "\n"-separated "Set-Cookie3" headers.
			 * 
			 *         ignore_discard and ignore_expires: see docstring for FileCookieJar.save
			 * 
			 *         
			 */
			as_lwp_str(ignore_discard?: boolean, ignore_expires?: boolean): Promise<any>
			as_lwp_str$({ ignore_discard, ignore_expires }: { ignore_discard?, ignore_expires?}): Promise<any>
			save(filename?, ignore_discard?: boolean, ignore_expires?: boolean): Promise<any>
			save$({ filename, ignore_discard, ignore_expires }: { filename?, ignore_discard?, ignore_expires?}): Promise<any>
		}

		/**
		 * 
		 * 
		 *     WARNING: you may want to backup your browser's cookies file if you use
		 *     this class to save cookies.  I *think* it works, but there have been
		 *     bugs in the past!
		 * 
		 *     This class differs from CookieJar only in the format it uses to save and
		 *     load cookies to and from a file.  This class uses the Mozilla/Netscape
		 *     `cookies.txt' format.  lynx uses this file format, too.
		 * 
		 *     Don't expect cookies saved while the browser is running to be noticed by
		 *     the browser (in fact, Mozilla on unix will overwrite your saved cookies if
		 *     you change them on disk while it's running; on Windows, you probably can't
		 *     save at all while the browser is running).
		 * 
		 *     Note that the Mozilla/Netscape format will downgrade RFC2965 cookies to
		 *     Netscape cookies on saving.
		 * 
		 *     In particular, the cookie version and port number information is lost,
		 *     together with information about whether or not Path, Port and Discard were
		 *     specified by the Set-Cookie2 (or Set-Cookie) header, and whether or not the
		 *     domain as set in the HTTP header started with a dot (yes, I'm aware some
		 *     domains in Netscape files start with a dot and some don't -- trust me, you
		 *     really don't want to know any more about this).
		 * 
		 *     Note that though Mozilla and Netscape use the same format, they use
		 *     slightly different headers.  The class saves cookies using the Netscape
		 *     header by default (Mozilla can cope with that).
		 * 
		 *     
		 */
		interface IMozillaCookieJar extends IFileCookieJar {
			save(filename?, ignore_discard?: boolean, ignore_expires?: boolean): Promise<any>
			save$({ filename, ignore_discard, ignore_expires }: { filename?, ignore_discard?, ignore_expires?}): Promise<any>
		}
		let debug: Promise<any>
		let logger: Promise<any>
		let HTTPONLY_ATTR: Promise<any>
		let HTTPONLY_PREFIX: Promise<any>
		let DEFAULT_HTTP_PORT: Promise<any>
		let NETSCAPE_MAGIC_RGX: Promise<any>
		let MISSING_FILENAME_TEXT: Promise<any>
		let NETSCAPE_HEADER_TEXT: Promise<any>
		let EPOCH_YEAR: Promise<any>
		let DAYS: Promise<any>
		let MONTHS: Promise<any>
		let MONTHS_LOWER: Promise<any>
		let UTC_ZONES: Promise<any>
		let TIMEZONE_RE: Promise<any>
		let STRICT_DATE_RE: Promise<any>
		let WEEKDAY_RE: Promise<any>
		let LOOSE_HTTP_DATE_RE: Promise<any>
		let ISO_DATE_RE: Promise<any>
		let HEADER_TOKEN_RE: Promise<any>
		let HEADER_QUOTED_VALUE_RE: Promise<any>
		let HEADER_VALUE_RE: Promise<any>
		let HEADER_ESCAPE_RE: Promise<any>
		let HEADER_JOIN_ESCAPE_RE: Promise<any>
		let IPV4_RE: Promise<any>
		let cut_port_re: Promise<any>
		let HTTP_PATH_SAFE: Promise<any>
		let ESCAPED_CHAR_RE: Promise<any>
	}
	module cookies {
		var _
		interface ICookieError {
		}

		/**
		 * A class to hold ONE (key, value) pair.
		 * 
		 *     In a cookie, each such pair may have several attributes, so this class is
		 *     used to keep the attributes associated with the appropriate key,value pair.
		 *     This class also includes a coded_value attribute, which is used to hold
		 *     the network representation of the value.
		 *     
		 */
		function Morsel(): Promise<IMorsel>
		function Morsel$({ }): Promise<IMorsel>
		interface IMorsel {
			key(): Promise<any>
			key$($: {}): Promise<any>
			value(): Promise<any>
			value$($: {}): Promise<any>
			coded_value(): Promise<any>
			coded_value$($: {}): Promise<any>
			setdefault(key, val?): Promise<any>
			setdefault$({ key, val }: { key, val?}): Promise<any>
			copy(): Promise<any>
			copy$($: {}): Promise<any>
			update(values): Promise<any>
			update$({ values }): Promise<any>
			isReservedKey(K): Promise<any>
			isReservedKey$({ K }): Promise<any>
			set(key, val, coded_val): Promise<any>
			set$({ key, val, coded_val }): Promise<any>
			output(attrs?, header?): Promise<any>
			output$({ attrs, header }: { attrs?, header?}): Promise<any>
			js_output(attrs?): Promise<any>
			js_output$({ attrs }: { attrs?}): Promise<any>
			OutputString(attrs?): Promise<any>
			OutputString$({ attrs }: { attrs?}): Promise<any>
		}

		/**
		 * A container class for a set of Morsels.
		 */
		function BaseCookie(input?): Promise<IBaseCookie>
		function BaseCookie$({ input }: { input?}): Promise<IBaseCookie>
		interface IBaseCookie {

			/**
			 * real_value, coded_value = value_decode(STRING)
			 *         Called prior to setting a cookie's value from the network
			 *         representation.  The VALUE is the value read from HTTP
			 *         header.
			 *         Override this function to modify the behavior of cookies.
			 *         
			 */
			value_decode(val): Promise<any>
			value_decode$({ val }): Promise<any>

			/**
			 * real_value, coded_value = value_encode(VALUE)
			 *         Called prior to setting a cookie's value from the dictionary
			 *         representation.  The VALUE is the value being assigned.
			 *         Override this function to modify the behavior of cookies.
			 *         
			 */
			value_encode(val): Promise<any>
			value_encode$({ val }): Promise<any>

			/**
			 * Return a string suitable for HTTP.
			 */
			output(attrs?, header?, sep?): Promise<any>
			output$({ attrs, header, sep }: { attrs?, header?, sep?}): Promise<any>

			/**
			 * Return a string suitable for JavaScript.
			 */
			js_output(attrs?): Promise<any>
			js_output$({ attrs }: { attrs?}): Promise<any>

			/**
			 * Load cookies from a string (presumably HTTP_COOKIE) or
			 *         from a dictionary.  Loading cookies from a dictionary 'd'
			 *         is equivalent to calling:
			 *             map(Cookie.__setitem__, d.keys(), d.values())
			 *         
			 */
			load(rawdata): Promise<any>
			load$({ rawdata }): Promise<any>
		}

		/**
		 * 
		 *     SimpleCookie supports strings as cookie values.  When setting
		 *     the value using the dictionary assignment notation, SimpleCookie
		 *     calls the builtin str() to convert the value to a string.  Values
		 *     received from HTTP are kept as strings.
		 *     
		 */
		interface ISimpleCookie extends IBaseCookie {
			value_decode(val): Promise<any>
			value_decode$({ val }): Promise<any>
			value_encode(val): Promise<any>
			value_encode$({ val }): Promise<any>
		}
	}
	module server {
		var _

		/**
		 * Internal routine to get nobody's uid
		 */
		function nobody_uid(): Promise<any>
		function nobody_uid$($: {}): Promise<any>

		/**
		 * Test for executable file.
		 */
		function executable(path): Promise<any>
		function executable$({ path }): Promise<any>

		/**
		 * Test the HTTP request handler class.
		 * 
		 *     This runs an HTTP server on port 8000 (or the port argument).
		 * 
		 *     
		 */
		function test(HandlerClass?, ServerClass?, protocol?, port?, bind?): Promise<any>
		function test$({ HandlerClass, ServerClass, protocol, port, bind }: { HandlerClass?, ServerClass?, protocol?, port?, bind?}): Promise<any>
		interface IHTTPServer {

			/**
			 * Override server_bind to store the server name.
			 */
			server_bind(): Promise<any>
			server_bind$($: {}): Promise<any>
			allow_reuse_address
		}
		interface IThreadingHTTPServer extends IHTTPServer {
			daemon_threads
		}

		/**
		 * HTTP request handler base class.
		 * 
		 *     The following explanation of HTTP serves to guide you through the
		 *     code as well as to expose any misunderstandings I may have about
		 *     HTTP (so you don't need to read the code to figure out I'm wrong
		 *     :-).
		 * 
		 *     HTTP (HyperText Transfer Protocol) is an extensible protocol on
		 *     top of a reliable stream transport (e.g. TCP/IP).  The protocol
		 *     recognizes three parts to a request:
		 * 
		 *     1. One line identifying the request type and path
		 *     2. An optional set of RFC-822-style headers
		 *     3. An optional data part
		 * 
		 *     The headers and data are separated by a blank line.
		 * 
		 *     The first line of the request has the form
		 * 
		 *     <command> <path> <version>
		 * 
		 *     where <command> is a (case-sensitive) keyword such as GET or POST,
		 *     <path> is a string containing path information for the request,
		 *     and <version> should be the string "HTTP/1.0" or "HTTP/1.1".
		 *     <path> is encoded using the URL encoding scheme (using %xx to signify
		 *     the ASCII character with hex code xx).
		 * 
		 *     The specification specifies that lines are separated by CRLF but
		 *     for compatibility with the widest range of clients recommends
		 *     servers also handle LF.  Similarly, whitespace in the request line
		 *     is treated sensibly (allowing multiple spaces between components
		 *     and allowing trailing whitespace).
		 * 
		 *     Similarly, for output, lines ought to be separated by CRLF pairs
		 *     but most clients grok LF characters just fine.
		 * 
		 *     If the first line of the request has the form
		 * 
		 *     <command> <path>
		 * 
		 *     (i.e. <version> is left out) then this is assumed to be an HTTP
		 *     0.9 request; this form has no optional headers and data part and
		 *     the reply consists of just the data.
		 * 
		 *     The reply form of the HTTP 1.x protocol again has three parts:
		 * 
		 *     1. One line giving the response code
		 *     2. An optional set of RFC-822-style headers
		 *     3. The data
		 * 
		 *     Again, the headers and data are separated by a blank line.
		 * 
		 *     The response code line has the form
		 * 
		 *     <version> <responsecode> <responsestring>
		 * 
		 *     where <version> is the protocol version ("HTTP/1.0" or "HTTP/1.1"),
		 *     <responsecode> is a 3-digit response code indicating success or
		 *     failure of the request, and <responsestring> is an optional
		 *     human-readable string explaining what the response code means.
		 * 
		 *     This server parses the request and the headers, and then calls a
		 *     function specific to the request type (<command>).  Specifically,
		 *     a request SPAM will be handled by a method do_SPAM().  If no
		 *     such method exists the server sends an error response to the
		 *     client.  If it exists, it is called with no arguments:
		 * 
		 *     do_SPAM()
		 * 
		 *     Note that the request name is case sensitive (i.e. SPAM and spam
		 *     are different requests).
		 * 
		 *     The various request details are stored in instance variables:
		 * 
		 *     - client_address is the client IP address in the form (host,
		 *     port);
		 * 
		 *     - command, path and version are the broken-down request line;
		 * 
		 *     - headers is an instance of email.message.Message (or a derived
		 *     class) containing the header information;
		 * 
		 *     - rfile is a file object open for reading positioned at the
		 *     start of the optional input data part;
		 * 
		 *     - wfile is a file object open for writing.
		 * 
		 *     IT IS IMPORTANT TO ADHERE TO THE PROTOCOL FOR WRITING!
		 * 
		 *     The first thing to be written must be the response line.  Then
		 *     follow 0 or more header lines, then a blank line, and then the
		 *     actual data (if any).  The meaning of the header lines depends on
		 *     the command executed by the server; in most cases, when data is
		 *     returned, there should be at least one header line of the form
		 * 
		 *     Content-type: <type>/<subtype>
		 * 
		 *     where <type> and <subtype> should be registered MIME types,
		 *     e.g. "text/html" or "text/plain".
		 * 
		 *     
		 */
		interface IBaseHTTPRequestHandler {

			/**
			 * Parse a request (internal).
			 * 
			 *         The request should be stored in self.raw_requestline; the results
			 *         are in self.command, self.path, self.request_version and
			 *         self.headers.
			 * 
			 *         Return True for success, False for failure; on failure, any relevant
			 *         error response has already been sent back.
			 * 
			 *         
			 */
			parse_request(): Promise<any>
			parse_request$($: {}): Promise<any>

			/**
			 * Decide what to do with an "Expect: 100-continue" header.
			 * 
			 *         If the client is expecting a 100 Continue response, we must
			 *         respond with either a 100 Continue or a final response before
			 *         waiting for the request body. The default is to always respond
			 *         with a 100 Continue. You can behave differently (for example,
			 *         reject unauthorized requests) by overriding this method.
			 * 
			 *         This method should either return True (possibly after sending
			 *         a 100 Continue response) or send an error response and return
			 *         False.
			 * 
			 *         
			 */
			handle_expect_100(): Promise<any>
			handle_expect_100$($: {}): Promise<any>

			/**
			 * Handle a single HTTP request.
			 * 
			 *         You normally don't need to override this method; see the class
			 *         __doc__ string for information on how to handle specific HTTP
			 *         commands such as GET and POST.
			 * 
			 *         
			 */
			handle_one_request(): Promise<any>
			handle_one_request$($: {}): Promise<any>

			/**
			 * Handle multiple requests if necessary.
			 */
			handle(): Promise<any>
			handle$($: {}): Promise<any>

			/**
			 * Send and log an error reply.
			 * 
			 *         Arguments are
			 *         * code:    an HTTP error code
			 *                    3 digits
			 *         * message: a simple optional 1 line reason phrase.
			 *                    *( HTAB / SP / VCHAR / %x80-FF )
			 *                    defaults to short entry matching the response code
			 *         * explain: a detailed message defaults to the long entry
			 *                    matching the response code.
			 * 
			 *         This sends an error response (so it must be called before any
			 *         output has been generated), logs the error, and finally sends
			 *         a piece of HTML explaining the error to the user.
			 * 
			 *         
			 */
			send_error(code, message?, explain?): Promise<any>
			send_error$({ code, message, explain }: { code, message?, explain?}): Promise<any>

			/**
			 * Add the response header to the headers buffer and log the
			 *         response code.
			 * 
			 *         Also send two standard headers with the server software
			 *         version and the current date.
			 * 
			 *         
			 */
			send_response(code, message?): Promise<any>
			send_response$({ code, message }: { code, message?}): Promise<any>

			/**
			 * Send the response header only.
			 */
			send_response_only(code, message?): Promise<any>
			send_response_only$({ code, message }: { code, message?}): Promise<any>

			/**
			 * Send a MIME header to the headers buffer.
			 */
			send_header(keyword, value): Promise<any>
			send_header$({ keyword, value }): Promise<any>

			/**
			 * Send the blank line ending the MIME headers.
			 */
			end_headers(): Promise<any>
			end_headers$($: {}): Promise<any>
			flush_headers(): Promise<any>
			flush_headers$($: {}): Promise<any>

			/**
			 * Log an accepted request.
			 * 
			 *         This is called by send_response().
			 * 
			 *         
			 */
			log_request(code?, size?): Promise<any>
			log_request$({ code, size }: { code?, size?}): Promise<any>

			/**
			 * Log an error.
			 * 
			 *         This is called when a request cannot be fulfilled.  By
			 *         default it passes the message on to log_message().
			 * 
			 *         Arguments are the same as for log_message().
			 * 
			 *         XXX This should go to the separate error log.
			 * 
			 *         
			 */
			log_error(format): Promise<any>
			log_error$({ format }): Promise<any>

			/**
			 * Log an arbitrary message.
			 * 
			 *         This is used by all other logging functions.  Override
			 *         it if you have specific logging wishes.
			 * 
			 *         The first argument, FORMAT, is a format string for the
			 *         message to be logged.  If the format string contains
			 *         any % escapes requiring parameters, they should be
			 *         specified as subsequent arguments (it's just like
			 *         printf!).
			 * 
			 *         The client ip and current date/time are prefixed to
			 *         every message.
			 * 
			 *         
			 */
			log_message(format): Promise<any>
			log_message$({ format }): Promise<any>

			/**
			 * Return the server software version string.
			 */
			version_string(): Promise<any>
			version_string$($: {}): Promise<any>

			/**
			 * Return the current date and time formatted for a message header.
			 */
			date_time_string(timestamp?): Promise<any>
			date_time_string$({ timestamp }: { timestamp?}): Promise<any>

			/**
			 * Return the current time formatted for logging.
			 */
			log_date_time_string(): Promise<any>
			log_date_time_string$($: {}): Promise<any>

			/**
			 * Return the client address.
			 */
			address_string(): Promise<any>
			address_string$($: {}): Promise<any>
			sys_version
			server_version
			error_message_format
			error_content_type
			default_request_version
			weekdayname
			monthname
			protocol_version
			MessageClass
			responses
		}

		/**
		 * Simple HTTP request handler with GET and HEAD commands.
		 * 
		 *     This serves files from the current directory and any of its
		 *     subdirectories.  The MIME type for files is determined by
		 *     calling the .guess_type() method.
		 * 
		 *     The GET and HEAD requests are identical except that the HEAD
		 *     request omits the actual contents of the file.
		 * 
		 *     
		 */
		function SimpleHTTPRequestHandler(): Promise<ISimpleHTTPRequestHandler>
		function SimpleHTTPRequestHandler$({ }): Promise<ISimpleHTTPRequestHandler>
		interface ISimpleHTTPRequestHandler extends IBaseHTTPRequestHandler {

			/**
			 * Serve a GET request.
			 */
			do_GET(): Promise<any>
			do_GET$($: {}): Promise<any>

			/**
			 * Serve a HEAD request.
			 */
			do_HEAD(): Promise<any>
			do_HEAD$($: {}): Promise<any>

			/**
			 * Common code for GET and HEAD commands.
			 * 
			 *         This sends the response code and MIME headers.
			 * 
			 *         Return value is either a file object (which has to be copied
			 *         to the outputfile by the caller unless the command was HEAD,
			 *         and must be closed by the caller under all circumstances), or
			 *         None, in which case the caller has nothing further to do.
			 * 
			 *         
			 */
			send_head(): Promise<any>
			send_head$($: {}): Promise<any>

			/**
			 * Helper to produce a directory listing (absent index.html).
			 * 
			 *         Return value is either a file object, or None (indicating an
			 *         error).  In either case, the headers are sent, making the
			 *         interface the same as for send_head().
			 * 
			 *         
			 */
			list_directory(path): Promise<any>
			list_directory$({ path }): Promise<any>

			/**
			 * Translate a /-separated PATH to the local filename syntax.
			 * 
			 *         Components that mean special things to the local file system
			 *         (e.g. drive or directory names) are ignored.  (XXX They should
			 *         probably be diagnosed.)
			 * 
			 *         
			 */
			translate_path(path): Promise<any>
			translate_path$({ path }): Promise<any>

			/**
			 * Copy all data between two file objects.
			 * 
			 *         The SOURCE argument is a file object open for reading
			 *         (or anything with a read() method) and the DESTINATION
			 *         argument is a file object open for writing (or
			 *         anything with a write() method).
			 * 
			 *         The only reason for overriding this would be to change
			 *         the block size or perhaps to replace newlines by CRLF
			 *         -- note however that this the default server uses this
			 *         to copy binary data as well.
			 * 
			 *         
			 */
			copyfile(source, outputfile): Promise<any>
			copyfile$({ source, outputfile }): Promise<any>

			/**
			 * Guess the type of a file.
			 * 
			 *         Argument is a PATH (a filename).
			 * 
			 *         Return value is a string of the form type/subtype,
			 *         usable for a MIME Content-type header.
			 * 
			 *         The default implementation looks the file's extension
			 *         up in the table self.extensions_map, using application/octet-stream
			 *         as a default; however it would be permissible (if
			 *         slow) to look inside the data to make a better guess.
			 * 
			 *         
			 */
			guess_type(path): Promise<any>
			guess_type$({ path }): Promise<any>
			extensions_map
		}

		/**
		 * Complete HTTP server with GET, HEAD and POST commands.
		 * 
		 *     GET and HEAD also support running CGI scripts.
		 * 
		 *     The POST command is *only* implemented for CGI scripts.
		 * 
		 *     
		 */
		interface ICGIHTTPRequestHandler extends ISimpleHTTPRequestHandler {

			/**
			 * Serve a POST request.
			 * 
			 *         This is only implemented for CGI scripts.
			 * 
			 *         
			 */
			do_POST(): Promise<any>
			do_POST$($: {}): Promise<any>

			/**
			 * Version of send_head that support CGI scripts
			 */
			send_head(): Promise<any>
			send_head$($: {}): Promise<any>

			/**
			 * Test whether self.path corresponds to a CGI script.
			 * 
			 *         Returns True and updates the cgi_info attribute to the tuple
			 *         (dir, rest) if self.path requires running a CGI script.
			 *         Returns False otherwise.
			 * 
			 *         If any exception is raised, the caller should assume that
			 *         self.path was rejected as invalid and act accordingly.
			 * 
			 *         The default implementation tests whether the normalized url
			 *         path begins with one of the strings in self.cgi_directories
			 *         (and the next character is a '/' or the end of the string).
			 * 
			 *         
			 */
			is_cgi(): Promise<any>
			is_cgi$($: {}): Promise<any>

			/**
			 * Test whether argument path is an executable file.
			 */
			is_executable(path): Promise<any>
			is_executable$({ path }): Promise<any>

			/**
			 * Test whether argument path is a Python script.
			 */
			is_python(path): Promise<any>
			is_python$({ path }): Promise<any>

			/**
			 * Execute a CGI script.
			 */
			run_cgi(): Promise<any>
			run_cgi$($: {}): Promise<any>
			have_fork
			rbufsize
			cgi_directories
		}
		interface IDualStackServer extends IThreadingHTTPServer {
			server_bind(): Promise<any>
			server_bind$($: {}): Promise<any>
		}
		let DEFAULT_ERROR_MESSAGE: Promise<any>
		let DEFAULT_ERROR_CONTENT_TYPE: Promise<any>
		let nobody: Promise<any>
		let parser: Promise<any>
		let args: Promise<any>
		let handler_class: Promise<any>
	}
}
declare module idlelib {
	var _
	let testing: Promise<any>
	module __main__ {
		var _
	}
	module autocomplete {
		var _
		function AutoComplete(editwin?, tags?): Promise<IAutoComplete>
		function AutoComplete$({ editwin, tags }: { editwin?, tags?}): Promise<IAutoComplete>
		interface IAutoComplete {
			reload(): Promise<any>
			reload$($: {}): Promise<any>

			/**
			 * (^space) Open completion list, even if a function call is needed.
			 */
			force_open_completions_event(event): Promise<any>
			force_open_completions_event$({ event }): Promise<any>

			/**
			 * (tab) Complete word or open list if multiple options.
			 */
			autocomplete_event(event): Promise<any>
			autocomplete_event$({ event }): Promise<any>

			/**
			 * (./) Open completion list after pause with no movement.
			 */
			try_open_completions_event(event?): Promise<any>
			try_open_completions_event$({ event }: { event?}): Promise<any>

			/**
			 * Find the completions and create the AutoCompleteWindow.
			 *         Return True if successful (no syntax error or so found).
			 *         If complete is True, then if there's nothing to complete and no
			 *         start of completion, won't open completions and return False.
			 *         If mode is given, will open a completion list only in this mode.
			 *         
			 */
			open_completions(args): Promise<any>
			open_completions$({ args }): Promise<any>

			/**
			 * Return a pair of lists of completions for something. The first list
			 *         is a sublist of the second. Both are sorted.
			 * 
			 *         If there is a Python subprocess, get the comp. list there.  Otherwise,
			 *         either fetch_completions() is running in the subprocess itself or it
			 *         was called in an IDLE EditorWindow before any script had been run.
			 * 
			 *         The subprocess environment is that of the most recently run script.  If
			 *         two unrelated modules are being edited some calltips in the current
			 *         module may be inoperative if the module was not the last to run.
			 *         
			 */
			fetch_completions(what, mode): Promise<any>
			fetch_completions$({ what, mode }): Promise<any>

			/**
			 * Lookup name in a namespace spanning sys.modules and __main.dict__.
			 */
			get_entity(name): Promise<any>
			get_entity$({ name }): Promise<any>
		}
		let FORCE: Promise<any>
		let TAB: Promise<any>
		let TRY_A: Promise<any>
		let TRY_F: Promise<any>
		let ID_CHARS: Promise<any>
		let SEPS: Promise<any>
		let TRIGGERS: Promise<any>
	}
	module autocomplete_w {
		var _
		function AutoCompleteWindow(widget, tags): Promise<IAutoCompleteWindow>
		function AutoCompleteWindow$({ widget, tags }): Promise<IAutoCompleteWindow>
		interface IAutoCompleteWindow {

			/**
			 * Show the autocomplete list, bind events.
			 * 
			 *         If complete is True, complete the text, and if there is exactly
			 *         one matching completion, don't open a list.
			 *         
			 */
			show_window(comp_lists, index, complete, mode, userWantsWin): Promise<any>
			show_window$({ comp_lists, index, complete, mode, userWantsWin }): Promise<any>
			winconfig_event(event): Promise<any>
			winconfig_event$({ event }): Promise<any>
			hide_event(event): Promise<any>
			hide_event$({ event }): Promise<any>
			listselect_event(event): Promise<any>
			listselect_event$({ event }): Promise<any>
			doubleclick_event(event): Promise<any>
			doubleclick_event$({ event }): Promise<any>
			keypress_event(event): Promise<any>
			keypress_event$({ event }): Promise<any>
			keyrelease_event(event): Promise<any>
			keyrelease_event$({ event }): Promise<any>
			is_active(): Promise<any>
			is_active$($: {}): Promise<any>
			complete(): Promise<any>
			complete$($: {}): Promise<any>
			hide_window(): Promise<any>
			hide_window$($: {}): Promise<any>
		}
		let HIDE_VIRTUAL_EVENT_NAME: Promise<any>
		let HIDE_FOCUS_OUT_SEQUENCE: Promise<any>
		let HIDE_SEQUENCES: Promise<any>
		let KEYPRESS_VIRTUAL_EVENT_NAME: Promise<any>
		let KEYPRESS_SEQUENCES: Promise<any>
		let KEYRELEASE_VIRTUAL_EVENT_NAME: Promise<any>
		let KEYRELEASE_SEQUENCE: Promise<any>
		let LISTUPDATE_SEQUENCE: Promise<any>
		let WINCONFIG_SEQUENCE: Promise<any>
		let DOUBLECLICK_SEQUENCE: Promise<any>
	}
	module autoexpand {
		var _
		function AutoExpand(editwin): Promise<IAutoExpand>
		function AutoExpand$({ editwin }): Promise<IAutoExpand>
		interface IAutoExpand {

			/**
			 * Replace the current word with the next expansion.
			 */
			expand_word_event(event): Promise<any>
			expand_word_event$({ event }): Promise<any>

			/**
			 * Return a list of words that match the prefix before the cursor.
			 */
			getwords(): Promise<any>
			getwords$($: {}): Promise<any>

			/**
			 * Return the word prefix before the cursor.
			 */
			getprevword(): Promise<any>
			getprevword$($: {}): Promise<any>
			wordchars
		}
	}
	module browser {
		var _

		/**
		 * Transform a child dictionary to an ordered sequence of objects.
		 * 
		 *     The dictionary maps names to pyclbr information objects.
		 *     Filter out imported objects.
		 *     Augment class names with bases.
		 *     The insertion order of the dictionary is assumed to have been in line
		 *     number order, so sorting is not necessary.
		 * 
		 *     The current tree only calls this once per child_dict as it saves
		 *     TreeItems once created.  A future tree and tests might violate this,
		 *     so a check prevents multiple in-place augmentations.
		 *     
		 */
		function transform_children(child_dict, modname?): Promise<any>
		function transform_children$({ child_dict, modname }: { child_dict, modname?}): Promise<any>

		/**
		 * Browse module classes and functions in IDLE.
		 *     
		 */

		/**
		 * Create a window for browsing a module's structure.
		 * 
		 *         Args:
		 *             master: parent for widgets.
		 *             path: full path of file to browse.
		 *             _htest - bool; change box location when running htest.
		 *             -utest - bool; suppress contents when running unittest.
		 * 
		 *         Global variables:
		 *             file_open: Function used for opening a file.
		 * 
		 *         Instance variables:
		 *             name: Module name.
		 *             file: Full path and module with .py extension.  Used in
		 *                 creating ModuleBrowserTreeItem as the rootnode for
		 *                 the tree and subsequently in the children.
		 *         
		 */
		function ModuleBrowser(master, path): Promise<IModuleBrowser>
		function ModuleBrowser$({ master, path }): Promise<IModuleBrowser>
		interface IModuleBrowser {

			/**
			 * Dismiss the window and the tree nodes.
			 */
			close(event?): Promise<any>
			close$({ event }: { event?}): Promise<any>

			/**
			 * Create browser tkinter widgets, including the tree.
			 */
			init(): Promise<any>
			init$($: {}): Promise<any>

			/**
			 * Set the window title.
			 */
			settitle(): Promise<any>
			settitle$($: {}): Promise<any>

			/**
			 * Return a ModuleBrowserTreeItem as the root of the tree.
			 */
			rootnode(): Promise<any>
			rootnode$($: {}): Promise<any>
		}

		/**
		 * Browser tree for Python module.
		 * 
		 *     Uses TreeItem as the basis for the structure of the tree.
		 *     Used by both browsers.
		 *     
		 */

		/**
		 * Create a TreeItem for the file.
		 * 
		 *         Args:
		 *             file: Full path and module name.
		 *         
		 */
		function ModuleBrowserTreeItem(file): Promise<IModuleBrowserTreeItem>
		function ModuleBrowserTreeItem$({ file }): Promise<IModuleBrowserTreeItem>
		interface IModuleBrowserTreeItem {

			/**
			 * Return the module name as the text string to display.
			 */
			GetText(): Promise<any>
			GetText$($: {}): Promise<any>

			/**
			 * Return the name of the icon to display.
			 */
			GetIconName(): Promise<any>
			GetIconName$($: {}): Promise<any>

			/**
			 * Return ChildBrowserTreeItems for children.
			 */
			GetSubList(): Promise<any>
			GetSubList$($: {}): Promise<any>

			/**
			 * Open a module in an editor window when double clicked.
			 */
			OnDoubleClick(): Promise<any>
			OnDoubleClick$($: {}): Promise<any>

			/**
			 * Return True if Python (.py) file.
			 */
			IsExpandable(): Promise<any>
			IsExpandable$($: {}): Promise<any>

			/**
			 * Return sequenced classes and functions in the module.
			 */
			listchildren(): Promise<any>
			listchildren$($: {}): Promise<any>
		}

		/**
		 * Browser tree for child nodes within the module.
		 * 
		 *     Uses TreeItem as the basis for the structure of the tree.
		 *     
		 */

		/**
		 * Create a TreeItem for a pyclbr class/function object.
		 */
		function ChildBrowserTreeItem(obj): Promise<IChildBrowserTreeItem>
		function ChildBrowserTreeItem$({ obj }): Promise<IChildBrowserTreeItem>
		interface IChildBrowserTreeItem {

			/**
			 * Return the name of the function/class to display.
			 */
			GetText(): Promise<any>
			GetText$($: {}): Promise<any>

			/**
			 * Return the name of the icon to display.
			 */
			GetIconName(): Promise<any>
			GetIconName$($: {}): Promise<any>

			/**
			 * Return True if self.obj has nested objects.
			 */
			IsExpandable(): Promise<any>
			IsExpandable$($: {}): Promise<any>

			/**
			 * Return ChildBrowserTreeItems for children.
			 */
			GetSubList(): Promise<any>
			GetSubList$($: {}): Promise<any>

			/**
			 * Open module with file_open and position to lineno.
			 */
			OnDoubleClick(): Promise<any>
			OnDoubleClick$($: {}): Promise<any>
		}
		let file_open: Promise<any>
	}
	module calltip {
		var _

		/**
		 * Return the object corresponding to expression evaluated
		 *     in a namespace spanning sys.modules and __main.dict__.
		 *     
		 */
		function get_entity(expression): Promise<any>
		function get_entity$({ expression }): Promise<any>

		/**
		 * Return a string describing the signature of a callable object, or ''.
		 * 
		 *     For Python-coded functions and methods, the first line is introspected.
		 *     Delete 'self' parameter for classes (.__init__) and bound methods.
		 *     The next lines are the first lines of the doc string up to the first
		 *     empty line or _MAX_LINES.    For builtins, this typically includes
		 *     the arguments in addition to the return value.
		 *     
		 */
		function get_argspec(ob): Promise<any>
		function get_argspec$({ ob }): Promise<any>
		function Calltip(editwin?): Promise<ICalltip>
		function Calltip$({ editwin }: { editwin?}): Promise<ICalltip>
		interface ICalltip {
			close(): Promise<any>
			close$($: {}): Promise<any>
			remove_calltip_window(event?): Promise<any>
			remove_calltip_window$({ event }: { event?}): Promise<any>

			/**
			 * The user selected the menu entry or hotkey, open the tip.
			 */
			force_open_calltip_event(event): Promise<any>
			force_open_calltip_event$({ event }): Promise<any>

			/**
			 * Happens when it would be nice to open a calltip, but not really
			 *         necessary, for example after an opening bracket, so function calls
			 *         won't be made.
			 *         
			 */
			try_open_calltip_event(event): Promise<any>
			try_open_calltip_event$({ event }): Promise<any>
			refresh_calltip_event(event): Promise<any>
			refresh_calltip_event$({ event }): Promise<any>

			/**
			 * Maybe close an existing calltip and maybe open a new calltip.
			 * 
			 *         Called from (force_open|try_open|refresh)_calltip_event functions.
			 *         
			 */
			open_calltip(evalfuncs): Promise<any>
			open_calltip$({ evalfuncs }): Promise<any>

			/**
			 * Return the argument list and docstring of a function or class.
			 * 
			 *         If there is a Python subprocess, get the calltip there.  Otherwise,
			 *         either this fetch_tip() is running in the subprocess or it was
			 *         called in an IDLE running without the subprocess.
			 * 
			 *         The subprocess environment is that of the most recently run script.  If
			 *         two unrelated modules are being edited some calltips in the current
			 *         module may be inoperative if the module was not the last to run.
			 * 
			 *         To find methods, fetch_tip must be fed a fully qualified name.
			 * 
			 *         
			 */
			fetch_tip(expression): Promise<any>
			fetch_tip$({ expression }): Promise<any>
		}
	}
	module calltip_w {
		var _

		/**
		 * A call-tip widget for tkinter text widgets.
		 */

		/**
		 * Create a call-tip; shown by showtip().
		 * 
		 *         text_widget: a Text widget with code for which call-tips are desired
		 *         
		 */
		function CalltipWindow(text_widget): Promise<ICalltipWindow>
		function CalltipWindow$({ text_widget }): Promise<ICalltipWindow>
		interface ICalltipWindow {

			/**
			 * Choose the position of the call-tip.
			 */
			get_position(): Promise<any>
			get_position$($: {}): Promise<any>

			/**
			 * Reposition the window if needed.
			 */
			position_window(): Promise<any>
			position_window$($: {}): Promise<any>

			/**
			 * Show the call-tip, bind events which will close it and reposition it.
			 * 
			 *         text: the text to display in the call-tip
			 *         parenleft: index of the opening parenthesis in the text widget
			 *         parenright: index of the closing parenthesis in the text widget,
			 *                     or the end of the line if there is no closing parenthesis
			 *         
			 */
			showtip(text, parenleft, parenright): Promise<any>
			showtip$({ text, parenleft, parenright }): Promise<any>

			/**
			 * Create the call-tip widget.
			 */
			showcontents(): Promise<any>
			showcontents$($: {}): Promise<any>

			/**
			 * Handle CHECK_HIDE_EVENT: call hidetip or reschedule.
			 */
			checkhide_event(event?): Promise<any>
			checkhide_event$({ event }: { event?}): Promise<any>

			/**
			 * Handle HIDE_EVENT by calling hidetip.
			 */
			hide_event(event): Promise<any>
			hide_event$({ event }): Promise<any>

			/**
			 * Hide the call-tip.
			 */
			hidetip(): Promise<any>
			hidetip$($: {}): Promise<any>
		}
		let HIDE_EVENT: Promise<any>
		let HIDE_SEQUENCES: Promise<any>
		let CHECKHIDE_EVENT: Promise<any>
		let CHECKHIDE_SEQUENCES: Promise<any>
		let CHECKHIDE_TIME: Promise<any>
		let MARK_RIGHT: Promise<any>
	}
	module codecontext {
		var _

		/**
		 * Extract the beginning whitespace and first word from codeline.
		 */
		function get_spaces_firstword(codeline, c?): Promise<any>
		function get_spaces_firstword$({ codeline, c }: { codeline, c?}): Promise<any>

		/**
		 * Return tuple of (line indent value, codeline, block start keyword).
		 * 
		 *     The indentation of empty lines (or comment lines) is INFINITY.
		 *     If the line does not start a block, the keyword value is False.
		 *     
		 */
		function get_line_info(codeline): Promise<any>
		function get_line_info$({ codeline }): Promise<any>

		/**
		 * Display block context above the edit window.
		 */

		/**
		 * Initialize settings for context block.
		 * 
		 *         editwin is the Editor window for the context block.
		 *         self.text is the editor window text widget.
		 * 
		 *         self.context displays the code context text above the editor text.
		 *           Initially None, it is toggled via <<toggle-code-context>>.
		 *         self.topvisible is the number of the top text line displayed.
		 *         self.info is a list of (line number, indent level, line text,
		 *           block keyword) tuples for the block structure above topvisible.
		 *           self.info[0] is initialized with a 'dummy' line which
		 *           starts the toplevel 'block' of the module.
		 * 
		 *         self.t1 and self.t2 are two timer events on the editor text widget to
		 *           monitor for changes to the context text or editor font.
		 *         
		 */
		function CodeContext(editwin): Promise<ICodeContext>
		function CodeContext$({ editwin }): Promise<ICodeContext>
		interface ICodeContext {

			/**
			 * Load class variables from config.
			 */
			reload(): Promise<any>
			reload$($: {}): Promise<any>

			/**
			 * Toggle code context display.
			 * 
			 *         If self.context doesn't exist, create it to match the size of the editor
			 *         window text (toggle on).  If it does exist, destroy it (toggle off).
			 *         Return 'break' to complete the processing of the binding.
			 *         
			 */
			toggle_code_context_event(event?): Promise<any>
			toggle_code_context_event$({ event }: { event?}): Promise<any>

			/**
			 * Return a list of block line tuples and the 'last' indent.
			 * 
			 *         The tuple fields are (linenum, indent, text, opener).
			 *         The list represents header lines from new_topvisible back to
			 *         stopline with successively shorter indents > stopindent.
			 *         The list is returned ordered by line number.
			 *         Last indent returned is the smallest indent observed.
			 *         
			 */
			get_context(new_topvisible, stopline?, stopindent?): Promise<any>
			get_context$({ new_topvisible, stopline, stopindent }: { new_topvisible, stopline?, stopindent?}): Promise<any>

			/**
			 * Update context information and lines visible in the context pane.
			 * 
			 *         No update is done if the text hasn't been scrolled.  If the text
			 *         was scrolled, the lines that should be shown in the context will
			 *         be retrieved and the context area will be updated with the code,
			 *         up to the number of maxlines.
			 *         
			 */
			update_code_context(): Promise<any>
			update_code_context$($: {}): Promise<any>

			/**
			 *  Show clicked context line at top of editor.
			 * 
			 *         If a selection was made, don't jump; allow copying.
			 *         If no visible context, show the top line of the file.
			 *         
			 */
			jumptoline(event?): Promise<any>
			jumptoline$({ event }: { event?}): Promise<any>

			/**
			 * Event on editor text widget triggered every UPDATEINTERVAL ms.
			 */
			timer_event(): Promise<any>
			timer_event$($: {}): Promise<any>
			update_font(): Promise<any>
			update_font$($: {}): Promise<any>
			update_highlight_colors(): Promise<any>
			update_highlight_colors$($: {}): Promise<any>
			UPDATEINTERVAL
		}
		let BLOCKOPENERS: Promise<any>
	}
	module colorizer {
		var _

		/**
		 * Return a named group pattern matching list of alternates.
		 */
		function any(name, alternates): Promise<any>
		function any$({ name, alternates }): Promise<any>
		function make_pat(): Promise<any>
		function make_pat$($: {}): Promise<any>

		/**
		 * Get only the non-empty named groups from an re.Match object.
		 */
		function matched_named_groups(re_match): Promise<any>
		function matched_named_groups$({ re_match }): Promise<any>

		/**
		 * Set color options of Text widget.
		 * 
		 *     If ColorDelegator is used, this should be called first.
		 *     
		 */
		function color_config(text): Promise<any>
		function color_config$({ text }): Promise<any>

		/**
		 * Delegator for syntax highlighting (text coloring).
		 * 
		 *     Instance variables:
		 *         delegate: Delegator below this one in the stack, meaning the
		 *                 one this one delegates to.
		 * 
		 *         Used to track state:
		 *         after_id: Identifier for scheduled after event, which is a
		 *                 timer for colorizing the text.
		 *         allow_colorizing: Boolean toggle for applying colorizing.
		 *         colorizing: Boolean flag when colorizing is in process.
		 *         stop_colorizing: Boolean flag to end an active colorizing
		 *                 process.
		 *     
		 */
		function ColorDelegator(): Promise<IColorDelegator>
		function ColorDelegator$({ }): Promise<IColorDelegator>
		interface IColorDelegator {

			/**
			 * Initialize variables that track colorizing state.
			 */
			init_state(): Promise<any>
			init_state$($: {}): Promise<any>

			/**
			 * Set the delegate for this instance.
			 * 
			 *         A delegate is an instance of a Delegator class and each
			 *         delegate points to the next delegator in the stack.  This
			 *         allows multiple delegators to be chained together for a
			 *         widget.  The bottom delegate for a colorizer is a Text
			 *         widget.
			 * 
			 *         If there is a delegate, also start the colorizing process.
			 *         
			 */
			setdelegate(delegate): Promise<any>
			setdelegate$({ delegate }): Promise<any>

			/**
			 * Configure text widget tags with colors from tagdefs.
			 */
			config_colors(): Promise<any>
			config_colors$($: {}): Promise<any>

			/**
			 * Create dictionary of tag names to text colors.
			 */
			LoadTagDefs(): Promise<any>
			LoadTagDefs$($: {}): Promise<any>

			/**
			 * Insert chars into widget at index and mark for colorizing.
			 */
			insert(index, chars, tags?): Promise<any>
			insert$({ index, chars, tags }: { index, chars, tags?}): Promise<any>

			/**
			 * Delete chars between indexes and mark for colorizing.
			 */
			delete(index1, index2?): Promise<any>
			delete$({ index1, index2 }: { index1, index2?}): Promise<any>

			/**
			 * Mark text changes for processing and restart colorizing, if active.
			 */
			notify_range(index1, index2?): Promise<any>
			notify_range$({ index1, index2 }: { index1, index2?}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Toggle colorizing on and off.
			 * 
			 *         When toggling off, if colorizing is scheduled or is in
			 *         process, it will be cancelled and/or stopped.
			 * 
			 *         When toggling on, colorizing will be scheduled.
			 *         
			 */
			toggle_colorize_event(event?): Promise<any>
			toggle_colorize_event$({ event }: { event?}): Promise<any>

			/**
			 * Timer event (every 1ms) to colorize text.
			 * 
			 *         Colorizing is only attempted when the text widget exists,
			 *         when colorizing is toggled on, and when the colorizing
			 *         process is not already running.
			 * 
			 *         After colorizing is complete, some cleanup is done to
			 *         make sure that all the text has been colorized.
			 *         
			 */
			recolorize(): Promise<any>
			recolorize$($: {}): Promise<any>

			/**
			 * Evaluate text and apply colorizing tags.
			 */
			recolorize_main(): Promise<any>
			recolorize_main$($: {}): Promise<any>

			/**
			 * Remove all colorizing tags.
			 */
			removecolors(): Promise<any>
			removecolors$($: {}): Promise<any>
		}
		let DEBUG: Promise<any>
		let prog: Promise<any>
		let idprog: Promise<any>
		let prog_group_name_to_tag: Promise<any>
	}
	module config {
		var _
		interface IInvalidConfigType {
		}
		interface IInvalidConfigSet {
		}
		interface IInvalidTheme {
		}

		/**
		 * 
		 *     A ConfigParser specialised for idle configuration file handling
		 *     
		 */

		/**
		 * 
		 *         cfgFile - string, fully specified configuration file name
		 *         
		 */
		function IdleConfParser(cfgFile, cfgDefaults?): Promise<IIdleConfParser>
		function IdleConfParser$({ cfgFile, cfgDefaults }: { cfgFile, cfgDefaults?}): Promise<IIdleConfParser>
		interface IIdleConfParser {

			/**
			 * 
			 *         Get an option value for given section/option or return default.
			 *         If type is specified, return as type.
			 *         
			 */
			Get(section, option, type?, def?, raw?: boolean): Promise<any>
			Get$({ section, option, type, def, raw }: { section, option, type?, def?, raw?}): Promise<any>

			/**
			 * Return a list of options for given section, else [].
			 */
			GetOptionList(section): Promise<any>
			GetOptionList$({ section }): Promise<any>

			/**
			 * Load the configuration file from disk.
			 */
			Load(): Promise<any>
			Load$($: {}): Promise<any>
		}

		/**
		 * 
		 *     IdleConfigParser specialised for user configuration handling.
		 *     
		 */
		interface IIdleUserConfParser extends IIdleConfParser {

			/**
			 * Return True if option is added or changed to value, else False.
			 * 
			 *         Add section if required.  False means option already had value.
			 *         
			 */
			SetOption(section, option, value): Promise<any>
			SetOption$({ section, option, value }): Promise<any>

			/**
			 * Return True if option is removed from section, else False.
			 * 
			 *         False if either section does not exist or did not have option.
			 *         
			 */
			RemoveOption(section, option): Promise<any>
			RemoveOption$({ section, option }): Promise<any>

			/**
			 * If section doesn't exist, add it.
			 */
			AddSection(section): Promise<any>
			AddSection$({ section }): Promise<any>

			/**
			 * Remove any sections that have no options.
			 */
			RemoveEmptySections(): Promise<any>
			RemoveEmptySections$($: {}): Promise<any>

			/**
			 * Return True if no sections after removing empty sections.
			 */
			IsEmpty(): Promise<any>
			IsEmpty$($: {}): Promise<any>

			/**
			 * Update user configuration file.
			 * 
			 *         If self not empty after removing empty sections, write the file
			 *         to disk. Otherwise, remove the file from disk if it exists.
			 *         
			 */
			Save(): Promise<any>
			Save$($: {}): Promise<any>
		}

		/**
		 * Hold config parsers for all idle config files in singleton instance.
		 * 
		 *     Default config files, self.defaultCfg --
		 *         for config_type in self.config_types:
		 *             (idle install dir)/config-{config-type}.def
		 * 
		 *     User config files, self.userCfg --
		 *         for config_type in self.config_types:
		 *         (user home dir)/.idlerc/config-{config-type}.cfg
		 *     
		 */
		function IdleConf(_utest?: boolean): Promise<IIdleConf>
		function IdleConf$({ _utest }: { _utest?}): Promise<IIdleConf>
		interface IIdleConf {

			/**
			 * Populate default and user config parser dictionaries.
			 */
			CreateConfigHandlers(): Promise<any>
			CreateConfigHandlers$($: {}): Promise<any>

			/**
			 * Return a filesystem directory for storing user config files.
			 * 
			 *         Creates it if required.
			 *         
			 */
			GetUserCfgDir(): Promise<any>
			GetUserCfgDir$($: {}): Promise<any>

			/**
			 * Return a value for configType section option, or default.
			 * 
			 *         If type is not None, return a value of that type.  Also pass raw
			 *         to the config parser.  First try to return a valid value
			 *         (including type) from a user configuration. If that fails, try
			 *         the default configuration. If that fails, return default, with a
			 *         default of None.
			 * 
			 *         Warn if either user or default configurations have an invalid value.
			 *         Warn if default is returned and warn_on_default is True.
			 *         
			 */
			GetOption(configType, section, option, def?, type?, warn_on_default?: boolean, raw?: boolean): Promise<any>
			GetOption$({ configType, section, option, def, type, warn_on_default, raw }: { configType, section, option, def?, type?, warn_on_default?, raw?}): Promise<any>

			/**
			 * Set section option to value in user config file.
			 */
			SetOption(configType, section, option, value): Promise<any>
			SetOption$({ configType, section, option, value }): Promise<any>

			/**
			 * Return sections for configSet configType configuration.
			 * 
			 *         configSet must be either 'user' or 'default'
			 *         configType must be in self.config_types.
			 *         
			 */
			GetSectionList(configSet, configType): Promise<any>
			GetSectionList$({ configSet, configType }): Promise<any>

			/**
			 * Return dict of theme element highlight colors.
			 * 
			 *         The keys are 'foreground' and 'background'.  The values are
			 *         tkinter color strings for configuring backgrounds and tags.
			 *         
			 */
			GetHighlight(theme, element): Promise<any>
			GetHighlight$({ theme, element }): Promise<any>

			/**
			 * Return {option:value} dict for elements in themeName.
			 * 
			 *         type - string, 'default' or 'user' theme type
			 *         themeName - string, theme name
			 *         Values are loaded over ultimate fallback defaults to guarantee
			 *         that all theme elements are present in a newly created theme.
			 *         
			 */
			GetThemeDict(type, themeName): Promise<any>
			GetThemeDict$({ type, themeName }): Promise<any>

			/**
			 * Return the name of the currently active text color theme.
			 */
			CurrentTheme(): Promise<any>
			CurrentTheme$($: {}): Promise<any>

			/**
			 * Return the name of the currently active key set.
			 */
			CurrentKeys(): Promise<any>
			CurrentKeys$($: {}): Promise<any>

			/**
			 * Return the currently active name for Theme or Keys section.
			 * 
			 *         idlelib.config-main.def ('default') includes these sections
			 * 
			 *         [Theme]
			 *         default= 1
			 *         name= IDLE Classic
			 *         name2=
			 * 
			 *         [Keys]
			 *         default= 1
			 *         name=
			 *         name2=
			 * 
			 *         Item 'name2', is used for built-in ('default') themes and keys
			 *         added after 2015 Oct 1 and 2016 July 1.  This kludge is needed
			 *         because setting 'name' to a builtin not defined in older IDLEs
			 *         to display multiple error messages or quit.
			 *         See https://bugs.python.org/issue25313.
			 *         When default = True, 'name2' takes precedence over 'name',
			 *         while older IDLEs will just use name.  When default = False,
			 *         'name2' may still be set, but it is ignored.
			 *         
			 */
			current_colors_and_keys(section): Promise<any>
			current_colors_and_keys$({ section }): Promise<any>
			default_keys(): Promise<any>
			default_keys$($: {}): Promise<any>

			/**
			 * Return extensions in default and user config-extensions files.
			 * 
			 *         If active_only True, only return active (enabled) extensions
			 *         and optionally only editor or shell extensions.
			 *         If active_only False, return all extensions.
			 *         
			 */
			GetExtensions(active_only?: boolean, editor_only?: boolean, shell_only?: boolean): Promise<any>
			GetExtensions$({ active_only, editor_only, shell_only }: { active_only?, editor_only?, shell_only?}): Promise<any>

			/**
			 * Return extnNameList with keybinding section names removed.
			 */
			RemoveKeyBindNames(extnNameList): Promise<any>
			RemoveKeyBindNames$({ extnNameList }): Promise<any>

			/**
			 * Return the name of the extension binding virtualEvent, or None.
			 * 
			 *         virtualEvent - string, name of the virtual event to test for,
			 *                        without the enclosing '<< >>'
			 *         
			 */
			GetExtnNameForEvent(virtualEvent): Promise<any>
			GetExtnNameForEvent$({ virtualEvent }): Promise<any>

			/**
			 * Return dict: {configurable extensionName event : active keybinding}.
			 * 
			 *         Events come from default config extension_cfgBindings section.
			 *         Keybindings come from GetCurrentKeySet() active key dict,
			 *         where previously used bindings are disabled.
			 *         
			 */
			GetExtensionKeys(extensionName): Promise<any>
			GetExtensionKeys$({ extensionName }): Promise<any>

			/**
			 * Return dict {extensionName event : active or defined keybinding}.
			 * 
			 *         Augment self.GetExtensionKeys(extensionName) with mapping of non-
			 *         configurable events (from default config) to GetOption splits,
			 *         as in self.__GetRawExtensionKeys.
			 *         
			 */
			GetExtensionBindings(extensionName): Promise<any>
			GetExtensionBindings$({ extensionName }): Promise<any>

			/**
			 * Return the keybinding list for keySetName eventStr.
			 * 
			 *         keySetName - name of key binding set (config-keys section).
			 *         eventStr - virtual event, including brackets, as in '<<event>>'.
			 *         
			 */
			GetKeyBinding(keySetName, eventStr): Promise<any>
			GetKeyBinding$({ keySetName, eventStr }): Promise<any>

			/**
			 * Return CurrentKeys with 'darwin' modifications.
			 */
			GetCurrentKeySet(): Promise<any>
			GetCurrentKeySet$($: {}): Promise<any>

			/**
			 * Return event-key dict for keySetName core plus active extensions.
			 * 
			 *         If a binding defined in an extension is already in use, the
			 *         extension binding is disabled by being set to ''
			 *         
			 */
			GetKeySet(keySetName): Promise<any>
			GetKeySet$({ keySetName }): Promise<any>

			/**
			 * Return True if the virtual event is one of the core idle key events.
			 * 
			 *         virtualEvent - string, name of the virtual event to test for,
			 *                        without the enclosing '<< >>'
			 *         
			 */
			IsCoreBinding(virtualEvent): Promise<any>
			IsCoreBinding$({ virtualEvent }): Promise<any>

			/**
			 * Return dict of core virtual-key keybindings for keySetName.
			 * 
			 *         The default keySetName None corresponds to the keyBindings base
			 *         dict. If keySetName is not None, bindings from the config
			 *         file(s) are loaded _over_ these defaults, so if there is a
			 *         problem getting any core binding there will be an 'ultimate last
			 *         resort fallback' to the CUA-ish bindings defined here.
			 *         
			 */
			GetCoreKeys(keySetName?): Promise<any>
			GetCoreKeys$({ keySetName }: { keySetName?}): Promise<any>

			/**
			 * Return list of extra help sources from a given configSet.
			 * 
			 *         Valid configSets are 'user' or 'default'.  Return a list of tuples of
			 *         the form (menu_item , path_to_help_file , option), or return the empty
			 *         list.  'option' is the sequence number of the help resource.  'option'
			 *         values determine the position of the menu items on the Help menu,
			 *         therefore the returned list must be sorted by 'option'.
			 * 
			 *         
			 */
			GetExtraHelpSourceList(configSet): Promise<any>
			GetExtraHelpSourceList$({ configSet }): Promise<any>

			/**
			 * Return a list of the details of all additional help sources.
			 * 
			 *         Tuples in the list are those of GetExtraHelpSourceList.
			 *         
			 */
			GetAllExtraHelpSourcesList(): Promise<any>
			GetAllExtraHelpSourcesList$($: {}): Promise<any>

			/**
			 * Retrieve a font from configuration (font, font-size, font-bold)
			 *         Intercept the special value 'TkFixedFont' and substitute
			 *         the actual font, factoring in some tweaks if needed for
			 *         appearance sakes.
			 * 
			 *         The 'root' parameter can normally be any valid Tkinter widget.
			 * 
			 *         Return a tuple (family, size, weight) suitable for passing
			 *         to tkinter.Font
			 *         
			 */
			GetFont(root, configType, section): Promise<any>
			GetFont$({ root, configType, section }): Promise<any>

			/**
			 * Load all configuration files.
			 */
			LoadCfgFiles(): Promise<any>
			LoadCfgFiles$($: {}): Promise<any>

			/**
			 * Write all loaded user configuration files to disk.
			 */
			SaveUserCfgFiles(): Promise<any>
			SaveUserCfgFiles$($: {}): Promise<any>
			former_extension_events
		}

		/**
		 * Manage a user's proposed configuration option changes.
		 * 
		 *     Names used across multiple methods:
		 *         page -- one of the 4 top-level dicts representing a
		 *                 .idlerc/config-x.cfg file.
		 *         config_type -- name of a page.
		 *         section -- a section within a page/file.
		 *         option -- name of an option within a section.
		 *         value -- value for the option.
		 * 
		 *     Methods
		 *         add_option: Add option and value to changes.
		 *         save_option: Save option and value to config parser.
		 *         save_all: Save all the changes to the config parser and file.
		 *         delete_section: If section exists,
		 *                         delete from changes, userCfg, and file.
		 *         clear: Clear all changes by clearing each page.
		 *     
		 */

		/**
		 * Create a page for each configuration file
		 */
		function ConfigChanges(): Promise<IConfigChanges>
		function ConfigChanges$({ }): Promise<IConfigChanges>
		interface IConfigChanges {

			/**
			 * Add item/value pair for config_type and section.
			 */
			add_option(config_type, section, item, value): Promise<any>
			add_option$({ config_type, section, item, value }): Promise<any>

			/**
			 * Return True if the configuration value was added or changed.
			 * 
			 *         Helper for save_all.
			 *         
			 */
			save_option(section, item, value): Promise<any>
			save_option$({ section, item, value }): Promise<any>

			/**
			 * Save configuration changes to the user config file.
			 * 
			 *         Clear self in preparation for additional changes.
			 *         Return changed for testing.
			 *         
			 */
			save_all(): Promise<any>
			save_all$($: {}): Promise<any>

			/**
			 * Delete a section from self, userCfg, and file.
			 * 
			 *         Used to delete custom themes and keysets.
			 *         
			 */
			delete_section(config_type, section): Promise<any>
			delete_section$({ config_type, section }): Promise<any>

			/**
			 * Clear all 4 pages.
			 * 
			 *         Called in save_all after saving to idleConf.
			 *         XXX Mark window *title* when there are changes; unmark here.
			 *         
			 */
			clear(): Promise<any>
			clear$($: {}): Promise<any>
		}
		let idleConf: Promise<any>
	}
	module config_key {
		var _

		/**
		 * Translate from keycap symbol to the Tkinter keysym.
		 */
		function translate_key(key, modifiers): Promise<any>
		function translate_key$({ key, modifiers }): Promise<any>

		/**
		 * 
		 *         parent - parent of this dialog
		 *         title - string which is the title of the popup dialog
		 *         action - string, the name of the virtual event these keys will be
		 *                  mapped to
		 *         current_key_sequences - list, a list of all key sequence lists
		 *                  currently mapped to virtual events, for overlap checking
		 *         _htest - bool, change box location when running htest
		 *         _utest - bool, do not wait when running unittest
		 *         
		 */
		function GetKeysDialog(parent, title, action, current_key_sequences): Promise<IGetKeysDialog>
		function GetKeysDialog$({ parent, title, action, current_key_sequences }): Promise<IGetKeysDialog>
		interface IGetKeysDialog {
			showerror(): Promise<any>
			showerror$($: {}): Promise<any>
			create_widgets(): Promise<any>
			create_widgets$($: {}): Promise<any>

			/**
			 * Determine list of names of key modifiers for this platform.
			 * 
			 *         The names are used to build Tk bindings -- it doesn't matter if the
			 *         keyboard has these keys; it matters if Tk understands them.  The
			 *         order is also important: key binding equality depends on it, so
			 *         config-keys.def must use the same ordering.
			 *         
			 */
			set_modifiers_for_platform(): Promise<any>
			set_modifiers_for_platform$($: {}): Promise<any>

			/**
			 * Toggle between basic and advanced keys.
			 */
			toggle_level(): Promise<any>
			toggle_level$($: {}): Promise<any>

			/**
			 * Handler for clicking on key in basic settings list.
			 */
			final_key_selected(event?): Promise<any>
			final_key_selected$({ event }: { event?}): Promise<any>

			/**
			 * Create formatted string of modifiers plus the key.
			 */
			build_key_string(): Promise<any>
			build_key_string$($: {}): Promise<any>

			/**
			 * Return ordered list of modifiers that have been selected.
			 */
			get_modifiers(): Promise<any>
			get_modifiers$($: {}): Promise<any>

			/**
			 * Clear modifiers and keys selection.
			 */
			clear_key_seq(): Promise<any>
			clear_key_seq$($: {}): Promise<any>
			ok(event?): Promise<any>
			ok$({ event }: { event?}): Promise<any>
			cancel(event?): Promise<any>
			cancel$({ event }: { event?}): Promise<any>

			/**
			 * Validity check on user's 'basic' keybinding selection.
			 * 
			 *         Doesn't check the string produced by the advanced dialog because
			 *         'modifiers' isn't set.
			 *         
			 */
			keys_ok(keys): Promise<any>
			keys_ok$({ keys }): Promise<any>

			/**
			 * Return True if Tcl accepts the new keys else show message.
			 */
			bind_ok(keys): Promise<any>
			bind_ok$({ keys }): Promise<any>
			keyerror_title
		}
		let FUNCTION_KEYS: Promise<any>
		let ALPHANUM_KEYS: Promise<any>
		let PUNCTUATION_KEYS: Promise<any>
		let WHITESPACE_KEYS: Promise<any>
		let EDIT_KEYS: Promise<any>
		let MOVE_KEYS: Promise<any>
		let AVAILABLE_KEYS: Promise<any>
	}
	module configdialog {
		var _

		/**
		 * Return 's is blank or represents an int'
		 */
		function is_int(s): Promise<any>
		function is_int$({ s }): Promise<any>

		/**
		 * Config dialog for IDLE.
		 *     
		 */

		/**
		 * Show the tabbed dialog for user configuration.
		 * 
		 *         Args:
		 *             parent - parent of this dialog
		 *             title - string which is the title of this popup dialog
		 *             _htest - bool, change box location when running htest
		 *             _utest - bool, don't wait_window when running unittest
		 * 
		 *         Note: Focus set on font page fontlist.
		 * 
		 *         Methods:
		 *             create_widgets
		 *             cancel: Bound to DELETE_WINDOW protocol.
		 *         
		 */
		function ConfigDialog(parent, title?): Promise<IConfigDialog>
		function ConfigDialog$({ parent, title }: { parent, title?}): Promise<IConfigDialog>
		interface IConfigDialog {

			/**
			 * Create and place widgets for tabbed dialog.
			 * 
			 *         Widgets Bound to self:
			 *             frame: encloses all other widgets
			 *             note: Notebook
			 *             highpage: HighPage
			 *             fontpage: FontPage
			 *             keyspage: KeysPage
			 *             winpage: WinPage
			 *             shedpage: ShedPage
			 *             extpage: ExtPage
			 * 
			 *         Methods:
			 *             create_action_buttons
			 *             load_configs: Load pages except for extensions.
			 *             activate_config_changes: Tell editors to reload.
			 *         
			 */
			create_widgets(): Promise<any>
			create_widgets$($: {}): Promise<any>

			/**
			 * Return frame of action buttons for dialog.
			 * 
			 *         Methods:
			 *             ok
			 *             apply
			 *             cancel
			 *             help
			 * 
			 *         Widget Structure:
			 *             outer: Frame
			 *                 buttons: Frame
			 *                     (no assignment): Button (ok)
			 *                     (no assignment): Button (apply)
			 *                     (no assignment): Button (cancel)
			 *                     (no assignment): Button (help)
			 *                 (no assignment): Frame
			 *         
			 */
			create_action_buttons(): Promise<any>
			create_action_buttons$($: {}): Promise<any>

			/**
			 * Apply config changes, then dismiss dialog.
			 */
			ok(): Promise<any>
			ok$($: {}): Promise<any>

			/**
			 * Apply config changes and leave dialog open.
			 */
			apply(): Promise<any>
			apply$($: {}): Promise<any>

			/**
			 * Dismiss config dialog.
			 * 
			 *         Methods:
			 *             destroy: inherited
			 *         
			 */
			cancel(): Promise<any>
			cancel$($: {}): Promise<any>
			destroy(): Promise<any>
			destroy$($: {}): Promise<any>

			/**
			 * Create textview for config dialog help.
			 * 
			 *         Attributes accessed:
			 *             note
			 *         Methods:
			 *             view_text: Method from textview module.
			 *         
			 */
			help(): Promise<any>
			help$($: {}): Promise<any>

			/**
			 * Remove current key bindings.
			 *         Iterate over window instances defined in parent and remove
			 *         the keybindings.
			 *         
			 */
			deactivate_current_config(): Promise<any>
			deactivate_current_config$($: {}): Promise<any>

			/**
			 * Apply configuration changes to current windows.
			 * 
			 *         Dynamically update the current parent window instances
			 *         with some of the configuration changes.
			 *         
			 */
			activate_config_changes(): Promise<any>
			activate_config_changes$($: {}): Promise<any>
		}
		function FontPage(master, highpage): Promise<IFontPage>
		function FontPage$({ master, highpage }): Promise<IFontPage>
		interface IFontPage {

			/**
			 * Return frame of widgets for Font tab.
			 * 
			 *         Fonts: Enable users to provisionally change font face, size, or
			 *         boldness and to see the consequence of proposed choices.  Each
			 *         action set 3 options in changes structuree and changes the
			 *         corresponding aspect of the font sample on this page and
			 *         highlight sample on highlight page.
			 * 
			 *         Function load_font_cfg initializes font vars and widgets from
			 *         idleConf entries and tk.
			 * 
			 *         Fontlist: mouse button 1 click or up or down key invoke
			 *         on_fontlist_select(), which sets var font_name.
			 * 
			 *         Sizelist: clicking the menubutton opens the dropdown menu. A
			 *         mouse button 1 click or return key sets var font_size.
			 * 
			 *         Bold_toggle: clicking the box toggles var font_bold.
			 * 
			 *         Changing any of the font vars invokes var_changed_font, which
			 *         adds all 3 font options to changes and calls set_samples.
			 *         Set_samples applies a new font constructed from the font vars to
			 *         font_sample and to highlight_sample on the highlight page.
			 * 
			 *         Widgets for FontPage(Frame):  (*) widgets bound to self
			 *             frame_font: LabelFrame
			 *                 frame_font_name: Frame
			 *                     font_name_title: Label
			 *                     (*)fontlist: ListBox - font_name
			 *                     scroll_font: Scrollbar
			 *                 frame_font_param: Frame
			 *                     font_size_title: Label
			 *                     (*)sizelist: DynOptionMenu - font_size
			 *                     (*)bold_toggle: Checkbutton - font_bold
			 *             frame_sample: LabelFrame
			 *                 (*)font_sample: Label
			 *         
			 */
			create_page_font(): Promise<any>
			create_page_font$($: {}): Promise<any>

			/**
			 * Load current configuration settings for the font options.
			 * 
			 *         Retrieve current font with idleConf.GetFont and font families
			 *         from tk. Setup fontlist and set font_name.  Setup sizelist,
			 *         which sets font_size.  Set font_bold.  Call set_samples.
			 *         
			 */
			load_font_cfg(): Promise<any>
			load_font_cfg$($: {}): Promise<any>

			/**
			 * Store changes to font attributes.
			 * 
			 *         When one font attribute changes, save them all, as they are
			 *         not independent from each other. In particular, when we are
			 *         overriding the default font, we need to write out everything.
			 *         
			 */
			var_changed_font(): Promise<any>
			var_changed_font$($: {}): Promise<any>

			/**
			 * Handle selecting a font from the list.
			 * 
			 *         Event can result from either mouse click or Up or Down key.
			 *         Set font_name and example displays to selection.
			 *         
			 */
			on_fontlist_select(event): Promise<any>
			on_fontlist_select$({ event }): Promise<any>

			/**
			 * Update update both screen samples with the font settings.
			 * 
			 *         Called on font initialization and change events.
			 *         Accesses font_name, font_size, and font_bold Variables.
			 *         Updates font_sample and highlight page highlight_sample.
			 *         
			 */
			set_samples(event?): Promise<any>
			set_samples$({ event }: { event?}): Promise<any>
		}
		function HighPage(master, extpage): Promise<IHighPage>
		function HighPage$({ master, extpage }): Promise<IHighPage>
		interface IHighPage {

			/**
			 * Return frame of widgets for Highlights tab.
			 * 
			 *         Enable users to provisionally change foreground and background
			 *         colors applied to textual tags.  Color mappings are stored in
			 *         complete listings called themes.  Built-in themes in
			 *         idlelib/config-highlight.def are fixed as far as the dialog is
			 *         concerned. Any theme can be used as the base for a new custom
			 *         theme, stored in .idlerc/config-highlight.cfg.
			 * 
			 *         Function load_theme_cfg() initializes tk variables and theme
			 *         lists and calls paint_theme_sample() and set_highlight_target()
			 *         for the current theme.  Radiobuttons builtin_theme_on and
			 *         custom_theme_on toggle var theme_source, which controls if the
			 *         current set of colors are from a builtin or custom theme.
			 *         DynOptionMenus builtinlist and customlist contain lists of the
			 *         builtin and custom themes, respectively, and the current item
			 *         from each list is stored in vars builtin_name and custom_name.
			 * 
			 *         Function paint_theme_sample() applies the colors from the theme
			 *         to the tags in text widget highlight_sample and then invokes
			 *         set_color_sample().  Function set_highlight_target() sets the state
			 *         of the radiobuttons fg_on and bg_on based on the tag and it also
			 *         invokes set_color_sample().
			 * 
			 *         Function set_color_sample() sets the background color for the frame
			 *         holding the color selector.  This provides a larger visual of the
			 *         color for the current tag and plane (foreground/background).
			 * 
			 *         Note: set_color_sample() is called from many places and is often
			 *         called more than once when a change is made.  It is invoked when
			 *         foreground or background is selected (radiobuttons), from
			 *         paint_theme_sample() (theme is changed or load_cfg is called), and
			 *         from set_highlight_target() (target tag is changed or load_cfg called).
			 * 
			 *         Button delete_custom invokes delete_custom() to delete
			 *         a custom theme from idleConf.userCfg['highlight'] and changes.
			 *         Button save_custom invokes save_as_new_theme() which calls
			 *         get_new_theme_name() and create_new() to save a custom theme
			 *         and its colors to idleConf.userCfg['highlight'].
			 * 
			 *         Radiobuttons fg_on and bg_on toggle var fg_bg_toggle to control
			 *         if the current selected color for a tag is for the foreground or
			 *         background.
			 * 
			 *         DynOptionMenu targetlist contains a readable description of the
			 *         tags applied to Python source within IDLE.  Selecting one of the
			 *         tags from this list populates highlight_target, which has a callback
			 *         function set_highlight_target().
			 * 
			 *         Text widget highlight_sample displays a block of text (which is
			 *         mock Python code) in which is embedded the defined tags and reflects
			 *         the color attributes of the current theme and changes for those tags.
			 *         Mouse button 1 allows for selection of a tag and updates
			 *         highlight_target with that tag value.
			 * 
			 *         Note: The font in highlight_sample is set through the config in
			 *         the fonts tab.
			 * 
			 *         In other words, a tag can be selected either from targetlist or
			 *         by clicking on the sample text within highlight_sample.  The
			 *         plane (foreground/background) is selected via the radiobutton.
			 *         Together, these two (tag and plane) control what color is
			 *         shown in set_color_sample() for the current theme.  Button set_color
			 *         invokes get_color() which displays a ColorChooser to change the
			 *         color for the selected tag/plane.  If a new color is picked,
			 *         it will be saved to changes and the highlight_sample and
			 *         frame background will be updated.
			 * 
			 *         Tk Variables:
			 *             color: Color of selected target.
			 *             builtin_name: Menu variable for built-in theme.
			 *             custom_name: Menu variable for custom theme.
			 *             fg_bg_toggle: Toggle for foreground/background color.
			 *                 Note: this has no callback.
			 *             theme_source: Selector for built-in or custom theme.
			 *             highlight_target: Menu variable for the highlight tag target.
			 * 
			 *         Instance Data Attributes:
			 *             theme_elements: Dictionary of tags for text highlighting.
			 *                 The key is the display name and the value is a tuple of
			 *                 (tag name, display sort order).
			 * 
			 *         Methods [attachment]:
			 *             load_theme_cfg: Load current highlight colors.
			 *             get_color: Invoke colorchooser [button_set_color].
			 *             set_color_sample_binding: Call set_color_sample [fg_bg_toggle].
			 *             set_highlight_target: set fg_bg_toggle, set_color_sample().
			 *             set_color_sample: Set frame background to target.
			 *             on_new_color_set: Set new color and add option.
			 *             paint_theme_sample: Recolor sample.
			 *             get_new_theme_name: Get from popup.
			 *             create_new: Combine theme with changes and save.
			 *             save_as_new_theme: Save [button_save_custom].
			 *             set_theme_type: Command for [theme_source].
			 *             delete_custom: Activate default [button_delete_custom].
			 *             save_new: Save to userCfg['theme'] (is function).
			 * 
			 *         Widgets of highlights page frame:  (*) widgets bound to self
			 *             frame_custom: LabelFrame
			 *                 (*)highlight_sample: Text
			 *                 (*)frame_color_set: Frame
			 *                     (*)button_set_color: Button
			 *                     (*)targetlist: DynOptionMenu - highlight_target
			 *                 frame_fg_bg_toggle: Frame
			 *                     (*)fg_on: Radiobutton - fg_bg_toggle
			 *                     (*)bg_on: Radiobutton - fg_bg_toggle
			 *                 (*)button_save_custom: Button
			 *             frame_theme: LabelFrame
			 *                 theme_type_title: Label
			 *                 (*)builtin_theme_on: Radiobutton - theme_source
			 *                 (*)custom_theme_on: Radiobutton - theme_source
			 *                 (*)builtinlist: DynOptionMenu - builtin_name
			 *                 (*)customlist: DynOptionMenu - custom_name
			 *                 (*)button_delete_custom: Button
			 *                 (*)theme_message: Label
			 *         
			 */
			create_page_highlight(): Promise<any>
			create_page_highlight$($: {}): Promise<any>

			/**
			 * Load current configuration settings for the theme options.
			 * 
			 *         Based on the theme_source toggle, the theme is set as
			 *         either builtin or custom and the initial widget values
			 *         reflect the current settings from idleConf.
			 * 
			 *         Attributes updated:
			 *             theme_source: Set from idleConf.
			 *             builtinlist: List of default themes from idleConf.
			 *             customlist: List of custom themes from idleConf.
			 *             custom_theme_on: Disabled if there are no custom themes.
			 *             custom_theme: Message with additional information.
			 *             targetlist: Create menu from self.theme_elements.
			 * 
			 *         Methods:
			 *             set_theme_type
			 *             paint_theme_sample
			 *             set_highlight_target
			 *         
			 */
			load_theme_cfg(): Promise<any>
			load_theme_cfg$($: {}): Promise<any>

			/**
			 * Process new builtin theme selection.
			 * 
			 *         Add the changed theme's name to the changed_items and recreate
			 *         the sample with the values from the selected theme.
			 *         
			 */
			var_changed_builtin_name(): Promise<any>
			var_changed_builtin_name$($: {}): Promise<any>

			/**
			 * Process new custom theme selection.
			 * 
			 *         If a new custom theme is selected, add the name to the
			 *         changed_items and apply the theme to the sample.
			 *         
			 */
			var_changed_custom_name(): Promise<any>
			var_changed_custom_name$($: {}): Promise<any>

			/**
			 * Process toggle between builtin and custom theme.
			 * 
			 *         Update the default toggle value and apply the newly
			 *         selected theme type.
			 *         
			 */
			var_changed_theme_source(): Promise<any>
			var_changed_theme_source$($: {}): Promise<any>

			/**
			 * Process change to color choice.
			 */
			var_changed_color(): Promise<any>
			var_changed_color$($: {}): Promise<any>

			/**
			 * Process selection of new target tag for highlighting.
			 */
			var_changed_highlight_target(): Promise<any>
			var_changed_highlight_target$($: {}): Promise<any>

			/**
			 * Set available screen options based on builtin or custom theme.
			 * 
			 *         Attributes accessed:
			 *             theme_source
			 * 
			 *         Attributes updated:
			 *             builtinlist
			 *             customlist
			 *             button_delete_custom
			 *             custom_theme_on
			 * 
			 *         Called from:
			 *             handler for builtin_theme_on and custom_theme_on
			 *             delete_custom
			 *             create_new
			 *             load_theme_cfg
			 *         
			 */
			set_theme_type(): Promise<any>
			set_theme_type$($: {}): Promise<any>

			/**
			 * Handle button to select a new color for the target tag.
			 * 
			 *         If a new color is selected while using a builtin theme, a
			 *         name must be supplied to create a custom theme.
			 * 
			 *         Attributes accessed:
			 *             highlight_target
			 *             frame_color_set
			 *             theme_source
			 * 
			 *         Attributes updated:
			 *             color
			 * 
			 *         Methods:
			 *             get_new_theme_name
			 *             create_new
			 *         
			 */
			get_color(): Promise<any>
			get_color$($: {}): Promise<any>

			/**
			 * Display sample of new color selection on the dialog.
			 */
			on_new_color_set(): Promise<any>
			on_new_color_set$($: {}): Promise<any>

			/**
			 * Return name of new theme from query popup.
			 */
			get_new_theme_name(message): Promise<any>
			get_new_theme_name$({ message }): Promise<any>

			/**
			 * Prompt for new theme name and create the theme.
			 * 
			 *         Methods:
			 *             get_new_theme_name
			 *             create_new
			 *         
			 */
			save_as_new_theme(): Promise<any>
			save_as_new_theme$($: {}): Promise<any>

			/**
			 * Create a new custom theme with the given name.
			 * 
			 *         Create the new theme based on the previously active theme
			 *         with the current changes applied.  Once it is saved, then
			 *         activate the new theme.
			 * 
			 *         Attributes accessed:
			 *             builtin_name
			 *             custom_name
			 * 
			 *         Attributes updated:
			 *             customlist
			 *             theme_source
			 * 
			 *         Method:
			 *             save_new
			 *             set_theme_type
			 *         
			 */
			create_new(new_theme_name): Promise<any>
			create_new$({ new_theme_name }): Promise<any>

			/**
			 * Set fg/bg toggle and color based on highlight tag target.
			 * 
			 *         Instance variables accessed:
			 *             highlight_target
			 * 
			 *         Attributes updated:
			 *             fg_on
			 *             bg_on
			 *             fg_bg_toggle
			 * 
			 *         Methods:
			 *             set_color_sample
			 * 
			 *         Called from:
			 *             var_changed_highlight_target
			 *             load_theme_cfg
			 *         
			 */
			set_highlight_target(): Promise<any>
			set_highlight_target$($: {}): Promise<any>

			/**
			 * Change color sample based on foreground/background toggle.
			 * 
			 *         Methods:
			 *             set_color_sample
			 *         
			 */
			set_color_sample_binding(): Promise<any>
			set_color_sample_binding$($: {}): Promise<any>

			/**
			 * Set the color of the frame background to reflect the selected target.
			 * 
			 *         Instance variables accessed:
			 *             theme_elements
			 *             highlight_target
			 *             fg_bg_toggle
			 *             highlight_sample
			 * 
			 *         Attributes updated:
			 *             frame_color_set
			 *         
			 */
			set_color_sample(): Promise<any>
			set_color_sample$($: {}): Promise<any>

			/**
			 * Apply the theme colors to each element tag in the sample text.
			 * 
			 *         Instance attributes accessed:
			 *             theme_elements
			 *             theme_source
			 *             builtin_name
			 *             custom_name
			 * 
			 *         Attributes updated:
			 *             highlight_sample: Set the tag elements to the theme.
			 * 
			 *         Methods:
			 *             set_color_sample
			 * 
			 *         Called from:
			 *             var_changed_builtin_name
			 *             var_changed_custom_name
			 *             load_theme_cfg
			 *         
			 */
			paint_theme_sample(): Promise<any>
			paint_theme_sample$($: {}): Promise<any>

			/**
			 * Save a newly created theme to idleConf.
			 * 
			 *         theme_name - string, the name of the new theme
			 *         theme - dictionary containing the new theme
			 *         
			 */
			save_new(theme_name, theme): Promise<any>
			save_new$({ theme_name, theme }): Promise<any>
			askyesno(): Promise<any>
			askyesno$($: {}): Promise<any>

			/**
			 * Handle event to delete custom theme.
			 * 
			 *         The current theme is deactivated and the default theme is
			 *         activated.  The custom theme is permanently removed from
			 *         the config file.
			 * 
			 *         Attributes accessed:
			 *             custom_name
			 * 
			 *         Attributes updated:
			 *             custom_theme_on
			 *             customlist
			 *             theme_source
			 *             builtin_name
			 * 
			 *         Methods:
			 *             deactivate_current_config
			 *             save_all_changed_extensions
			 *             activate_config_changes
			 *             set_theme_type
			 *         
			 */
			delete_custom(): Promise<any>
			delete_custom$($: {}): Promise<any>
		}
		function KeysPage(master, extpage): Promise<IKeysPage>
		function KeysPage$({ master, extpage }): Promise<IKeysPage>
		interface IKeysPage {

			/**
			 * Return frame of widgets for Keys tab.
			 * 
			 *         Enable users to provisionally change both individual and sets of
			 *         keybindings (shortcut keys). Except for features implemented as
			 *         extensions, keybindings are stored in complete sets called
			 *         keysets. Built-in keysets in idlelib/config-keys.def are fixed
			 *         as far as the dialog is concerned. Any keyset can be used as the
			 *         base for a new custom keyset, stored in .idlerc/config-keys.cfg.
			 * 
			 *         Function load_key_cfg() initializes tk variables and keyset
			 *         lists and calls load_keys_list for the current keyset.
			 *         Radiobuttons builtin_keyset_on and custom_keyset_on toggle var
			 *         keyset_source, which controls if the current set of keybindings
			 *         are from a builtin or custom keyset. DynOptionMenus builtinlist
			 *         and customlist contain lists of the builtin and custom keysets,
			 *         respectively, and the current item from each list is stored in
			 *         vars builtin_name and custom_name.
			 * 
			 *         Button delete_custom_keys invokes delete_custom_keys() to delete
			 *         a custom keyset from idleConf.userCfg['keys'] and changes.  Button
			 *         save_custom_keys invokes save_as_new_key_set() which calls
			 *         get_new_keys_name() and create_new_key_set() to save a custom keyset
			 *         and its keybindings to idleConf.userCfg['keys'].
			 * 
			 *         Listbox bindingslist contains all of the keybindings for the
			 *         selected keyset.  The keybindings are loaded in load_keys_list()
			 *         and are pairs of (event, [keys]) where keys can be a list
			 *         of one or more key combinations to bind to the same event.
			 *         Mouse button 1 click invokes on_bindingslist_select(), which
			 *         allows button_new_keys to be clicked.
			 * 
			 *         So, an item is selected in listbindings, which activates
			 *         button_new_keys, and clicking button_new_keys calls function
			 *         get_new_keys().  Function get_new_keys() gets the key mappings from the
			 *         current keyset for the binding event item that was selected.  The
			 *         function then displays another dialog, GetKeysDialog, with the
			 *         selected binding event and current keys and allows new key sequences
			 *         to be entered for that binding event.  If the keys aren't
			 *         changed, nothing happens.  If the keys are changed and the keyset
			 *         is a builtin, function get_new_keys_name() will be called
			 *         for input of a custom keyset name.  If no name is given, then the
			 *         change to the keybinding will abort and no updates will be made.  If
			 *         a custom name is entered in the prompt or if the current keyset was
			 *         already custom (and thus didn't require a prompt), then
			 *         idleConf.userCfg['keys'] is updated in function create_new_key_set()
			 *         with the change to the event binding.  The item listing in bindingslist
			 *         is updated with the new keys.  Var keybinding is also set which invokes
			 *         the callback function, var_changed_keybinding, to add the change to
			 *         the 'keys' or 'extensions' changes tracker based on the binding type.
			 * 
			 *         Tk Variables:
			 *             keybinding: Action/key bindings.
			 * 
			 *         Methods:
			 *             load_keys_list: Reload active set.
			 *             create_new_key_set: Combine active keyset and changes.
			 *             set_keys_type: Command for keyset_source.
			 *             save_new_key_set: Save to idleConf.userCfg['keys'] (is function).
			 *             deactivate_current_config: Remove keys bindings in editors.
			 * 
			 *         Widgets for KeysPage(frame):  (*) widgets bound to self
			 *             frame_key_sets: LabelFrame
			 *                 frames[0]: Frame
			 *                     (*)builtin_keyset_on: Radiobutton - var keyset_source
			 *                     (*)custom_keyset_on: Radiobutton - var keyset_source
			 *                     (*)builtinlist: DynOptionMenu - var builtin_name,
			 *                             func keybinding_selected
			 *                     (*)customlist: DynOptionMenu - var custom_name,
			 *                             func keybinding_selected
			 *                     (*)keys_message: Label
			 *                 frames[1]: Frame
			 *                     (*)button_delete_custom_keys: Button - delete_custom_keys
			 *                     (*)button_save_custom_keys: Button -  save_as_new_key_set
			 *             frame_custom: LabelFrame
			 *                 frame_target: Frame
			 *                     target_title: Label
			 *                     scroll_target_y: Scrollbar
			 *                     scroll_target_x: Scrollbar
			 *                     (*)bindingslist: ListBox - on_bindingslist_select
			 *                     (*)button_new_keys: Button - get_new_keys & ..._name
			 *         
			 */
			create_page_keys(): Promise<any>
			create_page_keys$($: {}): Promise<any>

			/**
			 * Load current configuration settings for the keybinding options.
			 */
			load_key_cfg(): Promise<any>
			load_key_cfg$($: {}): Promise<any>

			/**
			 * Process selection of builtin key set.
			 */
			var_changed_builtin_name(): Promise<any>
			var_changed_builtin_name$($: {}): Promise<any>

			/**
			 * Process selection of custom key set.
			 */
			var_changed_custom_name(): Promise<any>
			var_changed_custom_name$($: {}): Promise<any>

			/**
			 * Process toggle between builtin key set and custom key set.
			 */
			var_changed_keyset_source(): Promise<any>
			var_changed_keyset_source$($: {}): Promise<any>

			/**
			 * Store change to a keybinding.
			 */
			var_changed_keybinding(): Promise<any>
			var_changed_keybinding$($: {}): Promise<any>

			/**
			 * Set available screen options based on builtin or custom key set.
			 */
			set_keys_type(): Promise<any>
			set_keys_type$($: {}): Promise<any>

			/**
			 * Handle event to change key binding for selected line.
			 * 
			 *         A selection of a key/binding in the list of current
			 *         bindings pops up a dialog to enter a new binding.  If
			 *         the current key set is builtin and a binding has
			 *         changed, then a name for a custom key set needs to be
			 *         entered for the change to be applied.
			 *         
			 */
			get_new_keys(): Promise<any>
			get_new_keys$($: {}): Promise<any>

			/**
			 * Return new key set name from query popup.
			 */
			get_new_keys_name(message): Promise<any>
			get_new_keys_name$({ message }): Promise<any>

			/**
			 * Prompt for name of new key set and save changes using that name.
			 */
			save_as_new_key_set(): Promise<any>
			save_as_new_key_set$($: {}): Promise<any>

			/**
			 * Activate button to assign new keys to selected action.
			 */
			on_bindingslist_select(event): Promise<any>
			on_bindingslist_select$({ event }): Promise<any>

			/**
			 * Create a new custom key set with the given name.
			 * 
			 *         Copy the bindings/keys from the previously active keyset
			 *         to the new keyset and activate the new custom keyset.
			 *         
			 */
			create_new_key_set(new_key_set_name): Promise<any>
			create_new_key_set$({ new_key_set_name }): Promise<any>

			/**
			 * Reload the list of action/key binding pairs for the active key set.
			 * 
			 *         An action/key binding can be selected to change the key binding.
			 *         
			 */
			load_keys_list(keyset_name): Promise<any>
			load_keys_list$({ keyset_name }): Promise<any>

			/**
			 * Save a newly created core key set.
			 * 
			 *         Add keyset to idleConf.userCfg['keys'], not to disk.
			 *         If the keyset doesn't exist, it is created.  The
			 *         binding/keys are taken from the keyset argument.
			 * 
			 *         keyset_name - string, the name of the new key set
			 *         keyset - dictionary containing the new keybindings
			 *         
			 */
			save_new_key_set(keyset): Promise<any>
			save_new_key_set$({ keyset }): Promise<any>
			askyesno(): Promise<any>
			askyesno$($: {}): Promise<any>

			/**
			 * Handle event to delete a custom key set.
			 * 
			 *         Applying the delete deactivates the current configuration and
			 *         reverts to the default.  The custom key set is permanently
			 *         deleted from the config file.
			 *         
			 */
			delete_custom_keys(): Promise<any>
			delete_custom_keys$($: {}): Promise<any>
		}
		function WinPage(master): Promise<IWinPage>
		function WinPage$({ master }): Promise<IWinPage>
		interface IWinPage {
			init_validators(): Promise<any>
			init_validators$($: {}): Promise<any>

			/**
			 * Return frame of widgets for Windows tab.
			 * 
			 *         Enable users to provisionally change general window options.
			 *         Function load_windows_cfg initializes tk variable idleConf.
			 *         Radiobuttons startup_shell_on and startup_editor_on set var
			 *         startup_edit. Entry boxes win_width_int and win_height_int set var
			 *         win_width and win_height.  Setting var_name invokes the default
			 *         callback that adds option to changes.
			 * 
			 *         Widgets for WinPage(Frame):  > vars, bound to self
			 *             frame_window: LabelFrame
			 *                 frame_run: Frame
			 *                     startup_title: Label
			 *                     startup_editor_on: Radiobutton > startup_edit
			 *                     startup_shell_on: Radiobutton > startup_edit
			 *                 frame_win_size: Frame
			 *                     win_size_title: Label
			 *                     win_width_title: Label
			 *                     win_width_int: Entry > win_width
			 *                     win_height_title: Label
			 *                     win_height_int: Entry > win_height
			 *                 frame_cursor: Frame
			 *                     indent_title: Label
			 *                     indent_chooser: Spinbox (Combobox < 8.5.9) > indent_spaces
			 *                     blink_on: Checkbutton > cursor_blink
			 *                 frame_autocomplete: Frame
			 *                     auto_wait_title: Label
			 *                     auto_wait_int: Entry > autocomplete_wait
			 *                 frame_paren1: Frame
			 *                     paren_style_title: Label
			 *                     paren_style_type: OptionMenu > paren_style
			 *                 frame_paren2: Frame
			 *                     paren_time_title: Label
			 *                     paren_flash_time: Entry > flash_delay
			 *                     bell_on: Checkbutton > paren_bell
			 *                 frame_format: Frame
			 *                     format_width_title: Label
			 *                     format_width_int: Entry > format_width
			 *         
			 */
			create_page_windows(): Promise<any>
			create_page_windows$($: {}): Promise<any>
			load_windows_cfg(): Promise<any>
			load_windows_cfg$($: {}): Promise<any>
		}
		function ShedPage(master): Promise<IShedPage>
		function ShedPage$({ master }): Promise<IShedPage>
		interface IShedPage {
			init_validators(): Promise<any>
			init_validators$($: {}): Promise<any>

			/**
			 * Return frame of widgets for Shell/Ed tab.
			 * 
			 *         Enable users to provisionally change shell and editor options.
			 *         Function load_shed_cfg initializes tk variables using idleConf.
			 *         Entry box auto_squeeze_min_lines_int sets
			 *         auto_squeeze_min_lines_int.  Setting var_name invokes the
			 *         default callback that adds option to changes.
			 * 
			 *         Widgets for ShedPage(Frame):  (*) widgets bound to self
			 *             frame_shell: LabelFrame
			 *                 frame_auto_squeeze_min_lines: Frame
			 *                     auto_squeeze_min_lines_title: Label
			 *                     (*)auto_squeeze_min_lines_int: Entry -
			 *                        auto_squeeze_min_lines
			 *             frame_editor: LabelFrame
			 *                 frame_save: Frame
			 *                     run_save_title: Label
			 *                     (*)save_ask_on: Radiobutton - autosave
			 *                     (*)save_auto_on: Radiobutton - autosave
			 *                 frame_format: Frame
			 *                     format_width_title: Label
			 *                     (*)format_width_int: Entry - format_width
			 *                 frame_line_numbers_default: Frame
			 *                     line_numbers_default_title: Label
			 *                     (*)line_numbers_default_bool: Checkbutton - line_numbers_default
			 *                 frame_context: Frame
			 *                     context_title: Label
			 *                     (*)context_int: Entry - context_lines
			 *         
			 */
			create_page_shed(): Promise<any>
			create_page_shed$($: {}): Promise<any>
			load_shelled_cfg(): Promise<any>
			load_shelled_cfg$($: {}): Promise<any>
		}
		function ExtPage(master): Promise<IExtPage>
		function ExtPage$({ master }): Promise<IExtPage>
		interface IExtPage {

			/**
			 * Configure IDLE feature extensions and help menu extensions.
			 * 
			 *         List the feature extensions and a configuration box for the
			 *         selected extension.  Help menu extensions are in a HelpFrame.
			 * 
			 *         This code reads the current configuration using idleConf,
			 *         supplies a GUI interface to change the configuration values,
			 *         and saves the changes using idleConf.
			 * 
			 *         Some changes may require restarting IDLE.  This depends on each
			 *         extension's implementation.
			 * 
			 *         All values are treated as text, and it is up to the user to
			 *         supply reasonable values. The only exception to this are the
			 *         'enable*' options, which are boolean, and can be toggled with a
			 *         True/False button.
			 * 
			 *         Methods:
			 *             extension_selected: Handle selection from list.
			 *             create_extension_frame: Hold widgets for one extension.
			 *             set_extension_value: Set in userCfg['extensions'].
			 *             save_all_changed_extensions: Call extension page Save().
			 *         
			 */
			create_page_extensions(): Promise<any>
			create_page_extensions$($: {}): Promise<any>

			/**
			 * Fill self.extensions with data from the default and user configs.
			 */
			load_extensions(): Promise<any>
			load_extensions$($: {}): Promise<any>

			/**
			 * Handle selection of an extension from the list.
			 */
			extension_selected(event): Promise<any>
			extension_selected$({ event }): Promise<any>

			/**
			 * Create a frame holding the widgets to configure one extension
			 */
			create_extension_frame(ext_name): Promise<any>
			create_extension_frame$({ ext_name }): Promise<any>

			/**
			 * Return True if the configuration was added or changed.
			 * 
			 *         If the value is the same as the default, then remove it
			 *         from user config file.
			 *         
			 */
			set_extension_value(section, opt): Promise<any>
			set_extension_value$({ section, opt }): Promise<any>

			/**
			 * Save configuration changes to the user config file.
			 * 
			 *         Attributes accessed:
			 *             extensions
			 * 
			 *         Methods:
			 *             set_extension_value
			 *         
			 */
			save_all_changed_extensions(): Promise<any>
			save_all_changed_extensions$($: {}): Promise<any>
		}
		function HelpFrame(master): Promise<IHelpFrame>
		function HelpFrame$({ master }): Promise<IHelpFrame>
		interface IHelpFrame {

			/**
			 * Create LabelFrame for additional help menu sources.
			 * 
			 *         load_helplist loads list user_helplist with
			 *         name, position pairs and copies names to listbox helplist.
			 *         Clicking a name invokes help_source selected. Clicking
			 *         button_helplist_name invokes helplist_item_name, which also
			 *         changes user_helplist.  These functions all call
			 *         set_add_delete_state. All but load call update_help_changes to
			 *         rewrite changes['main']['HelpFiles'].
			 * 
			 *         Widgets for HelpFrame(LabelFrame):  (*) widgets bound to self
			 *             frame_helplist: Frame
			 *                 (*)helplist: ListBox
			 *                 scroll_helplist: Scrollbar
			 *             frame_buttons: Frame
			 *                 (*)button_helplist_edit
			 *                 (*)button_helplist_add
			 *                 (*)button_helplist_remove
			 *         
			 */
			create_frame_help(): Promise<any>
			create_frame_help$($: {}): Promise<any>

			/**
			 * Handle event for selecting additional help.
			 */
			help_source_selected(event): Promise<any>
			help_source_selected$({ event }): Promise<any>

			/**
			 * Toggle the state for the help list buttons based on list entries.
			 */
			set_add_delete_state(): Promise<any>
			set_add_delete_state$($: {}): Promise<any>

			/**
			 * Handle add button for the help list.
			 * 
			 *         Query for name and location of new help sources and add
			 *         them to the list.
			 *         
			 */
			helplist_item_add(): Promise<any>
			helplist_item_add$($: {}): Promise<any>

			/**
			 * Handle edit button for the help list.
			 * 
			 *         Query with existing help source information and update
			 *         config if the values are changed.
			 *         
			 */
			helplist_item_edit(): Promise<any>
			helplist_item_edit$($: {}): Promise<any>

			/**
			 * Handle remove button for the help list.
			 * 
			 *         Delete the help list item from config.
			 *         
			 */
			helplist_item_remove(): Promise<any>
			helplist_item_remove$($: {}): Promise<any>

			/**
			 * Clear and rebuild the HelpFiles section in changes
			 */
			update_help_changes(): Promise<any>
			update_help_changes$($: {}): Promise<any>
			load_helplist(): Promise<any>
			load_helplist$($: {}): Promise<any>
		}

		/**
		 * Maintain Tk variables trace state.
		 */

		/**
		 * Store Tk variables and callbacks.
		 * 
		 *         untraced: List of tuples (var, callback)
		 *             that do not have the callback attached
		 *             to the Tk var.
		 *         traced: List of tuples (var, callback) where
		 *             that callback has been attached to the var.
		 *         
		 */
		function VarTrace(): Promise<IVarTrace>
		function VarTrace$({ }): Promise<IVarTrace>
		interface IVarTrace {

			/**
			 * Clear lists (for tests).
			 */
			clear(): Promise<any>
			clear$($: {}): Promise<any>

			/**
			 * Add (var, callback) tuple to untraced list.
			 * 
			 *         Args:
			 *             var: Tk variable instance.
			 *             callback: Either function name to be used as a callback
			 *                 or a tuple with IdleConf config-type, section, and
			 *                 option names used in the default callback.
			 * 
			 *         Return:
			 *             Tk variable instance.
			 *         
			 */
			add(variable, callback): Promise<any>
			add$({ variable, callback }): Promise<any>

			/**
			 * Return default callback function to add values to changes instance.
			 */
			make_callback(config): Promise<any>
			make_callback$({ config }): Promise<any>

			/**
			 * Attach callback to all vars that are not traced.
			 */
			attach(): Promise<any>
			attach$($: {}): Promise<any>

			/**
			 * Remove callback from traced vars.
			 */
			detach(): Promise<any>
			detach$($: {}): Promise<any>
		}

		/**
		 * A pure Tkinter vertically scrollable frame.
		 * 
		 *     * Use the 'interior' attribute to place widgets inside the scrollable frame
		 *     * Construct and pack/place/grid normally
		 *     * This frame only allows vertical scrolling
		 *     
		 */
		function VerticalScrolledFrame(parent): Promise<IVerticalScrolledFrame>
		function VerticalScrolledFrame$({ parent }): Promise<IVerticalScrolledFrame>
		interface IVerticalScrolledFrame {
		}
		let changes: Promise<any>
		let reloadables: Promise<any>
		let font_sample_text: Promise<any>
		let tracers: Promise<any>
		let help_common: Promise<any>
		let help_pages: Promise<any>
	}
	module _debugger {
		var _
		function Idb(gui): Promise<IIdb>
		function Idb$({ gui }): Promise<IIdb>
		interface IIdb {
			user_line(frame): Promise<any>
			user_line$({ frame }): Promise<any>
			user_exception(frame, info): Promise<any>
			user_exception$({ frame, info }): Promise<any>
			in_rpc_code(frame): Promise<any>
			in_rpc_code$({ frame }): Promise<any>
		}
		function Debugger(pyshell, idb?): Promise<IDebugger>
		function Debugger$({ pyshell, idb }: { pyshell, idb?}): Promise<IDebugger>
		interface IDebugger {
			run(): Promise<any>
			run$($: {}): Promise<any>
			close(event?): Promise<any>
			close$({ event }: { event?}): Promise<any>
			make_gui(): Promise<any>
			make_gui$($: {}): Promise<any>
			interaction(message, frame, info?): Promise<any>
			interaction$({ message, frame, info }: { message, frame, info?}): Promise<any>
			sync_source_line(): Promise<any>
			sync_source_line$($: {}): Promise<any>
			cont(): Promise<any>
			cont$($: {}): Promise<any>
			step(): Promise<any>
			step$($: {}): Promise<any>
			next(): Promise<any>
			next$($: {}): Promise<any>
			ret(): Promise<any>
			ret$($: {}): Promise<any>
			quit(): Promise<any>
			quit$($: {}): Promise<any>
			abort_loop(): Promise<any>
			abort_loop$($: {}): Promise<any>
			show_stack(): Promise<any>
			show_stack$($: {}): Promise<any>
			show_source(): Promise<any>
			show_source$($: {}): Promise<any>
			show_frame(stackitem): Promise<any>
			show_frame$({ stackitem }): Promise<any>
			show_locals(): Promise<any>
			show_locals$($: {}): Promise<any>
			show_globals(): Promise<any>
			show_globals$($: {}): Promise<any>
			show_variables(force?): Promise<any>
			show_variables$({ force }: { force?}): Promise<any>
			set_breakpoint_here(filename, lineno): Promise<any>
			set_breakpoint_here$({ filename, lineno }): Promise<any>
			clear_breakpoint_here(filename, lineno): Promise<any>
			clear_breakpoint_here$({ filename, lineno }): Promise<any>
			clear_file_breaks(filename): Promise<any>
			clear_file_breaks$({ filename }): Promise<any>

			/**
			 * Load PyShellEditorWindow breakpoints into subprocess debugger
			 */
			load_breakpoints(): Promise<any>
			load_breakpoints$($: {}): Promise<any>
			vstack
			vsource
			vlocals
			vglobals
			stackviewer
			localsviewer
			globalsviewer
		}
		function StackViewer(master, flist, gui): Promise<IStackViewer>
		function StackViewer$({ master, flist, gui }): Promise<IStackViewer>
		interface IStackViewer {
			load_stack(stack, index?): Promise<any>
			load_stack$({ stack, index }: { stack, index?}): Promise<any>

			/**
			 * override base method
			 */
			popup_event(event): Promise<any>
			popup_event$({ event }): Promise<any>

			/**
			 * override base method
			 */
			fill_menu(): Promise<any>
			fill_menu$($: {}): Promise<any>

			/**
			 * override base method
			 */
			on_select(index): Promise<any>
			on_select$({ index }): Promise<any>

			/**
			 * override base method
			 */
			on_double(index): Promise<any>
			on_double$({ index }): Promise<any>
			goto_source_line(): Promise<any>
			goto_source_line$($: {}): Promise<any>
			show_stack_frame(): Promise<any>
			show_stack_frame$($: {}): Promise<any>
			show_source(index): Promise<any>
			show_source$({ index }): Promise<any>
		}
		function NamespaceViewer(master, title, dict?): Promise<INamespaceViewer>
		function NamespaceViewer$({ master, title, dict }: { master, title, dict?}): Promise<INamespaceViewer>
		interface INamespaceViewer {
			load_dict(dict, force?, rpc_client?): Promise<any>
			load_dict$({ dict, force, rpc_client }: { dict, force?, rpc_client?}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			dict
		}
	}
	module debugger_r {
		var _
		function wrap_frame(frame): Promise<any>
		function wrap_frame$({ frame }): Promise<any>

		/**
		 * replace info[2], a traceback instance, by its ID
		 */
		function wrap_info(info): Promise<any>
		function wrap_info$({ info }): Promise<any>

		/**
		 * Start the debugger and its RPC link in the Python subprocess
		 * 
		 *     Start the subprocess side of the split debugger and set up that side of the
		 *     RPC link by instantiating the GUIProxy, Idb debugger, and IdbAdapter
		 *     objects and linking them together.  Register the IdbAdapter with the
		 *     RPCServer to handle RPC requests from the split debugger GUI via the
		 *     IdbProxy.
		 * 
		 *     
		 */
		function start_debugger(rpchandler, gui_adap_oid): Promise<any>
		function start_debugger$({ rpchandler, gui_adap_oid }): Promise<any>

		/**
		 * Start the subprocess debugger, initialize the debugger GUI and RPC link
		 * 
		 *     Request the RPCServer start the Python subprocess debugger and link.  Set
		 *     up the Idle side of the split debugger by instantiating the IdbProxy,
		 *     debugger GUI, and debugger GUIAdapter objects and linking them together.
		 * 
		 *     Register the GUIAdapter with the RPCClient to handle debugger GUI
		 *     interaction requests coming from the subprocess debugger via the GUIProxy.
		 * 
		 *     The IdbAdapter will pass execution and environment requests coming from the
		 *     Idle debugger GUI to the subprocess debugger via the IdbProxy.
		 * 
		 *     
		 */
		function start_remote_debugger(rpcclt, pyshell): Promise<any>
		function start_remote_debugger$({ rpcclt, pyshell }): Promise<any>

		/**
		 * Shut down subprocess debugger and Idle side of debugger RPC link
		 * 
		 *     Request that the RPCServer shut down the subprocess debugger and link.
		 *     Unregister the GUIAdapter, which will cause a GC on the Idle process
		 *     debugger and RPC link objects.  (The second reference to the debugger GUI
		 *     is deleted in pyshell.close_remote_debugger().)
		 * 
		 *     
		 */
		function close_remote_debugger(rpcclt): Promise<any>
		function close_remote_debugger$({ rpcclt }): Promise<any>
		function close_subprocess_debugger(rpcclt): Promise<any>
		function close_subprocess_debugger$({ rpcclt }): Promise<any>
		function restart_subprocess_debugger(rpcclt): Promise<any>
		function restart_subprocess_debugger$({ rpcclt }): Promise<any>
		function GUIProxy(conn, gui_adap_oid): Promise<IGUIProxy>
		function GUIProxy$({ conn, gui_adap_oid }): Promise<IGUIProxy>
		interface IGUIProxy {
			interaction(message, frame, info?): Promise<any>
			interaction$({ message, frame, info }: { message, frame, info?}): Promise<any>
		}
		function IdbAdapter(idb): Promise<IIdbAdapter>
		function IdbAdapter$({ idb }): Promise<IIdbAdapter>
		interface IIdbAdapter {
			set_step(): Promise<any>
			set_step$($: {}): Promise<any>
			set_quit(): Promise<any>
			set_quit$($: {}): Promise<any>
			set_continue(): Promise<any>
			set_continue$($: {}): Promise<any>
			set_next(fid): Promise<any>
			set_next$({ fid }): Promise<any>
			set_return(fid): Promise<any>
			set_return$({ fid }): Promise<any>
			get_stack(fid, tbid): Promise<any>
			get_stack$({ fid, tbid }): Promise<any>
			run(cmd): Promise<any>
			run$({ cmd }): Promise<any>
			set_break(filename, lineno): Promise<any>
			set_break$({ filename, lineno }): Promise<any>
			clear_break(filename, lineno): Promise<any>
			clear_break$({ filename, lineno }): Promise<any>
			clear_all_file_breaks(filename): Promise<any>
			clear_all_file_breaks$({ filename }): Promise<any>
			frame_attr(fid, name): Promise<any>
			frame_attr$({ fid, name }): Promise<any>
			frame_globals(fid): Promise<any>
			frame_globals$({ fid }): Promise<any>
			frame_locals(fid): Promise<any>
			frame_locals$({ fid }): Promise<any>
			frame_code(fid): Promise<any>
			frame_code$({ fid }): Promise<any>
			code_name(cid): Promise<any>
			code_name$({ cid }): Promise<any>
			code_filename(cid): Promise<any>
			code_filename$({ cid }): Promise<any>
			dict_keys(did): Promise<any>
			dict_keys$({ did }): Promise<any>
			dict_keys_list(did): Promise<any>
			dict_keys_list$({ did }): Promise<any>
			dict_item(did, key): Promise<any>
			dict_item$({ did, key }): Promise<any>
		}
		function FrameProxy(conn, fid): Promise<IFrameProxy>
		function FrameProxy$({ conn, fid }): Promise<IFrameProxy>
		interface IFrameProxy {
		}
		function CodeProxy(conn, oid, cid): Promise<ICodeProxy>
		function CodeProxy$({ conn, oid, cid }): Promise<ICodeProxy>
		interface ICodeProxy {
		}
		function DictProxy(conn, oid, did): Promise<IDictProxy>
		function DictProxy$({ conn, oid, did }): Promise<IDictProxy>
		interface IDictProxy {
			keys(): Promise<any>
			keys$($: {}): Promise<any>
		}
		function GUIAdapter(conn, gui): Promise<IGUIAdapter>
		function GUIAdapter$({ conn, gui }): Promise<IGUIAdapter>
		interface IGUIAdapter {
			interaction(message, fid, modified_info): Promise<any>
			interaction$({ message, fid, modified_info }): Promise<any>
		}
		function IdbProxy(conn, shell, oid): Promise<IIdbProxy>
		function IdbProxy$({ conn, shell, oid }): Promise<IIdbProxy>
		interface IIdbProxy {
			call(methodname): Promise<any>
			call$({ methodname }): Promise<any>
			run(cmd, locals): Promise<any>
			run$({ cmd, locals }): Promise<any>
			get_stack(frame, tbid): Promise<any>
			get_stack$({ frame, tbid }): Promise<any>
			set_continue(): Promise<any>
			set_continue$($: {}): Promise<any>
			set_step(): Promise<any>
			set_step$($: {}): Promise<any>
			set_next(frame): Promise<any>
			set_next$({ frame }): Promise<any>
			set_return(frame): Promise<any>
			set_return$({ frame }): Promise<any>
			set_quit(): Promise<any>
			set_quit$($: {}): Promise<any>
			set_break(filename, lineno): Promise<any>
			set_break$({ filename, lineno }): Promise<any>
			clear_break(filename, lineno): Promise<any>
			clear_break$({ filename, lineno }): Promise<any>
			clear_all_file_breaks(filename): Promise<any>
			clear_all_file_breaks$({ filename }): Promise<any>
		}
		let debugging: Promise<any>
		let idb_adap_oid: Promise<any>
		let gui_adap_oid: Promise<any>
		let frametable: Promise<any>
		let dicttable: Promise<any>
		let codetable: Promise<any>
		let tracebacktable: Promise<any>
	}
	module debugobj {
		var _
		function make_objecttreeitem(labeltext, object, setfunction?): Promise<any>
		function make_objecttreeitem$({ labeltext, object, setfunction }: { labeltext, object, setfunction?}): Promise<any>
		function ObjectTreeItem(labeltext, object, setfunction?): Promise<IObjectTreeItem>
		function ObjectTreeItem$({ labeltext, object, setfunction }: { labeltext, object, setfunction?}): Promise<IObjectTreeItem>
		interface IObjectTreeItem {
			GetLabelText(): Promise<any>
			GetLabelText$($: {}): Promise<any>
			GetText(): Promise<any>
			GetText$($: {}): Promise<any>
			GetIconName(): Promise<any>
			GetIconName$($: {}): Promise<any>
			IsEditable(): Promise<any>
			IsEditable$($: {}): Promise<any>
			SetText(text): Promise<any>
			SetText$({ text }): Promise<any>
			IsExpandable(): Promise<any>
			IsExpandable$($: {}): Promise<any>
			GetSubList(): Promise<any>
			GetSubList$($: {}): Promise<any>
		}
		interface IClassTreeItem extends IObjectTreeItem {
			IsExpandable(): Promise<any>
			IsExpandable$($: {}): Promise<any>
			GetSubList(): Promise<any>
			GetSubList$($: {}): Promise<any>
		}
		interface IAtomicObjectTreeItem extends IObjectTreeItem {
			IsExpandable(): Promise<any>
			IsExpandable$($: {}): Promise<any>
		}
		interface ISequenceTreeItem extends IObjectTreeItem {
			IsExpandable(): Promise<any>
			IsExpandable$($: {}): Promise<any>
			keys(): Promise<any>
			keys$($: {}): Promise<any>
			GetSubList(): Promise<any>
			GetSubList$($: {}): Promise<any>
		}
		interface IDictTreeItem extends ISequenceTreeItem {
			keys(): Promise<any>
			keys$($: {}): Promise<any>
		}
		let myrepr: Promise<any>
		let dispatch: Promise<any>
	}
	module debugobj_r {
		var _
		function remote_object_tree_item(item): Promise<any>
		function remote_object_tree_item$({ item }): Promise<any>
		function WrappedObjectTreeItem(item): Promise<IWrappedObjectTreeItem>
		function WrappedObjectTreeItem$({ item }): Promise<IWrappedObjectTreeItem>
		interface IWrappedObjectTreeItem {
		}
		function StubObjectTreeItem(sockio, oid): Promise<IStubObjectTreeItem>
		function StubObjectTreeItem$({ sockio, oid }): Promise<IStubObjectTreeItem>
		interface IStubObjectTreeItem {
		}
	}
	module delegator {
		var _
		function Delegator(delegate?): Promise<IDelegator>
		function Delegator$({ delegate }: { delegate?}): Promise<IDelegator>
		interface IDelegator {

			/**
			 * Removes added attributes while leaving original attributes.
			 */
			resetcache(): Promise<any>
			resetcache$($: {}): Promise<any>

			/**
			 * Reset attributes and change delegate.
			 */
			setdelegate(delegate): Promise<any>
			setdelegate$({ delegate }): Promise<any>
		}
	}
	module dynoption {
		var _

		/**
		 * 
		 *     unlike OptionMenu, our kwargs can include highlightthickness
		 *     
		 */
		function DynOptionMenu(master, variable, value): Promise<IDynOptionMenu>
		function DynOptionMenu$({ master, variable, value }): Promise<IDynOptionMenu>
		interface IDynOptionMenu {

			/**
			 * 
			 *         clear and reload the menu with a new set of options.
			 *         valueList - list of new options
			 *         value - initial value to set the optionmenu's menubutton to
			 *         
			 */
			SetMenu(valueList, value?): Promise<any>
			SetMenu$({ valueList, value }: { valueList, value?}): Promise<any>
		}
	}
	module editor {
		var _
		function index2line(index): Promise<any>
		function index2line$({ index }): Promise<any>

		/**
		 * Return a line's indentation as (# chars, effective # of spaces).
		 * 
		 *     The effective # of spaces is the length after properly "expanding"
		 *     the tabs into spaces, as done by str.expandtabs(tabwidth).
		 *     
		 */
		function get_line_indent(line, tabwidth): Promise<any>
		function get_line_indent$({ line, tabwidth }): Promise<any>
		function prepstr(s): Promise<any>
		function prepstr$({ s }): Promise<any>
		function get_accelerator(keydefs, eventname): Promise<any>
		function get_accelerator$({ keydefs, eventname }): Promise<any>
		function fixwordbreaks(root): Promise<any>
		function fixwordbreaks$({ root }): Promise<any>
		function EditorWindow(flist?, filename?, key?, root?): Promise<IEditorWindow>
		function EditorWindow$({ flist, filename, key, root }: { flist?, filename?, key?, root?}): Promise<IEditorWindow>
		interface IEditorWindow {
			handle_winconfig(event?): Promise<any>
			handle_winconfig$({ event }: { event?}): Promise<any>
			set_width(): Promise<any>
			set_width$($: {}): Promise<any>
			new_callback(event): Promise<any>
			new_callback$({ event }): Promise<any>
			home_callback(event): Promise<any>
			home_callback$({ event }): Promise<any>
			set_status_bar(): Promise<any>
			set_status_bar$($: {}): Promise<any>
			set_line_and_column(event?): Promise<any>
			set_line_and_column$({ event }: { event?}): Promise<any>
			createmenubar(): Promise<any>
			createmenubar$($: {}): Promise<any>
			postwindowsmenu(): Promise<any>
			postwindowsmenu$($: {}): Promise<any>

			/**
			 * Update label for menu item at index.
			 */
			update_menu_label(menu, index, label): Promise<any>
			update_menu_label$({ menu, index, label }): Promise<any>

			/**
			 * Update state for menu item at index.
			 */
			update_menu_state(menu, index, state): Promise<any>
			update_menu_state$({ menu, index, state }): Promise<any>

			/**
			 * Handle scrollbar.
			 */
			handle_yview(event): Promise<any>
			handle_yview$({ event }): Promise<any>
			right_menu_event(event): Promise<any>
			right_menu_event$({ event }): Promise<any>
			make_rmenu(): Promise<any>
			make_rmenu$($: {}): Promise<any>
			rmenu_check_cut(): Promise<any>
			rmenu_check_cut$($: {}): Promise<any>
			rmenu_check_copy(): Promise<any>
			rmenu_check_copy$($: {}): Promise<any>
			rmenu_check_paste(): Promise<any>
			rmenu_check_paste$($: {}): Promise<any>

			/**
			 * Handle Help 'About IDLE' event.
			 */
			about_dialog(event?): Promise<any>
			about_dialog$({ event }: { event?}): Promise<any>

			/**
			 * Handle Options 'Configure IDLE' event.
			 */
			config_dialog(event?): Promise<any>
			config_dialog$({ event }: { event?}): Promise<any>

			/**
			 * Handle Help 'IDLE Help' event.
			 */
			help_dialog(event?): Promise<any>
			help_dialog$({ event }: { event?}): Promise<any>
			python_docs(event?): Promise<any>
			python_docs$({ event }: { event?}): Promise<any>
			cut(event): Promise<any>
			cut$({ event }): Promise<any>
			copy(event): Promise<any>
			copy$({ event }): Promise<any>
			paste(event): Promise<any>
			paste$({ event }): Promise<any>
			select_all(event?): Promise<any>
			select_all$({ event }: { event?}): Promise<any>
			remove_selection(event?): Promise<any>
			remove_selection$({ event }: { event?}): Promise<any>

			/**
			 * Cursor move begins at start or end of selection
			 * 
			 *         When a left/right cursor key is pressed create and return to Tkinter a
			 *         function which causes a cursor move from the associated edge of the
			 *         selection.
			 * 
			 *         
			 */
			move_at_edge_if_selection(edge_index): Promise<any>
			move_at_edge_if_selection$({ edge_index }): Promise<any>
			del_word_left(event): Promise<any>
			del_word_left$({ event }): Promise<any>
			del_word_right(event): Promise<any>
			del_word_right$({ event }): Promise<any>
			find_event(event): Promise<any>
			find_event$({ event }): Promise<any>
			find_again_event(event): Promise<any>
			find_again_event$({ event }): Promise<any>
			find_selection_event(event): Promise<any>
			find_selection_event$({ event }): Promise<any>
			find_in_files_event(event): Promise<any>
			find_in_files_event$({ event }): Promise<any>
			replace_event(event): Promise<any>
			replace_event$({ event }): Promise<any>
			goto_line_event(event): Promise<any>
			goto_line_event$({ event }): Promise<any>

			/**
			 * Get module name from user and open it.
			 * 
			 *         Return module path or None for calls by open_module_browser
			 *         when latter is not invoked in named editor window.
			 *         
			 */
			open_module(): Promise<any>
			open_module$($: {}): Promise<any>
			open_module_event(event): Promise<any>
			open_module_event$({ event }): Promise<any>
			open_module_browser(event?): Promise<any>
			open_module_browser$({ event }: { event?}): Promise<any>
			open_path_browser(event?): Promise<any>
			open_path_browser$({ event }: { event?}): Promise<any>
			open_turtle_demo(event?): Promise<any>
			open_turtle_demo$({ event }: { event?}): Promise<any>
			gotoline(lineno): Promise<any>
			gotoline$({ lineno }): Promise<any>
			ispythonsource(filename): Promise<any>
			ispythonsource$({ filename }): Promise<any>
			close_hook(): Promise<any>
			close_hook$($: {}): Promise<any>
			set_close_hook(close_hook): Promise<any>
			set_close_hook$({ close_hook }): Promise<any>
			filename_change_hook(): Promise<any>
			filename_change_hook$($: {}): Promise<any>

			/**
			 * Update the color theme
			 */
			ResetColorizer(): Promise<any>
			ResetColorizer$($: {}): Promise<any>
			colorize_syntax_error(text, pos): Promise<any>
			colorize_syntax_error$({ text, pos }): Promise<any>

			/**
			 * Update the cursor blink configuration.
			 */
			update_cursor_blink(): Promise<any>
			update_cursor_blink$($: {}): Promise<any>

			/**
			 * Update the text widgets' font if it is changed
			 */
			ResetFont(): Promise<any>
			ResetFont$($: {}): Promise<any>

			/**
			 * Remove the keybindings before they are changed.
			 */
			RemoveKeybindings(): Promise<any>
			RemoveKeybindings$($: {}): Promise<any>

			/**
			 * Update the keybindings after they are changed
			 */
			ApplyKeybindings(): Promise<any>
			ApplyKeybindings$($: {}): Promise<any>

			/**
			 * Update the indentwidth if changed and not using tabs in this window
			 */
			set_notabs_indentwidth(): Promise<any>
			set_notabs_indentwidth$($: {}): Promise<any>

			/**
			 * Update the additional help entries on the Help menu
			 */
			reset_help_menu_entries(): Promise<any>
			reset_help_menu_entries$($: {}): Promise<any>

			/**
			 * Load and update the recent files list and menus
			 */
			update_recent_files_list(new_file?): Promise<any>
			update_recent_files_list$({ new_file }: { new_file?}): Promise<any>
			saved_change_hook(): Promise<any>
			saved_change_hook$($: {}): Promise<any>
			get_saved(): Promise<any>
			get_saved$($: {}): Promise<any>
			set_saved(flag): Promise<any>
			set_saved$({ flag }): Promise<any>
			reset_undo(): Promise<any>
			reset_undo$($: {}): Promise<any>
			short_title(): Promise<any>
			short_title$($: {}): Promise<any>
			long_title(): Promise<any>
			long_title$($: {}): Promise<any>
			center_insert_event(event): Promise<any>
			center_insert_event$({ event }): Promise<any>
			center(mark?): Promise<any>
			center$({ mark }: { mark?}): Promise<any>
			getwindowlines(): Promise<any>
			getwindowlines$($: {}): Promise<any>
			getlineno(mark?): Promise<any>
			getlineno$({ mark }: { mark?}): Promise<any>

			/**
			 * Return (width, height, x, y)
			 */
			get_geometry(): Promise<any>
			get_geometry$($: {}): Promise<any>
			close_event(event): Promise<any>
			close_event$({ event }): Promise<any>
			maybesave(): Promise<any>
			maybesave$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			load_extensions(): Promise<any>
			load_extensions$($: {}): Promise<any>
			unload_extensions(): Promise<any>
			unload_extensions$($: {}): Promise<any>
			load_standard_extensions(): Promise<any>
			load_standard_extensions$($: {}): Promise<any>
			get_standard_extension_names(): Promise<any>
			get_standard_extension_names$($: {}): Promise<any>
			load_extension(name): Promise<any>
			load_extension$({ name }): Promise<any>
			apply_bindings(keydefs?): Promise<any>
			apply_bindings$({ keydefs }: { keydefs?}): Promise<any>

			/**
			 * Add appropriate entries to the menus and submenus
			 * 
			 *         Menus that are absent or None in self.menudict are ignored.
			 *         
			 */
			fill_menus(menudefs?, keydefs?): Promise<any>
			fill_menus$({ menudefs, keydefs }: { menudefs?, keydefs?}): Promise<any>
			getvar(name): Promise<any>
			getvar$({ name }): Promise<any>
			setvar(name, value, vartype?): Promise<any>
			setvar$({ name, value, vartype }: { name, value, vartype?}): Promise<any>
			get_var_obj(name, vartype?): Promise<any>
			get_var_obj$({ name, vartype }: { name, vartype?}): Promise<any>
			is_char_in_string(text_index): Promise<any>
			is_char_in_string$({ text_index }): Promise<any>
			get_selection_indices(): Promise<any>
			get_selection_indices$($: {}): Promise<any>
			get_tk_tabwidth(): Promise<any>
			get_tk_tabwidth$($: {}): Promise<any>
			set_tk_tabwidth(newtabwidth): Promise<any>
			set_tk_tabwidth$({ newtabwidth }): Promise<any>
			set_indentation_params(is_py_src, guess?: boolean): Promise<any>
			set_indentation_params$({ is_py_src, guess }: { is_py_src, guess?}): Promise<any>
			smart_backspace_event(event): Promise<any>
			smart_backspace_event$({ event }): Promise<any>
			smart_indent_event(event): Promise<any>
			smart_indent_event$({ event }): Promise<any>

			/**
			 * Insert a newline and indentation after Enter keypress event.
			 * 
			 *         Properly position the cursor on the new line based on information
			 *         from the current line.  This takes into account if the current line
			 *         is a shell prompt, is empty, has selected text, contains a block
			 *         opener, contains a block closer, is a continuation line, or
			 *         is inside a string.
			 *         
			 */
			newline_and_indent_event(event): Promise<any>
			newline_and_indent_event$({ event }): Promise<any>
			reindent_to(column): Promise<any>
			reindent_to$({ column }): Promise<any>
			guess_indent(): Promise<any>
			guess_indent$($: {}): Promise<any>
			toggle_line_numbers_event(event?): Promise<any>
			toggle_line_numbers_event$({ event }: { event?}): Promise<any>
			filesystemencoding
			help_url
			allow_code_context
			allow_line_numbers
			user_input_insert_tags
			menu_specs
			rmenu
			rmenu_specs
			IDENTCHARS
			extfiles
		}
		function IndentSearcher(text, tabwidth): Promise<IIndentSearcher>
		function IndentSearcher$({ text, tabwidth }): Promise<IIndentSearcher>
		interface IIndentSearcher {
			readline(): Promise<any>
			readline$($: {}): Promise<any>
			tokeneater(type, token, start, end, line, INDENT?, NAME?, OPENERS?): Promise<any>
			tokeneater$({ type, token, start, end, line, INDENT, NAME, OPENERS }: { type, token, start, end, line, INDENT?, NAME?, OPENERS?}): Promise<any>
			run(): Promise<any>
			run$($: {}): Promise<any>
		}
		let TK_TABWIDTH_DEFAULT: Promise<any>
		let darwin: Promise<any>
		let keynames: Promise<any>
	}
	module filelist {
		var _
		function FileList(root): Promise<IFileList>
		function FileList$({ root }): Promise<IFileList>
		interface IFileList {
			open(filename, action?): Promise<any>
			open$({ filename, action }: { filename, action?}): Promise<any>
			gotofileline(filename, lineno?): Promise<any>
			gotofileline$({ filename, lineno }: { filename, lineno?}): Promise<any>
			new$({ filename }: { filename?}): Promise<any>
			close_all_callback(): Promise<any>
			close_all_callback$($: {}): Promise<any>
			unregister_maybe_terminate(edit): Promise<any>
			unregister_maybe_terminate$({ edit }): Promise<any>
			filename_changed_edit(edit): Promise<any>
			filename_changed_edit$({ edit }): Promise<any>
			canonize(filename): Promise<any>
			canonize$({ filename }): Promise<any>
		}
	}
	module format {
		var _

		/**
		 * Returns the start/stop indices enclosing the paragraph that mark is in.
		 * 
		 *     Also returns the comment format string, if any, and paragraph of text
		 *     between the start/stop indices.
		 *     
		 */
		function find_paragraph(text, mark): Promise<any>
		function find_paragraph$({ text, mark }): Promise<any>

		/**
		 * Return data reformatted to specified width (limit).
		 */
		function reformat_paragraph(data, limit): Promise<any>
		function reformat_paragraph$({ data, limit }): Promise<any>

		/**
		 * Return data reformatted to specified width with comment header.
		 */
		function reformat_comment(data, limit, comment_header): Promise<any>
		function reformat_comment$({ data, limit, comment_header }): Promise<any>

		/**
		 * Return True if line is empty or all whitespace.
		 */
		function is_all_white(line): Promise<any>
		function is_all_white$({ line }): Promise<any>

		/**
		 * Return the initial space or tab indent of line.
		 */
		function get_indent(line): Promise<any>
		function get_indent$({ line }): Promise<any>

		/**
		 * Return string with leading whitespace and '#' from line or ''.
		 * 
		 *     A null return indicates that the line is not a comment line. A non-
		 *     null return, such as '    #', will be used to find the other lines of
		 *     a comment block with the same  indent.
		 *     
		 */
		function get_comment_header(line): Promise<any>
		function get_comment_header$({ line }): Promise<any>

		/**
		 * Return a line's indentation as (# chars, effective # of spaces).
		 * 
		 *     The effective # of spaces is the length after properly "expanding"
		 *     the tabs into spaces, as done by str.expandtabs(tabwidth).
		 *     
		 */
		function get_line_indent(line, tabwidth): Promise<any>
		function get_line_indent$({ line, tabwidth }): Promise<any>

		/**
		 * Format a paragraph, comment block, or selection to a max width.
		 * 
		 *     Does basic, standard text formatting, and also understands Python
		 *     comment blocks. Thus, for editing Python source code, this
		 *     extension is really only suitable for reformatting these comment
		 *     blocks or triple-quoted strings.
		 * 
		 *     Known problems with comment reformatting:
		 *     * If there is a selection marked, and the first line of the
		 *       selection is not complete, the block will probably not be detected
		 *       as comments, and will have the normal "text formatting" rules
		 *       applied.
		 *     * If a comment block has leading whitespace that mixes tabs and
		 *       spaces, they will not be considered part of the same block.
		 *     * Fancy comments, like this bulleted list, aren't handled :-)
		 *     
		 */
		function FormatParagraph(editwin): Promise<IFormatParagraph>
		function FormatParagraph$({ editwin }): Promise<IFormatParagraph>
		interface IFormatParagraph {
			reload(): Promise<any>
			reload$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Formats paragraph to a max width specified in idleConf.
			 * 
			 *         If text is selected, format_paragraph_event will start breaking lines
			 *         at the max width, starting from the beginning selection.
			 * 
			 *         If no text is selected, format_paragraph_event uses the current
			 *         cursor location to determine the paragraph (lines of text surrounded
			 *         by blank lines) and formats it.
			 * 
			 *         The length limit parameter is for testing with a known value.
			 *         
			 */
			format_paragraph_event(event, limit?): Promise<any>
			format_paragraph_event$({ event, limit }: { event, limit?}): Promise<any>
		}

		/**
		 * Format selected text (region).
		 */
		function FormatRegion(editwin): Promise<IFormatRegion>
		function FormatRegion$({ editwin }): Promise<IFormatRegion>
		interface IFormatRegion {

			/**
			 * Return line information about the selected text region.
			 * 
			 *         If text is selected, the first and last indices will be
			 *         for the selection.  If there is no text selected, the
			 *         indices will be the current cursor location.
			 * 
			 *         Return a tuple containing (first index, last index,
			 *             string representation of text, list of text lines).
			 *         
			 */
			get_region(): Promise<any>
			get_region$($: {}): Promise<any>

			/**
			 * Replace the text between the given indices.
			 * 
			 *         Args:
			 *             head: Starting index of text to replace.
			 *             tail: Ending index of text to replace.
			 *             chars: Expected to be string of current text
			 *                 between head and tail.
			 *             lines: List of new lines to insert between head
			 *                 and tail.
			 *         
			 */
			set_region(head, tail, chars, lines): Promise<any>
			set_region$({ head, tail, chars, lines }): Promise<any>

			/**
			 * Indent region by indentwidth spaces.
			 */
			indent_region_event(event?): Promise<any>
			indent_region_event$({ event }: { event?}): Promise<any>

			/**
			 * Dedent region by indentwidth spaces.
			 */
			dedent_region_event(event?): Promise<any>
			dedent_region_event$({ event }: { event?}): Promise<any>

			/**
			 * Comment out each line in region.
			 * 
			 *         ## is appended to the beginning of each line to comment it out.
			 *         
			 */
			comment_region_event(event?): Promise<any>
			comment_region_event$({ event }: { event?}): Promise<any>

			/**
			 * Uncomment each line in region.
			 * 
			 *         Remove ## or # in the first positions of a line.  If the comment
			 *         is not in the beginning position, this command will have no effect.
			 *         
			 */
			uncomment_region_event(event?): Promise<any>
			uncomment_region_event$({ event }: { event?}): Promise<any>

			/**
			 * Convert leading spaces to tabs for each line in selected region.
			 */
			tabify_region_event(event?): Promise<any>
			tabify_region_event$({ event }: { event?}): Promise<any>

			/**
			 * Expand tabs to spaces for each line in region.
			 */
			untabify_region_event(event?): Promise<any>
			untabify_region_event$({ event }: { event?}): Promise<any>
		}

		/**
		 * Change future indents.
		 */
		function Indents(editwin): Promise<IIndents>
		function Indents$({ editwin }): Promise<IIndents>
		interface IIndents {
			toggle_tabs_event(event): Promise<any>
			toggle_tabs_event$({ event }): Promise<any>
			change_indentwidth_event(event): Promise<any>
			change_indentwidth_event$({ event }): Promise<any>
		}
		function Rstrip(editwin): Promise<IRstrip>
		function Rstrip$({ editwin }): Promise<IRstrip>
		interface IRstrip {
			do_rstrip(event?): Promise<any>
			do_rstrip$({ event }: { event?}): Promise<any>
		}
	}
	module grep {
		var _

		/**
		 * Open the Find in Files dialog.
		 * 
		 *     Module-level function to access the singleton GrepDialog
		 *     instance and open the dialog.  If text is selected, it is
		 *     used as the search phrase; otherwise, the previous entry
		 *     is used.
		 * 
		 *     Args:
		 *         text: Text widget that contains the selected text for
		 *               default search phrase.
		 *         io: iomenu.IOBinding instance with default path to search.
		 *         flist: filelist.FileList instance for OutputWindow parent.
		 *     
		 */
		function grep(text, io?, flist?): Promise<any>
		function grep$({ text, io, flist }: { text, io?, flist?}): Promise<any>

		/**
		 * Handle os.walk error.
		 */
		function walk_error(msg): Promise<any>
		function walk_error$({ msg }): Promise<any>

		/**
		 * Generate file names in dir that match pattern.
		 * 
		 *     Args:
		 *         folder: Root directory to search.
		 *         pattern: File pattern to match.
		 *         recursive: True to include subdirectories.
		 *     
		 */
		function findfiles(folder, pattern, recursive): Promise<any>
		function findfiles$({ folder, pattern, recursive }): Promise<any>

		/**
		 * Dialog for searching multiple files.
		 */

		/**
		 * Create search dialog for searching for a phrase in the file system.
		 * 
		 *         Uses SearchDialogBase as the basis for the GUI and a
		 *         searchengine instance to prepare the search.
		 * 
		 *         Attributes:
		 *             flist: filelist.Filelist instance for OutputWindow parent.
		 *             globvar: String value of Entry widget for path to search.
		 *             globent: Entry widget for globvar.  Created in
		 *                 create_entries().
		 *             recvar: Boolean value of Checkbutton widget for
		 *                 traversing through subdirectories.
		 *         
		 */
		function GrepDialog(root, engine, flist): Promise<IGrepDialog>
		function GrepDialog$({ root, engine, flist }): Promise<IGrepDialog>
		interface IGrepDialog {

			/**
			 * Make dialog visible on top of others and ready to use.
			 * 
			 *         Extend the SearchDialogBase open() to set the initial value
			 *         for globvar.
			 * 
			 *         Args:
			 *             text: Multicall object containing the text information.
			 *             searchphrase: String phrase to search.
			 *             io: iomenu.IOBinding instance containing file path.
			 *         
			 */
			open(text, searchphrase, io?): Promise<any>
			open$({ text, searchphrase, io }: { text, searchphrase, io?}): Promise<any>

			/**
			 * Create base entry widgets and add widget for search path.
			 */
			create_entries(): Promise<any>
			create_entries$($: {}): Promise<any>

			/**
			 * Add check button to recurse down subdirectories.
			 */
			create_other_buttons(): Promise<any>
			create_other_buttons$($: {}): Promise<any>

			/**
			 * Create base command buttons and add button for Search Files.
			 */
			create_command_buttons(): Promise<any>
			create_command_buttons$($: {}): Promise<any>

			/**
			 * Grep for search pattern in file path. The default command is bound
			 *         to <Return>.
			 * 
			 *         If entry values are populated, set OutputWindow as stdout
			 *         and perform search.  The search dialog is closed automatically
			 *         when the search begins.
			 *         
			 */
			default_command(event?): Promise<any>
			default_command$({ event }: { event?}): Promise<any>

			/**
			 * Search for prog within the lines of the files in path.
			 * 
			 *         For the each file in the path directory, open the file and
			 *         search each line for the matching pattern.  If the pattern is
			 *         found,  write the file and line information to stdout (which
			 *         is an OutputWindow).
			 * 
			 *         Args:
			 *             prog: The compiled, cooked search pattern.
			 *             path: String containing the search path.
			 *         
			 */
			grep_it(prog, path): Promise<any>
			grep_it$({ prog, path }): Promise<any>
			title
			icon
			needwrapbutton
		}
	}
	module help {
		var _

		/**
		 * Copy idle.html to idlelib/help.html, stripping trailing whitespace.
		 * 
		 *     Files with trailing whitespace cannot be pushed to the git cpython
		 *     repository.  For 3.x (on Windows), help.html is generated, after
		 *     editing idle.rst on the master branch, with
		 *       sphinx-build -bhtml . build/html
		 *       python_d.exe -c "from idlelib.help import copy_strip; copy_strip()"
		 *     Check build/html/library/idle.html, the help.html diff, and the text
		 *     displayed by Help => IDLE Help.  Add a blurb and create a PR.
		 * 
		 *     It can be worthwhile to occasionally generate help.html without
		 *     touching idle.rst.  Changes to the master version and to the doc
		 *     build system may result in changes that should not changed
		 *     the displayed text, but might break HelpParser.
		 * 
		 *     As long as master and maintenance versions of idle.rst remain the
		 *     same, help.html can be backported.  The internal Python version
		 *     number is not displayed.  If maintenance idle.rst diverges from
		 *     the master version, then instead of backporting help.html from
		 *     master, repeat the procedure above to generate a maintenance
		 *     version.
		 *     
		 */
		function copy_strip(): Promise<any>
		function copy_strip$($: {}): Promise<any>

		/**
		 * Create HelpWindow; called from Idle Help event handler.
		 */
		function show_idlehelp(parent): Promise<any>
		function show_idlehelp$({ parent }): Promise<any>

		/**
		 * Render help.html into a text widget.
		 * 
		 *     The overridden handle_xyz methods handle a subset of html tags.
		 *     The supplied text should have the needed tag configurations.
		 *     The behavior for unsupported tags, such as table, is undefined.
		 *     If the tags generated by Sphinx change, this class, especially
		 *     the handle_starttag and handle_endtags methods, might have to also.
		 *     
		 */
		function HelpParser(text): Promise<IHelpParser>
		function HelpParser$({ text }): Promise<IHelpParser>
		interface IHelpParser {

			/**
			 * Change indent (+1, 0, -1) and tags.
			 */
			indent(amt?): Promise<any>
			indent$({ amt }: { amt?}): Promise<any>

			/**
			 * Handle starttags in help.html.
			 */
			handle_starttag(tag, attrs): Promise<any>
			handle_starttag$({ tag, attrs }): Promise<any>

			/**
			 * Handle endtags in help.html.
			 */
			handle_endtag(tag): Promise<any>
			handle_endtag$({ tag }): Promise<any>

			/**
			 * Handle date segments in help.html.
			 */
			handle_data(data): Promise<any>
			handle_data$({ data }): Promise<any>
		}

		/**
		 * Display help.html.
		 */

		/**
		 * Configure tags and feed file to parser.
		 */
		function HelpText(parent, filename): Promise<IHelpText>
		function HelpText$({ parent, filename }): Promise<IHelpText>
		interface IHelpText {

			/**
			 * Return name of first font family derived from names.
			 */
			findfont(names): Promise<any>
			findfont$({ names }): Promise<any>
		}

		/**
		 * Display html text, scrollbar, and toc.
		 */
		function HelpFrame(parent, filename): Promise<IHelpFrame>
		function HelpFrame$({ parent, filename }): Promise<IHelpFrame>
		interface IHelpFrame {

			/**
			 * Create table of contents as drop-down menu.
			 */
			toc_menu(text): Promise<any>
			toc_menu$({ text }): Promise<any>
		}

		/**
		 * Display frame with rendered html.
		 */
		function HelpWindow(parent, filename, title): Promise<IHelpWindow>
		function HelpWindow$({ parent, filename, title }): Promise<IHelpWindow>
		interface IHelpWindow {
		}
	}
	module help_about {
		var _

		/**
		 * Return bits for platform.
		 */
		function build_bits(): Promise<any>
		function build_bits$($: {}): Promise<any>

		/**
		 * Modal about dialog for idle
		 * 
		 *     
		 */

		/**
		 * Create popup, do not return until tk widget destroyed.
		 * 
		 *         parent - parent of this dialog
		 *         title - string which is title of popup dialog
		 *         _htest - bool, change box location when running htest
		 *         _utest - bool, don't wait_window when running unittest
		 *         
		 */
		function AboutDialog(parent, title?): Promise<IAboutDialog>
		function AboutDialog$({ parent, title }: { parent, title?}): Promise<IAboutDialog>
		interface IAboutDialog {
			create_widgets(): Promise<any>
			create_widgets$($: {}): Promise<any>

			/**
			 * Handle License button event.
			 */
			show_py_license(): Promise<any>
			show_py_license$($: {}): Promise<any>

			/**
			 * Handle Copyright button event.
			 */
			show_py_copyright(): Promise<any>
			show_py_copyright$($: {}): Promise<any>

			/**
			 * Handle Python Credits button event.
			 */
			show_py_credits(): Promise<any>
			show_py_credits$($: {}): Promise<any>

			/**
			 * Handle Idle Credits button event.
			 */
			show_idle_credits(): Promise<any>
			show_idle_credits$($: {}): Promise<any>

			/**
			 * Handle Readme button event.
			 */
			show_readme(): Promise<any>
			show_readme$($: {}): Promise<any>

			/**
			 * Handle News button event.
			 */
			show_idle_news(): Promise<any>
			show_idle_news$($: {}): Promise<any>

			/**
			 * Create textview for built-in constants.
			 * 
			 *         Built-in constants have type _sitebuiltins._Printer.  The
			 *         text is extracted from the built-in and then sent to a text
			 *         viewer with self as the parent and title as the title of
			 *         the popup.
			 *         
			 */
			display_printer_text(title, printer): Promise<any>
			display_printer_text$({ title, printer }): Promise<any>

			/**
			 * Create textview for filename.
			 * 
			 *         The filename needs to be in the current directory.  The path
			 *         is sent to a text viewer with self as the parent, title as
			 *         the title of the popup, and the file encoding.
			 *         
			 */
			display_file_text(title, filename, encoding?): Promise<any>
			display_file_text$({ title, filename, encoding }: { title, filename, encoding?}): Promise<any>

			/**
			 * Dismiss help_about dialog.
			 */
			ok(event?): Promise<any>
			ok$({ event }: { event?}): Promise<any>
		}
	}
	module history {
		var _

		/**
		 *  Implement Idle Shell history mechanism.
		 * 
		 *     store - Store source statement (called from pyshell.resetoutput).
		 *     fetch - Fetch stored statement matching prefix already entered.
		 *     history_next - Bound to <<history-next>> event (default Alt-N).
		 *     history_prev - Bound to <<history-prev>> event (default Alt-P).
		 *     
		 */

		/**
		 * Initialize data attributes and bind event methods.
		 * 
		 *         .text - Idle wrapper of tk Text widget, with .bell().
		 *         .history - source statements, possibly with multiple lines.
		 *         .prefix - source already entered at prompt; filters history list.
		 *         .pointer - index into history.
		 *         .cyclic - wrap around history list (or not).
		 *         
		 */
		function History(text): Promise<IHistory>
		function History$({ text }): Promise<IHistory>
		interface IHistory {

			/**
			 * Fetch later statement; start with earliest if cyclic.
			 */
			history_next(event): Promise<any>
			history_next$({ event }): Promise<any>

			/**
			 * Fetch earlier statement; start with most recent.
			 */
			history_prev(event): Promise<any>
			history_prev$({ event }): Promise<any>

			/**
			 * Fetch statement and replace current line in text widget.
			 * 
			 *         Set prefix and pointer as needed for successive fetches.
			 *         Reset them to None, None when returning to the start line.
			 *         Sound bell when return to start line or cannot leave a line
			 *         because cyclic is False.
			 *         
			 */
			fetch(reverse): Promise<any>
			fetch$({ reverse }): Promise<any>

			/**
			 * Store Shell input statement into history list.
			 */
			store(source): Promise<any>
			store$({ source }): Promise<any>
		}
	}
	module hyperparser {
		var _

		/**
		 * To initialize, analyze the surroundings of the given index.
		 */
		function HyperParser(editwin, index): Promise<IHyperParser>
		function HyperParser$({ editwin, index }): Promise<IHyperParser>
		interface IHyperParser {

			/**
			 * Set the index to which the functions relate.
			 * 
			 *         The index must be in the same statement.
			 *         
			 */
			set_index(index): Promise<any>
			set_index$({ index }): Promise<any>

			/**
			 * Is the index given to the HyperParser in a string?
			 */
			is_in_string(): Promise<any>
			is_in_string$($: {}): Promise<any>

			/**
			 * Is the index given to the HyperParser in normal code?
			 */
			is_in_code(): Promise<any>
			is_in_code$($: {}): Promise<any>

			/**
			 * Return bracket indexes or None.
			 * 
			 *         If the index given to the HyperParser is surrounded by a
			 *         bracket defined in openers (or at least has one before it),
			 *         return the indices of the opening bracket and the closing
			 *         bracket (or the end of line, whichever comes first).
			 * 
			 *         If it is not surrounded by brackets, or the end of line comes
			 *         before the closing bracket and mustclose is True, returns None.
			 *         
			 */
			get_surrounding_brackets(openers?, mustclose?: boolean): Promise<any>
			get_surrounding_brackets$({ openers, mustclose }: { openers?, mustclose?}): Promise<any>

			/**
			 * Return a string with the Python expression which ends at the
			 *         given index, which is empty if there is no real one.
			 *         
			 */
			get_expression(): Promise<any>
			get_expression$($: {}): Promise<any>
		}
	}
	module idle {
		var _
		let idlelib_dir: Promise<any>
	}
	module iomenu {
		var _
		function IOBinding(editwin): Promise<IIOBinding>
		function IOBinding$({ editwin }): Promise<IIOBinding>
		interface IIOBinding {
			close(): Promise<any>
			close$($: {}): Promise<any>
			get_saved(): Promise<any>
			get_saved$($: {}): Promise<any>
			set_saved(flag): Promise<any>
			set_saved$({ flag }): Promise<any>
			reset_undo(): Promise<any>
			reset_undo$($: {}): Promise<any>
			set_filename_change_hook(hook): Promise<any>
			set_filename_change_hook$({ hook }): Promise<any>
			set_filename(filename): Promise<any>
			set_filename$({ filename }): Promise<any>
			open(event?, editFile?): Promise<any>
			open$({ event, editFile }: { event?, editFile?}): Promise<any>
			loadfile(filename): Promise<any>
			loadfile$({ filename }): Promise<any>
			maybesave(): Promise<any>
			maybesave$($: {}): Promise<any>
			save(event): Promise<any>
			save$({ event }): Promise<any>
			save_as(event): Promise<any>
			save_as$({ event }): Promise<any>
			save_a_copy(event): Promise<any>
			save_a_copy$({ event }): Promise<any>
			writefile(filename): Promise<any>
			writefile$({ filename }): Promise<any>

			/**
			 * Return text with final 
			 *  if needed and os eols.
			 */
			fixnewlines(): Promise<any>
			fixnewlines$($: {}): Promise<any>
			encode(chars): Promise<any>
			encode$({ chars }): Promise<any>
			print_window(event): Promise<any>
			print_window$({ event }): Promise<any>
			askopenfile(): Promise<any>
			askopenfile$($: {}): Promise<any>
			defaultfilename(mode?): Promise<any>
			defaultfilename$({ mode }: { mode?}): Promise<any>
			asksavefile(): Promise<any>
			asksavefile$($: {}): Promise<any>

			/**
			 * Update recent file list on all editor windows
			 */
			updaterecentfileslist(filename): Promise<any>
			updaterecentfileslist$({ filename }): Promise<any>
			filename_change_hook
			filename
			dirname
			eol_convention
			opendialog
			savedialog
			filetypes
			defaultextension
		}
		let encoding: Promise<any>
		let errors: Promise<any>
	}
	module macosx {
		var _

		/**
		 * 
		 *     Returns True if IDLE is using a native OS X Tk (Cocoa or Carbon).
		 *     
		 */
		function isAquaTk(): Promise<any>
		function isAquaTk$($: {}): Promise<any>

		/**
		 * 
		 *     Returns True if IDLE is using a Carbon Aqua Tk (instead of the
		 *     newer Cocoa Aqua Tk).
		 *     
		 */
		function isCarbonTk(): Promise<any>
		function isCarbonTk$($: {}): Promise<any>

		/**
		 * 
		 *     Returns True if IDLE is using a Cocoa Aqua Tk.
		 *     
		 */
		function isCocoaTk(): Promise<any>
		function isCocoaTk$($: {}): Promise<any>

		/**
		 * 
		 *     Returns True if IDLE is using an OS X X11 Tk.
		 *     
		 */
		function isXQuartz(): Promise<any>
		function isXQuartz$($: {}): Promise<any>

		/**
		 * 
		 *     Returns a string warning message if the Tk version in use appears to
		 *     be one known to cause problems with IDLE.
		 *     1. Apple Cocoa-based Tk 8.5.7 shipped with Mac OS X 10.6 is unusable.
		 *     2. Apple Cocoa-based Tk 8.5.9 in OS X 10.7 and 10.8 is better but
		 *         can still crash unexpectedly.
		 *     
		 */
		function tkVersionWarning(root): Promise<any>
		function tkVersionWarning$({ root }): Promise<any>

		/**
		 * 
		 *     Fetch the macOS system preferences.
		 *     
		 */
		function readSystemPreferences(): Promise<any>
		function readSystemPreferences$($: {}): Promise<any>

		/**
		 * 
		 *     Warn if "Prefer tabs when opening documents" is set to "Always".
		 *     
		 */
		function preferTabsPreferenceWarning(): Promise<any>
		function preferTabsPreferenceWarning$($: {}): Promise<any>

		/**
		 * 
		 *     This ensures that the application will respond to open AppleEvents, which
		 *     makes is feasible to use IDLE as the default application for python files.
		 *     
		 */
		function addOpenEventSupport(root, flist): Promise<any>
		function addOpenEventSupport$({ root, flist }): Promise<any>
		function hideTkConsole(root): Promise<any>
		function hideTkConsole$({ root }): Promise<any>

		/**
		 * 
		 *     Replace the Tk root menu by something that is more appropriate for
		 *     IDLE with an Aqua Tk.
		 *     
		 */
		function overrideRootMenu(root, flist): Promise<any>
		function overrideRootMenu$({ root, flist }): Promise<any>

		/**
		 * Removed bad AquaTk Button-2 (right) and Paste bindings.
		 * 
		 *     They prevent context menu access and seem to be gone in AquaTk8.6.
		 *     See issue #24801.
		 *     
		 */
		function fixb2context(root): Promise<any>
		function fixb2context$({ root }): Promise<any>

		/**
		 * 
		 *     Perform initial OS X customizations if needed.
		 *     Called from pyshell.main() after initial calls to Tk()
		 * 
		 *     There are currently three major versions of Tk in use on OS X:
		 *         1. Aqua Cocoa Tk (native default since OS X 10.6)
		 *         2. Aqua Carbon Tk (original native, 32-bit only, deprecated)
		 *         3. X11 (supported by some third-party distributors, deprecated)
		 *     There are various differences among the three that affect IDLE
		 *     behavior, primarily with menus, mouse key events, and accelerators.
		 *     Some one-time customizations are performed here.
		 *     Others are dynamically tested throughout idlelib by calls to the
		 *     isAquaTk(), isCarbonTk(), isCocoaTk(), isXQuartz() functions which
		 *     are initialized here as well.
		 *     
		 */
		function setupApp(root, flist): Promise<any>
		function setupApp$({ root, flist }): Promise<any>
	}
	module mainmenu {
		var _
		let menudefs: Promise<any>
		let default_keydefs: Promise<any>
	}
	module multicall {
		var _

		/**
		 * For each item of states return a list containing all combinations of
		 *     that item with individual bits reset, sorted by the number of set bits.
		 *     
		 */
		function expand_substates(states): Promise<any>
		function expand_substates$({ states }): Promise<any>

		/**
		 * Return a MultiCall class which inherits its methods from the
		 *     given widget class (for example, Tkinter.Text). This is used
		 *     instead of a templating mechanism.
		 *     
		 */
		function MultiCallCreator(widget): Promise<any>
		function MultiCallCreator$({ widget }): Promise<any>
		interface I_SimpleBinder {
			bind(triplet, func): Promise<any>
			bind$({ triplet, func }): Promise<any>
			unbind(triplet, func): Promise<any>
			unbind$({ triplet, func }): Promise<any>
		}
		interface I_ComplexBinder {
			bind(triplet, func): Promise<any>
			bind$({ triplet, func }): Promise<any>
			unbind(triplet, func): Promise<any>
			unbind$({ triplet, func }): Promise<any>
		}
		let MC_KEYPRESS: Promise<any>
		let MC_KEYRELEASE: Promise<any>
		let MC_BUTTONPRESS: Promise<any>
		let MC_BUTTONRELEASE: Promise<any>
		let MC_ACTIVATE: Promise<any>
		let MC_CIRCULATE: Promise<any>
		let MC_COLORMAP: Promise<any>
		let MC_CONFIGURE: Promise<any>
		let MC_DEACTIVATE: Promise<any>
		let MC_DESTROY: Promise<any>
		let MC_ENTER: Promise<any>
		let MC_EXPOSE: Promise<any>
		let MC_FOCUSIN: Promise<any>
		let MC_FOCUSOUT: Promise<any>
		let MC_GRAVITY: Promise<any>
		let MC_LEAVE: Promise<any>
		let MC_MAP: Promise<any>
		let MC_MOTION: Promise<any>
		let MC_MOUSEWHEEL: Promise<any>
		let MC_PROPERTY: Promise<any>
		let MC_REPARENT: Promise<any>
		let MC_UNMAP: Promise<any>
		let MC_VISIBILITY: Promise<any>
		let MC_SHIFT: Promise<any>
		let MC_CONTROL: Promise<any>
		let MC_ALT: Promise<any>
		let MC_META: Promise<any>
		let MC_OPTION: Promise<any>
		let MC_COMMAND: Promise<any>
		let APPLICATION_GONE: Promise<any>
		let r: Promise<any>
	}
	module outwin {
		var _

		/**
		 * Compile the patterns for matching to file name and line number.
		 */
		function compile_progs(): Promise<any>
		function compile_progs$($: {}): Promise<any>

		/**
		 * Extract file name and line number from line of text.
		 * 
		 *     Check if line of text contains one of the file/line patterns.
		 *     If it does and if the file and line are valid, return
		 *     a tuple of the file name and line number.  If it doesn't match
		 *     or if the file or line is invalid, return None.
		 *     
		 */
		function file_line_helper(line): Promise<any>
		function file_line_helper$({ line }): Promise<any>

		/**
		 * An editor window that can serve as an output file.
		 * 
		 *     Also the future base class for the Python shell window.
		 *     This class has no input facilities.
		 * 
		 *     Adds binding to open a file at a line to the text widget.
		 *     
		 */
		function OutputWindow(): Promise<IOutputWindow>
		function OutputWindow$({ }): Promise<IOutputWindow>
		interface IOutputWindow {

			/**
			 * Python source is only part of output: do not colorize.
			 */
			ispythonsource(filename): Promise<any>
			ispythonsource$({ filename }): Promise<any>

			/**
			 * Customize EditorWindow title.
			 */
			short_title(): Promise<any>
			short_title$($: {}): Promise<any>

			/**
			 * Customize EditorWindow to not display save file messagebox.
			 */
			maybesave(): Promise<any>
			maybesave$($: {}): Promise<any>

			/**
			 * Write text to text widget.
			 * 
			 *         The text is inserted at the given index with the provided
			 *         tags.  The text widget is then scrolled to make it visible
			 *         and updated to display it, giving the effect of seeing each
			 *         line as it is added.
			 * 
			 *         Args:
			 *             s: Text to insert into text widget.
			 *             tags: Tuple of tag strings to apply on the insert.
			 *             mark: Index for the insert.
			 * 
			 *         Return:
			 *             Length of text inserted.
			 *         
			 */
			write(s, tags?, mark?): Promise<any>
			write$({ s, tags, mark }: { s, tags?, mark?}): Promise<any>

			/**
			 * Write each item in lines iterable.
			 */
			writelines(lines): Promise<any>
			writelines$({ lines }): Promise<any>

			/**
			 * No flushing needed as write() directly writes to widget.
			 */
			flush(): Promise<any>
			flush$($: {}): Promise<any>
			showerror(): Promise<any>
			showerror$($: {}): Promise<any>

			/**
			 * Handle request to open file/line.
			 * 
			 *         If the selected or previous line in the output window
			 *         contains a file name and line number, then open that file
			 *         name in a new window and position on the line number.
			 * 
			 *         Otherwise, display an error messagebox.
			 *         
			 */
			goto_file_line(event?): Promise<any>
			goto_file_line$({ event }: { event?}): Promise<any>
			rmenu_specs
			allow_code_context
		}
		function OnDemandOutputWindow(flist): Promise<IOnDemandOutputWindow>
		function OnDemandOutputWindow$({ flist }): Promise<IOnDemandOutputWindow>
		interface IOnDemandOutputWindow {
			write(s, tags, mark): Promise<any>
			write$({ s, tags, mark }): Promise<any>
			setup(): Promise<any>
			setup$($: {}): Promise<any>
			tagdefs
		}
		let file_line_pats: Promise<any>
		let file_line_progs: Promise<any>
	}
	module parenmatch {
		var _

		/**
		 * Highlight matching openers and closers, (), [], and {}.
		 * 
		 *     There are three supported styles of paren matching.  When a right
		 *     paren (opener) is typed:
		 * 
		 *     opener -- highlight the matching left paren (closer);
		 *     parens -- highlight the left and right parens (opener and closer);
		 *     expression -- highlight the entire expression from opener to closer.
		 *     (For back compatibility, 'default' is a synonym for 'opener').
		 * 
		 *     Flash-delay is the maximum milliseconds the highlighting remains.
		 *     Any cursor movement (key press or click) before that removes the
		 *     highlight.  If flash-delay is 0, there is no maximum.
		 * 
		 *     TODO:
		 *     - Augment bell() with mismatch warning in status window.
		 *     - Highlight when cursor is moved to the right of a closer.
		 *       This might be too expensive to check.
		 *     
		 */
		function ParenMatch(editwin): Promise<IParenMatch>
		function ParenMatch$({ editwin }): Promise<IParenMatch>
		interface IParenMatch {
			reload(): Promise<any>
			reload$($: {}): Promise<any>

			/**
			 * Activate mechanism to restore text from highlighting.
			 */
			activate_restore(): Promise<any>
			activate_restore$($: {}): Promise<any>

			/**
			 * Remove restore event bindings.
			 */
			deactivate_restore(): Promise<any>
			deactivate_restore$($: {}): Promise<any>

			/**
			 * Handle editor 'show surrounding parens' event (menu or shortcut).
			 */
			flash_paren_event(event): Promise<any>
			flash_paren_event$({ event }): Promise<any>

			/**
			 * Handle user input of closer.
			 */
			paren_closed_event(event): Promise<any>
			paren_closed_event$({ event }): Promise<any>
			finish_paren_event(indices): Promise<any>
			finish_paren_event$({ indices }): Promise<any>

			/**
			 * Remove effect of doing match.
			 */
			restore_event(event?): Promise<any>
			restore_event$({ event }: { event?}): Promise<any>
			handle_restore_timer(timer_count): Promise<any>
			handle_restore_timer$({ timer_count }): Promise<any>

			/**
			 * Highlight the single paren that matches
			 */
			create_tag_opener(indices): Promise<any>
			create_tag_opener$({ indices }): Promise<any>

			/**
			 * Highlight the left and right parens
			 */
			create_tag_parens(indices): Promise<any>
			create_tag_parens$({ indices }): Promise<any>

			/**
			 * Highlight the entire expression
			 */
			create_tag_expression(indices): Promise<any>
			create_tag_expression$({ indices }): Promise<any>

			/**
			 * Highlight will remain until user input turns it off
			 *         or the insert has moved
			 */
			set_timeout_none(): Promise<any>
			set_timeout_none$($: {}): Promise<any>

			/**
			 * The last highlight created will be removed after FLASH_DELAY millisecs
			 */
			set_timeout_last(): Promise<any>
			set_timeout_last$($: {}): Promise<any>
			RESTORE_VIRTUAL_EVENT_NAME
			RESTORE_SEQUENCES
			tagfuncs
		}
		let CHECK_DELAY: Promise<any>
	}
	module pathbrowser {
		var _

		/**
		 * 
		 *         _htest - bool, change box location when running htest
		 *         
		 */
		function PathBrowser(master): Promise<IPathBrowser>
		function PathBrowser$({ master }): Promise<IPathBrowser>
		interface IPathBrowser {

			/**
			 * Set window titles.
			 */
			settitle(): Promise<any>
			settitle$($: {}): Promise<any>
			rootnode(): Promise<any>
			rootnode$($: {}): Promise<any>
		}
		interface IPathBrowserTreeItem {
			GetText(): Promise<any>
			GetText$($: {}): Promise<any>
			GetSubList(): Promise<any>
			GetSubList$($: {}): Promise<any>
		}
		function DirBrowserTreeItem(dir, packages?): Promise<IDirBrowserTreeItem>
		function DirBrowserTreeItem$({ dir, packages }: { dir, packages?}): Promise<IDirBrowserTreeItem>
		interface IDirBrowserTreeItem {
			GetText(): Promise<any>
			GetText$($: {}): Promise<any>
			GetSubList(): Promise<any>
			GetSubList$($: {}): Promise<any>

			/**
			 *  Return true for directories that are packages.
			 */
			ispackagedir(file): Promise<any>
			ispackagedir$({ file }): Promise<any>
			listmodules(allnames): Promise<any>
			listmodules$({ allnames }): Promise<any>
		}
	}
	module percolator {
		var _
		function Percolator(text): Promise<IPercolator>
		function Percolator$({ text }): Promise<IPercolator>
		interface IPercolator {
			close(): Promise<any>
			close$($: {}): Promise<any>
			insert(index, chars, tags?): Promise<any>
			insert$({ index, chars, tags }: { index, chars, tags?}): Promise<any>
			delete(index1, index2?): Promise<any>
			delete$({ index1, index2 }: { index1, index2?}): Promise<any>
			insertfilter(filter): Promise<any>
			insertfilter$({ filter }): Promise<any>
			insertfilterafter(filter, after): Promise<any>
			insertfilterafter$({ filter, after }): Promise<any>
			removefilter(filter): Promise<any>
			removefilter$({ filter }): Promise<any>
		}
	}
	module pyparse {
		var _

		/**
		 * Dict subclass that maps anything not in dict to 'x'.
		 * 
		 *     This is designed to be used with str.translate in study1.
		 *     Anything not specifically mapped otherwise becomes 'x'.
		 *     Example: replace everything except whitespace with 'x'.
		 * 
		 *     >>> keepwhite = ParseMap((ord(c), ord(c)) for c in ' \t\n\r')
		 *     >>> "a + b\tc\nd".translate(keepwhite)
		 *     'x x x\tx\nx'
		 *     
		 */
		interface IParseMap {
		}
		function Parser(indentwidth, tabwidth): Promise<IParser>
		function Parser$({ indentwidth, tabwidth }): Promise<IParser>
		interface IParser {
			set_code(s): Promise<any>
			set_code$({ s }): Promise<any>

			/**
			 * 
			 *         Return index of a good place to begin parsing, as close to the
			 *         end of the string as possible.  This will be the start of some
			 *         popular stmt like "if" or "def".  Return None if none found:
			 *         the caller should pass more prior context then, if possible, or
			 *         if not (the entire program text up until the point of interest
			 *         has already been tried) pass 0 to set_lo().
			 * 
			 *         This will be reliable iff given a reliable is_char_in_string()
			 *         function, meaning that when it says "no", it's absolutely
			 *         guaranteed that the char is not in a string.
			 *         
			 */
			find_good_parse_start(is_char_in_string): Promise<any>
			find_good_parse_start$({ is_char_in_string }): Promise<any>

			/**
			 *  Throw away the start of the string.
			 * 
			 *         Intended to be called with the result of find_good_parse_start().
			 *         
			 */
			set_lo(lo): Promise<any>
			set_lo$({ lo }): Promise<any>
			get_continuation_type(): Promise<any>
			get_continuation_type$($: {}): Promise<any>

			/**
			 * Return number of spaces the next line should be indented.
			 * 
			 *         Line continuation must be C_BRACKET.
			 *         
			 */
			compute_bracket_indent(): Promise<any>
			compute_bracket_indent$($: {}): Promise<any>

			/**
			 * Return number of physical lines in last stmt.
			 * 
			 *         The statement doesn't have to be an interesting statement.  This is
			 *         intended to be called when continuation is C_BACKSLASH.
			 *         
			 */
			get_num_lines_in_stmt(): Promise<any>
			get_num_lines_in_stmt$($: {}): Promise<any>

			/**
			 * Return number of spaces the next line should be indented.
			 * 
			 *         Line continuation must be C_BACKSLASH.  Also assume that the new
			 *         line is the first one following the initial line of the stmt.
			 *         
			 */
			compute_backslash_indent(): Promise<any>
			compute_backslash_indent$($: {}): Promise<any>

			/**
			 * Return the leading whitespace on the initial line of the last
			 *         interesting stmt.
			 *         
			 */
			get_base_indent_string(): Promise<any>
			get_base_indent_string$($: {}): Promise<any>

			/**
			 * Return True if the last interesting statement opens a block.
			 */
			is_block_opener(): Promise<any>
			is_block_opener$($: {}): Promise<any>

			/**
			 * Return True if the last interesting statement closes a block.
			 */
			is_block_closer(): Promise<any>
			is_block_closer$($: {}): Promise<any>

			/**
			 * Return bracketing structure of the last interesting statement.
			 * 
			 *         The returned tuple is in the format defined in _study2().
			 *         
			 */
			get_last_stmt_bracketing(): Promise<any>
			get_last_stmt_bracketing$($: {}): Promise<any>
		}
		let trans: Promise<any>
	}
	module pyshell {
		var _

		/**
		 * Show Idle-format warning (after replacing warnings.showwarning).
		 * 
		 *     The differences are the formatter called, the file=None replacement,
		 *     which can be None, the capture of the consequence AttributeError,
		 *     and the output of a hard-coded prompt.
		 *     
		 */
		function idle_showwarning(message, category, filename, lineno, file?, line?): Promise<any>
		function idle_showwarning$({ message, category, filename, lineno, file, line }: { message, category, filename, lineno, file?, line?}): Promise<any>

		/**
		 * Replace warning.showwarning with idle_showwarning, or reverse.
		 */
		function capture_warnings(capture): Promise<any>
		function capture_warnings$({ capture }): Promise<any>

		/**
		 * Extend linecache.checkcache to preserve the <pyshell#...> entries
		 * 
		 *     Rather than repeating the linecache code, patch it to save the
		 *     <pyshell#...> entries, call the original linecache.checkcache()
		 *     (skipping them), and then restore the saved entries.
		 * 
		 *     orig_checkcache is bound at definition time to the original
		 *     method, allowing it to be patched.
		 *     
		 */
		function extended_linecache_checkcache(filename?, orig_checkcache?): Promise<any>
		function extended_linecache_checkcache$({ filename, orig_checkcache }: { filename?, orig_checkcache?}): Promise<any>

		/**
		 * Return width long restart line formatted with filename.
		 * 
		 *     Fill line with balanced '='s, with any extras and at least one at
		 *     the beginning.  Do not end with a trailing space.
		 *     
		 */
		function restart_line(width, filename): Promise<any>
		function restart_line$({ width, filename }): Promise<any>

		/**
		 * Make paste replace selection on x11.  See issue #5124.
		 */
		function fix_x11_paste(root): Promise<any>
		function fix_x11_paste$({ root }): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>

		/**
		 * Regular text edit window in IDLE, supports breakpoints
		 */
		function PyShellEditorWindow(): Promise<IPyShellEditorWindow>
		function PyShellEditorWindow$({ }): Promise<IPyShellEditorWindow>
		interface IPyShellEditorWindow {

			/**
			 * Turn colorizing of breakpoint text on or off
			 */
			color_breakpoint_text(color?: boolean): Promise<any>
			color_breakpoint_text$({ color }: { color?}): Promise<any>
			set_breakpoint(lineno): Promise<any>
			set_breakpoint$({ lineno }): Promise<any>
			set_breakpoint_here(event?): Promise<any>
			set_breakpoint_here$({ event }: { event?}): Promise<any>
			clear_breakpoint_here(event?): Promise<any>
			clear_breakpoint_here$({ event }: { event?}): Promise<any>
			clear_file_breaks(): Promise<any>
			clear_file_breaks$($: {}): Promise<any>

			/**
			 * Save breakpoints when file is saved
			 */
			store_file_breaks(): Promise<any>
			store_file_breaks$($: {}): Promise<any>
			restore_file_breaks(): Promise<any>
			restore_file_breaks$($: {}): Promise<any>

			/**
			 * Retrieves all the breakpoints in the current window
			 */
			update_breakpoints(): Promise<any>
			update_breakpoints$($: {}): Promise<any>
			ranges_to_linenumbers(ranges): Promise<any>
			ranges_to_linenumbers$({ ranges }): Promise<any>
			rmenu_specs
		}

		/**
		 * Extend base class: IDLE supports a shell and breakpoints
		 */
		interface IPyShellFileList {
			open_shell(event?): Promise<any>
			open_shell$({ event }: { event?}): Promise<any>
			EditorWindow
			pyshell
		}

		/**
		 * Extend base class: colorizer for the shell window itself
		 */
		interface IModifiedColorDelegator {
			recolorize_main(): Promise<any>
			recolorize_main$($: {}): Promise<any>
			removecolors(): Promise<any>
			removecolors$($: {}): Promise<any>
		}

		/**
		 * Extend base class: forbid insert/delete before the I/O mark
		 */
		interface IModifiedUndoDelegator {
			insert(index, chars, tags?): Promise<any>
			insert$({ index, chars, tags }: { index, chars, tags?}): Promise<any>
			delete(index1, index2?): Promise<any>
			delete$({ index1, index2 }: { index1, index2?}): Promise<any>
			undo_event(event): Promise<any>
			undo_event$({ event }): Promise<any>
		}

		/**
		 * Delegator used to tag user input with "stdin".
		 */
		interface IUserInputTaggingDelegator {
			insert(index, chars, tags?): Promise<any>
			insert$({ index, chars, tags }: { index, chars, tags?}): Promise<any>
		}
		interface IMyRPCClient {

			/**
			 * Override the base class - just re-raise EOFError
			 */
			handle_EOF(): Promise<any>
			handle_EOF$($: {}): Promise<any>
		}
		function ModifiedInterpreter(tkconsole): Promise<IModifiedInterpreter>
		function ModifiedInterpreter$({ tkconsole }): Promise<IModifiedInterpreter>
		interface IModifiedInterpreter {
			spawn_subprocess(): Promise<any>
			spawn_subprocess$($: {}): Promise<any>
			build_subprocess_arglist(): Promise<any>
			build_subprocess_arglist$($: {}): Promise<any>
			start_subprocess(): Promise<any>
			start_subprocess$($: {}): Promise<any>
			restart_subprocess(with_cwd?: boolean, filename?): Promise<any>
			restart_subprocess$({ with_cwd, filename }: { with_cwd?, filename?}): Promise<any>
			interrupt_subprocess(): Promise<any>
			interrupt_subprocess$($: {}): Promise<any>
			kill_subprocess(): Promise<any>
			kill_subprocess$($: {}): Promise<any>

			/**
			 * Make sure subprocess is terminated
			 */
			terminate_subprocess(): Promise<any>
			terminate_subprocess$($: {}): Promise<any>
			transfer_path(with_cwd?: boolean): Promise<any>
			transfer_path$({ with_cwd }: { with_cwd?}): Promise<any>
			poll_subprocess(): Promise<any>
			poll_subprocess$($: {}): Promise<any>
			setdebugger(debuger): Promise<any>
			setdebugger$({ debuger }): Promise<any>
			getdebugger(): Promise<any>
			getdebugger$($: {}): Promise<any>

			/**
			 * Initiate the remote stack viewer from a separate thread.
			 * 
			 *         This method is called from the subprocess, and by returning from this
			 *         method we allow the subprocess to unblock.  After a bit the shell
			 *         requests the subprocess to open the remote stack viewer which returns a
			 *         static object looking at the last exception.  It is queried through
			 *         the RPC mechanism.
			 * 
			 *         
			 */
			open_remote_stack_viewer(): Promise<any>
			open_remote_stack_viewer$($: {}): Promise<any>
			remote_stack_viewer(): Promise<any>
			remote_stack_viewer$($: {}): Promise<any>

			/**
			 * Like runsource() but assumes complete exec source
			 */
			execsource(source): Promise<any>
			execsource$({ source }): Promise<any>

			/**
			 * Execute an existing file
			 */
			execfile(filename, source?): Promise<any>
			execfile$({ filename, source }: { filename, source?}): Promise<any>

			/**
			 * Extend base class method: Stuff the source in the line cache first
			 */
			runsource(source): Promise<any>
			runsource$({ source }): Promise<any>

			/**
			 * Stuff source in the filename cache
			 */
			stuffsource(source): Promise<any>
			stuffsource$({ source }): Promise<any>

			/**
			 * Prepend sys.path with file's directory if not already included
			 */
			prepend_syspath(filename): Promise<any>
			prepend_syspath$({ filename }): Promise<any>

			/**
			 * Override Interactive Interpreter method: Use Colorizing
			 * 
			 *         Color the offending position instead of printing it and pointing at it
			 *         with a caret.
			 * 
			 *         
			 */
			showsyntaxerror(filename?): Promise<any>
			showsyntaxerror$({ filename }: { filename?}): Promise<any>

			/**
			 * Extend base class method to reset output properly
			 */
			showtraceback(): Promise<any>
			showtraceback$($: {}): Promise<any>
			checklinecache(): Promise<any>
			checklinecache$($: {}): Promise<any>

			/**
			 * Run the code without invoking the debugger
			 */
			runcommand(code): Promise<any>
			runcommand$({ code }): Promise<any>

			/**
			 * Override base class method
			 */
			runcode(code): Promise<any>
			runcode$({ code }): Promise<any>

			/**
			 * Override base class method
			 */
			write(s): Promise<any>
			write$({ s }): Promise<any>
			display_port_binding_error(): Promise<any>
			display_port_binding_error$($: {}): Promise<any>
			display_no_subprocess_error(): Promise<any>
			display_no_subprocess_error$($: {}): Promise<any>
			display_executing_dialog(): Promise<any>
			display_executing_dialog$($: {}): Promise<any>
			rpcclt
			rpcsubproc
			active_seq
			debugger
			gid
		}
		function PyShell(flist?): Promise<IPyShell>
		function PyShell$({ flist }: { flist?}): Promise<IPyShell>
		interface IPyShell {
			ResetFont(): Promise<any>
			ResetFont$($: {}): Promise<any>
			ResetColorizer(): Promise<any>
			ResetColorizer$($: {}): Promise<any>
			replace_event(event): Promise<any>
			replace_event$({ event }): Promise<any>
			get_standard_extension_names(): Promise<any>
			get_standard_extension_names$($: {}): Promise<any>

			/**
			 * Copy selected lines to the clipboard, with prompts.
			 * 
			 *         This makes the copied text useful for doc-tests and interactive
			 *         shell code examples.
			 * 
			 *         This always copies entire lines, even if only part of the first
			 *         and/or last lines is selected.
			 *         
			 */
			copy_with_prompts_callback(event?): Promise<any>
			copy_with_prompts_callback$({ event }: { event?}): Promise<any>
			set_warning_stream(stream): Promise<any>
			set_warning_stream$({ stream }): Promise<any>
			get_warning_stream(): Promise<any>
			get_warning_stream$($: {}): Promise<any>
			toggle_debugger(event?): Promise<any>
			toggle_debugger$({ event }: { event?}): Promise<any>
			set_debugger_indicator(): Promise<any>
			set_debugger_indicator$($: {}): Promise<any>
			toggle_jit_stack_viewer(event?): Promise<any>
			toggle_jit_stack_viewer$({ event }: { event?}): Promise<any>
			close_debugger(): Promise<any>
			close_debugger$($: {}): Promise<any>
			open_debugger(): Promise<any>
			open_debugger$($: {}): Promise<any>
			debug_menu_postcommand(): Promise<any>
			debug_menu_postcommand$($: {}): Promise<any>

			/**
			 * Helper for ModifiedInterpreter
			 */
			beginexecuting(): Promise<any>
			beginexecuting$($: {}): Promise<any>

			/**
			 * Helper for ModifiedInterpreter
			 */
			endexecuting(): Promise<any>
			endexecuting$($: {}): Promise<any>

			/**
			 * Extend EditorWindow.close()
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Override EditorWindow method: never remove the colorizer
			 */
			ispythonsource(filename): Promise<any>
			ispythonsource$({ filename }): Promise<any>
			short_title(): Promise<any>
			short_title$($: {}): Promise<any>
			begin(): Promise<any>
			begin$($: {}): Promise<any>
			stop_readline(): Promise<any>
			stop_readline$($: {}): Promise<any>
			readline(): Promise<any>
			readline$($: {}): Promise<any>
			isatty(): Promise<any>
			isatty$($: {}): Promise<any>
			cancel_callback(event?): Promise<any>
			cancel_callback$({ event }: { event?}): Promise<any>
			eof_callback(event): Promise<any>
			eof_callback$({ event }): Promise<any>
			linefeed_callback(event): Promise<any>
			linefeed_callback$({ event }): Promise<any>
			enter_callback(event): Promise<any>
			enter_callback$({ event }): Promise<any>
			recall(s, event): Promise<any>
			recall$({ s, event }): Promise<any>
			runit(): Promise<any>
			runit$($: {}): Promise<any>
			open_stack_viewer(event?): Promise<any>
			open_stack_viewer$({ event }: { event?}): Promise<any>
			view_restart_mark(event?): Promise<any>
			view_restart_mark$({ event }: { event?}): Promise<any>

			/**
			 * Callback for Run/Restart Shell Cntl-F6
			 */
			restart_shell(event?): Promise<any>
			restart_shell$({ event }: { event?}): Promise<any>
			showprompt(): Promise<any>
			showprompt$($: {}): Promise<any>
			show_warning(msg): Promise<any>
			show_warning$({ msg }): Promise<any>
			resetoutput(): Promise<any>
			resetoutput$($: {}): Promise<any>
			write(s, tags?): Promise<any>
			write$({ s, tags }: { s, tags?}): Promise<any>
			rmenu_check_cut(): Promise<any>
			rmenu_check_cut$($: {}): Promise<any>
			rmenu_check_paste(): Promise<any>
			rmenu_check_paste$($: {}): Promise<any>
			squeeze_current_text_event(event?): Promise<any>
			squeeze_current_text_event$({ event }: { event?}): Promise<any>
			on_squeezed_expand(index, text, tags): Promise<any>
			on_squeezed_expand$({ index, text, tags }): Promise<any>
			shell_title
			ColorDelegator
			UndoDelegator
			menu_specs
			allow_line_numbers
			user_input_insert_tags
			reading
			executing
			canceled
			endoffile
			closing
			COPYRIGHT
		}
		let PROCESS_SYSTEM_DPI_AWARE: Promise<any>
		let root: Promise<any>
		let use_subprocess: Promise<any>
		let HOST: Promise<any>
		let PORT: Promise<any>
		let warning_stream: Promise<any>
		let usage_msg: Promise<any>
	}
	module query {
		var _

		/**
		 * Base class for getting verified answer from a user.
		 * 
		 *     For this base class, accept any non-blank string.
		 *     
		 */

		/**
		 * Create modal popup, return when destroyed.
		 * 
		 *         Additional subclass init must be done before this unless
		 *         _utest=True is passed to suppress wait_window().
		 * 
		 *         title - string, title of popup dialog
		 *         message - string, informational message to display
		 *         text0 - initial value for entry
		 *         used_names - names already in use
		 *         _htest - bool, change box location when running htest
		 *         _utest - bool, leave window hidden and not modal
		 *         
		 */
		function Query(parent, title, message): Promise<IQuery>
		function Query$({ parent, title, message }): Promise<IQuery>
		interface IQuery {

			/**
			 * Create entry (rows, extras, buttons.
			 * 
			 *         Entry stuff on rows 0-2, spanning cols 0-2.
			 *         Buttons on row 99, cols 1, 2.
			 *         
			 */
			create_widgets(ok_text?): Promise<any>
			create_widgets$({ ok_text }: { ok_text?}): Promise<any>
			create_extra(): Promise<any>
			create_extra$($: {}): Promise<any>
			showerror(message, widget?): Promise<any>
			showerror$({ message, widget }: { message, widget?}): Promise<any>

			/**
			 * Return non-blank entry or None.
			 */
			entry_ok(): Promise<any>
			entry_ok$($: {}): Promise<any>

			/**
			 * If entry is valid, bind it to 'result' and destroy tk widget.
			 * 
			 *         Otherwise leave dialog open for user to correct entry or cancel.
			 *         
			 */
			ok(event?): Promise<any>
			ok$({ event }: { event?}): Promise<any>

			/**
			 * Set dialog result to None and destroy tk widget.
			 */
			cancel(event?): Promise<any>
			cancel$({ event }: { event?}): Promise<any>
			destroy(): Promise<any>
			destroy$($: {}): Promise<any>
		}

		/**
		 * Get a name for a config file section name.
		 */
		function SectionName(parent, title, message, used_names): Promise<ISectionName>
		function SectionName$({ parent, title, message, used_names }): Promise<ISectionName>
		interface ISectionName extends IQuery {

			/**
			 * Return sensible ConfigParser section name or None.
			 */
			entry_ok(): Promise<any>
			entry_ok$($: {}): Promise<any>
		}

		/**
		 * Get a module name for Open Module menu entry.
		 */
		function ModuleName(parent, title, message, text0): Promise<IModuleName>
		function ModuleName$({ parent, title, message, text0 }): Promise<IModuleName>
		interface IModuleName extends IQuery {

			/**
			 * Return entered module name as file path or None.
			 */
			entry_ok(): Promise<any>
			entry_ok$($: {}): Promise<any>
		}

		/**
		 * Get a positive line number for editor Go To Line.
		 */
		interface IGoto extends IQuery {
			entry_ok(): Promise<any>
			entry_ok$($: {}): Promise<any>
		}

		/**
		 * Get menu name and help source for Help menu.
		 */

		/**
		 * Get menu entry and url/local file for Additional Help.
		 * 
		 *         User enters a name for the Help resource and a web url or file
		 *         name. The user can browse for the file.
		 *         
		 */
		function HelpSource(parent, title): Promise<IHelpSource>
		function HelpSource$({ parent, title }): Promise<IHelpSource>
		interface IHelpSource extends IQuery {

			/**
			 * Add path widjets to rows 10-12.
			 */
			create_extra(): Promise<any>
			create_extra$($: {}): Promise<any>
			askfilename(filetypes, initdir, initfile): Promise<any>
			askfilename$({ filetypes, initdir, initfile }): Promise<any>
			browse_file(): Promise<any>
			browse_file$($: {}): Promise<any>

			/**
			 * Simple validity check for menu file path
			 */
			path_ok(): Promise<any>
			path_ok$($: {}): Promise<any>

			/**
			 * Return apparently valid (name, path) or None
			 */
			entry_ok(): Promise<any>
			entry_ok$($: {}): Promise<any>
			item_ok
		}

		/**
		 * Get settings for custom run of module.
		 * 
		 *     1. Command line arguments to extend sys.argv.
		 *     2. Whether to restart Shell or not.
		 *     
		 */

		/**
		 * cli_args is a list of strings.
		 * 
		 *         The list is assigned to the default Entry StringVar.
		 *         The strings are displayed joined by ' ' for display.
		 *         
		 */
		function CustomRun(parent, title): Promise<ICustomRun>
		function CustomRun$({ parent, title }): Promise<ICustomRun>
		interface ICustomRun extends IQuery {

			/**
			 * Add run mode on rows 10-12.
			 */
			create_extra(): Promise<any>
			create_extra$($: {}): Promise<any>

			/**
			 * Validity check and parsing for command line arguments.
			 */
			cli_args_ok(): Promise<any>
			cli_args_ok$($: {}): Promise<any>

			/**
			 * Return apparently valid (cli_args, restart) or None.
			 */
			entry_ok(): Promise<any>
			entry_ok$($: {}): Promise<any>
		}
	}
	module redirector {
		var _

		/**
		 * Support for redirecting arbitrary widget subcommands.
		 * 
		 *     Some Tk operations don't normally pass through tkinter.  For example, if a
		 *     character is inserted into a Text widget by pressing a key, a default Tk
		 *     binding to the widget's 'insert' operation is activated, and the Tk library
		 *     processes the insert without calling back into tkinter.
		 * 
		 *     Although a binding to <Key> could be made via tkinter, what we really want
		 *     to do is to hook the Tk 'insert' operation itself.  For one thing, we want
		 *     a text.insert call in idle code to have the same effect as a key press.
		 * 
		 *     When a widget is instantiated, a Tcl command is created whose name is the
		 *     same as the pathname widget._w.  This command is used to invoke the various
		 *     widget operations, e.g. insert (for a Text widget). We are going to hook
		 *     this command and provide a facility ('register') to intercept the widget
		 *     operation.  We will also intercept method calls on the tkinter class
		 *     instance that represents the tk widget.
		 * 
		 *     In IDLE, WidgetRedirector is used in Percolator to intercept Text
		 *     commands.  The function being registered provides access to the top
		 *     of a Percolator chain.  At the bottom of the chain is a call to the
		 *     original Tk widget operation.
		 *     
		 */

		/**
		 * Initialize attributes and setup redirection.
		 * 
		 *         _operations: dict mapping operation name to new function.
		 *         widget: the widget whose tcl command is to be intercepted.
		 *         tk: widget.tk, a convenience attribute, probably not needed.
		 *         orig: new name of the original tcl command.
		 * 
		 *         Since renaming to orig fails with TclError when orig already
		 *         exists, only one WidgetDirector can exist for a given widget.
		 *         
		 */
		function WidgetRedirector(widget): Promise<IWidgetRedirector>
		function WidgetRedirector$({ widget }): Promise<IWidgetRedirector>
		interface IWidgetRedirector {

			/**
			 * Unregister operations and revert redirection created by .__init__.
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Return OriginalCommand(operation) after registering function.
			 * 
			 *         Registration adds an operation: function pair to ._operations.
			 *         It also adds a widget function attribute that masks the tkinter
			 *         class instance method.  Method masking operates independently
			 *         from command dispatch.
			 * 
			 *         If a second function is registered for the same operation, the
			 *         first function is replaced in both places.
			 *         
			 */
			register(operation, func): Promise<any>
			register$({ operation, func }): Promise<any>

			/**
			 * Return the function for the operation, or None.
			 * 
			 *         Deleting the instance attribute unmasks the class attribute.
			 *         
			 */
			unregister(operation): Promise<any>
			unregister$({ operation }): Promise<any>

			/**
			 * Callback from Tcl which runs when the widget is referenced.
			 * 
			 *         If an operation has been registered in self._operations, apply the
			 *         associated function to the args passed into Tcl. Otherwise, pass the
			 *         operation through to Tk via the original Tcl function.
			 * 
			 *         Note that if a registered function is called, the operation is not
			 *         passed through to Tk.  Apply the function returned by self.register()
			 *         to *args to accomplish that.  For an example, see colorizer.py.
			 * 
			 *         
			 */
			dispatch(operation): Promise<any>
			dispatch$({ operation }): Promise<any>
		}

		/**
		 * Callable for original tk command that has been redirected.
		 * 
		 *     Returned by .register; can be used in the function registered.
		 *     redir = WidgetRedirector(text)
		 *     def my_insert(*args):
		 *         print("insert", args)
		 *         original_insert(*args)
		 *     original_insert = redir.register("insert", my_insert)
		 *     
		 */

		/**
		 * Create .tk_call and .orig_and_operation for .__call__ method.
		 * 
		 *         .redir and .operation store the input args for __repr__.
		 *         .tk and .orig copy attributes of .redir (probably not needed).
		 *         
		 */
		function OriginalCommand(redir, operation): Promise<IOriginalCommand>
		function OriginalCommand$({ redir, operation }): Promise<IOriginalCommand>
		interface IOriginalCommand {
		}
	}
	module replace {
		var _

		/**
		 * Create or reuse a singleton ReplaceDialog instance.
		 * 
		 *     The singleton dialog saves user entries and preferences
		 *     across instances.
		 * 
		 *     Args:
		 *         text: Text widget containing the text to be searched.
		 *     
		 */
		function replace(text, insert_tags?): Promise<any>
		function replace$({ text, insert_tags }: { text, insert_tags?}): Promise<any>

		/**
		 * Dialog for finding and replacing a pattern in text.
		 */

		/**
		 * Create search dialog for finding and replacing text.
		 * 
		 *         Uses SearchDialogBase as the basis for the GUI and a
		 *         searchengine instance to prepare the search.
		 * 
		 *         Attributes:
		 *             replvar: StringVar containing 'Replace with:' value.
		 *             replent: Entry widget for replvar.  Created in
		 *                 create_entries().
		 *             ok: Boolean used in searchengine.search_text to indicate
		 *                 whether the search includes the selection.
		 *         
		 */
		function ReplaceDialog(root, engine): Promise<IReplaceDialog>
		function ReplaceDialog$({ root, engine }): Promise<IReplaceDialog>
		interface IReplaceDialog {

			/**
			 * Make dialog visible on top of others and ready to use.
			 * 
			 *         Also, highlight the currently selected text and set the
			 *         search to include the current selection (self.ok).
			 * 
			 *         Args:
			 *             text: Text widget being searched.
			 *         
			 */
			open(text, insert_tags?): Promise<any>
			open$({ text, insert_tags }: { text, insert_tags?}): Promise<any>

			/**
			 * Create base and additional label and text entry widgets.
			 */
			create_entries(): Promise<any>
			create_entries$($: {}): Promise<any>

			/**
			 * Create base and additional command buttons.
			 * 
			 *         The additional buttons are for Find, Replace,
			 *         Replace+Find, and Replace All.
			 *         
			 */
			create_command_buttons(): Promise<any>
			create_command_buttons$($: {}): Promise<any>

			/**
			 * Handle the Find button.
			 */
			find_it(event?): Promise<any>
			find_it$({ event }: { event?}): Promise<any>

			/**
			 * Handle the Replace button.
			 * 
			 *         If the find is successful, then perform replace.
			 *         
			 */
			replace_it(event?): Promise<any>
			replace_it$({ event }: { event?}): Promise<any>

			/**
			 * Handle the Replace+Find button as the default command.
			 * 
			 *         First performs a replace and then, if the replace was
			 *         successful, a find next.
			 *         
			 */
			default_command(event?): Promise<any>
			default_command$({ event }: { event?}): Promise<any>

			/**
			 * Handle the Replace All button.
			 * 
			 *         Search text for occurrences of the Find value and replace
			 *         each of them.  The 'wrap around' value controls the start
			 *         point for searching.  If wrap isn't set, then the searching
			 *         starts at the first occurrence after the current selection;
			 *         if wrap is set, the replacement starts at the first line.
			 *         The replacement is always done top-to-bottom in the text.
			 *         
			 */
			replace_all(event?): Promise<any>
			replace_all$({ event }: { event?}): Promise<any>

			/**
			 * Search for and highlight next occurrence of pattern in text.
			 * 
			 *         No text replacement is done with this option.
			 *         
			 */
			do_find(ok?: boolean): Promise<any>
			do_find$({ ok }: { ok?}): Promise<any>

			/**
			 * Replace search pattern in text with replacement value.
			 */
			do_replace(): Promise<any>
			do_replace$($: {}): Promise<any>

			/**
			 * Highlight text between first and last indices.
			 * 
			 *         Text is highlighted via the 'hit' tag and the marked
			 *         section is brought into view.
			 * 
			 *         The colors from the 'hit' tag aren't currently shown
			 *         when the text is displayed.  This is due to the 'sel'
			 *         tag being added first, so the colors in the 'sel'
			 *         config are seen instead of the colors for 'hit'.
			 *         
			 */
			show_hit(first, last): Promise<any>
			show_hit$({ first, last }): Promise<any>

			/**
			 * Close the dialog and remove hit tags.
			 */
			close(event?): Promise<any>
			close$({ event }: { event?}): Promise<any>
			title
			icon
		}
	}
	module rpc {
		var _

		/**
		 * Return code object from marshal string ms.
		 */
		function unpickle_code(ms): Promise<any>
		function unpickle_code$({ ms }): Promise<any>

		/**
		 * Return unpickle function and tuple with marshalled co code object.
		 */
		function pickle_code(co): Promise<any>
		function pickle_code$({ co }): Promise<any>

		/**
		 * Return pickled (or marshalled) string for obj.
		 */
		function dumps(obj, protocol?): Promise<any>
		function dumps$({ obj, protocol }: { obj, protocol?}): Promise<any>
		function remoteref(obj): Promise<any>
		function remoteref$({ obj }): Promise<any>

		/**
		 * Override standard display hook to use non-locale encoding
		 */
		function displayhook(value): Promise<any>
		function displayhook$({ value }): Promise<any>
		interface ICodePickler {
			dispatch_table
		}
		function RPCServer(addr, handlerclass?): Promise<IRPCServer>
		function RPCServer$({ addr, handlerclass }: { addr, handlerclass?}): Promise<IRPCServer>
		interface IRPCServer {

			/**
			 * Override TCPServer method, no bind() phase for connecting entity
			 */
			server_bind(): Promise<any>
			server_bind$($: {}): Promise<any>

			/**
			 * Override TCPServer method, connect() instead of listen()
			 * 
			 *         Due to the reversed connection, self.server_address is actually the
			 *         address of the Idle Client to which we are connecting.
			 * 
			 *         
			 */
			server_activate(): Promise<any>
			server_activate$($: {}): Promise<any>

			/**
			 * Override TCPServer method, return already connected socket
			 */
			get_request(): Promise<any>
			get_request$($: {}): Promise<any>

			/**
			 * Override TCPServer method
			 * 
			 *         Error message goes to __stderr__.  No error message if exiting
			 *         normally or socket raised EOF.  Other exceptions not handled in
			 *         server code will cause os._exit.
			 * 
			 *         
			 */
			handle_error(request, client_address): Promise<any>
			handle_error$({ request, client_address }): Promise<any>
		}
		function SocketIO(sock, objtable?, debugging?): Promise<ISocketIO>
		function SocketIO$({ sock, objtable, debugging }: { sock, objtable?, debugging?}): Promise<ISocketIO>
		interface ISocketIO {
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * override for specific exit action
			 */
			exithook(): Promise<any>
			exithook$($: {}): Promise<any>
			debug(): Promise<any>
			debug$($: {}): Promise<any>
			register(oid, object): Promise<any>
			register$({ oid, object }): Promise<any>
			unregister(oid): Promise<any>
			unregister$({ oid }): Promise<any>
			localcall(seq, request): Promise<any>
			localcall$({ seq, request }): Promise<any>
			remotecall(oid, methodname, args, kwargs): Promise<any>
			remotecall$({ oid, methodname, args, kwargs }): Promise<any>
			remotequeue(oid, methodname, args, kwargs): Promise<any>
			remotequeue$({ oid, methodname, args, kwargs }): Promise<any>
			asynccall(oid, methodname, args, kwargs): Promise<any>
			asynccall$({ oid, methodname, args, kwargs }): Promise<any>
			asyncqueue(oid, methodname, args, kwargs): Promise<any>
			asyncqueue$({ oid, methodname, args, kwargs }): Promise<any>
			asyncreturn(seq): Promise<any>
			asyncreturn$({ seq }): Promise<any>
			decoderesponse(response): Promise<any>
			decoderesponse$({ response }): Promise<any>
			decode_interrupthook(): Promise<any>
			decode_interrupthook$($: {}): Promise<any>

			/**
			 * Listen on socket until I/O not ready or EOF
			 * 
			 *         pollresponse() will loop looking for seq number None, which
			 *         never comes, and exit on EOFError.
			 * 
			 *         
			 */
			mainloop(): Promise<any>
			mainloop$($: {}): Promise<any>
			getresponse(myseq, wait): Promise<any>
			getresponse$({ myseq, wait }): Promise<any>
			newseq(): Promise<any>
			newseq$($: {}): Promise<any>
			putmessage(message): Promise<any>
			putmessage$({ message }): Promise<any>
			pollpacket(wait): Promise<any>
			pollpacket$({ wait }): Promise<any>
			pollmessage(wait): Promise<any>
			pollmessage$({ wait }): Promise<any>

			/**
			 * Handle messages received on the socket.
			 * 
			 *         Some messages received may be asynchronous 'call' or 'queue' requests,
			 *         and some may be responses for other threads.
			 * 
			 *         'call' requests are passed to self.localcall() with the expectation of
			 *         immediate execution, during which time the socket is not serviced.
			 * 
			 *         'queue' requests are used for tasks (which may block or hang) to be
			 *         processed in a different thread.  These requests are fed into
			 *         request_queue by self.localcall().  Responses to queued requests are
			 *         taken from response_queue and sent across the link with the associated
			 *         sequence numbers.  Messages in the queues are (sequence_number,
			 *         request/response) tuples and code using this module removing messages
			 *         from the request_queue is responsible for returning the correct
			 *         sequence number in the response_queue.
			 * 
			 *         pollresponse() will loop until a response message with the myseq
			 *         sequence number is received, and will save other responses in
			 *         self.responses and notify the owning thread.
			 * 
			 *         
			 */
			pollresponse(myseq, wait): Promise<any>
			pollresponse$({ myseq, wait }): Promise<any>

			/**
			 * action taken upon link being closed by peer
			 */
			handle_EOF(): Promise<any>
			handle_EOF$($: {}): Promise<any>

			/**
			 * Classes using rpc client/server can override to augment EOF action
			 */
			EOFhook(): Promise<any>
			EOFhook$($: {}): Promise<any>
			nextseq
			buff
			bufneed
			bufstate
		}
		interface IRemoteObject {
		}
		function RemoteProxy(oid): Promise<IRemoteProxy>
		function RemoteProxy$({ oid }): Promise<IRemoteProxy>
		interface IRemoteProxy {
		}
		function RPCHandler(sock, addr, svr): Promise<IRPCHandler>
		function RPCHandler$({ sock, addr, svr }): Promise<IRPCHandler>
		interface IRPCHandler extends ISocketIO {

			/**
			 * handle() method required by socketserver
			 */
			handle(): Promise<any>
			handle$($: {}): Promise<any>
			get_remote_proxy(oid): Promise<any>
			get_remote_proxy$({ oid }): Promise<any>
			debugging
			location
		}
		function RPCClient(address, family?, type?): Promise<IRPCClient>
		function RPCClient$({ address, family, type }: { address, family?, type?}): Promise<IRPCClient>
		interface IRPCClient extends ISocketIO {
			accept(): Promise<any>
			accept$($: {}): Promise<any>
			get_remote_proxy(oid): Promise<any>
			get_remote_proxy$({ oid }): Promise<any>
		}
		function RPCProxy(sockio, oid): Promise<IRPCProxy>
		function RPCProxy$({ sockio, oid }): Promise<IRPCProxy>
		interface IRPCProxy {
		}
		function MethodProxy(sockio, oid, name): Promise<IMethodProxy>
		function MethodProxy$({ sockio, oid, name }): Promise<IMethodProxy>
		interface IMethodProxy {
		}
		let BUFSIZE: Promise<any>
		let LOCALHOST: Promise<any>
		let objecttable: Promise<any>
		let request_queue: Promise<any>
		let response_queue: Promise<any>
	}
	module run {
		var _

		/**
		 * Format warnings the IDLE way.
		 */
		function idle_formatwarning(message, category, filename, lineno, line?): Promise<any>
		function idle_formatwarning$({ message, category, filename, lineno, line }: { message, category, filename, lineno, line?}): Promise<any>

		/**
		 * Show Idle-format warning after replacing warnings.showwarning.
		 * 
		 *     The only difference is the formatter called.
		 *     
		 */
		function idle_showwarning_subproc(message, category, filename, lineno, file?, line?): Promise<any>
		function idle_showwarning_subproc$({ message, category, filename, lineno, file, line }: { message, category, filename, lineno, file?, line?}): Promise<any>

		/**
		 * Replace warning.showwarning with idle_showwarning_subproc, or reverse.
		 */
		function capture_warnings(capture): Promise<any>
		function capture_warnings$({ capture }): Promise<any>

		/**
		 * Process any tk events that are ready to be dispatched if tkinter
		 *     has been imported, a tcl interpreter has been created and tk has been
		 *     loaded.
		 */
		function handle_tk_events(tcl?): Promise<any>
		function handle_tk_events$({ tcl }: { tcl?}): Promise<any>

		/**
		 * Start the Python execution server in a subprocess
		 * 
		 *     In the Python subprocess, RPCServer is instantiated with handlerclass
		 *     MyHandler, which inherits register/unregister methods from RPCHandler via
		 *     the mix-in class SocketIO.
		 * 
		 *     When the RPCServer 'server' is instantiated, the TCPServer initialization
		 *     creates an instance of run.MyHandler and calls its handle() method.
		 *     handle() instantiates a run.Executive object, passing it a reference to the
		 *     MyHandler object.  That reference is saved as attribute rpchandler of the
		 *     Executive instance.  The Executive methods have access to the reference and
		 *     can pass it on to entities that they command
		 *     (e.g. debugger_r.Debugger.start_debugger()).  The latter, in turn, can
		 *     call MyHandler(SocketIO) register/unregister methods via the reference to
		 *     register and unregister themselves.
		 * 
		 *     
		 */
		function main(del_exitfunc?: boolean): Promise<any>
		function main$({ del_exitfunc }: { del_exitfunc?}): Promise<any>
		function manage_socket(address): Promise<any>
		function manage_socket$({ address }): Promise<any>

		/**
		 * Display socket error from manage_socket.
		 */
		function show_socket_error(err, address): Promise<any>
		function show_socket_error$({ err, address }): Promise<any>

		/**
		 * Return line composing the exception message.
		 */
		function get_message_lines(typ, exc, tb): Promise<any>
		function get_message_lines$({ typ, exc, tb }): Promise<any>
		function print_exception(): Promise<any>
		function print_exception$($: {}): Promise<any>

		/**
		 * Remove excluded traces from beginning/end of tb; get cached lines
		 */
		function cleanup_traceback(tb, exclude): Promise<any>
		function cleanup_traceback$({ tb, exclude }): Promise<any>

		/**
		 * XXX How to do this now?
		 */
		function flush_stdout(): Promise<any>
		function flush_stdout$($: {}): Promise<any>

		/**
		 * Exit subprocess, possibly after first clearing exit functions.
		 * 
		 *     If config-main.cfg/.def 'General' 'delete-exitfunc' is True, then any
		 *     functions registered with atexit will be removed before exiting.
		 *     (VPython support)
		 * 
		 *     
		 */
		function exit(): Promise<any>
		function exit$($: {}): Promise<any>

		/**
		 * Scale fonts on HiDPI displays.
		 */
		function fix_scaling(root): Promise<any>
		function fix_scaling$({ root }): Promise<any>
		function fixdoc(fun, text): Promise<any>
		function fixdoc$({ fun, text }): Promise<any>

		/**
		 * Install wrappers to always add 30 to the recursion limit.
		 */
		function install_recursionlimit_wrappers(): Promise<any>
		function install_recursionlimit_wrappers$($: {}): Promise<any>

		/**
		 * Uninstall the recursion limit wrappers from the sys module.
		 * 
		 *     IDLE only uses this for tests. Users can import run and call
		 *     this to remove the wrapping.
		 *     
		 */
		function uninstall_recursionlimit_wrappers(): Promise<any>
		function uninstall_recursionlimit_wrappers$($: {}): Promise<any>
		interface IMyRPCServer {

			/**
			 * Override RPCServer method for IDLE
			 * 
			 *         Interrupt the MainThread and exit server if link is dropped.
			 * 
			 *         
			 */
			handle_error(request, client_address): Promise<any>
			handle_error$({ request, client_address }): Promise<any>
		}
		function StdioFile(shell, tags, encoding?, errors?): Promise<IStdioFile>
		function StdioFile$({ shell, tags, encoding, errors }: { shell, tags, encoding?, errors?}): Promise<IStdioFile>
		interface IStdioFile {
			encoding(): Promise<any>
			encoding$($: {}): Promise<any>
			errors(): Promise<any>
			errors$($: {}): Promise<any>
			name(): Promise<any>
			name$($: {}): Promise<any>
			isatty(): Promise<any>
			isatty$($: {}): Promise<any>
		}
		interface IStdOutputFile extends IStdioFile {
			writable(): Promise<any>
			writable$($: {}): Promise<any>
			write(s): Promise<any>
			write$({ s }): Promise<any>
		}
		interface IStdInputFile extends IStdioFile {
			readable(): Promise<any>
			readable$($: {}): Promise<any>
			read(size?): Promise<any>
			read$({ size }: { size?}): Promise<any>
			readline(size?): Promise<any>
			readline$({ size }: { size?}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
		}
		interface IMyHandler {

			/**
			 * Override base method
			 */
			handle(): Promise<any>
			handle$($: {}): Promise<any>

			/**
			 * override SocketIO method - wait for MainThread to shut us down
			 */
			exithook(): Promise<any>
			exithook$($: {}): Promise<any>

			/**
			 * Override SocketIO method - terminate wait on callback and exit thread
			 */
			EOFhook(): Promise<any>
			EOFhook$($: {}): Promise<any>

			/**
			 * interrupt awakened thread
			 */
			decode_interrupthook(): Promise<any>
			decode_interrupthook$($: {}): Promise<any>
		}
		function Executive(rpchandler): Promise<IExecutive>
		function Executive$({ rpchandler }): Promise<IExecutive>
		interface IExecutive {
			runcode(code): Promise<any>
			runcode$({ code }): Promise<any>
			interrupt_the_server(): Promise<any>
			interrupt_the_server$($: {}): Promise<any>
			start_the_debugger(gui_adap_oid): Promise<any>
			start_the_debugger$({ gui_adap_oid }): Promise<any>

			/**
			 * Unregister the Idb Adapter.  Link objects and Idb then subject to GC
			 */
			stop_the_debugger(idb_adap_oid): Promise<any>
			stop_the_debugger$({ idb_adap_oid }): Promise<any>
			get_the_calltip(name): Promise<any>
			get_the_calltip$({ name }): Promise<any>
			get_the_completion_list(what, mode): Promise<any>
			get_the_completion_list$({ what, mode }): Promise<any>
			stackviewer(flist_oid?): Promise<any>
			stackviewer$({ flist_oid }: { flist_oid?}): Promise<any>
		}
		let LOCALHOST: Promise<any>
		let tcl: Promise<any>
		let exit_now: Promise<any>
		let quitting: Promise<any>
		let interruptable: Promise<any>
		let RECURSIONLIMIT_DELTA: Promise<any>
	}
	module runscript {
		var _
		function ScriptBinding(editwin): Promise<IScriptBinding>
		function ScriptBinding$({ editwin }): Promise<IScriptBinding>
		interface IScriptBinding {
			check_module_event(event): Promise<any>
			check_module_event$({ event }): Promise<any>
			tabnanny(filename): Promise<any>
			tabnanny$({ filename }): Promise<any>
			checksyntax(filename): Promise<any>
			checksyntax$({ filename }): Promise<any>
			run_custom_event(event): Promise<any>
			run_custom_event$({ event }): Promise<any>

			/**
			 * Run the module after setting up the environment.
			 * 
			 *         First check the syntax.  Next get customization.  If OK, make
			 *         sure the shell is active and then transfer the arguments, set
			 *         the run environment's working directory to the directory of the
			 *         module being executed and also add that directory to its
			 *         sys.path if not already included.
			 *         
			 */
			run_module_event(event): Promise<any>
			run_module_event$({ event }): Promise<any>

			/**
			 * Get source filename.  If not saved, offer to save (or create) file
			 * 
			 *         The debugger requires a source file.  Make sure there is one, and that
			 *         the current version of the source buffer has been saved.  If the user
			 *         declines to save or cancels the Save As dialog, return None.
			 * 
			 *         If the user has configured IDLE for Autosave, the file will be
			 *         silently saved if it already exists and is dirty.
			 * 
			 *         
			 */
			getfilename(): Promise<any>
			getfilename$($: {}): Promise<any>
			ask_save_dialog(): Promise<any>
			ask_save_dialog$($: {}): Promise<any>
			errorbox(title, message): Promise<any>
			errorbox$({ title, message }): Promise<any>
		}
		let indent_message: Promise<any>
	}
	module scrolledlist {
		var _
		function ScrolledList(master): Promise<IScrolledList>
		function ScrolledList$({ master }): Promise<IScrolledList>
		interface IScrolledList {
			close(): Promise<any>
			close$($: {}): Promise<any>
			clear(): Promise<any>
			clear$($: {}): Promise<any>
			append(item): Promise<any>
			append$({ item }): Promise<any>
			get(index): Promise<any>
			get$({ index }): Promise<any>
			click_event(event): Promise<any>
			click_event$({ event }): Promise<any>
			double_click_event(event): Promise<any>
			double_click_event$({ event }): Promise<any>
			popup_event(event): Promise<any>
			popup_event$({ event }): Promise<any>
			make_menu(): Promise<any>
			make_menu$($: {}): Promise<any>
			up_event(event): Promise<any>
			up_event$({ event }): Promise<any>
			down_event(event): Promise<any>
			down_event$({ event }): Promise<any>
			select(index): Promise<any>
			select$({ index }): Promise<any>
			fill_menu(): Promise<any>
			fill_menu$($: {}): Promise<any>
			on_select(index): Promise<any>
			on_select$({ index }): Promise<any>
			on_double(index): Promise<any>
			on_double$({ index }): Promise<any>
			default
			menu
		}
	}
	module search {
		var _

		/**
		 * Open the search dialog.
		 * 
		 *     Module-level function to access the singleton SearchDialog
		 *     instance and open the dialog.  If text is selected, it is
		 *     used as the search phrase; otherwise, the previous entry
		 *     is used.  No search is done with this command.
		 *     
		 */
		function find(text): Promise<any>
		function find$({ text }): Promise<any>

		/**
		 * Repeat the search for the last pattern and preferences.
		 * 
		 *     Module-level function to access the singleton SearchDialog
		 *     instance to search again using the user entries and preferences
		 *     from the last dialog.  If there was no prior search, open the
		 *     search dialog; otherwise, perform the search without showing the
		 *     dialog.
		 *     
		 */
		function find_again(text): Promise<any>
		function find_again$({ text }): Promise<any>

		/**
		 * Search for the selected pattern in the text.
		 * 
		 *     Module-level function to access the singleton SearchDialog
		 *     instance to search using the selected text.  With a text
		 *     selection, perform the search without displaying the dialog.
		 *     Without a selection, use the prior entry as the search phrase
		 *     and don't display the dialog.  If there has been no prior
		 *     search, open the search dialog.
		 *     
		 */
		function find_selection(text): Promise<any>
		function find_selection$({ text }): Promise<any>

		/**
		 * Dialog for finding a pattern in text.
		 */
		interface ISearchDialog {

			/**
			 * Create the base search dialog and add a button for Find Next.
			 */
			create_widgets(): Promise<any>
			create_widgets$($: {}): Promise<any>

			/**
			 * Handle the Find Next button as the default command.
			 */
			default_command(event?): Promise<any>
			default_command$({ event }: { event?}): Promise<any>

			/**
			 * Repeat the last search.
			 * 
			 *         If no search was previously run, open a new search dialog.  In
			 *         this case, no search is done.
			 * 
			 *         If a search was previously run, the search dialog won't be
			 *         shown and the options from the previous search (including the
			 *         search pattern) will be used to find the next occurrence
			 *         of the pattern.  Next is relative based on direction.
			 * 
			 *         Position the window to display the located occurrence in the
			 *         text.
			 * 
			 *         Return True if the search was successful and False otherwise.
			 *         
			 */
			find_again(text): Promise<any>
			find_again$({ text }): Promise<any>

			/**
			 * Search for selected text with previous dialog preferences.
			 * 
			 *         Instead of using the same pattern for searching (as Find
			 *         Again does), this first resets the pattern to the currently
			 *         selected text.  If the selected text isn't changed, then use
			 *         the prior search phrase.
			 *         
			 */
			find_selection(text): Promise<any>
			find_selection$({ text }): Promise<any>
		}
	}
	module searchbase {
		var _

		/**
		 * Create most of a 3 or 4 row, 3 column search dialog.
		 * 
		 *     The left and wide middle column contain:
		 *     1 or 2 labeled text entry lines (make_entry, create_entries);
		 *     a row of standard Checkbuttons (make_frame, create_option_buttons),
		 *     each of which corresponds to a search engine Variable;
		 *     a row of dialog-specific Check/Radiobuttons (create_other_buttons).
		 * 
		 *     The narrow right column contains command buttons
		 *     (make_button, create_command_buttons).
		 *     These are bound to functions that execute the command.
		 * 
		 *     Except for command buttons, this base class is not limited to items
		 *     common to all three subclasses.  Rather, it is the Find dialog minus
		 *     the "Find Next" command, its execution function, and the
		 *     default_command attribute needed in create_widgets. The other
		 *     dialogs override attributes and methods, the latter to replace and
		 *     add widgets.
		 *     
		 */

		/**
		 * Initialize root, engine, and top attributes.
		 * 
		 *         top (level widget): set in create_widgets() called from open().
		 *         frame: container for all widgets in dialog.
		 *         text (Text searched): set in open(), only used in subclasses().
		 *         ent (ry): created in make_entry() called from create_entry().
		 *         row (of grid): 0 in create_widgets(), +1 in make_entry/frame().
		 *         default_command: set in subclasses, used in create_widgets().
		 * 
		 *         title (of dialog): class attribute, override in subclasses.
		 *         icon (of dialog): ditto, use unclear if cannot minimize dialog.
		 *         
		 */
		function SearchDialogBase(root, engine): Promise<ISearchDialogBase>
		function SearchDialogBase$({ root, engine }): Promise<ISearchDialogBase>
		interface ISearchDialogBase {

			/**
			 * Make dialog visible on top of others and ready to use.
			 */
			open(text, searchphrase?): Promise<any>
			open$({ text, searchphrase }: { text, searchphrase?}): Promise<any>

			/**
			 * Put dialog away for later use.
			 */
			close(event?): Promise<any>
			close$({ event }: { event?}): Promise<any>

			/**
			 * Create basic 3 row x 3 col search (find) dialog.
			 * 
			 *         Other dialogs override subsidiary create_x methods as needed.
			 *         Replace and Find-in-Files add another entry row.
			 *         
			 */
			create_widgets(): Promise<any>
			create_widgets$($: {}): Promise<any>

			/**
			 * Return (entry, label), .
			 * 
			 *         entry - gridded labeled Entry for text entry.
			 *         label - Label widget, returned for testing.
			 *         
			 */
			make_entry(label_text, variable): Promise<any>
			make_entry$({ label_text, variable }): Promise<any>

			/**
			 * Create one or more entry lines with make_entry.
			 */
			create_entries(): Promise<any>
			create_entries$($: {}): Promise<any>

			/**
			 * Return (frame, label).
			 * 
			 *         frame - gridded labeled Frame for option or other buttons.
			 *         label - Label widget, returned for testing.
			 *         
			 */
			make_frame(labeltext?): Promise<any>
			make_frame$({ labeltext }: { labeltext?}): Promise<any>

			/**
			 * Return (filled frame, options) for testing.
			 * 
			 *         Options is a list of searchengine booleanvar, label pairs.
			 *         A gridded frame from make_frame is filled with a Checkbutton
			 *         for each pair, bound to the var, with the corresponding label.
			 *         
			 */
			create_option_buttons(): Promise<any>
			create_option_buttons$($: {}): Promise<any>

			/**
			 * Return (frame, others) for testing.
			 * 
			 *         Others is a list of value, label pairs.
			 *         A gridded frame from make_frame is filled with radio buttons.
			 *         
			 */
			create_other_buttons(): Promise<any>
			create_other_buttons$($: {}): Promise<any>

			/**
			 * Return command button gridded in command frame.
			 */
			make_button(label, command, isdef?): Promise<any>
			make_button$({ label, command, isdef }: { label, command, isdef?}): Promise<any>

			/**
			 * Place buttons in vertical command frame gridded on right.
			 */
			create_command_buttons(): Promise<any>
			create_command_buttons$($: {}): Promise<any>
			title
			icon
			needwrapbutton
		}

		/**
		 * Create auto-opening dialog with no text connection.
		 */
		interface I_searchbase extends ISearchDialogBase {
			default_command(dummy): Promise<any>
			default_command$({ dummy }): Promise<any>
		}
	}
	module searchengine {
		var _

		/**
		 * Return the singleton SearchEngine instance for the process.
		 * 
		 *     The single SearchEngine saves settings between dialog instances.
		 *     If there is not a SearchEngine already, make one.
		 *     
		 */
		function get(root): Promise<any>
		function get$({ root }): Promise<any>

		/**
		 * Search backwards and return an re match object or None.
		 * 
		 *     This is done by searching forwards until there is no match.
		 *     Prog: compiled re object with a search method returning a match.
		 *     Chars: line of text, without \n.
		 *     Col: stop index for the search; the limit for match.end().
		 *     
		 */
		function search_reverse(prog, chars, col): Promise<any>
		function search_reverse$({ prog, chars, col }): Promise<any>

		/**
		 * Return tuple of 'line.col' indexes from selection or insert mark.
		 *     
		 */
		function get_selection(text): Promise<any>
		function get_selection$({ text }): Promise<any>

		/**
		 * Return (line, col) tuple of ints from 'line.col' string.
		 */
		function get_line_col(index): Promise<any>
		function get_line_col$({ index }): Promise<any>

		/**
		 * Handles searching a text widget for Find, Replace, and Grep.
		 */

		/**
		 * Initialize Variables that save search state.
		 * 
		 *         The dialogs bind these to the UI elements present in the dialogs.
		 *         
		 */
		function SearchEngine(root): Promise<ISearchEngine>
		function SearchEngine$({ root }): Promise<ISearchEngine>
		interface ISearchEngine {
			getpat(): Promise<any>
			getpat$($: {}): Promise<any>
			setpat(pat): Promise<any>
			setpat$({ pat }): Promise<any>
			isre(): Promise<any>
			isre$($: {}): Promise<any>
			iscase(): Promise<any>
			iscase$($: {}): Promise<any>
			isword(): Promise<any>
			isword$($: {}): Promise<any>
			iswrap(): Promise<any>
			iswrap$($: {}): Promise<any>
			isback(): Promise<any>
			isback$($: {}): Promise<any>

			/**
			 * Set pattern after escaping if re.
			 */
			setcookedpat(pat): Promise<any>
			setcookedpat$({ pat }): Promise<any>
			getcookedpat(): Promise<any>
			getcookedpat$($: {}): Promise<any>

			/**
			 * Return compiled cooked search pattern.
			 */
			getprog(): Promise<any>
			getprog$($: {}): Promise<any>
			report_error(pat, msg, col?): Promise<any>
			report_error$({ pat, msg, col }: { pat, msg, col?}): Promise<any>

			/**
			 * Return (lineno, matchobj) or None for forward/backward search.
			 * 
			 *         This function calls the right function with the right arguments.
			 *         It directly return the result of that call.
			 * 
			 *         Text is a text widget. Prog is a precompiled pattern.
			 *         The ok parameter is a bit complicated as it has two effects.
			 * 
			 *         If there is a selection, the search begin at either end,
			 *         depending on the direction setting and ok, with ok meaning that
			 *         the search starts with the selection. Otherwise, search begins
			 *         at the insert mark.
			 * 
			 *         To aid progress, the search functions do not return an empty
			 *         match at the starting position unless ok is True.
			 *         
			 */
			search_text(text, prog?, ok?): Promise<any>
			search_text$({ text, prog, ok }: { text, prog?, ok?}): Promise<any>
			search_forward(text, prog, line, col, wrap, ok?): Promise<any>
			search_forward$({ text, prog, line, col, wrap, ok }: { text, prog, line, col, wrap, ok?}): Promise<any>
			search_backward(text, prog, line, col, wrap, ok?): Promise<any>
			search_backward$({ text, prog, line, col, wrap, ok }: { text, prog, line, col, wrap, ok?}): Promise<any>
		}
	}
	module sidebar {
		var _

		/**
		 * Return the line number of an index in a Tk text widget.
		 */
		function get_lineno(text, index): Promise<any>
		function get_lineno$({ text, index }): Promise<any>

		/**
		 * Return the number of the last line in a Tk text widget.
		 */
		function get_end_linenumber(text): Promise<any>
		function get_end_linenumber$({ text }): Promise<any>

		/**
		 * Display height, in lines, of a logical line in a Tk text widget.
		 */
		function get_displaylines(text, index): Promise<any>
		function get_displaylines$({ text, index }): Promise<any>

		/**
		 * Get the total padding of a Tk widget, including its border.
		 */
		function get_widget_padding(widget): Promise<any>
		function get_widget_padding$({ widget }): Promise<any>
		function temp_enable_text_widget(text): Promise<any>
		function temp_enable_text_widget$({ text }): Promise<any>

		/**
		 * A base class for sidebars using Text.
		 */
		function BaseSideBar(editwin): Promise<IBaseSideBar>
		function BaseSideBar$({ editwin }): Promise<IBaseSideBar>
		interface IBaseSideBar {

			/**
			 * Initialize the sidebar's widgets, returning the main widget.
			 */
			init_widgets(): Promise<any>
			init_widgets$($: {}): Promise<any>

			/**
			 * Update the sidebar text font, usually after config changes.
			 */
			update_font(): Promise<any>
			update_font$($: {}): Promise<any>

			/**
			 * Update the sidebar text colors, usually after config changes.
			 */
			update_colors(): Promise<any>
			update_colors$($: {}): Promise<any>

			/**
			 * Layout the widget, always using grid layout.
			 */
			grid(): Promise<any>
			grid$($: {}): Promise<any>
			show_sidebar(): Promise<any>
			show_sidebar$($: {}): Promise<any>
			hide_sidebar(): Promise<any>
			hide_sidebar$($: {}): Promise<any>

			/**
			 * Hook for vertical scrolling for sub-classes to override.
			 */
			yscroll_event(): Promise<any>
			yscroll_event$($: {}): Promise<any>

			/**
			 * Redirect vertical scrolling to the main editor text widget.
			 * 
			 *         The scroll bar is also updated.
			 *         
			 */
			redirect_yscroll_event(): Promise<any>
			redirect_yscroll_event$($: {}): Promise<any>

			/**
			 * Redirect focus-in events to the main editor text widget.
			 */
			redirect_focusin_event(event): Promise<any>
			redirect_focusin_event$({ event }): Promise<any>

			/**
			 * Redirect mouse button events to the main editor text widget.
			 */
			redirect_mousebutton_event(event, event_name): Promise<any>
			redirect_mousebutton_event$({ event, event_name }): Promise<any>

			/**
			 * Redirect mouse wheel events to the editwin text widget.
			 */
			redirect_mousewheel_event(event): Promise<any>
			redirect_mousewheel_event$({ event }): Promise<any>
			bind_events(): Promise<any>
			bind_events$($: {}): Promise<any>
		}

		/**
		 * Generate callbacks with the current end line number.
		 * 
		 *     The provided callback is called after every insert and delete.
		 *     
		 */
		function EndLineDelegator(changed_callback): Promise<IEndLineDelegator>
		function EndLineDelegator$({ changed_callback }): Promise<IEndLineDelegator>
		interface IEndLineDelegator {
			insert(index, chars, tags?): Promise<any>
			insert$({ index, chars, tags }: { index, chars, tags?}): Promise<any>
			delete(index1, index2?): Promise<any>
			delete$({ index1, index2 }: { index1, index2?}): Promise<any>
		}

		/**
		 * Line numbers support for editor windows.
		 */
		function LineNumbers(editwin): Promise<ILineNumbers>
		function LineNumbers$({ editwin }): Promise<ILineNumbers>
		interface ILineNumbers extends IBaseSideBar {
			init_widgets(): Promise<any>
			init_widgets$($: {}): Promise<any>
			grid(): Promise<any>
			grid$($: {}): Promise<any>
			update_font(): Promise<any>
			update_font$($: {}): Promise<any>

			/**
			 * Update the sidebar text colors, usually after config changes.
			 */
			update_colors(): Promise<any>
			update_colors$($: {}): Promise<any>

			/**
			 * 
			 *         Perform the following action:
			 *         Each line sidebar_text contains the linenumber for that line
			 *         Synchronize with editwin.text so that both sidebar_text and
			 *         editwin.text contain the same number of lines
			 */
			update_sidebar_text(end): Promise<any>
			update_sidebar_text$({ end }): Promise<any>
			yscroll_event(): Promise<any>
			yscroll_event$($: {}): Promise<any>
		}

		/**
		 * 
		 *         callback - Callable, will be called when an insert, delete or replace
		 *                    action on the text widget may require updating the shell
		 *                    sidebar.
		 *         
		 */
		function WrappedLineHeightChangeDelegator(callback): Promise<IWrappedLineHeightChangeDelegator>
		function WrappedLineHeightChangeDelegator$({ callback }): Promise<IWrappedLineHeightChangeDelegator>
		interface IWrappedLineHeightChangeDelegator {
			insert(index, chars, tags?): Promise<any>
			insert$({ index, chars, tags }: { index, chars, tags?}): Promise<any>
			delete(index1, index2?): Promise<any>
			delete$({ index1, index2 }: { index1, index2?}): Promise<any>
		}

		/**
		 * Sidebar for the PyShell window, for prompts etc.
		 */
		function ShellSidebar(editwin): Promise<IShellSidebar>
		function ShellSidebar$({ editwin }): Promise<IShellSidebar>
		interface IShellSidebar extends IBaseSideBar {
			init_widgets(): Promise<any>
			init_widgets$($: {}): Promise<any>
			bind_events(): Promise<any>
			bind_events$($: {}): Promise<any>
			context_menu_event(event): Promise<any>
			context_menu_event$({ event }): Promise<any>
			grid(): Promise<any>
			grid$($: {}): Promise<any>
			change_callback(): Promise<any>
			change_callback$($: {}): Promise<any>
			update_sidebar(): Promise<any>
			update_sidebar$($: {}): Promise<any>

			/**
			 * Redirect vertical scrolling to the main editor text widget.
			 * 
			 *         The scroll bar is also updated.
			 *         
			 */
			yscroll_event(): Promise<any>
			yscroll_event$($: {}): Promise<any>

			/**
			 * Update the sidebar text font, usually after config changes.
			 */
			update_font(): Promise<any>
			update_font$($: {}): Promise<any>

			/**
			 * Update the sidebar text colors, usually after config changes.
			 */
			update_colors(): Promise<any>
			update_colors$($: {}): Promise<any>
		}
	}
	module squeezer {
		var _

		/**
		 * Count the number of lines in a given string.
		 * 
		 *     Lines are counted as if the string was wrapped so that lines are never over
		 *     linewidth characters long.
		 * 
		 *     Tabs are considered tabwidth characters long.
		 *     
		 */
		function count_lines_with_wrapping(s, linewidth?): Promise<any>
		function count_lines_with_wrapping$({ s, linewidth }: { s, linewidth?}): Promise<any>

		/**
		 * Class for the "squeezed" text buttons used by Squeezer
		 * 
		 *     These buttons are displayed inside a Tk Text widget in place of text. A
		 *     user can then use the button to replace it with the original text, copy
		 *     the original text to the clipboard or view the original text in a separate
		 *     window.
		 * 
		 *     Each button is tied to a Squeezer instance, and it knows to update the
		 *     Squeezer instance when it is expanded (and therefore removed).
		 *     
		 */
		function ExpandingButton(s, tags, numoflines, squeezer): Promise<IExpandingButton>
		function ExpandingButton$({ s, tags, numoflines, squeezer }): Promise<IExpandingButton>
		interface IExpandingButton {
			set_is_dangerous(): Promise<any>
			set_is_dangerous$($: {}): Promise<any>

			/**
			 * expand event handler
			 * 
			 *         This inserts the original text in place of the button in the Text
			 *         widget, removes the button and updates the Squeezer instance.
			 * 
			 *         If the original text is dangerously long, i.e. expanding it could
			 *         cause a performance degradation, ask the user for confirmation.
			 *         
			 */
			expand(event?): Promise<any>
			expand$({ event }: { event?}): Promise<any>

			/**
			 * copy event handler
			 * 
			 *         Copy the original text to the clipboard.
			 *         
			 */
			copy(event?): Promise<any>
			copy$({ event }: { event?}): Promise<any>

			/**
			 * view event handler
			 * 
			 *         View the original text in a separate text viewer window.
			 *         
			 */
			view(event?): Promise<any>
			view$({ event }: { event?}): Promise<any>
			context_menu_event(event): Promise<any>
			context_menu_event$({ event }): Promise<any>
			rmenu_specs
		}

		/**
		 * Replace long outputs in the shell with a simple button.
		 * 
		 *     This avoids IDLE's shell slowing down considerably, and even becoming
		 *     completely unresponsive, when very long outputs are written.
		 *     
		 */

		/**
		 * Initialize settings for Squeezer.
		 * 
		 *         editwin is the shell's Editor window.
		 *         self.text is the editor window text widget.
		 *         self.base_test is the actual editor window Tk text widget, rather than
		 *             EditorWindow's wrapper.
		 *         self.expandingbuttons is the list of all buttons representing
		 *             "squeezed" output.
		 *         
		 */
		function Squeezer(editwin): Promise<ISqueezer>
		function Squeezer$({ editwin }): Promise<ISqueezer>
		interface ISqueezer {

			/**
			 * Load class variables from config.
			 */
			reload(): Promise<any>
			reload$($: {}): Promise<any>

			/**
			 * Count the number of lines in a given text.
			 * 
			 *         Before calculation, the tab width and line length of the text are
			 *         fetched, so that up-to-date values are used.
			 * 
			 *         Lines are counted as if the string was wrapped so that lines are never
			 *         over linewidth characters long.
			 * 
			 *         Tabs are considered tabwidth characters long.
			 *         
			 */
			count_lines(s): Promise<any>
			count_lines$({ s }): Promise<any>

			/**
			 * Squeeze the text block where the insertion cursor is.
			 * 
			 *         If the cursor is not in a squeezable block of text, give the
			 *         user a small warning and do nothing.
			 *         
			 */
			squeeze_current_text(): Promise<any>
			squeeze_current_text$($: {}): Promise<any>
		}
	}
	module stackviewer {
		var _
		function StackBrowser(root, flist?, tb?, top?): Promise<any>
		function StackBrowser$({ root, flist, tb, top }: { root, flist?, tb?, top?}): Promise<any>
		function StackTreeItem(flist?, tb?): Promise<IStackTreeItem>
		function StackTreeItem$({ flist, tb }: { flist?, tb?}): Promise<IStackTreeItem>
		interface IStackTreeItem {
			get_stack(tb): Promise<any>
			get_stack$({ tb }): Promise<any>
			get_exception(): Promise<any>
			get_exception$($: {}): Promise<any>
			GetText(): Promise<any>
			GetText$($: {}): Promise<any>
			GetSubList(): Promise<any>
			GetSubList$($: {}): Promise<any>
		}
		function FrameTreeItem(info, flist): Promise<IFrameTreeItem>
		function FrameTreeItem$({ info, flist }): Promise<IFrameTreeItem>
		interface IFrameTreeItem {
			GetText(): Promise<any>
			GetText$($: {}): Promise<any>
			GetSubList(): Promise<any>
			GetSubList$($: {}): Promise<any>
			OnDoubleClick(): Promise<any>
			OnDoubleClick$($: {}): Promise<any>
		}
		interface IVariablesTreeItem {
			GetText(): Promise<any>
			GetText$($: {}): Promise<any>
			GetLabelText(): Promise<any>
			GetLabelText$($: {}): Promise<any>
			IsExpandable(): Promise<any>
			IsExpandable$($: {}): Promise<any>
			GetSubList(): Promise<any>
			GetSubList$($: {}): Promise<any>
		}
	}
	module statusbar {
		var _
		function MultiStatusBar(master): Promise<IMultiStatusBar>
		function MultiStatusBar$({ master }): Promise<IMultiStatusBar>
		interface IMultiStatusBar {
			set_label(name, text?, side?, width?): Promise<any>
			set_label$({ name, text, side, width }: { name, text?, side?, width?}): Promise<any>
		}
	}
	module textview {
		var _

		/**
		 * Create text viewer for given text.
		 * 
		 *     parent - parent of this dialog
		 *     title - string which is the title of popup dialog
		 *     contents - text to display in this dialog
		 *     wrap - type of text wrapping to use ('word', 'char' or 'none')
		 *     modal - controls if users can interact with other windows while this
		 *             dialog is displayed
		 *     _utest - bool; controls wait_window on unittest
		 *     
		 */
		function view_text(parent, title, contents, modal?: boolean, wrap?, _utest?: boolean): Promise<any>
		function view_text$({ parent, title, contents, modal, wrap, _utest }: { parent, title, contents, modal?, wrap?, _utest?}): Promise<any>

		/**
		 * Create text viewer for text in filename.
		 * 
		 *     Return error message if file cannot be read.  Otherwise calls view_text
		 *     with contents of the file.
		 *     
		 */
		function view_file(parent, title, filename, encoding, modal?: boolean, wrap?, _utest?: boolean): Promise<any>
		function view_file$({ parent, title, filename, encoding, modal, wrap, _utest }: { parent, title, filename, encoding, modal?, wrap?, _utest?}): Promise<any>

		/**
		 * A scrollbar that is automatically hidden when not needed.
		 * 
		 *     Only the grid geometry manager is supported.
		 *     
		 */
		interface IAutoHideScrollbar {
			set(lo, hi): Promise<any>
			set$({ lo, hi }): Promise<any>
			pack(): Promise<any>
			pack$($: {}): Promise<any>
			place(): Promise<any>
			place$($: {}): Promise<any>
		}

		/**
		 * Display text with scrollbar(s).
		 */

		/**
		 * Create a frame for Textview.
		 * 
		 *         master - master widget for this frame
		 *         wrap - type of text wrapping to use ('word', 'char' or 'none')
		 * 
		 *         All parameters except for 'wrap' are passed to Frame.__init__().
		 * 
		 *         The Text widget is accessible via the 'text' attribute.
		 * 
		 *         Note: Changing the wrapping mode of the text widget after
		 *         instantiation is not supported.
		 *         
		 */
		function ScrollableTextFrame(master, wrap?): Promise<IScrollableTextFrame>
		function ScrollableTextFrame$({ master, wrap }: { master, wrap?}): Promise<IScrollableTextFrame>
		interface IScrollableTextFrame {
		}

		/**
		 * Display TextFrame and Close button.
		 */

		/**
		 * Create a frame for viewing text with a "Close" button.
		 * 
		 *         parent - parent widget for this frame
		 *         contents - text to display
		 *         wrap - type of text wrapping to use ('word', 'char' or 'none')
		 * 
		 *         The Text widget is accessible via the 'text' attribute.
		 *         
		 */
		function ViewFrame(parent, contents, wrap?): Promise<IViewFrame>
		function ViewFrame$({ parent, contents, wrap }: { parent, contents, wrap?}): Promise<IViewFrame>
		interface IViewFrame {

			/**
			 * Dismiss text viewer dialog.
			 */
			ok(event?): Promise<any>
			ok$({ event }: { event?}): Promise<any>
		}

		/**
		 * A simple text viewer dialog for IDLE.
		 */

		/**
		 * Show the given text in a scrollable window with a 'close' button.
		 * 
		 *         If modal is left True, users cannot interact with other windows
		 *         until the textview window is closed.
		 * 
		 *         parent - parent of this dialog
		 *         title - string which is title of popup dialog
		 *         contents - text to display in dialog
		 *         wrap - type of text wrapping to use ('word', 'char' or 'none')
		 *         _htest - bool; change box location when running htest.
		 *         _utest - bool; don't wait_window when running unittest.
		 *         
		 */
		function ViewWindow(parent, title, contents, modal?: boolean, wrap?): Promise<IViewWindow>
		function ViewWindow$({ parent, title, contents, modal, wrap }: { parent, title, contents, modal?, wrap?}): Promise<IViewWindow>
		interface IViewWindow {

			/**
			 * Dismiss text viewer dialog.
			 */
			ok(event?): Promise<any>
			ok$({ event }: { event?}): Promise<any>
		}
	}
	module tooltip {
		var _

		/**
		 * abstract base class for tooltips
		 */

		/**
		 * Create a tooltip.
		 * 
		 *         anchor_widget: the widget next to which the tooltip will be shown
		 * 
		 *         Note that a widget will only be shown when showtip() is called.
		 *         
		 */
		function TooltipBase(anchor_widget): Promise<ITooltipBase>
		function TooltipBase$({ anchor_widget }): Promise<ITooltipBase>
		interface ITooltipBase {

			/**
			 * display the tooltip
			 */
			showtip(): Promise<any>
			showtip$($: {}): Promise<any>

			/**
			 * (re)-set the tooltip's screen position
			 */
			position_window(): Promise<any>
			position_window$($: {}): Promise<any>

			/**
			 * choose a screen position for the tooltip
			 */
			get_position(): Promise<any>
			get_position$($: {}): Promise<any>

			/**
			 * content display hook for sub-classes
			 */
			showcontents(): Promise<any>
			showcontents$($: {}): Promise<any>

			/**
			 * hide the tooltip
			 */
			hidetip(): Promise<any>
			hidetip$($: {}): Promise<any>
		}

		/**
		 * abstract base class for tooltips, with delayed on-hover display
		 */

		/**
		 * Create a tooltip with a mouse hover delay.
		 * 
		 *         anchor_widget: the widget next to which the tooltip will be shown
		 *         hover_delay: time to delay before showing the tooltip, in milliseconds
		 * 
		 *         Note that a widget will only be shown when showtip() is called,
		 *         e.g. after hovering over the anchor widget with the mouse for enough
		 *         time.
		 *         
		 */
		function OnHoverTooltipBase(anchor_widget, hover_delay?): Promise<IOnHoverTooltipBase>
		function OnHoverTooltipBase$({ anchor_widget, hover_delay }: { anchor_widget, hover_delay?}): Promise<IOnHoverTooltipBase>
		interface IOnHoverTooltipBase extends ITooltipBase {

			/**
			 * schedule the future display of the tooltip
			 */
			schedule(): Promise<any>
			schedule$($: {}): Promise<any>

			/**
			 * cancel the future display of the tooltip
			 */
			unschedule(): Promise<any>
			unschedule$($: {}): Promise<any>

			/**
			 * hide the tooltip
			 */
			hidetip(): Promise<any>
			hidetip$($: {}): Promise<any>
		}

		/**
		 * A tooltip that pops up when a mouse hovers over an anchor widget.
		 */

		/**
		 * Create a text tooltip with a mouse hover delay.
		 * 
		 *         anchor_widget: the widget next to which the tooltip will be shown
		 *         hover_delay: time to delay before showing the tooltip, in milliseconds
		 * 
		 *         Note that a widget will only be shown when showtip() is called,
		 *         e.g. after hovering over the anchor widget with the mouse for enough
		 *         time.
		 *         
		 */
		function Hovertip(anchor_widget, text, hover_delay?): Promise<IHovertip>
		function Hovertip$({ anchor_widget, text, hover_delay }: { anchor_widget, text, hover_delay?}): Promise<IHovertip>
		interface IHovertip extends IOnHoverTooltipBase {
			showcontents(): Promise<any>
			showcontents$($: {}): Promise<any>
		}
	}
	module tree {
		var _

		/**
		 * Utility to display the available icons.
		 */
		function listicons(icondir?): Promise<any>
		function listicons$({ icondir }: { icondir?}): Promise<any>

		/**
		 * Handle scrollwheel event.
		 * 
		 *     For wheel up, event.delta = 120*n on Windows, -1*n on darwin,
		 *     where n can be > 1 if one scrolls fast.  Flicking the wheel
		 *     generates up to maybe 20 events with n up to 10 or more 1.
		 *     Macs use wheel down (delta = 1*n) to scroll up, so positive
		 *     delta means to scroll up on both systems.
		 * 
		 *     X-11 sends Control-Button-4,5 events instead.
		 * 
		 *     The widget parameter is needed so browser label bindings can pass
		 *     the underlying canvas.
		 * 
		 *     This function depends on widget.yview to not be overridden by
		 *     a subclass.
		 *     
		 */
		function wheel_event(event, widget?): Promise<any>
		function wheel_event$({ event, widget }: { event, widget?}): Promise<any>
		function TreeNode(canvas, parent, item): Promise<ITreeNode>
		function TreeNode$({ canvas, parent, item }): Promise<ITreeNode>
		interface ITreeNode {
			destroy(): Promise<any>
			destroy$($: {}): Promise<any>
			geticonimage(name): Promise<any>
			geticonimage$({ name }): Promise<any>
			select(event?): Promise<any>
			select$({ event }: { event?}): Promise<any>
			deselect(event?): Promise<any>
			deselect$({ event }: { event?}): Promise<any>
			deselectall(): Promise<any>
			deselectall$($: {}): Promise<any>
			deselecttree(): Promise<any>
			deselecttree$($: {}): Promise<any>
			flip(event?): Promise<any>
			flip$({ event }: { event?}): Promise<any>
			expand(event?): Promise<any>
			expand$({ event }: { event?}): Promise<any>
			collapse(event?): Promise<any>
			collapse$({ event }: { event?}): Promise<any>
			view(): Promise<any>
			view$($: {}): Promise<any>
			lastvisiblechild(): Promise<any>
			lastvisiblechild$($: {}): Promise<any>
			update(): Promise<any>
			update$($: {}): Promise<any>
			draw(x, y): Promise<any>
			draw$({ x, y }): Promise<any>
			drawicon(): Promise<any>
			drawicon$($: {}): Promise<any>
			drawtext(): Promise<any>
			drawtext$($: {}): Promise<any>
			select_or_edit(event?): Promise<any>
			select_or_edit$({ event }: { event?}): Promise<any>
			edit(event?): Promise<any>
			edit$({ event }: { event?}): Promise<any>
			edit_finish(event?): Promise<any>
			edit_finish$({ event }: { event?}): Promise<any>
			edit_cancel(event?): Promise<any>
			edit_cancel$({ event }: { event?}): Promise<any>
		}

		/**
		 * Abstract class representing tree items.
		 * 
		 *     Methods should typically be overridden, otherwise a default action
		 *     is used.
		 * 
		 *     
		 */

		/**
		 * Constructor.  Do whatever you need to do.
		 */
		function TreeItem(): Promise<ITreeItem>
		function TreeItem$({ }): Promise<ITreeItem>
		interface ITreeItem {

			/**
			 * Return text string to display.
			 */
			GetText(): Promise<any>
			GetText$($: {}): Promise<any>

			/**
			 * Return label text string to display in front of text (if any).
			 */
			GetLabelText(): Promise<any>
			GetLabelText$($: {}): Promise<any>

			/**
			 * Return whether there are subitems.
			 */
			IsExpandable(): Promise<any>
			IsExpandable$($: {}): Promise<any>

			/**
			 * Return whether the item's text may be edited.
			 */
			IsEditable(): Promise<any>
			IsEditable$($: {}): Promise<any>

			/**
			 * Change the item's text (if it is editable).
			 */
			SetText(text): Promise<any>
			SetText$({ text }): Promise<any>

			/**
			 * Return name of icon to be displayed normally.
			 */
			GetIconName(): Promise<any>
			GetIconName$($: {}): Promise<any>

			/**
			 * Return name of icon to be displayed when selected.
			 */
			GetSelectedIconName(): Promise<any>
			GetSelectedIconName$($: {}): Promise<any>

			/**
			 * Return list of items forming sublist.
			 */
			GetSubList(): Promise<any>
			GetSubList$($: {}): Promise<any>

			/**
			 * Called on a double-click on the item.
			 */
			OnDoubleClick(): Promise<any>
			OnDoubleClick$($: {}): Promise<any>
			expandable
		}

		/**
		 * Example TreeItem subclass -- browse the file system.
		 */
		function FileTreeItem(path): Promise<IFileTreeItem>
		function FileTreeItem$({ path }): Promise<IFileTreeItem>
		interface IFileTreeItem extends ITreeItem {
			GetText(): Promise<any>
			GetText$($: {}): Promise<any>
			IsEditable(): Promise<any>
			IsEditable$($: {}): Promise<any>
			SetText(text): Promise<any>
			SetText$({ text }): Promise<any>
			GetIconName(): Promise<any>
			GetIconName$($: {}): Promise<any>
			IsExpandable(): Promise<any>
			IsExpandable$($: {}): Promise<any>
			GetSubList(): Promise<any>
			GetSubList$($: {}): Promise<any>
		}
		function ScrolledCanvas(master): Promise<IScrolledCanvas>
		function ScrolledCanvas$({ master }): Promise<IScrolledCanvas>
		interface IScrolledCanvas {
			page_up(event): Promise<any>
			page_up$({ event }): Promise<any>
			page_down(event): Promise<any>
			page_down$({ event }): Promise<any>
			unit_up(event): Promise<any>
			unit_up$({ event }): Promise<any>
			unit_down(event): Promise<any>
			unit_down$({ event }): Promise<any>
			zoom_height(event): Promise<any>
			zoom_height$({ event }): Promise<any>
		}
		let ICONDIR: Promise<any>
	}
	module undo {
		var _
		function UndoDelegator(): Promise<IUndoDelegator>
		function UndoDelegator$({ }): Promise<IUndoDelegator>
		interface IUndoDelegator {
			setdelegate(delegate): Promise<any>
			setdelegate$({ delegate }): Promise<any>
			dump_event(event): Promise<any>
			dump_event$({ event }): Promise<any>
			reset_undo(): Promise<any>
			reset_undo$($: {}): Promise<any>
			set_saved(flag): Promise<any>
			set_saved$({ flag }): Promise<any>
			get_saved(): Promise<any>
			get_saved$($: {}): Promise<any>
			set_saved_change_hook(hook): Promise<any>
			set_saved_change_hook$({ hook }): Promise<any>
			check_saved(): Promise<any>
			check_saved$($: {}): Promise<any>
			insert(index, chars, tags?): Promise<any>
			insert$({ index, chars, tags }: { index, chars, tags?}): Promise<any>
			delete(index1, index2?): Promise<any>
			delete$({ index1, index2 }: { index1, index2?}): Promise<any>
			undo_block_start(): Promise<any>
			undo_block_start$($: {}): Promise<any>
			undo_block_stop(): Promise<any>
			undo_block_stop$($: {}): Promise<any>
			addcmd(cmd, execute?: boolean): Promise<any>
			addcmd$({ cmd, execute }: { cmd, execute?}): Promise<any>
			undo_event(event): Promise<any>
			undo_event$({ event }): Promise<any>
			redo_event(event): Promise<any>
			redo_event$({ event }): Promise<any>
			max_undo
			saved_change_hook
			was_saved
		}
		function Command(index1, index2, chars, tags?): Promise<ICommand>
		function Command$({ index1, index2, chars, tags }: { index1, index2, chars, tags?}): Promise<ICommand>
		interface ICommand {
			do(text): Promise<any>
			do$({ text }): Promise<any>
			redo(text): Promise<any>
			redo$({ text }): Promise<any>
			undo(text): Promise<any>
			undo$({ text }): Promise<any>
			merge(cmd): Promise<any>
			merge$({ cmd }): Promise<any>
			save_marks(text): Promise<any>
			save_marks$({ text }): Promise<any>
			set_marks(text, marks): Promise<any>
			set_marks$({ text, marks }): Promise<any>
			tags
		}
		function InsertCommand(index1, chars, tags?): Promise<IInsertCommand>
		function InsertCommand$({ index1, chars, tags }: { index1, chars, tags?}): Promise<IInsertCommand>
		interface IInsertCommand extends ICommand {
			do(text): Promise<any>
			do$({ text }): Promise<any>
			redo(text): Promise<any>
			redo$({ text }): Promise<any>
			undo(text): Promise<any>
			undo$({ text }): Promise<any>
			merge(cmd): Promise<any>
			merge$({ cmd }): Promise<any>
			classify(c): Promise<any>
			classify$({ c }): Promise<any>
			alphanumeric
		}
		function DeleteCommand(index1, index2?): Promise<IDeleteCommand>
		function DeleteCommand$({ index1, index2 }: { index1, index2?}): Promise<IDeleteCommand>
		interface IDeleteCommand extends ICommand {
			do(text): Promise<any>
			do$({ text }): Promise<any>
			redo(text): Promise<any>
			redo$({ text }): Promise<any>
			undo(text): Promise<any>
			undo$({ text }): Promise<any>
		}
		function CommandSequence(): Promise<ICommandSequence>
		function CommandSequence$({ }): Promise<ICommandSequence>
		interface ICommandSequence extends ICommand {
			append(cmd): Promise<any>
			append$({ cmd }): Promise<any>
			getcmd(i): Promise<any>
			getcmd$({ i }): Promise<any>
			redo(text): Promise<any>
			redo$({ text }): Promise<any>
			undo(text): Promise<any>
			undo$({ text }): Promise<any>
			bump_depth(incr?): Promise<any>
			bump_depth$({ incr }: { incr?}): Promise<any>
		}
	}
	module window {
		var _
		function WindowList(): Promise<IWindowList>
		function WindowList$({ }): Promise<IWindowList>
		interface IWindowList {
			add(window): Promise<any>
			add$({ window }): Promise<any>
			delete(window): Promise<any>
			delete$({ window }): Promise<any>
			add_windows_to_menu(menu): Promise<any>
			add_windows_to_menu$({ menu }): Promise<any>
			register_callback(callback): Promise<any>
			register_callback$({ callback }): Promise<any>
			unregister_callback(callback): Promise<any>
			unregister_callback$({ callback }): Promise<any>
			call_callbacks(): Promise<any>
			call_callbacks$($: {}): Promise<any>
		}
		function ListedToplevel(master): Promise<IListedToplevel>
		function ListedToplevel$({ master }): Promise<IListedToplevel>
		interface IListedToplevel {
			destroy(): Promise<any>
			destroy$($: {}): Promise<any>
			update_windowlist_registry(window): Promise<any>
			update_windowlist_registry$({ window }): Promise<any>
			get_title(): Promise<any>
			get_title$($: {}): Promise<any>
			wakeup(): Promise<any>
			wakeup$($: {}): Promise<any>
		}
		let registry: Promise<any>
	}
	module zoomheight {
		var _
		function get_window_geometry(top): Promise<any>
		function get_window_geometry$({ top }): Promise<any>
		function set_window_geometry(top, geometry): Promise<any>
		function set_window_geometry$({ top, geometry }): Promise<any>
		interface IWmInfoGatheringError {
		}
		function ZoomHeight(editwin): Promise<IZoomHeight>
		function ZoomHeight$({ editwin }): Promise<IZoomHeight>
		interface IZoomHeight {
			zoom_height_event(event?): Promise<any>
			zoom_height_event$({ event }: { event?}): Promise<any>
			zoom_height(): Promise<any>
			zoom_height$($: {}): Promise<any>
			get_max_height_and_y_coord(): Promise<any>
			get_max_height_and_y_coord$($: {}): Promise<any>
		}
	}
	module zzdummy {
		var _

		/**
		 * Apply a formatting function to all of the selected lines.
		 */
		function format_selection(format_line): Promise<any>
		function format_selection$({ format_line }): Promise<any>

		/**
		 * Prepend or remove initial text from selected lines.
		 */

		/**
		 * Initialize the settings for this extension.
		 */
		function ZzDummy(editwin): Promise<IZzDummy>
		function ZzDummy$({ editwin }): Promise<IZzDummy>
		interface IZzDummy {

			/**
			 * Load class variables from config.
			 */
			reload(): Promise<any>
			reload$($: {}): Promise<any>

			/**
			 * Insert text at the beginning of each selected line.
			 * 
			 *         This is bound to the <<z-in>> virtual event when the extensions
			 *         are loaded.
			 *         
			 */
			z_in_event(line): Promise<any>
			z_in_event$({ line }): Promise<any>

			/**
			 * Remove specific text from the beginning of each selected line.
			 * 
			 *         This is bound to the <<z-out>> virtual event when the extensions
			 *         are loaded.
			 *         
			 */
			z_out_event(line): Promise<any>
			z_out_event$({ line }): Promise<any>
			menudefs
		}
	}
}
declare module imaplib {
	var _

	/**
	 * Parse an IMAP4 INTERNALDATE string.
	 * 
	 *     Return corresponding local time.  The return value is a
	 *     time.struct_time tuple or None if the string has wrong format.
	 *     
	 */
	function Internaldate2tuple(resp): Promise<any>
	function Internaldate2tuple$({ resp }): Promise<any>

	/**
	 * Convert integer to A-P string representation.
	 */
	function Int2AP(num): Promise<any>
	function Int2AP$({ num }): Promise<any>

	/**
	 * Convert IMAP4 flags response to python tuple.
	 */
	function ParseFlags(resp): Promise<any>
	function ParseFlags$({ resp }): Promise<any>

	/**
	 * Convert date_time to IMAP4 INTERNALDATE representation.
	 * 
	 *     Return string in form: '"DD-Mmm-YYYY HH:MM:SS +HHMM"'.  The
	 *     date_time argument can be a number (int or float) representing
	 *     seconds since epoch (as returned by time.time()), a 9-tuple
	 *     representing local time, an instance of time.struct_time (as
	 *     returned by time.localtime()), an aware datetime instance or a
	 *     double-quoted string.  In the last case, it is assumed to already
	 *     be in the correct format.
	 *     
	 */
	function Time2Internaldate(date_time): Promise<any>
	function Time2Internaldate$({ date_time }): Promise<any>
	function run(cmd, args): Promise<any>
	function run$({ cmd, args }): Promise<any>

	/**
	 * IMAP4 client class.
	 * 
	 *     Instantiate with: IMAP4([host[, port[, timeout=None]]])
	 * 
	 *             host - host's name (default: localhost);
	 *             port - port number (default: standard IMAP4 port).
	 *             timeout - socket timeout (default: None)
	 *                       If timeout is not given or is None,
	 *                       the global default socket timeout is used
	 * 
	 *     All IMAP4rev1 commands are supported by methods of the same
	 *     name (in lowercase).
	 * 
	 *     All arguments to commands are converted to strings, except for
	 *     AUTHENTICATE, and the last argument to APPEND which is passed as
	 *     an IMAP4 literal.  If necessary (the string contains any
	 *     non-printing characters or white-space and isn't enclosed with
	 *     either parentheses or double quotes) each string is quoted.
	 *     However, the 'password' argument to the LOGIN command is always
	 *     quoted.  If you want to avoid having an argument string quoted
	 *     (eg: the 'flags' argument to STORE) then enclose the string in
	 *     parentheses (eg: "(\Deleted)").
	 * 
	 *     Each command returns a tuple: (type, [data, ...]) where 'type'
	 *     is usually 'OK' or 'NO', and 'data' is either the text from the
	 *     tagged response, or untagged results from command. Each 'data'
	 *     is either a string, or a tuple. If a tuple, then the first part
	 *     is the header of the response, and the second part contains
	 *     the data (ie: 'literal' value).
	 * 
	 *     Errors raise the exception class <instance>.error("<reason>").
	 *     IMAP4 server errors raise <instance>.abort("<reason>"),
	 *     which is a sub-class of 'error'. Mailbox status changes
	 *     from READ-WRITE to READ-ONLY raise the exception class
	 *     <instance>.readonly("<reason>"), which is a sub-class of 'abort'.
	 * 
	 *     "error" exceptions imply a program error.
	 *     "abort" exceptions imply the connection should be reset, and
	 *             the command re-tried.
	 *     "readonly" exceptions imply the command should be re-tried.
	 * 
	 *     Note: to use this module, you must read the RFCs pertaining to the
	 *     IMAP4 protocol, as the semantics of the arguments to each IMAP4
	 *     command are left to the invoker, not to mention the results. Also,
	 *     most IMAP servers implement a sub-set of the commands available here.
	 *     
	 */
	function IMAP4(host?, port?, timeout?): Promise<IIMAP4>
	function IMAP4$({ host, port, timeout }: { host?, port?, timeout?}): Promise<IIMAP4>
	interface IIMAP4 {

		/**
		 * Setup connection to remote server on "host:port"
		 *             (default: localhost:standard IMAP4 port).
		 *         This connection will be used by the routines:
		 *             read, readline, send, shutdown.
		 *         
		 */
		open(host?, port?, timeout?): Promise<any>
		open$({ host, port, timeout }: { host?, port?, timeout?}): Promise<any>

		/**
		 * Read 'size' bytes from remote.
		 */
		read(size): Promise<any>
		read$({ size }): Promise<any>

		/**
		 * Read line from remote.
		 */
		readline(): Promise<any>
		readline$($: {}): Promise<any>

		/**
		 * Send data to remote.
		 */
		send(data): Promise<any>
		send$({ data }): Promise<any>

		/**
		 * Close I/O established in "open".
		 */
		shutdown(): Promise<any>
		shutdown$($: {}): Promise<any>

		/**
		 * Return socket instance used to connect to IMAP4 server.
		 * 
		 *         socket = <instance>.socket()
		 *         
		 */
		socket(): Promise<any>
		socket$($: {}): Promise<any>

		/**
		 * Return most recent 'RECENT' responses if any exist,
		 *         else prompt server for an update using the 'NOOP' command.
		 * 
		 *         (typ, [data]) = <instance>.recent()
		 * 
		 *         'data' is None if no new messages,
		 *         else list of RECENT responses, most recent last.
		 *         
		 */
		recent(): Promise<any>
		recent$($: {}): Promise<any>

		/**
		 * Return data for response 'code' if received, or None.
		 * 
		 *         Old value for response 'code' is cleared.
		 * 
		 *         (code, [data]) = <instance>.response(code)
		 *         
		 */
		response(code): Promise<any>
		response$({ code }): Promise<any>

		/**
		 * Append message to named mailbox.
		 * 
		 *         (typ, [data]) = <instance>.append(mailbox, flags, date_time, message)
		 * 
		 *                 All args except `message' can be None.
		 *         
		 */
		append(mailbox, flags, date_time, message): Promise<any>
		append$({ mailbox, flags, date_time, message }): Promise<any>

		/**
		 * Authenticate command - requires response processing.
		 * 
		 *         'mechanism' specifies which authentication mechanism is to
		 *         be used - it must appear in <instance>.capabilities in the
		 *         form AUTH=<mechanism>.
		 * 
		 *         'authobject' must be a callable object:
		 * 
		 *                 data = authobject(response)
		 * 
		 *         It will be called to process server continuation responses; the
		 *         response argument it is passed will be a bytes.  It should return bytes
		 *         data that will be base64 encoded and sent to the server.  It should
		 *         return None if the client abort response '*' should be sent instead.
		 *         
		 */
		authenticate(mechanism, authobject): Promise<any>
		authenticate$({ mechanism, authobject }): Promise<any>

		/**
		 * (typ, [data]) = <instance>.capability()
		 *         Fetch capabilities list from server.
		 */
		capability(): Promise<any>
		capability$($: {}): Promise<any>

		/**
		 * Checkpoint mailbox on server.
		 * 
		 *         (typ, [data]) = <instance>.check()
		 *         
		 */
		check(): Promise<any>
		check$($: {}): Promise<any>

		/**
		 * Close currently selected mailbox.
		 * 
		 *         Deleted messages are removed from writable mailbox.
		 *         This is the recommended command before 'LOGOUT'.
		 * 
		 *         (typ, [data]) = <instance>.close()
		 *         
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>

		/**
		 * Copy 'message_set' messages onto end of 'new_mailbox'.
		 * 
		 *         (typ, [data]) = <instance>.copy(message_set, new_mailbox)
		 *         
		 */
		copy(message_set, new_mailbox): Promise<any>
		copy$({ message_set, new_mailbox }): Promise<any>

		/**
		 * Create new mailbox.
		 * 
		 *         (typ, [data]) = <instance>.create(mailbox)
		 *         
		 */
		create(mailbox): Promise<any>
		create$({ mailbox }): Promise<any>

		/**
		 * Delete old mailbox.
		 * 
		 *         (typ, [data]) = <instance>.delete(mailbox)
		 *         
		 */
		delete(mailbox): Promise<any>
		delete$({ mailbox }): Promise<any>

		/**
		 * Delete the ACLs (remove any rights) set for who on mailbox.
		 * 
		 *         (typ, [data]) = <instance>.deleteacl(mailbox, who)
		 *         
		 */
		deleteacl(mailbox, who): Promise<any>
		deleteacl$({ mailbox, who }): Promise<any>

		/**
		 * Send an RFC5161 enable string to the server.
		 * 
		 *         (typ, [data]) = <instance>.enable(capability)
		 *         
		 */
		enable(capability): Promise<any>
		enable$({ capability }): Promise<any>

		/**
		 * Permanently remove deleted items from selected mailbox.
		 * 
		 *         Generates 'EXPUNGE' response for each deleted message.
		 * 
		 *         (typ, [data]) = <instance>.expunge()
		 * 
		 *         'data' is list of 'EXPUNGE'd message numbers in order received.
		 *         
		 */
		expunge(): Promise<any>
		expunge$($: {}): Promise<any>

		/**
		 * Fetch (parts of) messages.
		 * 
		 *         (typ, [data, ...]) = <instance>.fetch(message_set, message_parts)
		 * 
		 *         'message_parts' should be a string of selected parts
		 *         enclosed in parentheses, eg: "(UID BODY[TEXT])".
		 * 
		 *         'data' are tuples of message part envelope and data.
		 *         
		 */
		fetch(message_set, message_parts): Promise<any>
		fetch$({ message_set, message_parts }): Promise<any>

		/**
		 * Get the ACLs for a mailbox.
		 * 
		 *         (typ, [data]) = <instance>.getacl(mailbox)
		 *         
		 */
		getacl(mailbox): Promise<any>
		getacl$({ mailbox }): Promise<any>

		/**
		 * (typ, [data]) = <instance>.getannotation(mailbox, entry, attribute)
		 *         Retrieve ANNOTATIONs.
		 */
		getannotation(mailbox, entry, attribute): Promise<any>
		getannotation$({ mailbox, entry, attribute }): Promise<any>

		/**
		 * Get the quota root's resource usage and limits.
		 * 
		 *         Part of the IMAP4 QUOTA extension defined in rfc2087.
		 * 
		 *         (typ, [data]) = <instance>.getquota(root)
		 *         
		 */
		getquota(root): Promise<any>
		getquota$({ root }): Promise<any>

		/**
		 * Get the list of quota roots for the named mailbox.
		 * 
		 *         (typ, [[QUOTAROOT responses...], [QUOTA responses]]) = <instance>.getquotaroot(mailbox)
		 *         
		 */
		getquotaroot(mailbox): Promise<any>
		getquotaroot$({ mailbox }): Promise<any>

		/**
		 * List mailbox names in directory matching pattern.
		 * 
		 *         (typ, [data]) = <instance>.list(directory='""', pattern='*')
		 * 
		 *         'data' is list of LIST responses.
		 *         
		 */
		list(directory?, pattern?): Promise<any>
		list$({ directory, pattern }: { directory?, pattern?}): Promise<any>

		/**
		 * Identify client using plaintext password.
		 * 
		 *         (typ, [data]) = <instance>.login(user, password)
		 * 
		 *         NB: 'password' will be quoted.
		 *         
		 */
		login(user, password): Promise<any>
		login$({ user, password }): Promise<any>

		/**
		 *  Force use of CRAM-MD5 authentication.
		 * 
		 *         (typ, [data]) = <instance>.login_cram_md5(user, password)
		 *         
		 */
		login_cram_md5(user, password): Promise<any>
		login_cram_md5$({ user, password }): Promise<any>

		/**
		 * Shutdown connection to server.
		 * 
		 *         (typ, [data]) = <instance>.logout()
		 * 
		 *         Returns server 'BYE' response.
		 *         
		 */
		logout(): Promise<any>
		logout$($: {}): Promise<any>

		/**
		 * List 'subscribed' mailbox names in directory matching pattern.
		 * 
		 *         (typ, [data, ...]) = <instance>.lsub(directory='""', pattern='*')
		 * 
		 *         'data' are tuples of message part envelope and data.
		 *         
		 */
		lsub(directory?, pattern?): Promise<any>
		lsub$({ directory, pattern }: { directory?, pattern?}): Promise<any>

		/**
		 * Show my ACLs for a mailbox (i.e. the rights that I have on mailbox).
		 * 
		 *         (typ, [data]) = <instance>.myrights(mailbox)
		 *         
		 */
		myrights(mailbox): Promise<any>
		myrights$({ mailbox }): Promise<any>

		/**
		 *  Returns IMAP namespaces ala rfc2342
		 * 
		 *         (typ, [data, ...]) = <instance>.namespace()
		 *         
		 */
		namespace(): Promise<any>
		namespace$($: {}): Promise<any>

		/**
		 * Send NOOP command.
		 * 
		 *         (typ, [data]) = <instance>.noop()
		 *         
		 */
		noop(): Promise<any>
		noop$($: {}): Promise<any>

		/**
		 * Fetch truncated part of a message.
		 * 
		 *         (typ, [data, ...]) = <instance>.partial(message_num, message_part, start, length)
		 * 
		 *         'data' is tuple of message part envelope and data.
		 *         
		 */
		partial(message_num, message_part, start, length): Promise<any>
		partial$({ message_num, message_part, start, length }): Promise<any>

		/**
		 * Assume authentication as "user".
		 * 
		 *         Allows an authorised administrator to proxy into any user's
		 *         mailbox.
		 * 
		 *         (typ, [data]) = <instance>.proxyauth(user)
		 *         
		 */
		proxyauth(user): Promise<any>
		proxyauth$({ user }): Promise<any>

		/**
		 * Rename old mailbox name to new.
		 * 
		 *         (typ, [data]) = <instance>.rename(oldmailbox, newmailbox)
		 *         
		 */
		rename(oldmailbox, newmailbox): Promise<any>
		rename$({ oldmailbox, newmailbox }): Promise<any>

		/**
		 * Search mailbox for matching messages.
		 * 
		 *         (typ, [data]) = <instance>.search(charset, criterion, ...)
		 * 
		 *         'data' is space separated list of matching message numbers.
		 *         If UTF8 is enabled, charset MUST be None.
		 *         
		 */
		search(charset): Promise<any>
		search$({ charset }): Promise<any>

		/**
		 * Select a mailbox.
		 * 
		 *         Flush all untagged responses.
		 * 
		 *         (typ, [data]) = <instance>.select(mailbox='INBOX', readonly=False)
		 * 
		 *         'data' is count of messages in mailbox ('EXISTS' response).
		 * 
		 *         Mandated responses are ('FLAGS', 'EXISTS', 'RECENT', 'UIDVALIDITY'), so
		 *         other responses should be obtained via <instance>.response('FLAGS') etc.
		 *         
		 */
		select(mailbox?, readonly?: boolean): Promise<any>
		select$({ mailbox, readonly }: { mailbox?, readonly?}): Promise<any>

		/**
		 * Set a mailbox acl.
		 * 
		 *         (typ, [data]) = <instance>.setacl(mailbox, who, what)
		 *         
		 */
		setacl(mailbox, who, what): Promise<any>
		setacl$({ mailbox, who, what }): Promise<any>

		/**
		 * (typ, [data]) = <instance>.setannotation(mailbox[, entry, attribute]+)
		 *         Set ANNOTATIONs.
		 */
		setannotation(): Promise<any>
		setannotation$($: {}): Promise<any>

		/**
		 * Set the quota root's resource limits.
		 * 
		 *         (typ, [data]) = <instance>.setquota(root, limits)
		 *         
		 */
		setquota(root, limits): Promise<any>
		setquota$({ root, limits }): Promise<any>

		/**
		 * IMAP4rev1 extension SORT command.
		 * 
		 *         (typ, [data]) = <instance>.sort(sort_criteria, charset, search_criteria, ...)
		 *         
		 */
		sort(sort_criteria, charset): Promise<any>
		sort$({ sort_criteria, charset }): Promise<any>
		starttls(ssl_context?): Promise<any>
		starttls$({ ssl_context }: { ssl_context?}): Promise<any>

		/**
		 * Request named status conditions for mailbox.
		 * 
		 *         (typ, [data]) = <instance>.status(mailbox, names)
		 *         
		 */
		status(mailbox, names): Promise<any>
		status$({ mailbox, names }): Promise<any>

		/**
		 * Alters flag dispositions for messages in mailbox.
		 * 
		 *         (typ, [data]) = <instance>.store(message_set, command, flags)
		 *         
		 */
		store(message_set, command, flags): Promise<any>
		store$({ message_set, command, flags }): Promise<any>

		/**
		 * Subscribe to new mailbox.
		 * 
		 *         (typ, [data]) = <instance>.subscribe(mailbox)
		 *         
		 */
		subscribe(mailbox): Promise<any>
		subscribe$({ mailbox }): Promise<any>

		/**
		 * IMAPrev1 extension THREAD command.
		 * 
		 *         (type, [data]) = <instance>.thread(threading_algorithm, charset, search_criteria, ...)
		 *         
		 */
		thread(threading_algorithm, charset): Promise<any>
		thread$({ threading_algorithm, charset }): Promise<any>

		/**
		 * Execute "command arg ..." with messages identified by UID,
		 *                 rather than message number.
		 * 
		 *         (typ, [data]) = <instance>.uid(command, arg1, arg2, ...)
		 * 
		 *         Returns response appropriate to 'command'.
		 *         
		 */
		uid(command): Promise<any>
		uid$({ command }): Promise<any>

		/**
		 * Unsubscribe from old mailbox.
		 * 
		 *         (typ, [data]) = <instance>.unsubscribe(mailbox)
		 *         
		 */
		unsubscribe(mailbox): Promise<any>
		unsubscribe$({ mailbox }): Promise<any>

		/**
		 * Free server's resources associated with the selected mailbox
		 *         and returns the server to the authenticated state.
		 *         This command performs the same actions as CLOSE, except
		 *         that no messages are permanently removed from the currently
		 *         selected mailbox.
		 * 
		 *         (typ, [data]) = <instance>.unselect()
		 *         
		 */
		unselect(): Promise<any>
		unselect$($: {}): Promise<any>

		/**
		 * Allow simple extension commands
		 *                 notified by server in CAPABILITY response.
		 * 
		 *         Assumes command is legal in current state.
		 * 
		 *         (typ, [data]) = <instance>.xatom(name, arg, ...)
		 * 
		 *         Returns response appropriate to extension command `name'.
		 *         
		 */
		xatom(name): Promise<any>
		xatom$({ name }): Promise<any>
	}

	/**
	 * IMAP4 client class over SSL connection
	 * 
	 *         Instantiate with: IMAP4_SSL([host[, port[, keyfile[, certfile[, ssl_context[, timeout=None]]]]]])
	 * 
	 *                 host - host's name (default: localhost);
	 *                 port - port number (default: standard IMAP4 SSL port);
	 *                 keyfile - PEM formatted file that contains your private key (default: None);
	 *                 certfile - PEM formatted certificate chain file (default: None);
	 *                 ssl_context - a SSLContext object that contains your certificate chain
	 *                               and private key (default: None)
	 *                 Note: if ssl_context is provided, then parameters keyfile or
	 *                 certfile should not be set otherwise ValueError is raised.
	 *                 timeout - socket timeout (default: None) If timeout is not given or is None,
	 *                           the global default socket timeout is used
	 * 
	 *         for more documentation see the docstring of the parent class IMAP4.
	 *         
	 */
	function IMAP4_SSL(host?, port?, keyfile?, certfile?, ssl_context?, timeout?): Promise<IIMAP4_SSL>
	function IMAP4_SSL$({ host, port, keyfile, certfile, ssl_context, timeout }: { host?, port?, keyfile?, certfile?, ssl_context?, timeout?}): Promise<IIMAP4_SSL>
	interface IIMAP4_SSL extends IIMAP4 {

		/**
		 * Setup connection to remote server on "host:port".
		 *                 (default: localhost:standard IMAP4 SSL port).
		 *             This connection will be used by the routines:
		 *                 read, readline, send, shutdown.
		 *             
		 */
		open(host?, port?, timeout?): Promise<any>
		open$({ host, port, timeout }: { host?, port?, timeout?}): Promise<any>
	}

	/**
	 * IMAP4 client class over a stream
	 * 
	 *     Instantiate with: IMAP4_stream(command)
	 * 
	 *             "command" - a string that can be passed to subprocess.Popen()
	 * 
	 *     for more documentation see the docstring of the parent class IMAP4.
	 *     
	 */
	function IMAP4_stream(command): Promise<IIMAP4_stream>
	function IMAP4_stream$({ command }): Promise<IIMAP4_stream>
	interface IIMAP4_stream extends IIMAP4 {

		/**
		 * Setup a stream connection.
		 *         This connection will be used by the routines:
		 *             read, readline, send, shutdown.
		 *         
		 */
		open(host?, port?, timeout?): Promise<any>
		open$({ host, port, timeout }: { host?, port?, timeout?}): Promise<any>

		/**
		 * Read 'size' bytes from remote.
		 */
		read(size): Promise<any>
		read$({ size }): Promise<any>

		/**
		 * Read line from remote.
		 */
		readline(): Promise<any>
		readline$($: {}): Promise<any>

		/**
		 * Send data to remote.
		 */
		send(data): Promise<any>
		send$({ data }): Promise<any>

		/**
		 * Close I/O established in "open".
		 */
		shutdown(): Promise<any>
		shutdown$($: {}): Promise<any>
	}

	/**
	 * Private class to provide en/decoding
	 *             for base64-based authentication conversation.
	 *     
	 */
	interface I_Authenticator {
		process(data): Promise<any>
		process$({ data }): Promise<any>
		encode(inp): Promise<any>
		encode$({ inp }): Promise<any>
		decode(inp): Promise<any>
		decode$({ inp }): Promise<any>
	}
	let HAVE_SSL: Promise<any>
	let CRLF: Promise<any>
	let Debug: Promise<any>
	let IMAP4_PORT: Promise<any>
	let IMAP4_SSL_PORT: Promise<any>
	let AllowedVersions: Promise<any>
	let Commands: Promise<any>
	let Continuation: Promise<any>
	let Flags: Promise<any>
	let InternalDate: Promise<any>
	let Literal: Promise<any>
	let MapCRLF: Promise<any>
	let Response_code: Promise<any>
	let Untagged_response: Promise<any>
	let Untagged_status: Promise<any>
	let Months: Promise<any>
	let Mon2num: Promise<any>
	let stream_command: Promise<any>
	let args: Promise<any>
	let host: Promise<any>
	let USER: Promise<any>
	let PASSWD: Promise<any>
	let test_mesg: Promise<any>
	let test_seq1: Promise<any>
	let test_seq2: Promise<any>
	let M: Promise<any>
	let mo: Promise<any>
	let path: Promise<any>
	let dat: Promise<any>
}
declare module imghdr {
	var _
	function what(file, h?): Promise<any>
	function what$({ file, h }: { file, h?}): Promise<any>

	/**
	 * JPEG data in JFIF or Exif format
	 */
	function test_jpeg(h, f): Promise<any>
	function test_jpeg$({ h, f }): Promise<any>
	function test_png(h, f): Promise<any>
	function test_png$({ h, f }): Promise<any>

	/**
	 * GIF ('87 and '89 variants)
	 */
	function test_gif(h, f): Promise<any>
	function test_gif$({ h, f }): Promise<any>

	/**
	 * TIFF (can be in Motorola or Intel byte order)
	 */
	function test_tiff(h, f): Promise<any>
	function test_tiff$({ h, f }): Promise<any>

	/**
	 * SGI image library
	 */
	function test_rgb(h, f): Promise<any>
	function test_rgb$({ h, f }): Promise<any>

	/**
	 * PBM (portable bitmap)
	 */
	function test_pbm(h, f): Promise<any>
	function test_pbm$({ h, f }): Promise<any>

	/**
	 * PGM (portable graymap)
	 */
	function test_pgm(h, f): Promise<any>
	function test_pgm$({ h, f }): Promise<any>

	/**
	 * PPM (portable pixmap)
	 */
	function test_ppm(h, f): Promise<any>
	function test_ppm$({ h, f }): Promise<any>

	/**
	 * Sun raster file
	 */
	function test_rast(h, f): Promise<any>
	function test_rast$({ h, f }): Promise<any>

	/**
	 * X bitmap (X10 or X11)
	 */
	function test_xbm(h, f): Promise<any>
	function test_xbm$({ h, f }): Promise<any>
	function test_bmp(h, f): Promise<any>
	function test_bmp$({ h, f }): Promise<any>
	function test_webp(h, f): Promise<any>
	function test_webp$({ h, f }): Promise<any>
	function test_exr(h, f): Promise<any>
	function test_exr$({ h, f }): Promise<any>
	function test(): Promise<any>
	function test$($: {}): Promise<any>
	function testall(list, recursive, toplevel): Promise<any>
	function testall$({ list, recursive, toplevel }): Promise<any>
	let tests: Promise<any>
}
declare module imp {
	var _

	/**
	 * **DEPRECATED**
	 * 
	 *     Create a new module.
	 * 
	 *     The module is not entered into sys.modules.
	 * 
	 *     
	 */
	function new_module(name): Promise<any>
	function new_module$({ name }): Promise<any>

	/**
	 * **DEPRECATED**
	 * 
	 *     Return the magic number for .pyc files.
	 *     
	 */
	function get_magic(): Promise<any>
	function get_magic$($: {}): Promise<any>

	/**
	 * Return the magic tag for .pyc files.
	 */
	function get_tag(): Promise<any>
	function get_tag$($: {}): Promise<any>

	/**
	 * **DEPRECATED**
	 * 
	 *     Given the path to a .py file, return the path to its .pyc file.
	 * 
	 *     The .py file does not need to exist; this simply returns the path to the
	 *     .pyc file calculated as if the .py file were imported.
	 * 
	 *     If debug_override is not None, then it must be a boolean and is used in
	 *     place of sys.flags.optimize.
	 * 
	 *     If sys.implementation.cache_tag is None then NotImplementedError is raised.
	 * 
	 *     
	 */
	function cache_from_source(path, debug_override?): Promise<any>
	function cache_from_source$({ path, debug_override }: { path, debug_override?}): Promise<any>

	/**
	 * **DEPRECATED**
	 * 
	 *     Given the path to a .pyc. file, return the path to its .py file.
	 * 
	 *     The .pyc file does not need to exist; this simply returns the path to
	 *     the .py file calculated to correspond to the .pyc file.  If path does
	 *     not conform to PEP 3147 format, ValueError will be raised. If
	 *     sys.implementation.cache_tag is None then NotImplementedError is raised.
	 * 
	 *     
	 */
	function source_from_cache(path): Promise<any>
	function source_from_cache$({ path }): Promise<any>

	/**
	 * **DEPRECATED**
	 */
	function get_suffixes(): Promise<any>
	function get_suffixes$($: {}): Promise<any>
	function load_source(name, pathname, file?): Promise<any>
	function load_source$({ name, pathname, file }: { name, pathname, file?}): Promise<any>

	/**
	 * **DEPRECATED**
	 */
	function load_compiled(name, pathname, file?): Promise<any>
	function load_compiled$({ name, pathname, file }: { name, pathname, file?}): Promise<any>

	/**
	 * **DEPRECATED**
	 */
	function load_package(name, path): Promise<any>
	function load_package$({ name, path }): Promise<any>

	/**
	 * **DEPRECATED**
	 * 
	 *     Load a module, given information returned by find_module().
	 * 
	 *     The module name must include the full package name, if any.
	 * 
	 *     
	 */
	function load_module(name, file, filename, details): Promise<any>
	function load_module$({ name, file, filename, details }): Promise<any>

	/**
	 * **DEPRECATED**
	 * 
	 *     Search for a module.
	 * 
	 *     If path is omitted or None, search for a built-in, frozen or special
	 *     module and continue search in sys.path. The module name cannot
	 *     contain '.'; to search for a submodule of a package, pass the
	 *     submodule name and the package's __path__.
	 * 
	 *     
	 */
	function find_module(name, path?): Promise<any>
	function find_module$({ name, path }: { name, path?}): Promise<any>

	/**
	 * **DEPRECATED**
	 * 
	 *     Reload the module and return it.
	 * 
	 *     The module must have been successfully imported before.
	 * 
	 *     
	 */
	function reload(module): Promise<any>
	function reload$({ module }): Promise<any>

	/**
	 * **DEPRECATED**
	 * 
	 *     Load and return a built-in module by name, or None is such module doesn't
	 *     exist
	 *     
	 */
	function init_builtin(name): Promise<any>
	function init_builtin$({ name }): Promise<any>

	/**
	 * **DEPRECATED**
	 * 
	 *         Load an extension module.
	 *         
	 */
	function load_dynamic(name, path, file?): Promise<any>
	function load_dynamic$({ name, path, file }: { name, path, file?}): Promise<any>

	/**
	 * **DEPRECATED**
	 * 
	 *     Null import object.
	 * 
	 *     
	 */
	function NullImporter(path): Promise<INullImporter>
	function NullImporter$({ path }): Promise<INullImporter>
	interface INullImporter {

		/**
		 * Always returns None.
		 */
		find_module(fullname): Promise<any>
		find_module$({ fullname }): Promise<any>
	}

	/**
	 * Compatibility support for 'file' arguments of various load_*()
	 *     functions.
	 */
	interface I_HackedGetData {

		/**
		 * Gross hack to contort loader to deal w/ load_*()'s bad API.
		 */
		get_data(path): Promise<any>
		get_data$({ path }): Promise<any>
	}

	/**
	 * Compatibility support for implementing load_source().
	 */
	interface I_LoadSourceCompatibility extends I_HackedGetData {
	}

	/**
	 * Compatibility support for implementing load_compiled().
	 */
	interface I_LoadCompiledCompatibility extends I_HackedGetData {
	}
	let SEARCH_ERROR: Promise<any>
	let PY_SOURCE: Promise<any>
	let PY_COMPILED: Promise<any>
	let C_EXTENSION: Promise<any>
	let PY_RESOURCE: Promise<any>
	let PKG_DIRECTORY: Promise<any>
	let C_BUILTIN: Promise<any>
	let PY_FROZEN: Promise<any>
	let PY_CODERESOURCE: Promise<any>
	let IMP_HOOK: Promise<any>
}
declare module importlib {
	var _

	/**
	 * Call the invalidate_caches() method on all meta path finders stored in
	 *     sys.meta_path (where implemented).
	 */
	function invalidate_caches(): Promise<any>
	function invalidate_caches$($: {}): Promise<any>

	/**
	 * Return the loader for the specified module.
	 * 
	 *     This is a backward-compatible wrapper around find_spec().
	 * 
	 *     This function is deprecated in favor of importlib.util.find_spec().
	 * 
	 *     
	 */
	function find_loader(name, path?): Promise<any>
	function find_loader$({ name, path }: { name, path?}): Promise<any>

	/**
	 * Import a module.
	 * 
	 *     The 'package' argument is required when performing a relative import. It
	 *     specifies the package to use as the anchor point from which to resolve the
	 *     relative import to an absolute import.
	 * 
	 *     
	 */
	function import_module(name, package?): Promise<any>
	function import_module$({ name, package }: { name, package?}): Promise<any>

	/**
	 * Reload the module and return it.
	 * 
	 *     The module must have been successfully imported before.
	 * 
	 *     
	 */
	function reload(module): Promise<any>
	function reload$({ module }): Promise<any>
	module _abc {
		var _

		/**
		 * Abstract base class for import loaders.
		 */
		interface ILoader {

			/**
			 * Return a module to initialize and into which to load.
			 * 
			 *         This method should raise ImportError if anything prevents it
			 *         from creating a new module.  It may return None to indicate
			 *         that the spec should create the new module.
			 *         
			 */
			create_module(spec): Promise<any>
			create_module$({ spec }): Promise<any>

			/**
			 * Return the loaded module.
			 * 
			 *         The module must be added to sys.modules and have import-related
			 *         attributes set properly.  The fullname is a str.
			 * 
			 *         ImportError is raised on failure.
			 * 
			 *         This method is deprecated in favor of loader.exec_module(). If
			 *         exec_module() exists then it is used to provide a backwards-compatible
			 *         functionality for this method.
			 * 
			 *         
			 */
			load_module(fullname): Promise<any>
			load_module$({ fullname }): Promise<any>

			/**
			 * Return a module's repr.
			 * 
			 *         Used by the module type when the method does not raise
			 *         NotImplementedError.
			 * 
			 *         This method is deprecated.
			 * 
			 *         
			 */
			module_repr(module): Promise<any>
			module_repr$({ module }): Promise<any>
		}
	}
	module _adapters {
		var _

		/**
		 * 
		 *     Construct a package spec with traversable compatibility
		 *     on the spec/loader/reader.
		 *     
		 */
		function wrap_spec(package): Promise<any>
		function wrap_spec$({ package }): Promise<any>

		/**
		 * 
		 *     Adapt a package spec to adapt the underlying loader.
		 *     
		 */
		function SpecLoaderAdapter(spec, adapter?): Promise<ISpecLoaderAdapter>
		function SpecLoaderAdapter$({ spec, adapter }: { spec, adapter?}): Promise<ISpecLoaderAdapter>
		interface ISpecLoaderAdapter {
		}

		/**
		 * 
		 *     Adapt a loader to provide TraversableResources.
		 *     
		 */
		function TraversableResourcesLoader(spec): Promise<ITraversableResourcesLoader>
		function TraversableResourcesLoader$({ spec }): Promise<ITraversableResourcesLoader>
		interface ITraversableResourcesLoader {
			get_resource_reader(name): Promise<any>
			get_resource_reader$({ name }): Promise<any>
		}

		/**
		 * 
		 *     Adapter for an existing or non-existant resource reader
		 *     to provide a degenerate .files().
		 *     
		 */
		function DegenerateFiles(spec): Promise<IDegenerateFiles>
		function DegenerateFiles$({ spec }): Promise<IDegenerateFiles>
		interface IDegenerateFiles {
			files(): Promise<any>
			files$($: {}): Promise<any>
		}
	}
	module _bootstrap {
		var _

		/**
		 * Return a module spec based on various loader methods.
		 */
		function spec_from_loader(name, loader): Promise<any>
		function spec_from_loader$({ name, loader }): Promise<any>

		/**
		 * Create a module based on the provided spec.
		 */
		function module_from_spec(spec): Promise<any>
		function module_from_spec$({ spec }): Promise<any>
		interface I_DeadlockError {
		}

		/**
		 * A recursive lock implementation which is able to detect deadlocks
		 *     (e.g. thread 1 trying to take locks A then B, and thread 2 trying to
		 *     take locks B then A).
		 *     
		 */
		interface I_ModuleLock {
			has_deadlock(): Promise<any>
			has_deadlock$($: {}): Promise<any>

			/**
			 * 
			 *         Acquire the module lock.  If a potential deadlock is detected,
			 *         a _DeadlockError is raised.
			 *         Otherwise, the lock is always acquired and True is returned.
			 *         
			 */
			acquire(): Promise<any>
			acquire$($: {}): Promise<any>
			release(): Promise<any>
			release$($: {}): Promise<any>
		}

		/**
		 * A simple _ModuleLock equivalent for Python builds without
		 *     multi-threading support.
		 */
		interface I_DummyModuleLock {
			acquire(): Promise<any>
			acquire$($: {}): Promise<any>
			release(): Promise<any>
			release$($: {}): Promise<any>
		}
		interface I_ModuleLockManager {
		}

		/**
		 * The specification for a module, used for loading.
		 * 
		 *     A module's spec is the source for information about the module.  For
		 *     data associated with the module, including source, use the spec's
		 *     loader.
		 * 
		 *     `name` is the absolute name of the module.  `loader` is the loader
		 *     to use when loading the module.  `parent` is the name of the
		 *     package the module is in.  The parent is derived from the name.
		 * 
		 *     `is_package` determines if the module is considered a package or
		 *     not.  On modules this is reflected by the `__path__` attribute.
		 * 
		 *     `origin` is the specific location used by the loader from which to
		 *     load the module, if that information is available.  When filename is
		 *     set, origin will match.
		 * 
		 *     `has_location` indicates that a spec's "origin" reflects a location.
		 *     When this is True, `__file__` attribute of the module is set.
		 * 
		 *     `cached` is the location of the cached bytecode file, if any.  It
		 *     corresponds to the `__cached__` attribute.
		 * 
		 *     `submodule_search_locations` is the sequence of path entries to
		 *     search when importing submodules.  If set, is_package should be
		 *     True--and False otherwise.
		 * 
		 *     Packages are simply modules that (may) have submodules.  If a spec
		 *     has a non-None value in `submodule_search_locations`, the import
		 *     system will consider modules loaded from the spec as packages.
		 * 
		 *     Only finders (see importlib.abc.MetaPathFinder and
		 *     importlib.abc.PathEntryFinder) should modify ModuleSpec instances.
		 * 
		 *     
		 */
		function ModuleSpec(name, loader): Promise<IModuleSpec>
		function ModuleSpec$({ name, loader }): Promise<IModuleSpec>
		interface IModuleSpec {
			cached(): Promise<any>
			cached$($: {}): Promise<any>
			cached(cached): Promise<any>
			cached$({ cached }): Promise<any>

			/**
			 * The name of the module's parent.
			 */
			parent(): Promise<any>
			parent$($: {}): Promise<any>
			has_location(): Promise<any>
			has_location$($: {}): Promise<any>
			has_location(value): Promise<any>
			has_location$({ value }): Promise<any>
		}

		/**
		 * Meta path import for built-in modules.
		 * 
		 *     All methods are either class or static methods to avoid the need to
		 *     instantiate the class.
		 * 
		 *     
		 */
		interface IBuiltinImporter {

			/**
			 * Return repr for the module.
			 * 
			 *         The method is deprecated.  The import machinery does the job itself.
			 * 
			 *         
			 */
			module_repr(): Promise<any>
			module_repr$($: {}): Promise<any>
			find_spec(fullname, path?, target?): Promise<any>
			find_spec$({ fullname, path, target }: { fullname, path?, target?}): Promise<any>

			/**
			 * Find the built-in module.
			 * 
			 *         If 'path' is ever specified then the search is considered a failure.
			 * 
			 *         This method is deprecated.  Use find_spec() instead.
			 * 
			 *         
			 */
			find_module(fullname, path?): Promise<any>
			find_module$({ fullname, path }: { fullname, path?}): Promise<any>

			/**
			 * Create a built-in module
			 */
			create_module(): Promise<any>
			create_module$($: {}): Promise<any>

			/**
			 * Exec a built-in module
			 */
			exec_module(): Promise<any>
			exec_module$($: {}): Promise<any>

			/**
			 * Return None as built-in modules do not have code objects.
			 */
			get_code(fullname): Promise<any>
			get_code$({ fullname }): Promise<any>

			/**
			 * Return None as built-in modules do not have source code.
			 */
			get_source(fullname): Promise<any>
			get_source$({ fullname }): Promise<any>

			/**
			 * Return False as built-in modules are never packages.
			 */
			is_package(fullname): Promise<any>
			is_package$({ fullname }): Promise<any>
			load_module
		}

		/**
		 * Meta path import for frozen modules.
		 * 
		 *     All methods are either class or static methods to avoid the need to
		 *     instantiate the class.
		 * 
		 *     
		 */
		interface IFrozenImporter {

			/**
			 * Return repr for the module.
			 * 
			 *         The method is deprecated.  The import machinery does the job itself.
			 * 
			 *         
			 */
			module_repr(): Promise<any>
			module_repr$($: {}): Promise<any>
			find_spec(fullname, path?, target?): Promise<any>
			find_spec$({ fullname, path, target }: { fullname, path?, target?}): Promise<any>

			/**
			 * Find a frozen module.
			 * 
			 *         This method is deprecated.  Use find_spec() instead.
			 * 
			 *         
			 */
			find_module(fullname, path?): Promise<any>
			find_module$({ fullname, path }: { fullname, path?}): Promise<any>

			/**
			 * Use default semantics for module creation.
			 */
			create_module(): Promise<any>
			create_module$($: {}): Promise<any>
			exec_module(): Promise<any>
			exec_module$($: {}): Promise<any>

			/**
			 * Load a frozen module.
			 * 
			 *         This method is deprecated.  Use exec_module() instead.
			 * 
			 *         
			 */
			load_module(fullname): Promise<any>
			load_module$({ fullname }): Promise<any>

			/**
			 * Return the code object for the frozen module.
			 */
			get_code(fullname): Promise<any>
			get_code$({ fullname }): Promise<any>

			/**
			 * Return None as frozen modules do not have source code.
			 */
			get_source(fullname): Promise<any>
			get_source$({ fullname }): Promise<any>

			/**
			 * Return True if the frozen module is a package.
			 */
			is_package(fullname): Promise<any>
			is_package$({ fullname }): Promise<any>
		}

		/**
		 * Context manager for the import lock.
		 */
		interface I_ImportLockContext {
		}
	}
	module _bootstrap_external {
		var _

		/**
		 * Given the path to a .py file, return the path to its .pyc file.
		 * 
		 *     The .py file does not need to exist; this simply returns the path to the
		 *     .pyc file calculated as if the .py file were imported.
		 * 
		 *     The 'optimization' parameter controls the presumed optimization level of
		 *     the bytecode file. If 'optimization' is not None, the string representation
		 *     of the argument is taken and verified to be alphanumeric (else ValueError
		 *     is raised).
		 * 
		 *     The debug_override parameter is deprecated. If debug_override is not None,
		 *     a True value is the same as setting 'optimization' to the empty string
		 *     while a False value is equivalent to setting 'optimization' to '1'.
		 * 
		 *     If sys.implementation.cache_tag is None then NotImplementedError is raised.
		 * 
		 *     
		 */
		function cache_from_source(path, debug_override?): Promise<any>
		function cache_from_source$({ path, debug_override }: { path, debug_override?}): Promise<any>

		/**
		 * Given the path to a .pyc. file, return the path to its .py file.
		 * 
		 *     The .pyc file does not need to exist; this simply returns the path to
		 *     the .py file calculated to correspond to the .pyc file.  If path does
		 *     not conform to PEP 3147/488 format, ValueError will be raised. If
		 *     sys.implementation.cache_tag is None then NotImplementedError is raised.
		 * 
		 *     
		 */
		function source_from_cache(path): Promise<any>
		function source_from_cache$({ path }): Promise<any>

		/**
		 * Decode bytes representing source code and return the string.
		 * 
		 *     Universal newline support is used in the decoding.
		 *     
		 */
		function decode_source(source_bytes): Promise<any>
		function decode_source$({ source_bytes }): Promise<any>

		/**
		 * Return a module spec based on a file location.
		 * 
		 *     To indicate that the module is a package, set
		 *     submodule_search_locations to a list of directory paths.  An
		 *     empty list is sufficient, though its not otherwise useful to the
		 *     import system.
		 * 
		 *     The loader must take a spec as its only __init__() arg.
		 * 
		 *     
		 */
		function spec_from_file_location(name, location?): Promise<any>
		function spec_from_file_location$({ name, location }: { name, location?}): Promise<any>

		/**
		 * Meta path finder for modules declared in the Windows registry.
		 */
		interface IWindowsRegistryFinder {
			find_spec(fullname, path?, target?): Promise<any>
			find_spec$({ fullname, path, target }: { fullname, path?, target?}): Promise<any>

			/**
			 * Find module named in the registry.
			 * 
			 *         This method is deprecated.  Use find_spec() instead.
			 * 
			 *         
			 */
			find_module(fullname, path?): Promise<any>
			find_module$({ fullname, path }: { fullname, path?}): Promise<any>
			REGISTRY_KEY
			REGISTRY_KEY_DEBUG
			DEBUG_BUILD
		}

		/**
		 * Base class of common code needed by both SourceLoader and
		 *     SourcelessFileLoader.
		 */
		interface I_LoaderBasics {

			/**
			 * Concrete implementation of InspectLoader.is_package by checking if
			 *         the path returned by get_filename has a filename of '__init__.py'.
			 */
			is_package(fullname): Promise<any>
			is_package$({ fullname }): Promise<any>

			/**
			 * Use default semantics for module creation.
			 */
			create_module(spec): Promise<any>
			create_module$({ spec }): Promise<any>

			/**
			 * Execute the module.
			 */
			exec_module(module): Promise<any>
			exec_module$({ module }): Promise<any>

			/**
			 * This method is deprecated.
			 */
			load_module(fullname): Promise<any>
			load_module$({ fullname }): Promise<any>
		}
		interface ISourceLoader extends I_LoaderBasics {

			/**
			 * Optional method that returns the modification time (an int) for the
			 *         specified path (a str).
			 * 
			 *         Raises OSError when the path cannot be handled.
			 *         
			 */
			path_mtime(path): Promise<any>
			path_mtime$({ path }): Promise<any>

			/**
			 * Optional method returning a metadata dict for the specified
			 *         path (a str).
			 * 
			 *         Possible keys:
			 *         - 'mtime' (mandatory) is the numeric timestamp of last source
			 *           code modification;
			 *         - 'size' (optional) is the size in bytes of the source code.
			 * 
			 *         Implementing this method allows the loader to read bytecode files.
			 *         Raises OSError when the path cannot be handled.
			 *         
			 */
			path_stats(path): Promise<any>
			path_stats$({ path }): Promise<any>

			/**
			 * Optional method which writes data (bytes) to a file path (a str).
			 * 
			 *         Implementing this method allows for the writing of bytecode files.
			 *         
			 */
			set_data(path, data): Promise<any>
			set_data$({ path, data }): Promise<any>

			/**
			 * Concrete implementation of InspectLoader.get_source.
			 */
			get_source(fullname): Promise<any>
			get_source$({ fullname }): Promise<any>

			/**
			 * Return the code object compiled from source.
			 * 
			 *         The 'data' argument can be any object type that compile() supports.
			 *         
			 */
			source_to_code(data, path): Promise<any>
			source_to_code$({ data, path }): Promise<any>

			/**
			 * Concrete implementation of InspectLoader.get_code.
			 * 
			 *         Reading of bytecode requires path_stats to be implemented. To write
			 *         bytecode, set_data must also be implemented.
			 * 
			 *         
			 */
			get_code(fullname): Promise<any>
			get_code$({ fullname }): Promise<any>
		}

		/**
		 * Base file loader class which implements the loader protocol methods that
		 *     require file system usage.
		 */

		/**
		 * Cache the module name and the path to the file found by the
		 *         finder.
		 */
		function FileLoader(fullname, path): Promise<IFileLoader>
		function FileLoader$({ fullname, path }): Promise<IFileLoader>
		interface IFileLoader {

			/**
			 * Load a module from a file.
			 * 
			 *         This method is deprecated.  Use exec_module() instead.
			 * 
			 *         
			 */
			load_module(fullname): Promise<any>
			load_module$({ fullname }): Promise<any>

			/**
			 * Return the path to the source file as found by the finder.
			 */
			get_filename(fullname): Promise<any>
			get_filename$({ fullname }): Promise<any>

			/**
			 * Return the data from path as raw bytes.
			 */
			get_data(path): Promise<any>
			get_data$({ path }): Promise<any>
			get_resource_reader(module): Promise<any>
			get_resource_reader$({ module }): Promise<any>
		}

		/**
		 * Concrete implementation of SourceLoader using the file system.
		 */
		interface ISourceFileLoader extends IFileLoader, ISourceLoader {

			/**
			 * Return the metadata for the path.
			 */
			path_stats(path): Promise<any>
			path_stats$({ path }): Promise<any>

			/**
			 * Write bytes data to a file.
			 */
			set_data(path, data): Promise<any>
			set_data$({ path, data }): Promise<any>
		}

		/**
		 * Loader which handles sourceless file imports.
		 */
		interface ISourcelessFileLoader extends IFileLoader, I_LoaderBasics {
			get_code(fullname): Promise<any>
			get_code$({ fullname }): Promise<any>

			/**
			 * Return None as there is no source code.
			 */
			get_source(fullname): Promise<any>
			get_source$({ fullname }): Promise<any>
		}

		/**
		 * Loader for extension modules.
		 * 
		 *     The constructor is designed to work with FileFinder.
		 * 
		 *     
		 */
		function ExtensionFileLoader(name, path): Promise<IExtensionFileLoader>
		function ExtensionFileLoader$({ name, path }): Promise<IExtensionFileLoader>
		interface IExtensionFileLoader extends IFileLoader, I_LoaderBasics {

			/**
			 * Create an uninitialized extension module
			 */
			create_module(spec): Promise<any>
			create_module$({ spec }): Promise<any>

			/**
			 * Initialize an extension module
			 */
			exec_module(module): Promise<any>
			exec_module$({ module }): Promise<any>

			/**
			 * Return True if the extension module is a package.
			 */
			is_package(fullname): Promise<any>
			is_package$({ fullname }): Promise<any>

			/**
			 * Return None as an extension module cannot create a code object.
			 */
			get_code(fullname): Promise<any>
			get_code$({ fullname }): Promise<any>

			/**
			 * Return None as extension modules have no source code.
			 */
			get_source(fullname): Promise<any>
			get_source$({ fullname }): Promise<any>

			/**
			 * Return the path to the source file as found by the finder.
			 */
			get_filename(fullname): Promise<any>
			get_filename$({ fullname }): Promise<any>
		}

		/**
		 * Represents a namespace package's path.  It uses the module name
		 *     to find its parent module, and from there it looks up the parent's
		 *     __path__.  When this changes, the module's own path is recomputed,
		 *     using path_finder.  For top-level modules, the parent module's path
		 *     is sys.path.
		 */
		interface I_NamespacePath {
			append(item): Promise<any>
			append$({ item }): Promise<any>
		}
		interface I_NamespaceLoader {

			/**
			 * Return repr for the module.
			 * 
			 *         The method is deprecated.  The import machinery does the job itself.
			 * 
			 *         
			 */
			module_repr(): Promise<any>
			module_repr$($: {}): Promise<any>
			is_package(fullname): Promise<any>
			is_package$({ fullname }): Promise<any>
			get_source(fullname): Promise<any>
			get_source$({ fullname }): Promise<any>
			get_code(fullname): Promise<any>
			get_code$({ fullname }): Promise<any>

			/**
			 * Use default semantics for module creation.
			 */
			create_module(spec): Promise<any>
			create_module$({ spec }): Promise<any>
			exec_module(module): Promise<any>
			exec_module$({ module }): Promise<any>

			/**
			 * Load a namespace module.
			 * 
			 *         This method is deprecated.  Use exec_module() instead.
			 * 
			 *         
			 */
			load_module(fullname): Promise<any>
			load_module$({ fullname }): Promise<any>
			get_resource_reader(module): Promise<any>
			get_resource_reader$({ module }): Promise<any>
		}

		/**
		 * Meta path finder for sys.path and package __path__ attributes.
		 */
		interface IPathFinder {

			/**
			 * Call the invalidate_caches() method on all path entry finders
			 *         stored in sys.path_importer_caches (where implemented).
			 */
			invalidate_caches(): Promise<any>
			invalidate_caches$($: {}): Promise<any>

			/**
			 * Try to find a spec for 'fullname' on sys.path or 'path'.
			 * 
			 *         The search is based on sys.path_hooks and sys.path_importer_cache.
			 *         
			 */
			find_spec(fullname, path?, target?): Promise<any>
			find_spec$({ fullname, path, target }: { fullname, path?, target?}): Promise<any>

			/**
			 * find the module on sys.path or 'path' based on sys.path_hooks and
			 *         sys.path_importer_cache.
			 * 
			 *         This method is deprecated.  Use find_spec() instead.
			 * 
			 *         
			 */
			find_module(fullname, path?): Promise<any>
			find_module$({ fullname, path }: { fullname, path?}): Promise<any>

			/**
			 * 
			 *         Find distributions.
			 * 
			 *         Return an iterable of all Distribution instances capable of
			 *         loading the metadata for packages matching ``context.name``
			 *         (or all names if ``None`` indicated) along the paths in the list
			 *         of directories ``context.path``.
			 *         
			 */
			find_distributions(): Promise<any>
			find_distributions$($: {}): Promise<any>
		}

		/**
		 * File-based finder.
		 * 
		 *     Interactions with the file system are cached for performance, being
		 *     refreshed when the directory the finder is handling has been modified.
		 * 
		 *     
		 */

		/**
		 * Initialize with the path to search on and a variable number of
		 *         2-tuples containing the loader and the file suffixes the loader
		 *         recognizes.
		 */
		function FileFinder(path): Promise<IFileFinder>
		function FileFinder$({ path }): Promise<IFileFinder>
		interface IFileFinder {

			/**
			 * Invalidate the directory mtime.
			 */
			invalidate_caches(): Promise<any>
			invalidate_caches$($: {}): Promise<any>

			/**
			 * Try to find a loader for the specified module, or the namespace
			 *         package portions. Returns (loader, list-of-portions).
			 * 
			 *         This method is deprecated.  Use find_spec() instead.
			 * 
			 *         
			 */
			find_loader(fullname): Promise<any>
			find_loader$({ fullname }): Promise<any>

			/**
			 * Try to find a spec for the specified module.
			 * 
			 *         Returns the matching spec, or None if not found.
			 *         
			 */
			find_spec(fullname, target?): Promise<any>
			find_spec$({ fullname, target }: { fullname, target?}): Promise<any>

			/**
			 * A class method which returns a closure to use on sys.path_hook
			 *         which will return an instance using the specified loaders and the path
			 *         called on the closure.
			 * 
			 *         If the path called on the closure is not a directory, ImportError is
			 *         raised.
			 * 
			 *         
			 */
			path_hook(): Promise<any>
			path_hook$($: {}): Promise<any>
		}
		let path_separators: Promise<any>
		let path_sep: Promise<any>
		let path_sep_tuple: Promise<any>
		let MAGIC_NUMBER: Promise<any>
		let SOURCE_SUFFIXES: Promise<any>
		let EXTENSION_SUFFIXES: Promise<any>
		let BYTECODE_SUFFIXES: Promise<any>
		let DEBUG_BYTECODE_SUFFIXES: Promise<any>
		let OPTIMIZED_BYTECODE_SUFFIXES: Promise<any>
	}
	module _common {
		var _

		/**
		 * 
		 *     Get a Traversable resource from a package
		 *     
		 */
		function files(package): Promise<any>
		function files$({ package }): Promise<any>

		/**
		 * Normalize a path by ensuring it is a string.
		 * 
		 *     If the resulting string contains path separators, an exception is raised.
		 *     
		 */
		function normalize_path(path): Promise<any>
		function normalize_path$({ path }): Promise<any>

		/**
		 * 
		 *     Return the package's loader if it's a ResourceReader.
		 *     
		 */
		function get_resource_reader(package): Promise<any>
		function get_resource_reader$({ package }): Promise<any>
		function resolve(cand): Promise<any>
		function resolve$({ cand }): Promise<any>

		/**
		 * Take a package name or module object and return the module.
		 * 
		 *     Raise an exception if the resolved module is not a package.
		 *     
		 */
		function get_package(package): Promise<any>
		function get_package$({ package }): Promise<any>

		/**
		 * 
		 *     Return a Traversable object for the given package.
		 * 
		 *     
		 */
		function from_package(package): Promise<any>
		function from_package$({ package }): Promise<any>

		/**
		 * 
		 *     Given a Traversable object, return that object as a
		 *     path on the local file system in a context manager.
		 *     
		 */
		function as_file(path): Promise<any>
		function as_file$({ path }): Promise<any>
		let Package: Promise<any>
	}
	module abc {
		var _

		/**
		 * Legacy abstract base class for import finders.
		 * 
		 *     It may be subclassed for compatibility with legacy third party
		 *     reimplementations of the import system.  Otherwise, finder
		 *     implementations should derive from the more specific MetaPathFinder
		 *     or PathEntryFinder ABCs.
		 * 
		 *     Deprecated since Python 3.3
		 *     
		 */
		function Finder(): Promise<IFinder>
		function Finder$({ }): Promise<IFinder>
		interface IFinder {

			/**
			 * An abstract method that should find a module.
			 *         The fullname is a str and the optional path is a str or None.
			 *         Returns a Loader object or None.
			 *         
			 */
			find_module(fullname, path?): Promise<any>
			find_module$({ fullname, path }: { fullname, path?}): Promise<any>
		}

		/**
		 * Abstract base class for import finders on sys.meta_path.
		 */
		interface IMetaPathFinder {

			/**
			 * Return a loader for the module.
			 * 
			 *         If no module is found, return None.  The fullname is a str and
			 *         the path is a list of strings or None.
			 * 
			 *         This method is deprecated since Python 3.4 in favor of
			 *         finder.find_spec(). If find_spec() exists then backwards-compatible
			 *         functionality is provided for this method.
			 * 
			 *         
			 */
			find_module(fullname, path): Promise<any>
			find_module$({ fullname, path }): Promise<any>

			/**
			 * An optional method for clearing the finder's cache, if any.
			 *         This method is used by importlib.invalidate_caches().
			 *         
			 */
			invalidate_caches(): Promise<any>
			invalidate_caches$($: {}): Promise<any>
		}

		/**
		 * Abstract base class for path entry finders used by PathFinder.
		 */
		interface IPathEntryFinder {

			/**
			 * Return (loader, namespace portion) for the path entry.
			 * 
			 *         The fullname is a str.  The namespace portion is a sequence of
			 *         path entries contributing to part of a namespace package. The
			 *         sequence may be empty.  If loader is not None, the portion will
			 *         be ignored.
			 * 
			 *         The portion will be discarded if another path entry finder
			 *         locates the module as a normal module or package.
			 * 
			 *         This method is deprecated since Python 3.4 in favor of
			 *         finder.find_spec(). If find_spec() is provided than backwards-compatible
			 *         functionality is provided.
			 *         
			 */
			find_loader(fullname): Promise<any>
			find_loader$({ fullname }): Promise<any>

			/**
			 * An optional method for clearing the finder's cache, if any.
			 *         This method is used by PathFinder.invalidate_caches().
			 *         
			 */
			invalidate_caches(): Promise<any>
			invalidate_caches$($: {}): Promise<any>
		}

		/**
		 * Abstract base class for loaders which can return data from their
		 *     back-end storage.
		 * 
		 *     This ABC represents one of the optional protocols specified by PEP 302.
		 * 
		 *     
		 */
		interface IResourceLoader {

			/**
			 * Abstract method which when implemented should return the bytes for
			 *         the specified path.  The path must be a str.
			 */
			get_data(path): Promise<any>
			get_data$({ path }): Promise<any>
		}

		/**
		 * Abstract base class for loaders which support inspection about the
		 *     modules they can load.
		 * 
		 *     This ABC represents one of the optional protocols specified by PEP 302.
		 * 
		 *     
		 */
		interface IInspectLoader {

			/**
			 * Optional method which when implemented should return whether the
			 *         module is a package.  The fullname is a str.  Returns a bool.
			 * 
			 *         Raises ImportError if the module cannot be found.
			 *         
			 */
			is_package(fullname): Promise<any>
			is_package$({ fullname }): Promise<any>

			/**
			 * Method which returns the code object for the module.
			 * 
			 *         The fullname is a str.  Returns a types.CodeType if possible, else
			 *         returns None if a code object does not make sense
			 *         (e.g. built-in module). Raises ImportError if the module cannot be
			 *         found.
			 *         
			 */
			get_code(fullname): Promise<any>
			get_code$({ fullname }): Promise<any>

			/**
			 * Abstract method which should return the source code for the
			 *         module.  The fullname is a str.  Returns a str.
			 * 
			 *         Raises ImportError if the module cannot be found.
			 *         
			 */
			get_source(fullname): Promise<any>
			get_source$({ fullname }): Promise<any>

			/**
			 * Compile 'data' into a code object.
			 * 
			 *         The 'data' argument can be anything that compile() can handle. The'path'
			 *         argument should be where the data was retrieved (when applicable).
			 */
			source_to_code(path?): Promise<any>
			source_to_code$({ path }: { path?}): Promise<any>
			exec_module
			load_module
		}

		/**
		 * Abstract base class for loaders that wish to support the execution of
		 *     modules as scripts.
		 * 
		 *     This ABC represents one of the optional protocols specified in PEP 302.
		 * 
		 *     
		 */
		interface IExecutionLoader extends IInspectLoader {

			/**
			 * Abstract method which should return the value that __file__ is to be
			 *         set to.
			 * 
			 *         Raises ImportError if the module cannot be found.
			 *         
			 */
			get_filename(fullname): Promise<any>
			get_filename$({ fullname }): Promise<any>

			/**
			 * Method to return the code object for fullname.
			 * 
			 *         Should return None if not applicable (e.g. built-in module).
			 *         Raise ImportError if the module cannot be found.
			 *         
			 */
			get_code(fullname): Promise<any>
			get_code$({ fullname }): Promise<any>
		}

		/**
		 * Abstract base class partially implementing the ResourceLoader and
		 *     ExecutionLoader ABCs.
		 */
		interface IFileLoader extends IResourceLoader, IExecutionLoader {
		}

		/**
		 * Abstract base class for loading source code (and optionally any
		 *     corresponding bytecode).
		 * 
		 *     To support loading from source code, the abstractmethods inherited from
		 *     ResourceLoader and ExecutionLoader need to be implemented. To also support
		 *     loading from bytecode, the optional methods specified directly by this ABC
		 *     is required.
		 * 
		 *     Inherited abstractmethods not implemented in this ABC:
		 * 
		 *         * ResourceLoader.get_data
		 *         * ExecutionLoader.get_filename
		 * 
		 *     
		 */
		interface ISourceLoader extends IResourceLoader, IExecutionLoader {

			/**
			 * Return the (int) modification time for the path (str).
			 */
			path_mtime(path): Promise<any>
			path_mtime$({ path }): Promise<any>

			/**
			 * Return a metadata dict for the source pointed to by the path (str).
			 *         Possible keys:
			 *         - 'mtime' (mandatory) is the numeric timestamp of last source
			 *           code modification;
			 *         - 'size' (optional) is the size in bytes of the source code.
			 *         
			 */
			path_stats(path): Promise<any>
			path_stats$({ path }): Promise<any>

			/**
			 * Write the bytes to the path (if possible).
			 * 
			 *         Accepts a str path and data as bytes.
			 * 
			 *         Any needed intermediary directories are to be created. If for some
			 *         reason the file cannot be written because of permissions, fail
			 *         silently.
			 *         
			 */
			set_data(path, data): Promise<any>
			set_data$({ path, data }): Promise<any>
		}

		/**
		 * Abstract base class for loaders to provide resource reading support.
		 */
		interface IResourceReader {

			/**
			 * Return an opened, file-like object for binary reading.
			 * 
			 *         The 'resource' argument is expected to represent only a file name.
			 *         If the resource cannot be found, FileNotFoundError is raised.
			 *         
			 */
			open_resource(resource): Promise<any>
			open_resource$({ resource }): Promise<any>

			/**
			 * Return the file system path to the specified resource.
			 * 
			 *         The 'resource' argument is expected to represent only a file name.
			 *         If the resource does not exist on the file system, raise
			 *         FileNotFoundError.
			 *         
			 */
			resource_path(resource): Promise<any>
			resource_path$({ resource }): Promise<any>

			/**
			 * Return True if the named 'path' is a resource.
			 * 
			 *         Files are resources, directories are not.
			 *         
			 */
			is_resource(path): Promise<any>
			is_resource$({ path }): Promise<any>

			/**
			 * Return an iterable of entries in `package`.
			 */
			contents(): Promise<any>
			contents$($: {}): Promise<any>
		}

		/**
		 * 
		 *     An object with a subset of pathlib.Path methods suitable for
		 *     traversing directories and opening files.
		 *     
		 */
		interface ITraversable {

			/**
			 * 
			 *         Yield Traversable objects in self
			 *         
			 */
			iterdir(): Promise<any>
			iterdir$($: {}): Promise<any>

			/**
			 * 
			 *         Read contents of self as bytes
			 *         
			 */
			read_bytes(): Promise<any>
			read_bytes$($: {}): Promise<any>

			/**
			 * 
			 *         Read contents of self as text
			 *         
			 */
			read_text(encoding?): Promise<any>
			read_text$({ encoding }: { encoding?}): Promise<any>

			/**
			 * 
			 *         Return True if self is a dir
			 *         
			 */
			is_dir(): Promise<any>
			is_dir$($: {}): Promise<any>

			/**
			 * 
			 *         Return True if self is a file
			 *         
			 */
			is_file(): Promise<any>
			is_file$($: {}): Promise<any>

			/**
			 * 
			 *         Return Traversable child in self
			 *         
			 */
			joinpath(child): Promise<any>
			joinpath$({ child }): Promise<any>

			/**
			 * 
			 *         mode may be 'r' or 'rb' to open as text or binary. Return a handle
			 *         suitable for reading (same as pathlib.Path.open).
			 * 
			 *         When opening as text, accepts encoding parameters such as those
			 *         accepted by io.TextIOWrapper.
			 *         
			 */
			open(mode?): Promise<any>
			open$({ mode }: { mode?}): Promise<any>

			/**
			 * 
			 *         The base name of this object without any parent references.
			 *         
			 */
			name(): Promise<any>
			name$($: {}): Promise<any>
		}

		/**
		 * 
		 *     The required interface for providing traversable
		 *     resources.
		 *     
		 */
		interface ITraversableResources extends IResourceReader {

			/**
			 * Return a Traversable object for the loaded package.
			 */
			files(): Promise<any>
			files$($: {}): Promise<any>
			open_resource(resource): Promise<any>
			open_resource$({ resource }): Promise<any>
			resource_path(resource): Promise<any>
			resource_path$({ resource }): Promise<any>
			is_resource(path): Promise<any>
			is_resource$({ path }): Promise<any>
			contents(): Promise<any>
			contents$($: {}): Promise<any>
		}
	}
	module machinery {
		var _

		/**
		 * Returns a list of all recognized module suffixes for this process
		 */
		function all_suffixes(): Promise<any>
		function all_suffixes$($: {}): Promise<any>
	}
	module metadata {
		var _
		function flake8_bypass(func): Promise<any>
		function flake8_bypass$({ func }): Promise<any>

		/**
		 * Get the ``Distribution`` instance for the named package.
		 * 
		 *     :param distribution_name: The name of the distribution package as a string.
		 *     :return: A ``Distribution`` instance (or subclass thereof).
		 *     
		 */
		function distribution(distribution_name): Promise<any>
		function distribution$({ distribution_name }): Promise<any>

		/**
		 * Get all ``Distribution`` instances in the current environment.
		 * 
		 *     :return: An iterable of ``Distribution`` instances.
		 *     
		 */
		function distributions(): Promise<any>
		function distributions$($: {}): Promise<any>

		/**
		 * Get the metadata for the named package.
		 * 
		 *     :param distribution_name: The name of the distribution package to query.
		 *     :return: A PackageMetadata containing the parsed metadata.
		 *     
		 */
		function metadata(distribution_name): Promise<any>
		function metadata$({ distribution_name }): Promise<any>

		/**
		 * Get the version string for the named package.
		 * 
		 *     :param distribution_name: The name of the distribution package to query.
		 *     :return: The version string for the package as defined in the package's
		 *         "Version" metadata key.
		 *     
		 */
		function version(distribution_name): Promise<any>
		function version$({ distribution_name }): Promise<any>

		/**
		 * Return EntryPoint objects for all installed packages.
		 * 
		 *     Pass selection parameters (group or name) to filter the
		 *     result to entry points matching those properties (see
		 *     EntryPoints.select()).
		 * 
		 *     For compatibility, returns ``SelectableGroups`` object unless
		 *     selection parameters are supplied. In the future, this function
		 *     will return ``EntryPoints`` instead of ``SelectableGroups``
		 *     even when no selection parameters are supplied.
		 * 
		 *     For maximum future compatibility, pass selection parameters
		 *     or invoke ``.select`` with parameters on the result.
		 * 
		 *     :return: EntryPoints or SelectableGroups for all installed packages.
		 *     
		 */
		function entry_points(): Promise<any>
		function entry_points$($: {}): Promise<any>

		/**
		 * Return a list of files for the named package.
		 * 
		 *     :param distribution_name: The name of the distribution package to query.
		 *     :return: List of files composing the distribution.
		 *     
		 */
		function files(distribution_name): Promise<any>
		function files$({ distribution_name }): Promise<any>

		/**
		 * 
		 *     Return a list of requirements for the named package.
		 * 
		 *     :return: An iterator of requirements, suitable for
		 *         packaging.requirement.Requirement.
		 *     
		 */
		function requires(distribution_name): Promise<any>
		function requires$({ distribution_name }): Promise<any>

		/**
		 * 
		 *     Return a mapping of top-level packages to their
		 *     distributions.
		 * 
		 *     >>> import collections.abc
		 *     >>> pkgs = packages_distributions()
		 *     >>> all(isinstance(dist, collections.abc.Sequence) for dist in pkgs.values())
		 *     True
		 *     
		 */
		function packages_distributions(): Promise<any>
		function packages_distributions$($: {}): Promise<any>

		/**
		 * The package was not found.
		 */
		interface IPackageNotFoundError {
			name(): Promise<any>
			name$($: {}): Promise<any>
		}

		/**
		 * 
		 *     A simple entry point config parser for performance
		 * 
		 *     >>> for item in Sectioned.read(Sectioned._sample):
		 *     ...     print(item)
		 *     Pair(name='sec1', value='# comments ignored')
		 *     Pair(name='sec1', value='a = 1')
		 *     Pair(name='sec1', value='b = 2')
		 *     Pair(name='sec2', value='a = 2')
		 * 
		 *     >>> res = Sectioned.section_pairs(Sectioned._sample)
		 *     >>> item = next(res)
		 *     >>> item.name
		 *     'sec1'
		 *     >>> item.value
		 *     Pair(name='a', value='1')
		 *     >>> item = next(res)
		 *     >>> item.value
		 *     Pair(name='b', value='2')
		 *     >>> item = next(res)
		 *     >>> item.name
		 *     'sec2'
		 *     >>> item.value
		 *     Pair(name='a', value='2')
		 *     >>> list(res)
		 *     []
		 *     
		 */
		interface ISectioned {
			section_pairs(text): Promise<any>
			section_pairs$({ text }): Promise<any>
			read(filter_?): Promise<any>
			read$({ filter_ }: { filter_?}): Promise<any>
			valid(): Promise<any>
			valid$($: {}): Promise<any>
		}

		/**
		 * An entry point as defined by Python packaging conventions.
		 * 
		 *     See `the packaging docs on entry points
		 *     <https://packaging.python.org/specifications/entry-points/>`_
		 *     for more information.
		 *     
		 */
		interface IEntryPoint {

			/**
			 * Load the entry point from its definition. If only a module
			 *         is indicated by the value, return that module. Otherwise,
			 *         return the named object.
			 *         
			 */
			load(): Promise<any>
			load$($: {}): Promise<any>
			module(): Promise<any>
			module$($: {}): Promise<any>
			attr(): Promise<any>
			attr$($: {}): Promise<any>
			extras(): Promise<any>
			extras$($: {}): Promise<any>
			matches(): Promise<any>
			matches$($: {}): Promise<any>
			pattern
		}

		/**
		 * 
		 *     Allow an otherwise immutable object to implement mutability
		 *     for compatibility.
		 * 
		 *     >>> recwarn = getfixture('recwarn')
		 *     >>> dl = DeprecatedList(range(3))
		 *     >>> dl[0] = 1
		 *     >>> dl.append(3)
		 *     >>> del dl[3]
		 *     >>> dl.reverse()
		 *     >>> dl.sort()
		 *     >>> dl.extend([4])
		 *     >>> dl.pop(-1)
		 *     4
		 *     >>> dl.remove(1)
		 *     >>> dl += [5]
		 *     >>> dl + [6]
		 *     [1, 2, 5, 6]
		 *     >>> dl + (6,)
		 *     [1, 2, 5, 6]
		 *     >>> dl.insert(0, 0)
		 *     >>> dl
		 *     [0, 1, 2, 5]
		 *     >>> dl == [0, 1, 2, 5]
		 *     True
		 *     >>> dl == (0, 1, 2, 5)
		 *     True
		 *     >>> len(recwarn)
		 *     1
		 *     
		 */
		interface IDeprecatedList {
			append(): Promise<any>
			append$($: {}): Promise<any>
			reverse(): Promise<any>
			reverse$($: {}): Promise<any>
			extend(): Promise<any>
			extend$($: {}): Promise<any>
			pop(): Promise<any>
			pop$($: {}): Promise<any>
			remove(): Promise<any>
			remove$($: {}): Promise<any>
			insert(): Promise<any>
			insert$($: {}): Promise<any>
			sort(): Promise<any>
			sort$($: {}): Promise<any>
		}

		/**
		 * 
		 *     An immutable collection of selectable EntryPoint objects.
		 *     
		 */
		interface IEntryPoints extends IDeprecatedList {

			/**
			 * 
			 *         Select entry points from self that match the
			 *         given parameters (typically group and/or name).
			 *         
			 */
			select(): Promise<any>
			select$($: {}): Promise<any>

			/**
			 * 
			 *         Return the set of all names of all entry points.
			 *         
			 */
			names(): Promise<any>
			names$($: {}): Promise<any>

			/**
			 * 
			 *         Return the set of all groups of all entry points.
			 * 
			 *         For coverage while SelectableGroups is present.
			 *         >>> EntryPoints().groups
			 *         set()
			 *         
			 */
			groups(): Promise<any>
			groups$($: {}): Promise<any>
		}

		/**
		 * 
		 *     Compatibility add-in for mapping to indicate that
		 *     mapping behavior is deprecated.
		 * 
		 *     >>> recwarn = getfixture('recwarn')
		 *     >>> class DeprecatedDict(Deprecated, dict): pass
		 *     >>> dd = DeprecatedDict(foo='bar')
		 *     >>> dd.get('baz', None)
		 *     >>> dd['foo']
		 *     'bar'
		 *     >>> list(dd)
		 *     ['foo']
		 *     >>> list(dd.keys())
		 *     ['foo']
		 *     >>> 'foo' in dd
		 *     True
		 *     >>> list(dd.values())
		 *     ['bar']
		 *     >>> len(recwarn)
		 *     1
		 *     
		 */
		interface IDeprecated {
			get(name, def?): Promise<any>
			get$({ name, def }: { name, def?}): Promise<any>
			keys(): Promise<any>
			keys$($: {}): Promise<any>
			values(): Promise<any>
			values$($: {}): Promise<any>
		}

		/**
		 * 
		 *     A backward- and forward-compatible result from
		 *     entry_points that fully implements the dict interface.
		 *     
		 */
		interface ISelectableGroups extends IDeprecated {
			load(eps): Promise<any>
			load$({ eps }): Promise<any>
			groups(): Promise<any>
			groups$($: {}): Promise<any>

			/**
			 * 
			 *         for coverage:
			 *         >>> SelectableGroups().names
			 *         set()
			 *         
			 */
			names(): Promise<any>
			names$($: {}): Promise<any>
			select(): Promise<any>
			select$($: {}): Promise<any>
		}

		/**
		 * A reference to a path in a package
		 */
		interface IPackagePath {
			read_text(encoding?): Promise<any>
			read_text$({ encoding }: { encoding?}): Promise<any>
			read_binary(): Promise<any>
			read_binary$($: {}): Promise<any>

			/**
			 * Return a path-like object for this path
			 */
			locate(): Promise<any>
			locate$($: {}): Promise<any>
		}
		function FileHash(spec): Promise<IFileHash>
		function FileHash$({ spec }): Promise<IFileHash>
		interface IFileHash {
		}

		/**
		 * A Python distribution package.
		 */
		interface IDistribution {

			/**
			 * Attempt to load metadata file given by the name.
			 * 
			 *         :param filename: The name of the file in the distribution info.
			 *         :return: The text if found, otherwise None.
			 *         
			 */
			read_text(filename): Promise<any>
			read_text$({ filename }): Promise<any>

			/**
			 * 
			 *         Given a path to a file in this distribution, return a path
			 *         to it.
			 *         
			 */
			locate_file(path): Promise<any>
			locate_file$({ path }): Promise<any>

			/**
			 * Return the Distribution for the given package name.
			 * 
			 *         :param name: The name of the distribution package to search for.
			 *         :return: The Distribution instance (or subclass thereof) for the named
			 *             package, if found.
			 *         :raises PackageNotFoundError: When the named package's distribution
			 *             metadata cannot be found.
			 *         
			 */
			from_name(name): Promise<any>
			from_name$({ name }): Promise<any>

			/**
			 * Return an iterable of Distribution objects for all packages.
			 * 
			 *         Pass a ``context`` or pass keyword arguments for constructing
			 *         a context.
			 * 
			 *         :context: A ``DistributionFinder.Context`` object.
			 *         :return: Iterable of Distribution objects for all packages.
			 *         
			 */
			discover(): Promise<any>
			discover$($: {}): Promise<any>

			/**
			 * Return a Distribution for the indicated metadata path
			 * 
			 *         :param path: a string or path-like object
			 *         :return: a concrete Distribution instance for the path
			 *         
			 */
			at(): Promise<any>
			at$($: {}): Promise<any>

			/**
			 * Return the parsed metadata for this Distribution.
			 * 
			 *         The returned object will have keys that name the various bits of
			 *         metadata.  See PEP 566 for details.
			 *         
			 */
			metadata(): Promise<any>
			metadata$($: {}): Promise<any>

			/**
			 * Return the 'Name' metadata for the distribution package.
			 */
			name(): Promise<any>
			name$($: {}): Promise<any>

			/**
			 * Return the 'Version' metadata for the distribution package.
			 */
			version(): Promise<any>
			version$($: {}): Promise<any>
			entry_points(): Promise<any>
			entry_points$($: {}): Promise<any>

			/**
			 * Files in this distribution.
			 * 
			 *         :return: List of PackagePath for this distribution or None
			 * 
			 *         Result is `None` if the metadata file that enumerates files
			 *         (i.e. RECORD for dist-info or SOURCES.txt for egg-info) is
			 *         missing.
			 *         Result may be empty if the metadata exists but is empty.
			 *         
			 */
			files(): Promise<any>
			files$($: {}): Promise<any>

			/**
			 * Generated requirements specified for this Distribution
			 */
			requires(): Promise<any>
			requires$($: {}): Promise<any>
		}

		/**
		 * 
		 *     A MetaPathFinder capable of discovering installed distributions.
		 *     
		 */
		interface IDistributionFinder {

			/**
			 * 
			 *         Find distributions.
			 * 
			 *         Return an iterable of all Distribution instances capable of
			 *         loading the metadata for packages matching the ``context``,
			 *         a DistributionFinder.Context instance.
			 *         
			 */
			find_distributions(context?): Promise<any>
			find_distributions$({ context }: { context?}): Promise<any>
		}

		/**
		 * 
		 *     Micro-optimized class for searching a path for
		 *     children.
		 *     
		 */
		function FastPath(root): Promise<IFastPath>
		function FastPath$({ root }): Promise<IFastPath>
		interface IFastPath {
			joinpath(child): Promise<any>
			joinpath$({ child }): Promise<any>
			children(): Promise<any>
			children$($: {}): Promise<any>
			zip_children(): Promise<any>
			zip_children$($: {}): Promise<any>
			search(name): Promise<any>
			search$({ name }): Promise<any>
			mtime(): Promise<any>
			mtime$($: {}): Promise<any>
			lookup(mtime): Promise<any>
			lookup$({ mtime }): Promise<any>
		}
		function Lookup(path): Promise<ILookup>
		function Lookup$({ path }): Promise<ILookup>
		interface ILookup {
			search(prepared): Promise<any>
			search$({ prepared }): Promise<any>
		}

		/**
		 * 
		 *     A prepared search for metadata on a possibly-named package.
		 *     
		 */
		function Prepared(name): Promise<IPrepared>
		function Prepared$({ name }): Promise<IPrepared>
		interface IPrepared {

			/**
			 * 
			 *         PEP 503 normalization plus dashes as underscores.
			 *         
			 */
			normalize(): Promise<any>
			normalize$($: {}): Promise<any>

			/**
			 * 
			 *         Normalize the package name as found in the convention in
			 *         older packaging tools versions and specs.
			 *         
			 */
			legacy_normalize(): Promise<any>
			legacy_normalize$($: {}): Promise<any>
			normalized
			legacy_normalized
		}
		interface IMetadataPathFinder extends IDistributionFinder {

			/**
			 * 
			 *         Find distributions.
			 * 
			 *         Return an iterable of all Distribution instances capable of
			 *         loading the metadata for packages matching ``context.name``
			 *         (or all names if ``None`` indicated) along the paths in the list
			 *         of directories ``context.path``.
			 *         
			 */
			find_distributions(context?): Promise<any>
			find_distributions$({ context }: { context?}): Promise<any>
			invalidate_caches(): Promise<any>
			invalidate_caches$($: {}): Promise<any>
		}

		/**
		 * Construct a distribution.
		 * 
		 *         :param path: SimplePath indicating the metadata directory.
		 *         
		 */
		function PathDistribution(path): Promise<IPathDistribution>
		function PathDistribution$({ path }): Promise<IPathDistribution>
		interface IPathDistribution extends IDistribution {
			read_text(filename): Promise<any>
			read_text$({ filename }): Promise<any>
			locate_file(path): Promise<any>
			locate_file$({ path }): Promise<any>
		}
		module _adapters {
			var _
			function Message(): Promise<IMessage>
			function Message$({ }): Promise<IMessage>
			interface IMessage {

				/**
				 * 
				 *         Convert PackageMetadata to a JSON-compatible format
				 *         per PEP 0566.
				 *         
				 */
				json(): Promise<any>
				json$($: {}): Promise<any>
				multiple_use_keys
			}
		}
		module _collections {
			var _

			/**
			 * 
			 *     Often it is desirable to prevent the mutation of
			 *     a default dict after its initial construction, such
			 *     as to prevent mutation during iteration.
			 * 
			 *     >>> dd = FreezableDefaultDict(list)
			 *     >>> dd[0].append('1')
			 *     >>> dd.freeze()
			 *     >>> dd[1]
			 *     []
			 *     >>> len(dd)
			 *     1
			 *     
			 */
			interface IFreezableDefaultDict {
				freeze(): Promise<any>
				freeze$($: {}): Promise<any>
			}
			interface IPair {
				parse(text): Promise<any>
				parse$({ text }): Promise<any>
			}
		}
		module _functools {
			var _

			/**
			 * 
			 *     Wrap lru_cache to support storing the cache data in the object instances.
			 * 
			 *     Abstracts the common paradigm where the method explicitly saves an
			 *     underscore-prefixed protected property on first call and returns that
			 *     subsequently.
			 * 
			 *     >>> class MyClass:
			 *     ...     calls = 0
			 *     ...
			 *     ...     @method_cache
			 *     ...     def method(self, value):
			 *     ...         self.calls += 1
			 *     ...         return value
			 * 
			 *     >>> a = MyClass()
			 *     >>> a.method(3)
			 *     3
			 *     >>> for x in range(75):
			 *     ...     res = a.method(x)
			 *     >>> a.calls
			 *     75
			 * 
			 *     Note that the apparent behavior will be exactly like that of lru_cache
			 *     except that the cache is stored on each instance, so values in one
			 *     instance will not flush values from another, and when an instance is
			 *     deleted, so are the cached values for that instance.
			 * 
			 *     >>> b = MyClass()
			 *     >>> for x in range(35):
			 *     ...     res = b.method(x)
			 *     >>> b.calls
			 *     35
			 *     >>> a.method(0)
			 *     0
			 *     >>> a.calls
			 *     75
			 * 
			 *     Note that if method had been decorated with ``functools.lru_cache()``,
			 *     a.calls would have been 76 (due to the cached value of 0 having been
			 *     flushed by the 'b' instance).
			 * 
			 *     Clear the cache with ``.cache_clear()``
			 * 
			 *     >>> a.method.cache_clear()
			 * 
			 *     Same for a method that hasn't yet been called.
			 * 
			 *     >>> c = MyClass()
			 *     >>> c.method.cache_clear()
			 * 
			 *     Another cache wrapper may be supplied:
			 * 
			 *     >>> cache = functools.lru_cache(maxsize=2)
			 *     >>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)
			 *     >>> a = MyClass()
			 *     >>> a.method2()
			 *     3
			 * 
			 *     Caution - do not subsequently wrap the method with another decorator, such
			 *     as ``@property``, which changes the semantics of the function.
			 * 
			 *     See also
			 *     http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/
			 *     for another implementation and additional justification.
			 *     
			 */
			function method_cache(method, cache_wrapper?): Promise<any>
			function method_cache$({ method, cache_wrapper }: { method, cache_wrapper?}): Promise<any>
		}
		module _itertools {
			var _

			/**
			 * List unique elements, preserving order. Remember all elements ever seen.
			 */
			function unique_everseen(iterable, key?): Promise<any>
			function unique_everseen$({ iterable, key }: { iterable, key?}): Promise<any>
		}
		module _meta {
			var _
			interface IPackageMetadata {

				/**
				 * 
				 *         Return all values associated with a possibly multi-valued key.
				 *         
				 */
				get_all(name, failobj?): Promise<any>
				get_all$({ name, failobj }: { name, failobj?}): Promise<any>

				/**
				 * 
				 *         A JSON-compatible form of the metadata.
				 *         
				 */
				json(): Promise<any>
				json$($: {}): Promise<any>
			}

			/**
			 * 
			 *     A minimal subset of pathlib.Path required by PathDistribution.
			 *     
			 */
			interface ISimplePath {

				/**
				 * ...
				 */
				joinpath(): Promise<any>
				joinpath$($: {}): Promise<any>

				/**
				 * ...
				 */
				parent(): Promise<any>
				parent$($: {}): Promise<any>

				/**
				 * ...
				 */
				read_text(): Promise<any>
				read_text$($: {}): Promise<any>
			}
		}
		module _text {
			var _

			/**
			 * 
			 *     A case insensitive string class; behaves just like str
			 *     except compares equal when the only variation is case.
			 * 
			 *     >>> s = FoldedCase('hello world')
			 * 
			 *     >>> s == 'Hello World'
			 *     True
			 * 
			 *     >>> 'Hello World' == s
			 *     True
			 * 
			 *     >>> s != 'Hello World'
			 *     False
			 * 
			 *     >>> s.index('O')
			 *     4
			 * 
			 *     >>> s.split('O')
			 *     ['hell', ' w', 'rld']
			 * 
			 *     >>> sorted(map(FoldedCase, ['GAMMA', 'alpha', 'Beta']))
			 *     ['alpha', 'Beta', 'GAMMA']
			 * 
			 *     Sequence membership is straightforward.
			 * 
			 *     >>> "Hello World" in [s]
			 *     True
			 *     >>> s in ["Hello World"]
			 *     True
			 * 
			 *     You may test for set inclusion, but candidate and elements
			 *     must both be folded.
			 * 
			 *     >>> FoldedCase("Hello World") in {s}
			 *     True
			 *     >>> s in {FoldedCase("Hello World")}
			 *     True
			 * 
			 *     String inclusion works as long as the FoldedCase object
			 *     is on the right.
			 * 
			 *     >>> "hello" in FoldedCase("Hello World")
			 *     True
			 * 
			 *     But not if the FoldedCase object is on the left:
			 * 
			 *     >>> FoldedCase('hello') in 'Hello World'
			 *     False
			 * 
			 *     In that case, use in_:
			 * 
			 *     >>> FoldedCase('hello').in_('Hello World')
			 *     True
			 * 
			 *     >>> FoldedCase('hello') > FoldedCase('Hello')
			 *     False
			 *     
			 */
			interface IFoldedCase {

				/**
				 * Does self appear in other?
				 */
				in_(other): Promise<any>
				in_$({ other }): Promise<any>
				lower(): Promise<any>
				lower$($: {}): Promise<any>
				index(sub): Promise<any>
				index$({ sub }): Promise<any>
				split(splitter?, maxsplit?): Promise<any>
				split$({ splitter, maxsplit }: { splitter?, maxsplit?}): Promise<any>
			}
		}
	}
	module readers {
		var _
		function remove_duplicates(items): Promise<any>
		function remove_duplicates$({ items }): Promise<any>
		function FileReader(loader): Promise<IFileReader>
		function FileReader$({ loader }): Promise<IFileReader>
		interface IFileReader {

			/**
			 * 
			 *         Return the file system path to prevent
			 *         `resources.path()` from creating a temporary
			 *         copy.
			 *         
			 */
			resource_path(resource): Promise<any>
			resource_path$({ resource }): Promise<any>
			files(): Promise<any>
			files$($: {}): Promise<any>
		}
		function ZipReader(loader, module): Promise<IZipReader>
		function ZipReader$({ loader, module }): Promise<IZipReader>
		interface IZipReader {
			open_resource(resource): Promise<any>
			open_resource$({ resource }): Promise<any>
			is_resource(path): Promise<any>
			is_resource$({ path }): Promise<any>
			files(): Promise<any>
			files$($: {}): Promise<any>
		}

		/**
		 * 
		 *     Given a series of Traversable objects, implement a merged
		 *     version of the interface across all objects. Useful for
		 *     namespace packages which may be multihomed at a single
		 *     name.
		 *     
		 */
		function MultiplexedPath(): Promise<IMultiplexedPath>
		function MultiplexedPath$({ }): Promise<IMultiplexedPath>
		interface IMultiplexedPath {
			iterdir(): Promise<any>
			iterdir$($: {}): Promise<any>
			read_bytes(): Promise<any>
			read_bytes$($: {}): Promise<any>
			read_text(): Promise<any>
			read_text$($: {}): Promise<any>
			is_dir(): Promise<any>
			is_dir$($: {}): Promise<any>
			is_file(): Promise<any>
			is_file$($: {}): Promise<any>
			joinpath(child): Promise<any>
			joinpath$({ child }): Promise<any>
			open(): Promise<any>
			open$($: {}): Promise<any>
			name(): Promise<any>
			name$($: {}): Promise<any>
		}
		function NamespaceReader(namespace_path): Promise<INamespaceReader>
		function NamespaceReader$({ namespace_path }): Promise<INamespaceReader>
		interface INamespaceReader {

			/**
			 * 
			 *         Return the file system path to prevent
			 *         `resources.path()` from creating a temporary
			 *         copy.
			 *         
			 */
			resource_path(resource): Promise<any>
			resource_path$({ resource }): Promise<any>
			files(): Promise<any>
			files$($: {}): Promise<any>
		}
	}
	module resources {
		var _

		/**
		 * Return a file-like object opened for binary reading of the resource.
		 */
		function open_binary(package, resource): Promise<any>
		function open_binary$({ package, resource }): Promise<any>

		/**
		 * Return a file-like object opened for text reading of the resource.
		 */
		function open_text(package, resource, encoding?, errors?): Promise<any>
		function open_text$({ package, resource, encoding, errors }: { package, resource, encoding?, errors?}): Promise<any>

		/**
		 * Return the binary contents of the resource.
		 */
		function read_binary(package, resource): Promise<any>
		function read_binary$({ package, resource }): Promise<any>

		/**
		 * Return the decoded string of the resource.
		 * 
		 *     The decoding-related arguments have the same semantics as those of
		 *     bytes.decode().
		 *     
		 */
		function read_text(package, resource, encoding?, errors?): Promise<any>
		function read_text$({ package, resource, encoding, errors }: { package, resource, encoding?, errors?}): Promise<any>

		/**
		 * A context manager providing a file path object to the resource.
		 * 
		 *     If the resource does not already exist on its own on the file system,
		 *     a temporary file will be created. If the file was created, the file
		 *     will be deleted upon exiting the context manager (no exception is
		 *     raised if the file was deleted prior to the context manager
		 *     exiting).
		 *     
		 */
		function path(package, resource): Promise<any>
		function path$({ package, resource }): Promise<any>

		/**
		 * True if 'name' is a resource inside 'package'.
		 * 
		 *     Directories are *not* resources.
		 *     
		 */
		function is_resource(package, name): Promise<any>
		function is_resource$({ package, name }): Promise<any>

		/**
		 * Return an iterable of entries in 'package'.
		 * 
		 *     Note that not all entries are resources.  Specifically, directories are
		 *     not considered resources.  Use `is_resource()` on each entry returned here
		 *     to check if it is a resource or not.
		 *     
		 */
		function contents(package): Promise<any>
		function contents$({ package }): Promise<any>
		let Package: Promise<any>
		let Resource: Promise<any>
	}
	module util {
		var _

		/**
		 * Return the hash of *source_bytes* as used in hash-based pyc files.
		 */
		function source_hash(source_bytes): Promise<any>
		function source_hash$({ source_bytes }): Promise<any>

		/**
		 * Resolve a relative module name to an absolute one.
		 */
		function resolve_name(name, package): Promise<any>
		function resolve_name$({ name, package }): Promise<any>

		/**
		 * Return the spec for the specified module.
		 * 
		 *     First, sys.modules is checked to see if the module was already imported. If
		 *     so, then sys.modules[name].__spec__ is returned. If that happens to be
		 *     set to None, then ValueError is raised. If the module is not in
		 *     sys.modules, then sys.meta_path is searched for a suitable spec with the
		 *     value of 'path' given to the finders. None is returned if no spec could
		 *     be found.
		 * 
		 *     If the name is for submodule (contains a dot), the parent module is
		 *     automatically imported.
		 * 
		 *     The name and package arguments work the same as importlib.import_module().
		 *     In other words, relative module names (with leading dots) work.
		 * 
		 *     
		 */
		function find_spec(name, package?): Promise<any>
		function find_spec$({ name, package }: { name, package?}): Promise<any>

		/**
		 * Set __package__ on the returned module.
		 * 
		 *     This function is deprecated.
		 * 
		 *     
		 */
		function set_package(fxn): Promise<any>
		function set_package$({ fxn }): Promise<any>

		/**
		 * Set __loader__ on the returned module.
		 * 
		 *     This function is deprecated.
		 * 
		 *     
		 */
		function set_loader(fxn): Promise<any>
		function set_loader$({ fxn }): Promise<any>

		/**
		 * Decorator to handle selecting the proper module for loaders.
		 * 
		 *     The decorated function is passed the module to use instead of the module
		 *     name. The module passed in to the function is either from sys.modules if
		 *     it already exists or is a new module. If the module is new, then __name__
		 *     is set the first argument to the method, __loader__ is set to self, and
		 *     __package__ is set accordingly (if self.is_package() is defined) will be set
		 *     before it is passed to the decorated function (if self.is_package() does
		 *     not work for the module it will be set post-load).
		 * 
		 *     If an exception is raised and the decorator created the module it is
		 *     subsequently removed from sys.modules.
		 * 
		 *     The decorator assumes that the decorated function takes the module name as
		 *     the second argument.
		 * 
		 *     
		 */
		function module_for_loader(fxn): Promise<any>
		function module_for_loader$({ fxn }): Promise<any>

		/**
		 * A subclass of the module type which triggers loading upon attribute access.
		 */
		interface I_LazyModule {
		}

		/**
		 * A loader that creates a module which defers loading until attribute access.
		 */
		function LazyLoader(loader): Promise<ILazyLoader>
		function LazyLoader$({ loader }): Promise<ILazyLoader>
		interface ILazyLoader {

			/**
			 * Construct a callable which returns the eager loader made lazy.
			 */
			factory(loader): Promise<any>
			factory$({ loader }): Promise<any>
			create_module(spec): Promise<any>
			create_module$({ spec }): Promise<any>

			/**
			 * Make the module load lazily.
			 */
			exec_module(module): Promise<any>
			exec_module$({ module }): Promise<any>
		}
	}
}
declare module inspect {
	var _

	/**
	 * Compute the annotations dict for an object.
	 * 
	 *     obj may be a callable, class, or module.
	 *     Passing in an object of any other type raises TypeError.
	 * 
	 *     Returns a dict.  get_annotations() returns a new dict every time
	 *     it's called; calling it twice on the same object will return two
	 *     different but equivalent dicts.
	 * 
	 *     This function handles several details for you:
	 * 
	 *       * If eval_str is true, values of type str will
	 *         be un-stringized using eval().  This is intended
	 *         for use with stringized annotations
	 *         ("from __future__ import annotations").
	 *       * If obj doesn't have an annotations dict, returns an
	 *         empty dict.  (Functions and methods always have an
	 *         annotations dict; classes, modules, and other types of
	 *         callables may not.)
	 *       * Ignores inherited annotations on classes.  If a class
	 *         doesn't have its own annotations dict, returns an empty dict.
	 *       * All accesses to object members and dict values are done
	 *         using getattr() and dict.get() for safety.
	 *       * Always, always, always returns a freshly-created dict.
	 * 
	 *     eval_str controls whether or not values of type str are replaced
	 *     with the result of calling eval() on those values:
	 * 
	 *       * If eval_str is true, eval() is called on values of type str.
	 *       * If eval_str is false (the default), values of type str are unchanged.
	 * 
	 *     globals and locals are passed in to eval(); see the documentation
	 *     for eval() for more information.  If either globals or locals is
	 *     None, this function may replace that value with a context-specific
	 *     default, contingent on type(obj):
	 * 
	 *       * If obj is a module, globals defaults to obj.__dict__.
	 *       * If obj is a class, globals defaults to
	 *         sys.modules[obj.__module__].__dict__ and locals
	 *         defaults to the obj class namespace.
	 *       * If obj is a callable, globals defaults to obj.__globals__,
	 *         although if obj is a wrapped function (using
	 *         functools.update_wrapper()) it is first unwrapped.
	 *     
	 */
	function get_annotations(obj): Promise<any>
	function get_annotations$({ obj }): Promise<any>

	/**
	 * Return true if the object is a module.
	 * 
	 *     Module objects provide these attributes:
	 *         __cached__      pathname to byte compiled file
	 *         __doc__         documentation string
	 *         __file__        filename (missing for built-in modules)
	 */
	function ismodule(object): Promise<any>
	function ismodule$({ object }): Promise<any>

	/**
	 * Return true if the object is a class.
	 * 
	 *     Class objects provide these attributes:
	 *         __doc__         documentation string
	 *         __module__      name of module in which this class was defined
	 */
	function isclass(object): Promise<any>
	function isclass$({ object }): Promise<any>

	/**
	 * Return true if the object is an instance method.
	 * 
	 *     Instance method objects provide these attributes:
	 *         __doc__         documentation string
	 *         __name__        name with which this method was defined
	 *         __func__        function object containing implementation of method
	 *         __self__        instance to which this method is bound
	 */
	function ismethod(object): Promise<any>
	function ismethod$({ object }): Promise<any>

	/**
	 * Return true if the object is a method descriptor.
	 * 
	 *     But not if ismethod() or isclass() or isfunction() are true.
	 * 
	 *     This is new in Python 2.2, and, for example, is true of int.__add__.
	 *     An object passing this test has a __get__ attribute but not a __set__
	 *     attribute, but beyond that the set of attributes varies.  __name__ is
	 *     usually sensible, and __doc__ often is.
	 * 
	 *     Methods implemented via descriptors that also pass one of the other
	 *     tests return false from the ismethoddescriptor() test, simply because
	 *     the other tests promise more -- you can, e.g., count on having the
	 *     __func__ attribute (etc) when an object passes ismethod().
	 */
	function ismethoddescriptor(object): Promise<any>
	function ismethoddescriptor$({ object }): Promise<any>

	/**
	 * Return true if the object is a data descriptor.
	 * 
	 *     Data descriptors have a __set__ or a __delete__ attribute.  Examples are
	 *     properties (defined in Python) and getsets and members (defined in C).
	 *     Typically, data descriptors will also have __name__ and __doc__ attributes
	 *     (properties, getsets, and members have both of these attributes), but this
	 *     is not guaranteed.
	 */
	function isdatadescriptor(object): Promise<any>
	function isdatadescriptor$({ object }): Promise<any>

	/**
	 * Return true if the object is a member descriptor.
	 * 
	 *         Member descriptors are specialized descriptors defined in extension
	 *         modules.
	 */
	function ismemberdescriptor(object): Promise<any>
	function ismemberdescriptor$({ object }): Promise<any>

	/**
	 * Return true if the object is a member descriptor.
	 * 
	 *         Member descriptors are specialized descriptors defined in extension
	 *         modules.
	 */
	function ismemberdescriptor(object): Promise<any>
	function ismemberdescriptor$({ object }): Promise<any>

	/**
	 * Return true if the object is a getset descriptor.
	 * 
	 *         getset descriptors are specialized descriptors defined in extension
	 *         modules.
	 */
	function isgetsetdescriptor(object): Promise<any>
	function isgetsetdescriptor$({ object }): Promise<any>

	/**
	 * Return true if the object is a getset descriptor.
	 * 
	 *         getset descriptors are specialized descriptors defined in extension
	 *         modules.
	 */
	function isgetsetdescriptor(object): Promise<any>
	function isgetsetdescriptor$({ object }): Promise<any>

	/**
	 * Return true if the object is a user-defined function.
	 * 
	 *     Function objects provide these attributes:
	 *         __doc__         documentation string
	 *         __name__        name with which this function was defined
	 *         __code__        code object containing compiled function bytecode
	 *         __defaults__    tuple of any default values for arguments
	 *         __globals__     global namespace in which this function was defined
	 *         __annotations__ dict of parameter annotations
	 *         __kwdefaults__  dict of keyword only parameters with defaults
	 */
	function isfunction(object): Promise<any>
	function isfunction$({ object }): Promise<any>

	/**
	 * Return true if the object is a user-defined generator function.
	 * 
	 *     Generator function objects provide the same attributes as functions.
	 *     See help(isfunction) for a list of attributes.
	 */
	function isgeneratorfunction(obj): Promise<any>
	function isgeneratorfunction$({ obj }): Promise<any>

	/**
	 * Return true if the object is a coroutine function.
	 * 
	 *     Coroutine functions are defined with "async def" syntax.
	 *     
	 */
	function iscoroutinefunction(obj): Promise<any>
	function iscoroutinefunction$({ obj }): Promise<any>

	/**
	 * Return true if the object is an asynchronous generator function.
	 * 
	 *     Asynchronous generator functions are defined with "async def"
	 *     syntax and have "yield" expressions in their body.
	 *     
	 */
	function isasyncgenfunction(obj): Promise<any>
	function isasyncgenfunction$({ obj }): Promise<any>

	/**
	 * Return true if the object is an asynchronous generator.
	 */
	function isasyncgen(object): Promise<any>
	function isasyncgen$({ object }): Promise<any>

	/**
	 * Return true if the object is a generator.
	 * 
	 *     Generator objects provide these attributes:
	 *         __iter__        defined to support iteration over container
	 *         close           raises a new GeneratorExit exception inside the
	 *                         generator to terminate the iteration
	 *         gi_code         code object
	 *         gi_frame        frame object or possibly None once the generator has
	 *                         been exhausted
	 *         gi_running      set to 1 when generator is executing, 0 otherwise
	 *         next            return the next item from the container
	 *         send            resumes the generator and "sends" a value that becomes
	 *                         the result of the current yield-expression
	 *         throw           used to raise an exception inside the generator
	 */
	function isgenerator(object): Promise<any>
	function isgenerator$({ object }): Promise<any>

	/**
	 * Return true if the object is a coroutine.
	 */
	function iscoroutine(object): Promise<any>
	function iscoroutine$({ object }): Promise<any>

	/**
	 * Return true if object can be passed to an ``await`` expression.
	 */
	function isawaitable(object): Promise<any>
	function isawaitable$({ object }): Promise<any>

	/**
	 * Return true if the object is a traceback.
	 * 
	 *     Traceback objects provide these attributes:
	 *         tb_frame        frame object at this level
	 *         tb_lasti        index of last attempted instruction in bytecode
	 *         tb_lineno       current line number in Python source code
	 *         tb_next         next inner traceback object (called by this level)
	 */
	function istraceback(object): Promise<any>
	function istraceback$({ object }): Promise<any>

	/**
	 * Return true if the object is a frame object.
	 * 
	 *     Frame objects provide these attributes:
	 *         f_back          next outer frame object (this frame's caller)
	 *         f_builtins      built-in namespace seen by this frame
	 *         f_code          code object being executed in this frame
	 *         f_globals       global namespace seen by this frame
	 *         f_lasti         index of last attempted instruction in bytecode
	 *         f_lineno        current line number in Python source code
	 *         f_locals        local namespace seen by this frame
	 *         f_trace         tracing function for this frame, or None
	 */
	function isframe(object): Promise<any>
	function isframe$({ object }): Promise<any>

	/**
	 * Return true if the object is a code object.
	 * 
	 *     Code objects provide these attributes:
	 *         co_argcount         number of arguments (not including *, ** args
	 *                             or keyword only arguments)
	 *         co_code             string of raw compiled bytecode
	 *         co_cellvars         tuple of names of cell variables
	 *         co_consts           tuple of constants used in the bytecode
	 *         co_filename         name of file in which this code object was created
	 *         co_firstlineno      number of first line in Python source code
	 *         co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
	 *                             | 16=nested | 32=generator | 64=nofree | 128=coroutine
	 *                             | 256=iterable_coroutine | 512=async_generator
	 *         co_freevars         tuple of names of free variables
	 *         co_posonlyargcount  number of positional only arguments
	 *         co_kwonlyargcount   number of keyword only arguments (not including ** arg)
	 *         co_lnotab           encoded mapping of line numbers to bytecode indices
	 *         co_name             name with which this code object was defined
	 *         co_names            tuple of names of local variables
	 *         co_nlocals          number of local variables
	 *         co_stacksize        virtual machine stack space required
	 *         co_varnames         tuple of names of arguments and local variables
	 */
	function iscode(object): Promise<any>
	function iscode$({ object }): Promise<any>

	/**
	 * Return true if the object is a built-in function or method.
	 * 
	 *     Built-in functions and methods provide these attributes:
	 *         __doc__         documentation string
	 *         __name__        original name of this function or method
	 *         __self__        instance to which a method is bound, or None
	 */
	function isbuiltin(object): Promise<any>
	function isbuiltin$({ object }): Promise<any>

	/**
	 * Return true if the object is any kind of function or method.
	 */
	function isroutine(object): Promise<any>
	function isroutine$({ object }): Promise<any>

	/**
	 * Return true if the object is an abstract base class (ABC).
	 */
	function isabstract(object): Promise<any>
	function isabstract$({ object }): Promise<any>

	/**
	 * Return all members of an object as (name, value) pairs sorted by name.
	 *     Optionally, only return members that satisfy a given predicate.
	 */
	function getmembers(object, predicate?): Promise<any>
	function getmembers$({ object, predicate }: { object, predicate?}): Promise<any>

	/**
	 * Return list of attribute-descriptor tuples.
	 * 
	 *     For each name in dir(cls), the return list contains a 4-tuple
	 *     with these elements:
	 * 
	 *         0. The name (a string).
	 * 
	 *         1. The kind of attribute this is, one of these strings:
	 *                'class method'    created via classmethod()
	 *                'static method'   created via staticmethod()
	 *                'property'        created via property()
	 *                'method'          any other flavor of method or descriptor
	 *                'data'            not a method
	 * 
	 *         2. The class which defined this attribute (a class).
	 * 
	 *         3. The object as obtained by calling getattr; if this fails, or if the
	 *            resulting object does not live anywhere in the class' mro (including
	 *            metaclasses) then the object is looked up in the defining class's
	 *            dict (found by walking the mro).
	 * 
	 *     If one of the items in dir(cls) is stored in the metaclass it will now
	 *     be discovered and not have None be listed as the class in which it was
	 *     defined.  Any items whose home class cannot be discovered are skipped.
	 *     
	 */
	function classify_class_attrs(cls): Promise<any>
	function classify_class_attrs$({ cls }): Promise<any>

	/**
	 * Return tuple of base classes (including cls) in method resolution order.
	 */
	function getmro(cls): Promise<any>
	function getmro$({ cls }): Promise<any>

	/**
	 * Get the object wrapped by *func*.
	 * 
	 *    Follows the chain of :attr:`__wrapped__` attributes returning the last
	 *    object in the chain.
	 * 
	 *    *stop* is an optional callback accepting an object in the wrapper chain
	 *    as its sole argument that allows the unwrapping to be terminated early if
	 *    the callback returns a true value. If the callback never returns a true
	 *    value, the last object in the chain is returned as usual. For example,
	 *    :func:`signature` uses this to stop unwrapping if any object in the
	 *    chain has a ``__signature__`` attribute defined.
	 * 
	 *    :exc:`ValueError` is raised if a cycle is encountered.
	 * 
	 *     
	 */
	function unwrap(func): Promise<any>
	function unwrap$({ func }): Promise<any>

	/**
	 * Return the indent size, in spaces, at the start of a line of text.
	 */
	function indentsize(line): Promise<any>
	function indentsize$({ line }): Promise<any>

	/**
	 * Get the documentation string for an object.
	 * 
	 *     All tabs are expanded to spaces.  To clean up docstrings that are
	 *     indented to line up with blocks of code, any whitespace than can be
	 *     uniformly removed from the second line onwards is removed.
	 */
	function getdoc(object): Promise<any>
	function getdoc$({ object }): Promise<any>

	/**
	 * Clean up indentation from docstrings.
	 * 
	 *     Any whitespace that can be uniformly removed from the second line
	 *     onwards is removed.
	 */
	function cleandoc(doc): Promise<any>
	function cleandoc$({ doc }): Promise<any>

	/**
	 * Work out which source or compiled file an object was defined in.
	 */
	function getfile(object): Promise<any>
	function getfile$({ object }): Promise<any>

	/**
	 * Return the module name for a given file, or None.
	 */
	function getmodulename(path): Promise<any>
	function getmodulename$({ path }): Promise<any>

	/**
	 * Return the filename that can be used to locate an object's source.
	 *     Return None if no way can be identified to get the source.
	 *     
	 */
	function getsourcefile(object): Promise<any>
	function getsourcefile$({ object }): Promise<any>

	/**
	 * Return an absolute path to the source or compiled file for an object.
	 * 
	 *     The idea is for each object to have a unique origin, so this routine
	 *     normalizes the result as much as possible.
	 */
	function getabsfile(object, _filename?): Promise<any>
	function getabsfile$({ object, _filename }: { object, _filename?}): Promise<any>

	/**
	 * Return the module an object was defined in, or None if not found.
	 */
	function getmodule(object, _filename?): Promise<any>
	function getmodule$({ object, _filename }: { object, _filename?}): Promise<any>

	/**
	 * Return the entire source file and starting line number for an object.
	 * 
	 *     The argument may be a module, class, method, function, traceback, frame,
	 *     or code object.  The source code is returned as a list of all the lines
	 *     in the file and the line number indexes a line in that list.  An OSError
	 *     is raised if the source code cannot be retrieved.
	 */
	function findsource(object): Promise<any>
	function findsource$({ object }): Promise<any>

	/**
	 * Get lines of comments immediately preceding an object's source code.
	 * 
	 *     Returns None when source can't be found.
	 *     
	 */
	function getcomments(object): Promise<any>
	function getcomments$({ object }): Promise<any>

	/**
	 * Extract the block of code at the top of the given list of lines.
	 */
	function getblock(lines): Promise<any>
	function getblock$({ lines }): Promise<any>

	/**
	 * Return a list of source lines and starting line number for an object.
	 * 
	 *     The argument may be a module, class, method, function, traceback, frame,
	 *     or code object.  The source code is returned as a list of the lines
	 *     corresponding to the object and the line number indicates where in the
	 *     original source file the first line of code was found.  An OSError is
	 *     raised if the source code cannot be retrieved.
	 */
	function getsourcelines(object): Promise<any>
	function getsourcelines$({ object }): Promise<any>

	/**
	 * Return the text of the source code for an object.
	 * 
	 *     The argument may be a module, class, method, function, traceback, frame,
	 *     or code object.  The source code is returned as a single string.  An
	 *     OSError is raised if the source code cannot be retrieved.
	 */
	function getsource(object): Promise<any>
	function getsource$({ object }): Promise<any>

	/**
	 * Recursive helper function for getclasstree().
	 */
	function walktree(classes, children, parent): Promise<any>
	function walktree$({ classes, children, parent }): Promise<any>

	/**
	 * Arrange the given list of classes into a hierarchy of nested lists.
	 * 
	 *     Where a nested list appears, it contains classes derived from the class
	 *     whose entry immediately precedes the list.  Each entry is a 2-tuple
	 *     containing a class and a tuple of its base classes.  If the 'unique'
	 *     argument is true, exactly one entry appears in the returned structure
	 *     for each class in the given list.  Otherwise, classes using multiple
	 *     inheritance and their descendants will appear multiple times.
	 */
	function getclasstree(classes, unique?: boolean): Promise<any>
	function getclasstree$({ classes, unique }: { classes, unique?}): Promise<any>

	/**
	 * Get information about the arguments accepted by a code object.
	 * 
	 *     Three things are returned: (args, varargs, varkw), where
	 *     'args' is the list of argument names. Keyword-only arguments are
	 *     appended. 'varargs' and 'varkw' are the names of the * and **
	 *     arguments or None.
	 */
	function getargs(co): Promise<any>
	function getargs$({ co }): Promise<any>

	/**
	 * Get the names and default values of a function's parameters.
	 * 
	 *     A tuple of four things is returned: (args, varargs, keywords, defaults).
	 *     'args' is a list of the argument names, including keyword-only argument names.
	 *     'varargs' and 'keywords' are the names of the * and ** parameters or None.
	 *     'defaults' is an n-tuple of the default values of the last n parameters.
	 * 
	 *     This function is deprecated, as it does not support annotations or
	 *     keyword-only parameters and will raise ValueError if either is present
	 *     on the supplied callable.
	 * 
	 *     For a more structured introspection API, use inspect.signature() instead.
	 * 
	 *     Alternatively, use getfullargspec() for an API with a similar namedtuple
	 *     based interface, but full support for annotations and keyword-only
	 *     parameters.
	 * 
	 *     Deprecated since Python 3.5, use `inspect.getfullargspec()`.
	 *     
	 */
	function getargspec(func): Promise<any>
	function getargspec$({ func }): Promise<any>

	/**
	 * Get the names and default values of a callable object's parameters.
	 * 
	 *     A tuple of seven things is returned:
	 *     (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).
	 *     'args' is a list of the parameter names.
	 *     'varargs' and 'varkw' are the names of the * and ** parameters or None.
	 *     'defaults' is an n-tuple of the default values of the last n parameters.
	 *     'kwonlyargs' is a list of keyword-only parameter names.
	 *     'kwonlydefaults' is a dictionary mapping names from kwonlyargs to defaults.
	 *     'annotations' is a dictionary mapping parameter names to annotations.
	 * 
	 *     Notable differences from inspect.signature():
	 *       - the "self" parameter is always reported, even for bound methods
	 *       - wrapper chains defined by __wrapped__ *not* unwrapped automatically
	 *     
	 */
	function getfullargspec(func): Promise<any>
	function getfullargspec$({ func }): Promise<any>

	/**
	 * Get information about arguments passed into a particular frame.
	 * 
	 *     A tuple of four things is returned: (args, varargs, varkw, locals).
	 *     'args' is a list of the argument names.
	 *     'varargs' and 'varkw' are the names of the * and ** arguments or None.
	 *     'locals' is the locals dictionary of the given frame.
	 */
	function getargvalues(frame): Promise<any>
	function getargvalues$({ frame }): Promise<any>
	function formatannotation(annotation, base_module?): Promise<any>
	function formatannotation$({ annotation, base_module }: { annotation, base_module?}): Promise<any>
	function formatannotationrelativeto(object): Promise<any>
	function formatannotationrelativeto$({ object }): Promise<any>

	/**
	 * Format an argument spec from the values returned by getfullargspec.
	 * 
	 *     The first seven arguments are (args, varargs, varkw, defaults,
	 *     kwonlyargs, kwonlydefaults, annotations).  The other five arguments
	 *     are the corresponding optional formatting functions that are called to
	 *     turn names and values into strings.  The last argument is an optional
	 *     function to format the sequence of arguments.
	 * 
	 *     Deprecated since Python 3.5: use the `signature` function and `Signature`
	 *     objects.
	 *     
	 */
	function formatargspec(args, varargs?, varkw?, defaults?, kwonlyargs?, kwonlydefaults?, annotations?, formatarg?, formatvarargs?, formatvarkw?, formatvalue?, formatreturns?, formatannotation?): Promise<any>
	function formatargspec$({ args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations, formatarg, formatvarargs, formatvarkw, formatvalue, formatreturns, formatannotation }: { args, varargs?, varkw?, defaults?, kwonlyargs?, kwonlydefaults?, annotations?, formatarg?, formatvarargs?, formatvarkw?, formatvalue?, formatreturns?, formatannotation?}): Promise<any>

	/**
	 * Format an argument spec from the 4 values returned by getargvalues.
	 * 
	 *     The first four arguments are (args, varargs, varkw, locals).  The
	 *     next four arguments are the corresponding optional formatting functions
	 *     that are called to turn names and values into strings.  The ninth
	 *     argument is an optional function to format the sequence of arguments.
	 */
	function formatargvalues(args, varargs, varkw, locals, formatarg?, formatvarargs?, formatvarkw?, formatvalue?): Promise<any>
	function formatargvalues$({ args, varargs, varkw, locals, formatarg, formatvarargs, formatvarkw, formatvalue }: { args, varargs, varkw, locals, formatarg?, formatvarargs?, formatvarkw?, formatvalue?}): Promise<any>

	/**
	 * Get the mapping of arguments to values.
	 * 
	 *     A dict is returned, with keys the function argument names (including the
	 *     names of the * and ** arguments, if any), and values the respective bound
	 *     values from 'positional' and 'named'.
	 */
	function getcallargs(func): Promise<any>
	function getcallargs$({ func }): Promise<any>

	/**
	 * 
	 *     Get the mapping of free variables to their current values.
	 * 
	 *     Returns a named tuple of dicts mapping the current nonlocal, global
	 *     and builtin references as seen by the body of the function. A final
	 *     set of unbound names that could not be resolved is also provided.
	 *     
	 */
	function getclosurevars(func): Promise<any>
	function getclosurevars$({ func }): Promise<any>

	/**
	 * Get information about a frame or traceback object.
	 * 
	 *     A tuple of five things is returned: the filename, the line number of
	 *     the current line, the function name, a list of lines of context from
	 *     the source code, and the index of the current line within that list.
	 *     The optional second argument specifies the number of lines of context
	 *     to return, which are centered around the current line.
	 */
	function getframeinfo(frame, context?): Promise<any>
	function getframeinfo$({ frame, context }: { frame, context?}): Promise<any>

	/**
	 * Get the line number from a frame object, allowing for optimization.
	 */
	function getlineno(frame): Promise<any>
	function getlineno$({ frame }): Promise<any>

	/**
	 * Get a list of records for a frame and all higher (calling) frames.
	 * 
	 *     Each record contains a frame object, filename, line number, function
	 *     name, a list of lines of context, and index within the context.
	 */
	function getouterframes(frame, context?): Promise<any>
	function getouterframes$({ frame, context }: { frame, context?}): Promise<any>

	/**
	 * Get a list of records for a traceback's frame and all lower frames.
	 * 
	 *     Each record contains a frame object, filename, line number, function
	 *     name, a list of lines of context, and index within the context.
	 */
	function getinnerframes(tb, context?): Promise<any>
	function getinnerframes$({ tb, context }: { tb, context?}): Promise<any>

	/**
	 * Return the frame of the caller or None if this is not possible.
	 */
	function currentframe(): Promise<any>
	function currentframe$($: {}): Promise<any>

	/**
	 * Return a list of records for the stack above the caller's frame.
	 */
	function stack(context?): Promise<any>
	function stack$({ context }: { context?}): Promise<any>

	/**
	 * Return a list of records for the stack below the current exception.
	 */
	function trace(context?): Promise<any>
	function trace$({ context }: { context?}): Promise<any>

	/**
	 * Retrieve attributes without triggering dynamic lookup via the
	 *        descriptor protocol,  __getattr__ or __getattribute__.
	 * 
	 *        Note: this function may not be able to retrieve all attributes
	 *        that getattr can fetch (like dynamically created attributes)
	 *        and may find attributes that getattr can't (like descriptors
	 *        that raise AttributeError). It can also return descriptor objects
	 *        instead of instance members in some cases. See the
	 *        documentation for details.
	 *     
	 */
	function getattr_static(obj, attr, def?): Promise<any>
	function getattr_static$({ obj, attr, def }: { obj, attr, def?}): Promise<any>

	/**
	 * Get current state of a generator-iterator.
	 * 
	 *     Possible states are:
	 *       GEN_CREATED: Waiting to start execution.
	 *       GEN_RUNNING: Currently being executed by the interpreter.
	 *       GEN_SUSPENDED: Currently suspended at a yield expression.
	 *       GEN_CLOSED: Execution has completed.
	 *     
	 */
	function getgeneratorstate(generator): Promise<any>
	function getgeneratorstate$({ generator }): Promise<any>

	/**
	 * 
	 *     Get the mapping of generator local variables to their current values.
	 * 
	 *     A dict is returned, with the keys the local variable names and values the
	 *     bound values.
	 */
	function getgeneratorlocals(generator): Promise<any>
	function getgeneratorlocals$({ generator }): Promise<any>

	/**
	 * Get current state of a coroutine object.
	 * 
	 *     Possible states are:
	 *       CORO_CREATED: Waiting to start execution.
	 *       CORO_RUNNING: Currently being executed by the interpreter.
	 *       CORO_SUSPENDED: Currently suspended at an await expression.
	 *       CORO_CLOSED: Execution has completed.
	 *     
	 */
	function getcoroutinestate(coroutine): Promise<any>
	function getcoroutinestate$({ coroutine }): Promise<any>

	/**
	 * 
	 *     Get the mapping of coroutine local variables to their current values.
	 * 
	 *     A dict is returned, with the keys the local variable names and values the
	 *     bound values.
	 */
	function getcoroutinelocals(coroutine): Promise<any>
	function getcoroutinelocals$({ coroutine }): Promise<any>

	/**
	 * Get a signature object for the passed callable.
	 */
	function signature(obj): Promise<any>
	function signature$({ obj }): Promise<any>
	interface IClassFoundException {
	}
	interface I_ClassFinder {
		visit_FunctionDef(node): Promise<any>
		visit_FunctionDef$({ node }): Promise<any>
		visit_ClassDef(node): Promise<any>
		visit_ClassDef$({ node }): Promise<any>
		visit_AsyncFunctionDef
	}
	interface IEndOfBlock {
	}

	/**
	 * Provide a tokeneater() method to detect the end of a code block.
	 */
	function BlockFinder(): Promise<IBlockFinder>
	function BlockFinder$({ }): Promise<IBlockFinder>
	interface IBlockFinder {
		tokeneater(type, token, srowcol, erowcol, line): Promise<any>
		tokeneater$({ type, token, srowcol, erowcol, line }): Promise<any>
	}

	/**
	 * A private marker - used in Parameter & Signature.
	 */
	interface I_void {
	}

	/**
	 * Marker object for Signature.empty and Parameter.empty.
	 */
	interface I_empty {
	}
	interface I_ParameterKind {
		description(): Promise<any>
		description$($: {}): Promise<any>
		POSITIONAL_ONLY
		POSITIONAL_OR_KEYWORD
		VAR_POSITIONAL
		KEYWORD_ONLY
		VAR_KEYWORD
	}

	/**
	 * Represents a parameter in a function signature.
	 * 
	 *     Has the following public attributes:
	 * 
	 *     * name : str
	 *         The name of the parameter as a string.
	 *     * default : object
	 *         The default value for the parameter if specified.  If the
	 *         parameter has no default value, this attribute is set to
	 *         `Parameter.empty`.
	 *     * annotation
	 *         The annotation for the parameter if specified.  If the
	 *         parameter has no annotation, this attribute is set to
	 *         `Parameter.empty`.
	 *     * kind : str
	 *         Describes how argument values are bound to the parameter.
	 *         Possible values: `Parameter.POSITIONAL_ONLY`,
	 *         `Parameter.POSITIONAL_OR_KEYWORD`, `Parameter.VAR_POSITIONAL`,
	 *         `Parameter.KEYWORD_ONLY`, `Parameter.VAR_KEYWORD`.
	 *     
	 */
	function Parameter(name, kind): Promise<IParameter>
	function Parameter$({ name, kind }): Promise<IParameter>
	interface IParameter {
		name(): Promise<any>
		name$($: {}): Promise<any>
		default(): Promise<any>
		default$($: {}): Promise<any>
		annotation(): Promise<any>
		annotation$($: {}): Promise<any>
		kind(): Promise<any>
		kind$($: {}): Promise<any>

		/**
		 * Creates a customized copy of the Parameter.
		 */
		replace(): Promise<any>
		replace$($: {}): Promise<any>
		empty
	}

	/**
	 * Result of `Signature.bind` call.  Holds the mapping of arguments
	 *     to the function's parameters.
	 * 
	 *     Has the following public attributes:
	 * 
	 *     * arguments : dict
	 *         An ordered mutable mapping of parameters' names to arguments' values.
	 *         Does not contain arguments' default values.
	 *     * signature : Signature
	 *         The Signature object that created this instance.
	 *     * args : tuple
	 *         Tuple of positional arguments values.
	 *     * kwargs : dict
	 *         Dict of keyword arguments values.
	 *     
	 */
	function BoundArguments(signature, arguments): Promise<IBoundArguments>
	function BoundArguments$({ signature, arguments }): Promise<IBoundArguments>
	interface IBoundArguments {
		signature(): Promise<any>
		signature$($: {}): Promise<any>
		args(): Promise<any>
		args$($: {}): Promise<any>
		kwargs(): Promise<any>
		kwargs$($: {}): Promise<any>

		/**
		 * Set default values for missing arguments.
		 * 
		 *         For variable-positional arguments (*args) the default is an
		 *         empty tuple.
		 * 
		 *         For variable-keyword arguments (**kwargs) the default is an
		 *         empty dict.
		 *         
		 */
		apply_defaults(): Promise<any>
		apply_defaults$($: {}): Promise<any>
	}

	/**
	 * A Signature object represents the overall signature of a function.
	 *     It stores a Parameter object for each parameter accepted by the
	 *     function, as well as information specific to the function itself.
	 * 
	 *     A Signature object has the following public attributes and methods:
	 * 
	 *     * parameters : OrderedDict
	 *         An ordered mapping of parameters' names to the corresponding
	 *         Parameter objects (keyword-only arguments are in the same order
	 *         as listed in `code.co_varnames`).
	 *     * return_annotation : object
	 *         The annotation for the return type of the function if specified.
	 *         If the function has no annotation for its return type, this
	 *         attribute is set to `Signature.empty`.
	 *     * bind(*args, **kwargs) -> BoundArguments
	 *         Creates a mapping from positional and keyword arguments to
	 *         parameters.
	 *     * bind_partial(*args, **kwargs) -> BoundArguments
	 *         Creates a partial mapping from positional and keyword arguments
	 *         to parameters (simulating 'functools.partial' behavior.)
	 *     
	 */

	/**
	 * Constructs Signature from the given list of Parameter
	 *         objects and 'return_annotation'.  All arguments are optional.
	 *         
	 */
	function Signature(parameters?): Promise<ISignature>
	function Signature$({ parameters }: { parameters?}): Promise<ISignature>
	interface ISignature {

		/**
		 * Constructs Signature for the given python function.
		 * 
		 *         Deprecated since Python 3.5, use `Signature.from_callable()`.
		 *         
		 */
		from_function(func): Promise<any>
		from_function$({ func }): Promise<any>

		/**
		 * Constructs Signature for the given builtin function.
		 * 
		 *         Deprecated since Python 3.5, use `Signature.from_callable()`.
		 *         
		 */
		from_builtin(func): Promise<any>
		from_builtin$({ func }): Promise<any>

		/**
		 * Constructs Signature for the given callable object.
		 */
		from_callable(obj): Promise<any>
		from_callable$({ obj }): Promise<any>
		parameters(): Promise<any>
		parameters$($: {}): Promise<any>
		return_annotation(): Promise<any>
		return_annotation$($: {}): Promise<any>

		/**
		 * Creates a customized copy of the Signature.
		 *         Pass 'parameters' and/or 'return_annotation' arguments
		 *         to override them in the new copy.
		 *         
		 */
		replace(): Promise<any>
		replace$($: {}): Promise<any>

		/**
		 * Get a BoundArguments object, that maps the passed `args`
		 *         and `kwargs` to the function's signature.  Raises `TypeError`
		 *         if the passed arguments can not be bound.
		 *         
		 */
		bind(): Promise<any>
		bind$($: {}): Promise<any>

		/**
		 * Get a BoundArguments object, that partially maps the
		 *         passed `args` and `kwargs` to the function's signature.
		 *         Raises `TypeError` if the passed arguments can not be bound.
		 *         
		 */
		bind_partial(): Promise<any>
		bind_partial$($: {}): Promise<any>
	}
	let mod_dict: Promise<any>
	let TPFLAGS_IS_ABSTRACT: Promise<any>
	let Attribute: Promise<any>
	let modulesbyfile: Promise<any>
	let Arguments: Promise<any>
	let ArgSpec: Promise<any>
	let FullArgSpec: Promise<any>
	let ArgInfo: Promise<any>
	let ClosureVars: Promise<any>
	let Traceback: Promise<any>
	let FrameInfo: Promise<any>
	let GEN_CREATED: Promise<any>
	let GEN_RUNNING: Promise<any>
	let GEN_SUSPENDED: Promise<any>
	let GEN_CLOSED: Promise<any>
	let CORO_CREATED: Promise<any>
	let CORO_RUNNING: Promise<any>
	let CORO_SUSPENDED: Promise<any>
	let CORO_CLOSED: Promise<any>
}
declare module io {
	var _
	interface IIOBase {
	}
	interface IRawIOBase extends IIOBase {
	}
	interface IBufferedIOBase extends IIOBase {
	}
	interface ITextIOBase extends IIOBase {
	}
	let SEEK_SET: Promise<any>
	let SEEK_CUR: Promise<any>
	let SEEK_END: Promise<any>
}
declare module ipaddress {
	var _

	/**
	 * Take an IP string/int and return an object of the correct type.
	 * 
	 *     Args:
	 *         address: A string or integer, the IP address.  Either IPv4 or
	 *           IPv6 addresses may be supplied; integers less than 2**32 will
	 *           be considered to be IPv4 by default.
	 * 
	 *     Returns:
	 *         An IPv4Address or IPv6Address object.
	 * 
	 *     Raises:
	 *         ValueError: if the *address* passed isn't either a v4 or a v6
	 *           address
	 * 
	 *     
	 */
	function ip_address(address): Promise<any>
	function ip_address$({ address }): Promise<any>

	/**
	 * Take an IP string/int and return an object of the correct type.
	 * 
	 *     Args:
	 *         address: A string or integer, the IP network.  Either IPv4 or
	 *           IPv6 networks may be supplied; integers less than 2**32 will
	 *           be considered to be IPv4 by default.
	 * 
	 *     Returns:
	 *         An IPv4Network or IPv6Network object.
	 * 
	 *     Raises:
	 *         ValueError: if the string passed isn't either a v4 or a v6
	 *           address. Or if the network has host bits set.
	 * 
	 *     
	 */
	function ip_network(address, strict?: boolean): Promise<any>
	function ip_network$({ address, strict }: { address, strict?}): Promise<any>

	/**
	 * Take an IP string/int and return an object of the correct type.
	 * 
	 *     Args:
	 *         address: A string or integer, the IP address.  Either IPv4 or
	 *           IPv6 addresses may be supplied; integers less than 2**32 will
	 *           be considered to be IPv4 by default.
	 * 
	 *     Returns:
	 *         An IPv4Interface or IPv6Interface object.
	 * 
	 *     Raises:
	 *         ValueError: if the string passed isn't either a v4 or a v6
	 *           address.
	 * 
	 *     Notes:
	 *         The IPv?Interface classes describe an Address on a particular
	 *         Network, so they're basically a combination of both the Address
	 *         and Network classes.
	 * 
	 *     
	 */
	function ip_interface(address): Promise<any>
	function ip_interface$({ address }): Promise<any>

	/**
	 * Represent an address as 4 packed bytes in network (big-endian) order.
	 * 
	 *     Args:
	 *         address: An integer representation of an IPv4 IP address.
	 * 
	 *     Returns:
	 *         The integer address packed as 4 bytes in network (big-endian) order.
	 * 
	 *     Raises:
	 *         ValueError: If the integer is negative or too large to be an
	 *           IPv4 IP address.
	 * 
	 *     
	 */
	function v4_int_to_packed(address): Promise<any>
	function v4_int_to_packed$({ address }): Promise<any>

	/**
	 * Represent an address as 16 packed bytes in network (big-endian) order.
	 * 
	 *     Args:
	 *         address: An integer representation of an IPv6 IP address.
	 * 
	 *     Returns:
	 *         The integer address packed as 16 bytes in network (big-endian) order.
	 * 
	 *     
	 */
	function v6_int_to_packed(address): Promise<any>
	function v6_int_to_packed$({ address }): Promise<any>

	/**
	 * Summarize a network range given the first and last IP addresses.
	 * 
	 *     Example:
	 *         >>> list(summarize_address_range(IPv4Address('192.0.2.0'),
	 *         ...                              IPv4Address('192.0.2.130')))
	 *         ...                                #doctest: +NORMALIZE_WHITESPACE
	 *         [IPv4Network('192.0.2.0/25'), IPv4Network('192.0.2.128/31'),
	 *          IPv4Network('192.0.2.130/32')]
	 * 
	 *     Args:
	 *         first: the first IPv4Address or IPv6Address in the range.
	 *         last: the last IPv4Address or IPv6Address in the range.
	 * 
	 *     Returns:
	 *         An iterator of the summarized IPv(4|6) network objects.
	 * 
	 *     Raise:
	 *         TypeError:
	 *             If the first and last objects are not IP addresses.
	 *             If the first and last objects are not the same version.
	 *         ValueError:
	 *             If the last object is not greater than the first.
	 *             If the version of the first address is not 4 or 6.
	 * 
	 *     
	 */
	function summarize_address_range(first, last): Promise<any>
	function summarize_address_range$({ first, last }): Promise<any>

	/**
	 * Collapse a list of IP objects.
	 * 
	 *     Example:
	 *         collapse_addresses([IPv4Network('192.0.2.0/25'),
	 *                             IPv4Network('192.0.2.128/25')]) ->
	 *                            [IPv4Network('192.0.2.0/24')]
	 * 
	 *     Args:
	 *         addresses: An iterator of IPv4Network or IPv6Network objects.
	 * 
	 *     Returns:
	 *         An iterator of the collapsed IPv(4|6)Network objects.
	 * 
	 *     Raises:
	 *         TypeError: If passed a list of mixed version objects.
	 * 
	 *     
	 */
	function collapse_addresses(addresses): Promise<any>
	function collapse_addresses$({ addresses }): Promise<any>

	/**
	 * Return a key suitable for sorting between networks and addresses.
	 * 
	 *     Address and Network objects are not sortable by default; they're
	 *     fundamentally different so the expression
	 * 
	 *         IPv4Address('192.0.2.0') <= IPv4Network('192.0.2.0/24')
	 * 
	 *     doesn't make any sense.  There are some times however, where you may wish
	 *     to have ipaddress sort these for you anyway. If you need to do this, you
	 *     can use this function as the key= argument to sorted().
	 * 
	 *     Args:
	 *       obj: either a Network or Address object.
	 *     Returns:
	 *       appropriate key.
	 * 
	 *     
	 */
	function get_mixed_type_key(obj): Promise<any>
	function get_mixed_type_key$({ obj }): Promise<any>

	/**
	 * A Value Error related to the address.
	 */
	interface IAddressValueError {
	}

	/**
	 * A Value Error related to the netmask.
	 */
	interface INetmaskValueError {
	}

	/**
	 * The mother class.
	 */
	interface I_IPAddressBase {

		/**
		 * Return the longhand version of the IP address as a string.
		 */
		exploded(): Promise<any>
		exploded$($: {}): Promise<any>

		/**
		 * Return the shorthand version of the IP address as a string.
		 */
		compressed(): Promise<any>
		compressed$($: {}): Promise<any>

		/**
		 * The name of the reverse DNS pointer for the IP address, e.g.:
		 *             >>> ipaddress.ip_address("127.0.0.1").reverse_pointer
		 *             '1.0.0.127.in-addr.arpa'
		 *             >>> ipaddress.ip_address("2001:db8::1").reverse_pointer
		 *             '1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa'
		 * 
		 *         
		 */
		reverse_pointer(): Promise<any>
		reverse_pointer$($: {}): Promise<any>
		version(): Promise<any>
		version$($: {}): Promise<any>
	}

	/**
	 * A generic IP object.
	 * 
	 *     This IP class contains the version independent methods which are
	 *     used by single IP addresses.
	 *     
	 */
	interface I_BaseAddress extends I_IPAddressBase {
	}

	/**
	 * A generic IP network object.
	 * 
	 *     This IP class contains the version independent methods which are
	 *     used by networks.
	 *     
	 */
	interface I_BaseNetwork extends I_IPAddressBase {

		/**
		 * Generate Iterator over usable hosts in a network.
		 * 
		 *         This is like __iter__ except it doesn't return the network
		 *         or broadcast addresses.
		 * 
		 *         
		 */
		hosts(): Promise<any>
		hosts$($: {}): Promise<any>

		/**
		 * Tell if self is partly contained in other.
		 */
		overlaps(other): Promise<any>
		overlaps$({ other }): Promise<any>
		broadcast_address(): Promise<any>
		broadcast_address$($: {}): Promise<any>
		hostmask(): Promise<any>
		hostmask$($: {}): Promise<any>
		with_prefixlen(): Promise<any>
		with_prefixlen$($: {}): Promise<any>
		with_netmask(): Promise<any>
		with_netmask$($: {}): Promise<any>
		with_hostmask(): Promise<any>
		with_hostmask$($: {}): Promise<any>

		/**
		 * Number of hosts in the current subnet.
		 */
		num_addresses(): Promise<any>
		num_addresses$($: {}): Promise<any>
		prefixlen(): Promise<any>
		prefixlen$($: {}): Promise<any>

		/**
		 * Remove an address from a larger block.
		 * 
		 *         For example:
		 * 
		 *             addr1 = ip_network('192.0.2.0/28')
		 *             addr2 = ip_network('192.0.2.1/32')
		 *             list(addr1.address_exclude(addr2)) =
		 *                 [IPv4Network('192.0.2.0/32'), IPv4Network('192.0.2.2/31'),
		 *                  IPv4Network('192.0.2.4/30'), IPv4Network('192.0.2.8/29')]
		 * 
		 *         or IPv6:
		 * 
		 *             addr1 = ip_network('2001:db8::1/32')
		 *             addr2 = ip_network('2001:db8::1/128')
		 *             list(addr1.address_exclude(addr2)) =
		 *                 [ip_network('2001:db8::1/128'),
		 *                  ip_network('2001:db8::2/127'),
		 *                  ip_network('2001:db8::4/126'),
		 *                  ip_network('2001:db8::8/125'),
		 *                  ...
		 *                  ip_network('2001:db8:8000::/33')]
		 * 
		 *         Args:
		 *             other: An IPv4Network or IPv6Network object of the same type.
		 * 
		 *         Returns:
		 *             An iterator of the IPv(4|6)Network objects which is self
		 *             minus other.
		 * 
		 *         Raises:
		 *             TypeError: If self and other are of differing address
		 *               versions, or if other is not a network object.
		 *             ValueError: If other is not completely contained by self.
		 * 
		 *         
		 */
		address_exclude(other): Promise<any>
		address_exclude$({ other }): Promise<any>

		/**
		 * Compare two IP objects.
		 * 
		 *         This is only concerned about the comparison of the integer
		 *         representation of the network addresses.  This means that the
		 *         host bits aren't considered at all in this method.  If you want
		 *         to compare host bits, you can easily enough do a
		 *         'HostA._ip < HostB._ip'
		 * 
		 *         Args:
		 *             other: An IP object.
		 * 
		 *         Returns:
		 *             If the IP versions of self and other are the same, returns:
		 * 
		 *             -1 if self < other:
		 *               eg: IPv4Network('192.0.2.0/25') < IPv4Network('192.0.2.128/25')
		 *               IPv6Network('2001:db8::1000/124') <
		 *                   IPv6Network('2001:db8::2000/124')
		 *             0 if self == other
		 *               eg: IPv4Network('192.0.2.0/24') == IPv4Network('192.0.2.0/24')
		 *               IPv6Network('2001:db8::1000/124') ==
		 *                   IPv6Network('2001:db8::1000/124')
		 *             1 if self > other
		 *               eg: IPv4Network('192.0.2.128/25') > IPv4Network('192.0.2.0/25')
		 *                   IPv6Network('2001:db8::2000/124') >
		 *                       IPv6Network('2001:db8::1000/124')
		 * 
		 *           Raises:
		 *               TypeError if the IP versions are different.
		 * 
		 *         
		 */
		compare_networks(other): Promise<any>
		compare_networks$({ other }): Promise<any>

		/**
		 * The subnets which join to make the current subnet.
		 * 
		 *         In the case that self contains only one IP
		 *         (self._prefixlen == 32 for IPv4 or self._prefixlen == 128
		 *         for IPv6), yield an iterator with just ourself.
		 * 
		 *         Args:
		 *             prefixlen_diff: An integer, the amount the prefix length
		 *               should be increased by. This should not be set if
		 *               new_prefix is also set.
		 *             new_prefix: The desired new prefix length. This must be a
		 *               larger number (smaller prefix) than the existing prefix.
		 *               This should not be set if prefixlen_diff is also set.
		 * 
		 *         Returns:
		 *             An iterator of IPv(4|6) objects.
		 * 
		 *         Raises:
		 *             ValueError: The prefixlen_diff is too small or too large.
		 *                 OR
		 *             prefixlen_diff and new_prefix are both set or new_prefix
		 *               is a smaller number than the current prefix (smaller
		 *               number means a larger network)
		 * 
		 *         
		 */
		subnets(prefixlen_diff?, new_prefix?): Promise<any>
		subnets$({ prefixlen_diff, new_prefix }: { prefixlen_diff?, new_prefix?}): Promise<any>

		/**
		 * The supernet containing the current network.
		 * 
		 *         Args:
		 *             prefixlen_diff: An integer, the amount the prefix length of
		 *               the network should be decreased by.  For example, given a
		 *               /24 network and a prefixlen_diff of 3, a supernet with a
		 *               /21 netmask is returned.
		 * 
		 *         Returns:
		 *             An IPv4 network object.
		 * 
		 *         Raises:
		 *             ValueError: If self.prefixlen - prefixlen_diff < 0. I.e., you have
		 *               a negative prefix length.
		 *                 OR
		 *             If prefixlen_diff and new_prefix are both set or new_prefix is a
		 *               larger number than the current prefix (larger number means a
		 *               smaller network)
		 * 
		 *         
		 */
		supernet(prefixlen_diff?, new_prefix?): Promise<any>
		supernet$({ prefixlen_diff, new_prefix }: { prefixlen_diff?, new_prefix?}): Promise<any>

		/**
		 * Test if the address is reserved for multicast use.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is a multicast address.
		 *             See RFC 2373 2.7 for details.
		 * 
		 *         
		 */
		is_multicast(): Promise<any>
		is_multicast$($: {}): Promise<any>

		/**
		 * Return True if this network is a subnet of other.
		 */
		subnet_of(other): Promise<any>
		subnet_of$({ other }): Promise<any>

		/**
		 * Return True if this network is a supernet of other.
		 */
		supernet_of(other): Promise<any>
		supernet_of$({ other }): Promise<any>

		/**
		 * Test if the address is otherwise IETF reserved.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is within one of the
		 *             reserved IPv6 Network ranges.
		 * 
		 *         
		 */
		is_reserved(): Promise<any>
		is_reserved$($: {}): Promise<any>

		/**
		 * Test if the address is reserved for link-local.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is reserved per RFC 4291.
		 * 
		 *         
		 */
		is_link_local(): Promise<any>
		is_link_local$($: {}): Promise<any>

		/**
		 * Test if this address is allocated for private networks.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is reserved per
		 *             iana-ipv4-special-registry or iana-ipv6-special-registry.
		 * 
		 *         
		 */
		is_private(): Promise<any>
		is_private$($: {}): Promise<any>

		/**
		 * Test if this address is allocated for public networks.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is not reserved per
		 *             iana-ipv4-special-registry or iana-ipv6-special-registry.
		 * 
		 *         
		 */
		is_global(): Promise<any>
		is_global$($: {}): Promise<any>

		/**
		 * Test if the address is unspecified.
		 * 
		 *         Returns:
		 *             A boolean, True if this is the unspecified address as defined in
		 *             RFC 2373 2.5.2.
		 * 
		 *         
		 */
		is_unspecified(): Promise<any>
		is_unspecified$($: {}): Promise<any>

		/**
		 * Test if the address is a loopback address.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is a loopback address as defined in
		 *             RFC 2373 2.5.3.
		 * 
		 *         
		 */
		is_loopback(): Promise<any>
		is_loopback$($: {}): Promise<any>
	}

	/**
	 * Base IPv4 object.
	 * 
	 *     The following methods are used by IPv4 objects in both single IP
	 *     addresses and networks.
	 * 
	 *     
	 */
	interface I_BaseV4 {
		max_prefixlen(): Promise<any>
		max_prefixlen$($: {}): Promise<any>
		version(): Promise<any>
		version$($: {}): Promise<any>
	}

	/**
	 * Represent and manipulate single IPv4 Addresses.
	 */

	/**
	 * 
	 *         Args:
	 *             address: A string or integer representing the IP
	 * 
	 *               Additionally, an integer can be passed, so
	 *               IPv4Address('192.0.2.1') == IPv4Address(3221225985).
	 *               or, more generally
	 *               IPv4Address(int(IPv4Address('192.0.2.1'))) ==
	 *                 IPv4Address('192.0.2.1')
	 * 
	 *         Raises:
	 *             AddressValueError: If ipaddress isn't a valid IPv4 address.
	 * 
	 *         
	 */
	function IPv4Address(address): Promise<IIPv4Address>
	function IPv4Address$({ address }): Promise<IIPv4Address>
	interface IIPv4Address extends I_BaseV4, I_BaseAddress {

		/**
		 * The binary representation of this address.
		 */
		packed(): Promise<any>
		packed$($: {}): Promise<any>

		/**
		 * Test if the address is otherwise IETF reserved.
		 * 
		 *          Returns:
		 *              A boolean, True if the address is within the
		 *              reserved IPv4 Network range.
		 * 
		 *         
		 */
		is_reserved(): Promise<any>
		is_reserved$($: {}): Promise<any>

		/**
		 * Test if this address is allocated for private networks.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is reserved per
		 *             iana-ipv4-special-registry.
		 * 
		 *         
		 */
		is_private(): Promise<any>
		is_private$($: {}): Promise<any>
		is_global(): Promise<any>
		is_global$($: {}): Promise<any>

		/**
		 * Test if the address is reserved for multicast use.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is multicast.
		 *             See RFC 3171 for details.
		 * 
		 *         
		 */
		is_multicast(): Promise<any>
		is_multicast$($: {}): Promise<any>

		/**
		 * Test if the address is unspecified.
		 * 
		 *         Returns:
		 *             A boolean, True if this is the unspecified address as defined in
		 *             RFC 5735 3.
		 * 
		 *         
		 */
		is_unspecified(): Promise<any>
		is_unspecified$($: {}): Promise<any>

		/**
		 * Test if the address is a loopback address.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is a loopback per RFC 3330.
		 * 
		 *         
		 */
		is_loopback(): Promise<any>
		is_loopback$($: {}): Promise<any>

		/**
		 * Test if the address is reserved for link-local.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is link-local per RFC 3927.
		 * 
		 *         
		 */
		is_link_local(): Promise<any>
		is_link_local$($: {}): Promise<any>
	}
	function IPv4Interface(address): Promise<IIPv4Interface>
	function IPv4Interface$({ address }): Promise<IIPv4Interface>
	interface IIPv4Interface extends IIPv4Address {
		hostmask(): Promise<any>
		hostmask$($: {}): Promise<any>
		ip(): Promise<any>
		ip$($: {}): Promise<any>
		with_prefixlen(): Promise<any>
		with_prefixlen$($: {}): Promise<any>
		with_netmask(): Promise<any>
		with_netmask$($: {}): Promise<any>
		with_hostmask(): Promise<any>
		with_hostmask$($: {}): Promise<any>
	}

	/**
	 * This class represents and manipulates 32-bit IPv4 network + addresses..
	 * 
	 *     Attributes: [examples for IPv4Network('192.0.2.0/27')]
	 *         .network_address: IPv4Address('192.0.2.0')
	 *         .hostmask: IPv4Address('0.0.0.31')
	 *         .broadcast_address: IPv4Address('192.0.2.32')
	 *         .netmask: IPv4Address('255.255.255.224')
	 *         .prefixlen: 27
	 * 
	 *     
	 */

	/**
	 * Instantiate a new IPv4 network object.
	 * 
	 *         Args:
	 *             address: A string or integer representing the IP [& network].
	 *               '192.0.2.0/24'
	 *               '192.0.2.0/255.255.255.0'
	 *               '192.0.2.0/0.0.0.255'
	 *               are all functionally the same in IPv4. Similarly,
	 *               '192.0.2.1'
	 *               '192.0.2.1/255.255.255.255'
	 *               '192.0.2.1/32'
	 *               are also functionally equivalent. That is to say, failing to
	 *               provide a subnetmask will create an object with a mask of /32.
	 * 
	 *               If the mask (portion after the / in the argument) is given in
	 *               dotted quad form, it is treated as a netmask if it starts with a
	 *               non-zero field (e.g. /255.0.0.0 == /8) and as a hostmask if it
	 *               starts with a zero field (e.g. 0.255.255.255 == /8), with the
	 *               single exception of an all-zero mask which is treated as a
	 *               netmask == /0. If no mask is given, a default of /32 is used.
	 * 
	 *               Additionally, an integer can be passed, so
	 *               IPv4Network('192.0.2.1') == IPv4Network(3221225985)
	 *               or, more generally
	 *               IPv4Interface(int(IPv4Interface('192.0.2.1'))) ==
	 *                 IPv4Interface('192.0.2.1')
	 * 
	 *         Raises:
	 *             AddressValueError: If ipaddress isn't a valid IPv4 address.
	 *             NetmaskValueError: If the netmask isn't valid for
	 *               an IPv4 address.
	 *             ValueError: If strict is True and a network address is not
	 *               supplied.
	 *         
	 */
	function IPv4Network(address, strict?: boolean): Promise<IIPv4Network>
	function IPv4Network$({ address, strict }: { address, strict?}): Promise<IIPv4Network>
	interface IIPv4Network extends I_BaseV4, I_BaseNetwork {

		/**
		 * Test if this address is allocated for public networks.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is not reserved per
		 *             iana-ipv4-special-registry.
		 * 
		 *         
		 */
		is_global(): Promise<any>
		is_global$($: {}): Promise<any>
	}
	interface I_IPv4Constants {
	}

	/**
	 * Base IPv6 object.
	 * 
	 *     The following methods are used by IPv6 objects in both single IP
	 *     addresses and networks.
	 * 
	 *     
	 */
	interface I_BaseV6 {
		max_prefixlen(): Promise<any>
		max_prefixlen$($: {}): Promise<any>
		version(): Promise<any>
		version$($: {}): Promise<any>
	}

	/**
	 * Represent and manipulate single IPv6 Addresses.
	 */

	/**
	 * Instantiate a new IPv6 address object.
	 * 
	 *         Args:
	 *             address: A string or integer representing the IP
	 * 
	 *               Additionally, an integer can be passed, so
	 *               IPv6Address('2001:db8::') ==
	 *                 IPv6Address(42540766411282592856903984951653826560)
	 *               or, more generally
	 *               IPv6Address(int(IPv6Address('2001:db8::'))) ==
	 *                 IPv6Address('2001:db8::')
	 * 
	 *         Raises:
	 *             AddressValueError: If address isn't a valid IPv6 address.
	 * 
	 *         
	 */
	function IPv6Address(address): Promise<IIPv6Address>
	function IPv6Address$({ address }): Promise<IIPv6Address>
	interface IIPv6Address extends I_BaseV6, I_BaseAddress {

		/**
		 * Identifier of a particular zone of the address's scope.
		 * 
		 *         See RFC 4007 for details.
		 * 
		 *         Returns:
		 *             A string identifying the zone of the address if specified, else None.
		 * 
		 *         
		 */
		scope_id(): Promise<any>
		scope_id$($: {}): Promise<any>

		/**
		 * The binary representation of this address.
		 */
		packed(): Promise<any>
		packed$($: {}): Promise<any>

		/**
		 * Test if the address is reserved for multicast use.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is a multicast address.
		 *             See RFC 2373 2.7 for details.
		 * 
		 *         
		 */
		is_multicast(): Promise<any>
		is_multicast$($: {}): Promise<any>

		/**
		 * Test if the address is otherwise IETF reserved.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is within one of the
		 *             reserved IPv6 Network ranges.
		 * 
		 *         
		 */
		is_reserved(): Promise<any>
		is_reserved$($: {}): Promise<any>

		/**
		 * Test if the address is reserved for link-local.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is reserved per RFC 4291.
		 * 
		 *         
		 */
		is_link_local(): Promise<any>
		is_link_local$($: {}): Promise<any>

		/**
		 * Test if the address is reserved for site-local.
		 * 
		 *         Note that the site-local address space has been deprecated by RFC 3879.
		 *         Use is_private to test if this address is in the space of unique local
		 *         addresses as defined by RFC 4193.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is reserved per RFC 3513 2.5.6.
		 * 
		 *         
		 */
		is_site_local(): Promise<any>
		is_site_local$($: {}): Promise<any>

		/**
		 * Test if this address is allocated for private networks.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is reserved per
		 *             iana-ipv6-special-registry, or is ipv4_mapped and is
		 *             reserved in the iana-ipv4-special-registry.
		 * 
		 *         
		 */
		is_private(): Promise<any>
		is_private$($: {}): Promise<any>

		/**
		 * Test if this address is allocated for public networks.
		 * 
		 *         Returns:
		 *             A boolean, true if the address is not reserved per
		 *             iana-ipv6-special-registry.
		 * 
		 *         
		 */
		is_global(): Promise<any>
		is_global$($: {}): Promise<any>

		/**
		 * Test if the address is unspecified.
		 * 
		 *         Returns:
		 *             A boolean, True if this is the unspecified address as defined in
		 *             RFC 2373 2.5.2.
		 * 
		 *         
		 */
		is_unspecified(): Promise<any>
		is_unspecified$($: {}): Promise<any>

		/**
		 * Test if the address is a loopback address.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is a loopback address as defined in
		 *             RFC 2373 2.5.3.
		 * 
		 *         
		 */
		is_loopback(): Promise<any>
		is_loopback$($: {}): Promise<any>

		/**
		 * Return the IPv4 mapped address.
		 * 
		 *         Returns:
		 *             If the IPv6 address is a v4 mapped address, return the
		 *             IPv4 mapped address. Return None otherwise.
		 * 
		 *         
		 */
		ipv4_mapped(): Promise<any>
		ipv4_mapped$($: {}): Promise<any>

		/**
		 * Tuple of embedded teredo IPs.
		 * 
		 *         Returns:
		 *             Tuple of the (server, client) IPs or None if the address
		 *             doesn't appear to be a teredo address (doesn't start with
		 *             2001::/32)
		 * 
		 *         
		 */
		teredo(): Promise<any>
		teredo$($: {}): Promise<any>

		/**
		 * Return the IPv4 6to4 embedded address.
		 * 
		 *         Returns:
		 *             The IPv4 6to4-embedded address if present or None if the
		 *             address doesn't appear to contain a 6to4 embedded address.
		 * 
		 *         
		 */
		sixtofour(): Promise<any>
		sixtofour$($: {}): Promise<any>
	}
	function IPv6Interface(address): Promise<IIPv6Interface>
	function IPv6Interface$({ address }): Promise<IIPv6Interface>
	interface IIPv6Interface extends IIPv6Address {
		hostmask(): Promise<any>
		hostmask$($: {}): Promise<any>
		ip(): Promise<any>
		ip$($: {}): Promise<any>
		with_prefixlen(): Promise<any>
		with_prefixlen$($: {}): Promise<any>
		with_netmask(): Promise<any>
		with_netmask$($: {}): Promise<any>
		with_hostmask(): Promise<any>
		with_hostmask$($: {}): Promise<any>
		is_unspecified(): Promise<any>
		is_unspecified$($: {}): Promise<any>
		is_loopback(): Promise<any>
		is_loopback$($: {}): Promise<any>
	}

	/**
	 * This class represents and manipulates 128-bit IPv6 networks.
	 * 
	 *     Attributes: [examples for IPv6('2001:db8::1000/124')]
	 *         .network_address: IPv6Address('2001:db8::1000')
	 *         .hostmask: IPv6Address('::f')
	 *         .broadcast_address: IPv6Address('2001:db8::100f')
	 *         .netmask: IPv6Address('ffff:ffff:ffff:ffff:ffff:ffff:ffff:fff0')
	 *         .prefixlen: 124
	 * 
	 *     
	 */

	/**
	 * Instantiate a new IPv6 Network object.
	 * 
	 *         Args:
	 *             address: A string or integer representing the IPv6 network or the
	 *               IP and prefix/netmask.
	 *               '2001:db8::/128'
	 *               '2001:db8:0000:0000:0000:0000:0000:0000/128'
	 *               '2001:db8::'
	 *               are all functionally the same in IPv6.  That is to say,
	 *               failing to provide a subnetmask will create an object with
	 *               a mask of /128.
	 * 
	 *               Additionally, an integer can be passed, so
	 *               IPv6Network('2001:db8::') ==
	 *                 IPv6Network(42540766411282592856903984951653826560)
	 *               or, more generally
	 *               IPv6Network(int(IPv6Network('2001:db8::'))) ==
	 *                 IPv6Network('2001:db8::')
	 * 
	 *             strict: A boolean. If true, ensure that we have been passed
	 *               A true network address, eg, 2001:db8::1000/124 and not an
	 *               IP address on a network, eg, 2001:db8::1/124.
	 * 
	 *         Raises:
	 *             AddressValueError: If address isn't a valid IPv6 address.
	 *             NetmaskValueError: If the netmask isn't valid for
	 *               an IPv6 address.
	 *             ValueError: If strict was True and a network address was not
	 *               supplied.
	 *         
	 */
	function IPv6Network(address, strict?: boolean): Promise<IIPv6Network>
	function IPv6Network$({ address, strict }: { address, strict?}): Promise<IIPv6Network>
	interface IIPv6Network extends I_BaseV6, I_BaseNetwork {

		/**
		 * Generate Iterator over usable hosts in a network.
		 * 
		 *           This is like __iter__ except it doesn't return the
		 *           Subnet-Router anycast address.
		 * 
		 *         
		 */
		hosts(): Promise<any>
		hosts$($: {}): Promise<any>

		/**
		 * Test if the address is reserved for site-local.
		 * 
		 *         Note that the site-local address space has been deprecated by RFC 3879.
		 *         Use is_private to test if this address is in the space of unique local
		 *         addresses as defined by RFC 4193.
		 * 
		 *         Returns:
		 *             A boolean, True if the address is reserved per RFC 3513 2.5.6.
		 * 
		 *         
		 */
		is_site_local(): Promise<any>
		is_site_local$($: {}): Promise<any>
	}
	interface I_IPv6Constants {
	}
	let IPV4LENGTH: Promise<any>
	let IPV6LENGTH: Promise<any>
}
declare module json {
	var _

	/**
	 * Serialize ``obj`` as a JSON formatted stream to ``fp`` (a
	 *     ``.write()``-supporting file-like object).
	 * 
	 *     If ``skipkeys`` is true then ``dict`` keys that are not basic types
	 *     (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped
	 *     instead of raising a ``TypeError``.
	 * 
	 *     If ``ensure_ascii`` is false, then the strings written to ``fp`` can
	 *     contain non-ASCII characters if they appear in strings contained in
	 *     ``obj``. Otherwise, all such characters are escaped in JSON strings.
	 * 
	 *     If ``check_circular`` is false, then the circular reference check
	 *     for container types will be skipped and a circular reference will
	 *     result in an ``OverflowError`` (or worse).
	 * 
	 *     If ``allow_nan`` is false, then it will be a ``ValueError`` to
	 *     serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)
	 *     in strict compliance of the JSON specification, instead of using the
	 *     JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).
	 * 
	 *     If ``indent`` is a non-negative integer, then JSON array elements and
	 *     object members will be pretty-printed with that indent level. An indent
	 *     level of 0 will only insert newlines. ``None`` is the most compact
	 *     representation.
	 * 
	 *     If specified, ``separators`` should be an ``(item_separator, key_separator)``
	 *     tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and
	 *     ``(',', ': ')`` otherwise.  To get the most compact JSON representation,
	 *     you should specify ``(',', ':')`` to eliminate whitespace.
	 * 
	 *     ``default(obj)`` is a function that should return a serializable version
	 *     of obj or raise TypeError. The default simply raises TypeError.
	 * 
	 *     If *sort_keys* is true (default: ``False``), then the output of
	 *     dictionaries will be sorted by key.
	 * 
	 *     To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
	 *     ``.default()`` method to serialize additional types), specify it with
	 *     the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.
	 * 
	 *     
	 */
	function dump(obj, fp): Promise<any>
	function dump$({ obj, fp }): Promise<any>

	/**
	 * Serialize ``obj`` to a JSON formatted ``str``.
	 * 
	 *     If ``skipkeys`` is true then ``dict`` keys that are not basic types
	 *     (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped
	 *     instead of raising a ``TypeError``.
	 * 
	 *     If ``ensure_ascii`` is false, then the return value can contain non-ASCII
	 *     characters if they appear in strings contained in ``obj``. Otherwise, all
	 *     such characters are escaped in JSON strings.
	 * 
	 *     If ``check_circular`` is false, then the circular reference check
	 *     for container types will be skipped and a circular reference will
	 *     result in an ``OverflowError`` (or worse).
	 * 
	 *     If ``allow_nan`` is false, then it will be a ``ValueError`` to
	 *     serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in
	 *     strict compliance of the JSON specification, instead of using the
	 *     JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).
	 * 
	 *     If ``indent`` is a non-negative integer, then JSON array elements and
	 *     object members will be pretty-printed with that indent level. An indent
	 *     level of 0 will only insert newlines. ``None`` is the most compact
	 *     representation.
	 * 
	 *     If specified, ``separators`` should be an ``(item_separator, key_separator)``
	 *     tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and
	 *     ``(',', ': ')`` otherwise.  To get the most compact JSON representation,
	 *     you should specify ``(',', ':')`` to eliminate whitespace.
	 * 
	 *     ``default(obj)`` is a function that should return a serializable version
	 *     of obj or raise TypeError. The default simply raises TypeError.
	 * 
	 *     If *sort_keys* is true (default: ``False``), then the output of
	 *     dictionaries will be sorted by key.
	 * 
	 *     To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
	 *     ``.default()`` method to serialize additional types), specify it with
	 *     the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.
	 * 
	 *     
	 */
	function dumps(obj): Promise<any>
	function dumps$({ obj }): Promise<any>
	function detect_encoding(b): Promise<any>
	function detect_encoding$({ b }): Promise<any>

	/**
	 * Deserialize ``fp`` (a ``.read()``-supporting file-like object containing
	 *     a JSON document) to a Python object.
	 * 
	 *     ``object_hook`` is an optional function that will be called with the
	 *     result of any object literal decode (a ``dict``). The return value of
	 *     ``object_hook`` will be used instead of the ``dict``. This feature
	 *     can be used to implement custom decoders (e.g. JSON-RPC class hinting).
	 * 
	 *     ``object_pairs_hook`` is an optional function that will be called with the
	 *     result of any object literal decoded with an ordered list of pairs.  The
	 *     return value of ``object_pairs_hook`` will be used instead of the ``dict``.
	 *     This feature can be used to implement custom decoders.  If ``object_hook``
	 *     is also defined, the ``object_pairs_hook`` takes priority.
	 * 
	 *     To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``
	 *     kwarg; otherwise ``JSONDecoder`` is used.
	 *     
	 */
	function load(fp): Promise<any>
	function load$({ fp }): Promise<any>

	/**
	 * Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance
	 *     containing a JSON document) to a Python object.
	 * 
	 *     ``object_hook`` is an optional function that will be called with the
	 *     result of any object literal decode (a ``dict``). The return value of
	 *     ``object_hook`` will be used instead of the ``dict``. This feature
	 *     can be used to implement custom decoders (e.g. JSON-RPC class hinting).
	 * 
	 *     ``object_pairs_hook`` is an optional function that will be called with the
	 *     result of any object literal decoded with an ordered list of pairs.  The
	 *     return value of ``object_pairs_hook`` will be used instead of the ``dict``.
	 *     This feature can be used to implement custom decoders.  If ``object_hook``
	 *     is also defined, the ``object_pairs_hook`` takes priority.
	 * 
	 *     ``parse_float``, if specified, will be called with the string
	 *     of every JSON float to be decoded. By default this is equivalent to
	 *     float(num_str). This can be used to use another datatype or parser
	 *     for JSON floats (e.g. decimal.Decimal).
	 * 
	 *     ``parse_int``, if specified, will be called with the string
	 *     of every JSON int to be decoded. By default this is equivalent to
	 *     int(num_str). This can be used to use another datatype or parser
	 *     for JSON integers (e.g. float).
	 * 
	 *     ``parse_constant``, if specified, will be called with one of the
	 *     following strings: -Infinity, Infinity, NaN.
	 *     This can be used to raise an exception if invalid JSON numbers
	 *     are encountered.
	 * 
	 *     To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``
	 *     kwarg; otherwise ``JSONDecoder`` is used.
	 *     
	 */
	function loads(s): Promise<any>
	function loads$({ s }): Promise<any>
	module decoder {
		var _

		/**
		 * Scan the string s for a JSON string. End is the index of the
		 *     character in s after the quote that started the JSON string.
		 *     Unescapes all valid JSON string escape sequences and raises ValueError
		 *     on attempt to decode an invalid string. If strict is False then literal
		 *     control characters are allowed in the string.
		 * 
		 *     Returns a tuple of the decoded string and the index of the character in s
		 *     after the end quote.
		 */
		function py_scanstring(s, end, strict?: boolean, _b?, _m?): Promise<any>
		function py_scanstring$({ s, end, strict, _b, _m }: { s, end, strict?, _b?, _m?}): Promise<any>
		function JSONObject(s_and_end, strict, scan_once, object_hook, object_pairs_hook, memo?, _w?, _ws?): Promise<any>
		function JSONObject$({ s_and_end, strict, scan_once, object_hook, object_pairs_hook, memo, _w, _ws }: { s_and_end, strict, scan_once, object_hook, object_pairs_hook, memo?, _w?, _ws?}): Promise<any>
		function JSONArray(s_and_end, scan_once, _w?, _ws?): Promise<any>
		function JSONArray$({ s_and_end, scan_once, _w, _ws }: { s_and_end, scan_once, _w?, _ws?}): Promise<any>

		/**
		 * Subclass of ValueError with the following additional properties:
		 * 
		 *     msg: The unformatted error message
		 *     doc: The JSON document being parsed
		 *     pos: The start index of doc where parsing failed
		 *     lineno: The line corresponding to pos
		 *     colno: The column corresponding to pos
		 * 
		 *     
		 */
		function JSONDecodeError(msg, doc, pos): Promise<IJSONDecodeError>
		function JSONDecodeError$({ msg, doc, pos }): Promise<IJSONDecodeError>
		interface IJSONDecodeError {
		}

		/**
		 * Simple JSON <http://json.org> decoder
		 * 
		 *     Performs the following translations in decoding by default:
		 * 
		 *     +---------------+-------------------+
		 *     | JSON          | Python            |
		 *     +===============+===================+
		 *     | object        | dict              |
		 *     +---------------+-------------------+
		 *     | array         | list              |
		 *     +---------------+-------------------+
		 *     | string        | str               |
		 *     +---------------+-------------------+
		 *     | number (int)  | int               |
		 *     +---------------+-------------------+
		 *     | number (real) | float             |
		 *     +---------------+-------------------+
		 *     | true          | True              |
		 *     +---------------+-------------------+
		 *     | false         | False             |
		 *     +---------------+-------------------+
		 *     | null          | None              |
		 *     +---------------+-------------------+
		 * 
		 *     It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as
		 *     their corresponding ``float`` values, which is outside the JSON spec.
		 * 
		 *     
		 */

		/**
		 * ``object_hook``, if specified, will be called with the result
		 *         of every JSON object decoded and its return value will be used in
		 *         place of the given ``dict``.  This can be used to provide custom
		 *         deserializations (e.g. to support JSON-RPC class hinting).
		 * 
		 *         ``object_pairs_hook``, if specified will be called with the result of
		 *         every JSON object decoded with an ordered list of pairs.  The return
		 *         value of ``object_pairs_hook`` will be used instead of the ``dict``.
		 *         This feature can be used to implement custom decoders.
		 *         If ``object_hook`` is also defined, the ``object_pairs_hook`` takes
		 *         priority.
		 * 
		 *         ``parse_float``, if specified, will be called with the string
		 *         of every JSON float to be decoded. By default this is equivalent to
		 *         float(num_str). This can be used to use another datatype or parser
		 *         for JSON floats (e.g. decimal.Decimal).
		 * 
		 *         ``parse_int``, if specified, will be called with the string
		 *         of every JSON int to be decoded. By default this is equivalent to
		 *         int(num_str). This can be used to use another datatype or parser
		 *         for JSON integers (e.g. float).
		 * 
		 *         ``parse_constant``, if specified, will be called with one of the
		 *         following strings: -Infinity, Infinity, NaN.
		 *         This can be used to raise an exception if invalid JSON numbers
		 *         are encountered.
		 * 
		 *         If ``strict`` is false (true is the default), then control
		 *         characters will be allowed inside strings.  Control characters in
		 *         this context are those with character codes in the 0-31 range,
		 *         including ``'\t'`` (tab), ``'\n'``, ``'\r'`` and ``'\0'``.
		 *         
		 */
		function JSONDecoder(): Promise<IJSONDecoder>
		function JSONDecoder$({ }): Promise<IJSONDecoder>
		interface IJSONDecoder {

			/**
			 * Return the Python representation of ``s`` (a ``str`` instance
			 *         containing a JSON document).
			 * 
			 *         
			 */
			decode(s, _w?): Promise<any>
			decode$({ s, _w }: { s, _w?}): Promise<any>

			/**
			 * Decode a JSON document from ``s`` (a ``str`` beginning with
			 *         a JSON document) and return a 2-tuple of the Python
			 *         representation and the index in ``s`` where the document ended.
			 * 
			 *         This can be used to decode a JSON document from a string that may
			 *         have extraneous data at the end.
			 * 
			 *         
			 */
			raw_decode(s, idx?): Promise<any>
			raw_decode$({ s, idx }: { s, idx?}): Promise<any>
		}
		let FLAGS: Promise<any>
		let NaN: Promise<any>
		let PosInf: Promise<any>
		let NegInf: Promise<any>
		let STRINGCHUNK: Promise<any>
		let BACKSLASH: Promise<any>
		let scanstring: Promise<any>
		let WHITESPACE: Promise<any>
		let WHITESPACE_STR: Promise<any>
	}
	module encoder {
		var _

		/**
		 * Return a JSON representation of a Python string
		 * 
		 *     
		 */
		function py_encode_basestring(s): Promise<any>
		function py_encode_basestring$({ s }): Promise<any>

		/**
		 * Return an ASCII-only JSON representation of a Python string
		 * 
		 *     
		 */
		function py_encode_basestring_ascii(s): Promise<any>
		function py_encode_basestring_ascii$({ s }): Promise<any>

		/**
		 * Extensible JSON <http://json.org> encoder for Python data structures.
		 * 
		 *     Supports the following objects and types by default:
		 * 
		 *     +-------------------+---------------+
		 *     | Python            | JSON          |
		 *     +===================+===============+
		 *     | dict              | object        |
		 *     +-------------------+---------------+
		 *     | list, tuple       | array         |
		 *     +-------------------+---------------+
		 *     | str               | string        |
		 *     +-------------------+---------------+
		 *     | int, float        | number        |
		 *     +-------------------+---------------+
		 *     | True              | true          |
		 *     +-------------------+---------------+
		 *     | False             | false         |
		 *     +-------------------+---------------+
		 *     | None              | null          |
		 *     +-------------------+---------------+
		 * 
		 *     To extend this to recognize other objects, subclass and implement a
		 *     ``.default()`` method with another method that returns a serializable
		 *     object for ``o`` if possible, otherwise it should call the superclass
		 *     implementation (to raise ``TypeError``).
		 * 
		 *     
		 */

		/**
		 * Constructor for JSONEncoder, with sensible defaults.
		 * 
		 *         If skipkeys is false, then it is a TypeError to attempt
		 *         encoding of keys that are not str, int, float or None.  If
		 *         skipkeys is True, such items are simply skipped.
		 * 
		 *         If ensure_ascii is true, the output is guaranteed to be str
		 *         objects with all incoming non-ASCII characters escaped.  If
		 *         ensure_ascii is false, the output can contain non-ASCII characters.
		 * 
		 *         If check_circular is true, then lists, dicts, and custom encoded
		 *         objects will be checked for circular references during encoding to
		 *         prevent an infinite recursion (which would cause an OverflowError).
		 *         Otherwise, no such check takes place.
		 * 
		 *         If allow_nan is true, then NaN, Infinity, and -Infinity will be
		 *         encoded as such.  This behavior is not JSON specification compliant,
		 *         but is consistent with most JavaScript based encoders and decoders.
		 *         Otherwise, it will be a ValueError to encode such floats.
		 * 
		 *         If sort_keys is true, then the output of dictionaries will be
		 *         sorted by key; this is useful for regression tests to ensure
		 *         that JSON serializations can be compared on a day-to-day basis.
		 * 
		 *         If indent is a non-negative integer, then JSON array
		 *         elements and object members will be pretty-printed with that
		 *         indent level.  An indent level of 0 will only insert newlines.
		 *         None is the most compact representation.
		 * 
		 *         If specified, separators should be an (item_separator, key_separator)
		 *         tuple.  The default is (', ', ': ') if *indent* is ``None`` and
		 *         (',', ': ') otherwise.  To get the most compact JSON representation,
		 *         you should specify (',', ':') to eliminate whitespace.
		 * 
		 *         If specified, default is a function that gets called for objects
		 *         that can't otherwise be serialized.  It should return a JSON encodable
		 *         version of the object or raise a ``TypeError``.
		 * 
		 *         
		 */
		function JSONEncoder(): Promise<IJSONEncoder>
		function JSONEncoder$({ }): Promise<IJSONEncoder>
		interface IJSONEncoder {

			/**
			 * Implement this method in a subclass such that it returns
			 *         a serializable object for ``o``, or calls the base implementation
			 *         (to raise a ``TypeError``).
			 * 
			 *         For example, to support arbitrary iterators, you could
			 *         implement default like this::
			 * 
			 *             def default(self, o):
			 *                 try:
			 *                     iterable = iter(o)
			 *                 except TypeError:
			 *                     pass
			 *                 else:
			 *                     return list(iterable)
			 *                 # Let the base class default method raise the TypeError
			 *                 return JSONEncoder.default(self, o)
			 * 
			 *         
			 */
			default(o): Promise<any>
			default$({ o }): Promise<any>

			/**
			 * Return a JSON string representation of a Python data structure.
			 * 
			 *         >>> from json.encoder import JSONEncoder
			 *         >>> JSONEncoder().encode({"foo": ["bar", "baz"]})
			 *         '{"foo": ["bar", "baz"]}'
			 * 
			 *         
			 */
			encode(o): Promise<any>
			encode$({ o }): Promise<any>

			/**
			 * Encode the given object and yield each string
			 *         representation as available.
			 * 
			 *         For example::
			 * 
			 *             for chunk in JSONEncoder().iterencode(bigobject):
			 *                 mysocket.write(chunk)
			 * 
			 *         
			 */
			iterencode(o, _one_shot?: boolean): Promise<any>
			iterencode$({ o, _one_shot }: { o, _one_shot?}): Promise<any>
			item_separator
			key_separator
		}
		let ESCAPE: Promise<any>
		let ESCAPE_ASCII: Promise<any>
		let HAS_UTF8: Promise<any>
		let ESCAPE_DCT: Promise<any>
		let INFINITY: Promise<any>
		let encode_basestring: Promise<any>
		let encode_basestring_ascii: Promise<any>
	}
	module scanner {
		var _
		function py_make_scanner(context): Promise<any>
		function py_make_scanner$({ context }): Promise<any>
		let NUMBER_RE: Promise<any>
		let make_scanner: Promise<any>
	}
	module tool {
		var _
		function main(): Promise<any>
		function main$($: {}): Promise<any>
	}
}
declare module keyword {
	var _
	let kwlist: Promise<any>
	let softkwlist: Promise<any>
	let iskeyword: Promise<any>
	let issoftkeyword: Promise<any>
}
declare module lib2to3 {
	var _
	module __main__ {
		var _
	}
	module btm_matcher {
		var _
		function type_repr(type_num): Promise<any>
		function type_repr$({ type_num }): Promise<any>

		/**
		 * Class for a node of the Aho-Corasick automaton used in matching
		 */
		function BMNode(): Promise<IBMNode>
		function BMNode$({ }): Promise<IBMNode>
		interface IBMNode {
			count
		}

		/**
		 * The main matcher class. After instantiating the patterns should
		 *     be added using the add_fixer method
		 */
		function BottomMatcher(): Promise<IBottomMatcher>
		function BottomMatcher$({ }): Promise<IBottomMatcher>
		interface IBottomMatcher {

			/**
			 * Reduces a fixer's pattern tree to a linear path and adds it
			 *         to the matcher(a common Aho-Corasick automaton). The fixer is
			 *         appended on the matching states and called when they are
			 *         reached
			 */
			add_fixer(fixer): Promise<any>
			add_fixer$({ fixer }): Promise<any>

			/**
			 * Recursively adds a linear pattern to the AC automaton
			 */
			add(pattern, start): Promise<any>
			add$({ pattern, start }): Promise<any>

			/**
			 * The main interface with the bottom matcher. The tree is
			 *         traversed from the bottom using the constructed
			 *         automaton. Nodes are only checked once as the tree is
			 *         retraversed. When the automaton fails, we give it one more
			 *         shot(in case the above tree matches as a whole with the
			 *         rejected leaf), then we break for the next leaf. There is the
			 *         special case of multiple arguments(see code comments) where we
			 *         recheck the nodes
			 * 
			 *         Args:
			 *            The leaves of the AST tree to be matched
			 * 
			 *         Returns:
			 *            A dictionary of node matches with fixers as the keys
			 *         
			 */
			run(leaves): Promise<any>
			run$({ leaves }): Promise<any>

			/**
			 * Prints a graphviz diagram of the BM automaton(for debugging)
			 */
			print_ac(): Promise<any>
			print_ac$($: {}): Promise<any>
		}
	}
	module btm_utils {
		var _

		/**
		 * 
		 *     Internal function. Reduces a compiled pattern tree to an
		 *     intermediate representation suitable for feeding the
		 *     automaton. This also trims off any optional pattern elements(like
		 *     [a], a*).
		 *     
		 */
		function reduce_tree(node, parent?): Promise<any>
		function reduce_tree$({ node, parent }: { node, parent?}): Promise<any>

		/**
		 * Picks the most characteristic from a list of linear patterns
		 *     Current order used is:
		 *     names > common_names > common_chars
		 *     
		 */
		function get_characteristic_subpattern(subpatterns): Promise<any>
		function get_characteristic_subpattern$({ subpatterns }): Promise<any>

		/**
		 * Tests test_func on all items of sequence and items of included
		 *     sub-iterables
		 */
		function rec_test(sequence, test_func): Promise<any>
		function rec_test$({ sequence, test_func }): Promise<any>

		/**
		 * This class serves as an intermediate representation of the
		 *     pattern tree during the conversion to sets of leaf-to-root
		 *     subpatterns
		 */
		function MinNode(type?, name?): Promise<IMinNode>
		function MinNode$({ type, name }: { type?, name?}): Promise<IMinNode>
		interface IMinNode {

			/**
			 * Internal method. Returns a characteristic path of the
			 *         pattern tree. This method must be run for all leaves until the
			 *         linear subpatterns are merged into a single
			 */
			leaf_to_root(): Promise<any>
			leaf_to_root$($: {}): Promise<any>

			/**
			 * Drives the leaf_to_root method. The reason that
			 *         leaf_to_root must be run multiple times is because we need to
			 *         reject 'group' matches; for example the alternative form
			 *         (a | b c) creates a group [b c] that needs to be matched. Since
			 *         matching multiple linear patterns overcomes the automaton's
			 *         capabilities, leaf_to_root merges each group into a single
			 *         choice based on 'characteristic'ity,
			 * 
			 *         i.e. (a|b c) -> (a|b) if b more characteristic than c
			 * 
			 *         Returns: The most 'characteristic'(as defined by
			 *           get_characteristic_subpattern) path for the compiled pattern
			 *           tree.
			 *         
			 */
			get_linear_subpattern(): Promise<any>
			get_linear_subpattern$($: {}): Promise<any>

			/**
			 * Generator that returns the leaves of the tree
			 */
			leaves(): Promise<any>
			leaves$($: {}): Promise<any>
		}
		let syms: Promise<any>
		let pysyms: Promise<any>
		let tokens: Promise<any>
		let token_labels: Promise<any>
		let TYPE_ANY: Promise<any>
		let TYPE_ALTERNATIVES: Promise<any>
		let TYPE_GROUP: Promise<any>
	}
	module fixer_base {
		var _

		/**
		 * Optional base class for fixers.
		 * 
		 *     The subclass name must be FixFooBar where FooBar is the result of
		 *     removing underscores and capitalizing the words of the fix name.
		 *     For example, the class name for a fixer named 'has_key' should be
		 *     FixHasKey.
		 *     
		 */

		/**
		 * Initializer.  Subclass may override.
		 * 
		 *         Args:
		 *             options: a dict containing the options passed to RefactoringTool
		 *             that could be used to customize the fixer through the command line.
		 *             log: a list to append warnings and other messages to.
		 *         
		 */
		function BaseFix(options, log): Promise<IBaseFix>
		function BaseFix$({ options, log }): Promise<IBaseFix>
		interface IBaseFix {

			/**
			 * Compiles self.PATTERN into self.pattern.
			 * 
			 *         Subclass may override if it doesn't want to use
			 *         self.{pattern,PATTERN} in .match().
			 *         
			 */
			compile_pattern(): Promise<any>
			compile_pattern$($: {}): Promise<any>

			/**
			 * Set the filename.
			 * 
			 *         The main refactoring tool should call this.
			 *         
			 */
			set_filename(filename): Promise<any>
			set_filename$({ filename }): Promise<any>

			/**
			 * Returns match for a given parse tree node.
			 * 
			 *         Should return a true or false object (not necessarily a bool).
			 *         It may return a non-empty dict of matching sub-nodes as
			 *         returned by a matching pattern.
			 * 
			 *         Subclass may override.
			 *         
			 */
			match(node): Promise<any>
			match$({ node }): Promise<any>

			/**
			 * Returns the transformation for a given parse tree node.
			 * 
			 *         Args:
			 *           node: the root of the parse tree that matched the fixer.
			 *           results: a dict mapping symbolic names to part of the match.
			 * 
			 *         Returns:
			 *           None, or a node that is a modified copy of the
			 *           argument node.  The node argument may also be modified in-place to
			 *           effect the same change.
			 * 
			 *         Subclass *must* override.
			 *         
			 */
			transform(node, results): Promise<any>
			transform$({ node, results }): Promise<any>

			/**
			 * Return a string suitable for use as an identifier
			 * 
			 *         The new name is guaranteed not to conflict with other identifiers.
			 *         
			 */
			new_name(template?): Promise<any>
			new_name$({ template }: { template?}): Promise<any>
			log_message(message): Promise<any>
			log_message$({ message }): Promise<any>

			/**
			 * Warn the user that a given chunk of code is not valid Python 3,
			 *         but that it cannot be converted automatically.
			 * 
			 *         First argument is the top-level node for the code in question.
			 *         Optional second argument is why it can't be converted.
			 *         
			 */
			cannot_convert(node, reason?): Promise<any>
			cannot_convert$({ node, reason }: { node, reason?}): Promise<any>

			/**
			 * Used for warning the user about possible uncertainty in the
			 *         translation.
			 * 
			 *         First argument is the top-level node for the code in question.
			 *         Optional second argument is why it can't be converted.
			 *         
			 */
			warning(node, reason): Promise<any>
			warning$({ node, reason }): Promise<any>

			/**
			 * Some fixers need to maintain tree-wide state.
			 *         This method is called once, at the start of tree fix-up.
			 * 
			 *         tree - the root node of the tree to be processed.
			 *         filename - the name of the file the tree came from.
			 *         
			 */
			start_tree(tree, filename): Promise<any>
			start_tree$({ tree, filename }): Promise<any>

			/**
			 * Some fixers need to maintain tree-wide state.
			 *         This method is called once, at the conclusion of tree fix-up.
			 * 
			 *         tree - the root node of the tree to be processed.
			 *         filename - the name of the file the tree came from.
			 *         
			 */
			finish_tree(tree, filename): Promise<any>
			finish_tree$({ tree, filename }): Promise<any>
			PATTERN
			pattern
			pattern_tree
			options
			filename
			numbers
			used_names
			order
			explicit
			run_order
			keep_line_order
			BM_compatible
			syms
		}

		/**
		 *  Base class for fixers which not execute if an import is found. 
		 */
		interface IConditionalFix extends IBaseFix {
			start_tree(): Promise<any>
			start_tree$($: {}): Promise<any>
			should_skip(node): Promise<any>
			should_skip$({ node }): Promise<any>
			skip_on
		}
	}
	module fixer_util {
		var _
		function KeywordArg(keyword, value): Promise<any>
		function KeywordArg$({ keyword, value }): Promise<any>
		function LParen(): Promise<any>
		function LParen$($: {}): Promise<any>
		function RParen(): Promise<any>
		function RParen$($: {}): Promise<any>

		/**
		 * Build an assignment statement
		 */
		function Assign(target, source): Promise<any>
		function Assign$({ target, source }): Promise<any>

		/**
		 * Return a NAME leaf
		 */
		function Name(name, prefix?): Promise<any>
		function Name$({ name, prefix }: { name, prefix?}): Promise<any>

		/**
		 * A node tuple for obj.attr
		 */
		function Attr(obj, attr): Promise<any>
		function Attr$({ obj, attr }): Promise<any>

		/**
		 * A comma leaf
		 */
		function Comma(): Promise<any>
		function Comma$($: {}): Promise<any>

		/**
		 * A period (.) leaf
		 */
		function Dot(): Promise<any>
		function Dot$($: {}): Promise<any>

		/**
		 * A parenthesised argument list, used by Call()
		 */
		function ArgList(args, lparen?, rparen?): Promise<any>
		function ArgList$({ args, lparen, rparen }: { args, lparen?, rparen?}): Promise<any>

		/**
		 * A function call
		 */
		function Call(func_name, args?, prefix?): Promise<any>
		function Call$({ func_name, args, prefix }: { func_name, args?, prefix?}): Promise<any>

		/**
		 * A newline literal
		 */
		function Newline(): Promise<any>
		function Newline$($: {}): Promise<any>

		/**
		 * A blank line
		 */
		function BlankLine(): Promise<any>
		function BlankLine$($: {}): Promise<any>
		function Number(n, prefix?): Promise<any>
		function Number$({ n, prefix }: { n, prefix?}): Promise<any>

		/**
		 * A numeric or string subscript
		 */
		function Subscript(index_node): Promise<any>
		function Subscript$({ index_node }): Promise<any>

		/**
		 * A string leaf
		 */
		function String(string, prefix?): Promise<any>
		function String$({ string, prefix }: { string, prefix?}): Promise<any>

		/**
		 * A list comprehension of the form [xp for fp in it if test].
		 * 
		 *     If test is None, the "if test" part is omitted.
		 *     
		 */
		function ListComp(xp, fp, it, test?): Promise<any>
		function ListComp$({ xp, fp, it, test }: { xp, fp, it, test?}): Promise<any>

		/**
		 *  Return an import statement in the form:
		 *         from package import name_leafs
		 */
		function FromImport(package_name, name_leafs): Promise<any>
		function FromImport$({ package_name, name_leafs }): Promise<any>

		/**
		 * Returns an import statement and calls a method
		 *     of the module:
		 * 
		 *     import module
		 *     module.name()
		 */
		function ImportAndCall(node, results, names): Promise<any>
		function ImportAndCall$({ node, results, names }): Promise<any>

		/**
		 * Does the node represent a tuple literal?
		 */
		function is_tuple(node): Promise<any>
		function is_tuple$({ node }): Promise<any>

		/**
		 * Does the node represent a list literal?
		 */
		function is_list(node): Promise<any>
		function is_list$({ node }): Promise<any>
		function parenthesize(node): Promise<any>
		function parenthesize$({ node }): Promise<any>

		/**
		 * Follow an attribute chain.
		 * 
		 *     If you have a chain of objects where a.foo -> b, b.foo-> c, etc,
		 *     use this to iterate over all objects in the chain. Iteration is
		 *     terminated by getattr(x, attr) is None.
		 * 
		 *     Args:
		 *         obj: the starting object
		 *         attr: the name of the chaining attribute
		 * 
		 *     Yields:
		 *         Each successive object in the chain.
		 *     
		 */
		function attr_chain(obj, attr): Promise<any>
		function attr_chain$({ obj, attr }): Promise<any>

		/**
		 *  Returns true if node is in an environment where all that is required
		 *         of it is being iterable (ie, it doesn't matter if it returns a list
		 *         or an iterator).
		 *         See test_map_nochange in test_fixers.py for some examples and tests.
		 *         
		 */
		function in_special_context(node): Promise<any>
		function in_special_context$({ node }): Promise<any>

		/**
		 * 
		 *     Check that something isn't an attribute or function name etc.
		 *     
		 */
		function is_probably_builtin(node): Promise<any>
		function is_probably_builtin$({ node }): Promise<any>

		/**
		 * Find the indentation of *node*.
		 */
		function find_indentation(node): Promise<any>
		function find_indentation$({ node }): Promise<any>
		function make_suite(node): Promise<any>
		function make_suite$({ node }): Promise<any>

		/**
		 * Find the top level namespace.
		 */
		function find_root(node): Promise<any>
		function find_root$({ node }): Promise<any>

		/**
		 *  Returns true if name is imported from package at the
		 *         top level of the tree which node belongs to.
		 *         To cover the case of an import like 'import foo', use
		 *         None for the package and 'foo' for the name. 
		 */
		function does_tree_import(package, name, node): Promise<any>
		function does_tree_import$({ package, name, node }): Promise<any>

		/**
		 * Returns true if the node is an import statement.
		 */
		function is_import(node): Promise<any>
		function is_import$({ node }): Promise<any>

		/**
		 *  Works like `does_tree_import` but adds an import statement
		 *         if it was not imported. 
		 */
		function touch_import(package, name, node): Promise<any>
		function touch_import$({ package, name, node }): Promise<any>

		/**
		 *  Returns the node which binds variable name, otherwise None.
		 *         If optional argument package is supplied, only imports will
		 *         be returned.
		 *         See test cases for examples.
		 */
		function find_binding(name, node, package?): Promise<any>
		function find_binding$({ name, node, package }: { name, node, package?}): Promise<any>
		let consuming_calls: Promise<any>
		let p0: Promise<any>
		let p1: Promise<any>
		let p2: Promise<any>
		let pats_built: Promise<any>
	}
	module fixes {
		var _
		module fix_apply {
			var _
			interface IFixApply {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_asserts {
			var _
			interface IFixAsserts {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				PATTERN
			}
			let NAMES: Promise<any>
		}
		module fix_basestring {
			var _
			interface IFixBasestring {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_buffer {
			var _
			interface IFixBuffer {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				explicit
				PATTERN
			}
		}
		module fix_dict {
			var _
			interface IFixDict {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				in_special_context(node, isiter): Promise<any>
				in_special_context$({ node, isiter }): Promise<any>
				BM_compatible
				PATTERN
				P1
				p1
				P2
				p2
			}
			let iter_exempt: Promise<any>
		}
		module fix_except {
			var _
			function find_excepts(nodes): Promise<any>
			function find_excepts$({ nodes }): Promise<any>
			interface IFixExcept {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_exec {
			var _
			interface IFixExec {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_execfile {
			var _
			interface IFixExecfile {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_exitfunc {
			var _
			function FixExitfunc(): Promise<IFixExitfunc>
			function FixExitfunc$({ }): Promise<IFixExitfunc>
			interface IFixExitfunc {
				start_tree(tree, filename): Promise<any>
				start_tree$({ tree, filename }): Promise<any>
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				keep_line_order
				BM_compatible
				PATTERN
			}
		}
		module fix_filter {
			var _
			interface IFixFilter {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
				skip_on
			}
		}
		module fix_funcattrs {
			var _
			interface IFixFuncattrs {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_future {
			var _
			interface IFixFuture {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
				run_order
			}
		}
		module fix_getcwdu {
			var _
			interface IFixGetcwdu {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_has_key {
			var _
			interface IFixHasKey {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_idioms {
			var _
			interface IFixIdioms {
				match(node): Promise<any>
				match$({ node }): Promise<any>
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				transform_isinstance(node, results): Promise<any>
				transform_isinstance$({ node, results }): Promise<any>
				transform_while(node, results): Promise<any>
				transform_while$({ node, results }): Promise<any>
				transform_sort(node, results): Promise<any>
				transform_sort$({ node, results }): Promise<any>
				explicit
				PATTERN
			}
			let CMP: Promise<any>
			let TYPE: Promise<any>
		}
		module fix_import {
			var _

			/**
			 * 
			 *     Walks over all the names imported in a dotted_as_names node.
			 *     
			 */
			function traverse_imports(names): Promise<any>
			function traverse_imports$({ names }): Promise<any>
			interface IFixImport {
				start_tree(tree, name): Promise<any>
				start_tree$({ tree, name }): Promise<any>
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				probably_a_local_import(imp_name): Promise<any>
				probably_a_local_import$({ imp_name }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_imports {
			var _
			function alternates(members): Promise<any>
			function alternates$({ members }): Promise<any>
			function build_pattern(mapping?): Promise<any>
			function build_pattern$({ mapping }: { mapping?}): Promise<any>
			interface IFixImports {
				build_pattern(): Promise<any>
				build_pattern$($: {}): Promise<any>
				compile_pattern(): Promise<any>
				compile_pattern$($: {}): Promise<any>
				match(node): Promise<any>
				match$({ node }): Promise<any>
				start_tree(tree, filename): Promise<any>
				start_tree$({ tree, filename }): Promise<any>
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				keep_line_order
				mapping
				run_order
			}
			let MAPPING: Promise<any>
		}
		module fix_imports2 {
			var _
			interface IFixImports2 {
				run_order
				mapping
			}
			let MAPPING: Promise<any>
		}
		module fix_input {
			var _
			interface IFixInput {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
			let context: Promise<any>
		}
		module fix_intern {
			var _
			interface IFixIntern {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				order
				PATTERN
			}
		}
		module fix_isinstance {
			var _
			interface IFixIsinstance {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
				run_order
			}
		}
		module fix_itertools {
			var _
			interface IFixItertools {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				it_funcs
				PATTERN
				run_order
			}
		}
		module fix_itertools_imports {
			var _
			interface IFixItertoolsImports {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_long {
			var _
			interface IFixLong {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_map {
			var _
			interface IFixMap {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
				skip_on
			}
		}
		module fix_metaclass {
			var _

			/**
			 *  we have to check the cls_node without changing it.
			 *         There are two possibilities:
			 *           1)  clsdef => suite => simple_stmt => expr_stmt => Leaf('__meta')
			 *           2)  clsdef => simple_stmt => expr_stmt => Leaf('__meta')
			 *     
			 */
			function has_metaclass(parent): Promise<any>
			function has_metaclass$({ parent }): Promise<any>

			/**
			 *  one-line classes don't get a suite in the parse tree so we add
			 *         one to normalize the tree
			 *     
			 */
			function fixup_parse_tree(cls_node): Promise<any>
			function fixup_parse_tree$({ cls_node }): Promise<any>

			/**
			 *  if there is a semi-colon all the parts count as part of the same
			 *         simple_stmt.  We just want the __metaclass__ part so we move
			 *         everything after the semi-colon into its own simple_stmt node
			 *     
			 */
			function fixup_simple_stmt(parent, i, stmt_node): Promise<any>
			function fixup_simple_stmt$({ parent, i, stmt_node }): Promise<any>
			function remove_trailing_newline(node): Promise<any>
			function remove_trailing_newline$({ node }): Promise<any>
			function find_metas(cls_node): Promise<any>
			function find_metas$({ cls_node }): Promise<any>

			/**
			 *  If an INDENT is followed by a thing with a prefix then nuke the prefix
			 *         Otherwise we get in trouble when removing __metaclass__ at suite start
			 *     
			 */
			function fixup_indent(suite): Promise<any>
			function fixup_indent$({ suite }): Promise<any>
			interface IFixMetaclass {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_methodattrs {
			var _
			interface IFixMethodattrs {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
			let MAP: Promise<any>
		}
		module fix_ne {
			var _
			interface IFixNe {
				match(node): Promise<any>
				match$({ node }): Promise<any>
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
			}
		}
		module fix_next {
			var _
			function is_assign_target(node): Promise<any>
			function is_assign_target$({ node }): Promise<any>
			function find_assign(node): Promise<any>
			function find_assign$({ node }): Promise<any>
			function is_subtree(root, node): Promise<any>
			function is_subtree$({ root, node }): Promise<any>
			interface IFixNext {
				start_tree(tree, filename): Promise<any>
				start_tree$({ tree, filename }): Promise<any>
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
				order
			}
			let bind_warning: Promise<any>
		}
		module fix_nonzero {
			var _
			interface IFixNonzero {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_numliterals {
			var _
			interface IFixNumliterals {
				match(node): Promise<any>
				match$({ node }): Promise<any>
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
			}
		}
		module fix_operator {
			var _
			function invocation(s): Promise<any>
			function invocation$({ s }): Promise<any>
			interface IFixOperator {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				order
				methods
				obj
				PATTERN
			}
		}
		module fix_paren {
			var _
			interface IFixParen {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_print {
			var _
			interface IFixPrint {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				add_kwarg(l_nodes, s_kwd, n_expr): Promise<any>
				add_kwarg$({ l_nodes, s_kwd, n_expr }): Promise<any>
				BM_compatible
				PATTERN
			}
			let parend_expr: Promise<any>
		}
		module fix_raise {
			var _
			interface IFixRaise {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_raw_input {
			var _
			interface IFixRawInput {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_reduce {
			var _
			interface IFixReduce {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				order
				PATTERN
			}
		}
		module fix_reload {
			var _
			interface IFixReload {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				order
				PATTERN
			}
		}
		module fix_renames {
			var _
			function alternates(members): Promise<any>
			function alternates$({ members }): Promise<any>
			function build_pattern(): Promise<any>
			function build_pattern$($: {}): Promise<any>
			interface IFixRenames {
				match(node): Promise<any>
				match$({ node }): Promise<any>
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
				order
			}
			let MAPPING: Promise<any>
			let LOOKUP: Promise<any>
		}
		module fix_repr {
			var _
			interface IFixRepr {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_set_literal {
			var _
			interface IFixSetLiteral {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				explicit
				PATTERN
			}
		}
		module fix_standarderror {
			var _
			interface IFixStandarderror {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_sys_exc {
			var _
			interface IFixSysExc {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				exc_info
				BM_compatible
				PATTERN
			}
		}
		module fix_throw {
			var _
			interface IFixThrow {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_tuple_params {
			var _
			function is_docstring(stmt): Promise<any>
			function is_docstring$({ stmt }): Promise<any>
			function simplify_args(node): Promise<any>
			function simplify_args$({ node }): Promise<any>
			function find_params(node): Promise<any>
			function find_params$({ node }): Promise<any>
			function map_to_index(param_list, prefix?, d?): Promise<any>
			function map_to_index$({ param_list, prefix, d }: { param_list, prefix?, d?}): Promise<any>
			function tuple_name(param_list): Promise<any>
			function tuple_name$({ param_list }): Promise<any>
			interface IFixTupleParams {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				transform_lambda(node, results): Promise<any>
				transform_lambda$({ node, results }): Promise<any>
				run_order
				BM_compatible
				PATTERN
			}
		}
		module fix_types {
			var _
			interface IFixTypes {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_unicode {
			var _
			interface IFixUnicode {
				start_tree(tree, filename): Promise<any>
				start_tree$({ tree, filename }): Promise<any>
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_urllib {
			var _
			function build_pattern(): Promise<any>
			function build_pattern$($: {}): Promise<any>
			interface IFixUrllib {
				build_pattern(): Promise<any>
				build_pattern$($: {}): Promise<any>

				/**
				 * Transform for the basic import case. Replaces the old
				 *            import name with a comma separated list of its
				 *            replacements.
				 *         
				 */
				transform_import(node, results): Promise<any>
				transform_import$({ node, results }): Promise<any>

				/**
				 * Transform for imports of specific module elements. Replaces
				 *            the module to be imported from with the appropriate new
				 *            module.
				 *         
				 */
				transform_member(node, results): Promise<any>
				transform_member$({ node, results }): Promise<any>

				/**
				 * Transform for calls to module members in code.
				 */
				transform_dot(node, results): Promise<any>
				transform_dot$({ node, results }): Promise<any>
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
			}
			let MAPPING: Promise<any>
		}
		module fix_ws_comma {
			var _
			interface IFixWsComma {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				explicit
				PATTERN
				COMMA
				COLON
				SEPS
			}
		}
		module fix_xrange {
			var _
			interface IFixXrange {
				start_tree(tree, filename): Promise<any>
				start_tree$({ tree, filename }): Promise<any>
				finish_tree(tree, filename): Promise<any>
				finish_tree$({ tree, filename }): Promise<any>
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				transform_xrange(node, results): Promise<any>
				transform_xrange$({ node, results }): Promise<any>
				transform_range(node, results): Promise<any>
				transform_range$({ node, results }): Promise<any>
				in_special_context(node): Promise<any>
				in_special_context$({ node }): Promise<any>
				BM_compatible
				PATTERN
				P1
				p1
				P2
				p2
			}
		}
		module fix_xreadlines {
			var _
			interface IFixXreadlines {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
			}
		}
		module fix_zip {
			var _
			interface IFixZip {
				transform(node, results): Promise<any>
				transform$({ node, results }): Promise<any>
				BM_compatible
				PATTERN
				skip_on
			}
		}
	}
	module main {
		var _

		/**
		 * Return a unified diff of two strings.
		 */
		function diff_texts(a, b, filename): Promise<any>
		function diff_texts$({ a, b, filename }): Promise<any>
		function warn(msg): Promise<any>
		function warn$({ msg }): Promise<any>

		/**
		 * Main program.
		 * 
		 *     Args:
		 *         fixer_pkg: the name of a package where the fixers are located.
		 *         args: optional; a list of command line arguments. If omitted,
		 *               sys.argv[1:] is used.
		 * 
		 *     Returns a suggested exit status (0, 1, 2).
		 *     
		 */
		function main(fixer_pkg, args?): Promise<any>
		function main$({ fixer_pkg, args }: { fixer_pkg, args?}): Promise<any>

		/**
		 * 
		 *     A refactoring tool that can avoid overwriting its input files.
		 *     Prints output to stdout.
		 * 
		 *     Output files can optionally be written to a different directory and or
		 *     have an extra file suffix appended to their name for use in situations
		 *     where you do not want to replace the input files.
		 *     
		 */

		/**
		 * 
		 *         Args:
		 *             fixers: A list of fixers to import.
		 *             options: A dict with RefactoringTool configuration.
		 *             explicit: A list of fixers to run even if they are explicit.
		 *             nobackups: If true no backup '.bak' files will be created for those
		 *                 files that are being refactored.
		 *             show_diffs: Should diffs of the refactoring be printed to stdout?
		 *             input_base_dir: The base directory for all input files.  This class
		 *                 will strip this path prefix off of filenames before substituting
		 *                 it with output_dir.  Only meaningful if output_dir is supplied.
		 *                 All files processed by refactor() must start with this path.
		 *             output_dir: If supplied, all converted files will be written into
		 *                 this directory tree instead of input_base_dir.
		 *             append_suffix: If supplied, all files output by this tool will have
		 *                 this appended to their filename.  Useful for changing .py to
		 *                 .py3 for example by passing append_suffix='3'.
		 *         
		 */
		function StdoutRefactoringTool(fixers, options, explicit, nobackups, show_diffs, input_base_dir?, output_dir?, append_suffix?): Promise<IStdoutRefactoringTool>
		function StdoutRefactoringTool$({ fixers, options, explicit, nobackups, show_diffs, input_base_dir, output_dir, append_suffix }: { fixers, options, explicit, nobackups, show_diffs, input_base_dir?, output_dir?, append_suffix?}): Promise<IStdoutRefactoringTool>
		interface IStdoutRefactoringTool {
			log_error(msg): Promise<any>
			log_error$({ msg }): Promise<any>
			write_file(new_text, filename, old_text, encoding): Promise<any>
			write_file$({ new_text, filename, old_text, encoding }): Promise<any>
			print_output(old, New, filename, equal): Promise<any>
			print_output$({ old, New, filename, equal }): Promise<any>
		}
	}
	module patcomp {
		var _

		/**
		 * Tokenizes a string suppressing significant whitespace.
		 */
		function tokenize_wrapper(input): Promise<any>
		function tokenize_wrapper$({ input }): Promise<any>

		/**
		 * Converts raw node information to a Node or Leaf instance.
		 */
		function pattern_convert(grammar, raw_node_info): Promise<any>
		function pattern_convert$({ grammar, raw_node_info }): Promise<any>
		function compile_pattern(pattern): Promise<any>
		function compile_pattern$({ pattern }): Promise<any>
		interface IPatternSyntaxError {
		}

		/**
		 * Initializer.
		 * 
		 *         Takes an optional alternative filename for the pattern grammar.
		 *         
		 */
		function PatternCompiler(grammar_file?): Promise<IPatternCompiler>
		function PatternCompiler$({ grammar_file }: { grammar_file?}): Promise<IPatternCompiler>
		interface IPatternCompiler {

			/**
			 * Compiles a pattern string to a nested pytree.*Pattern object.
			 */
			compile_pattern(input, debug?: boolean, with_tree?: boolean): Promise<any>
			compile_pattern$({ input, debug, with_tree }: { input, debug?, with_tree?}): Promise<any>

			/**
			 * Compiles a node, recursively.
			 * 
			 *         This is one big switch on the node type.
			 *         
			 */
			compile_node(node): Promise<any>
			compile_node$({ node }): Promise<any>
			compile_basic(nodes, repeat?): Promise<any>
			compile_basic$({ nodes, repeat }: { nodes, repeat?}): Promise<any>
			get_int(node): Promise<any>
			get_int$({ node }): Promise<any>
		}
		let TOKEN_MAP: Promise<any>
	}
	module pgen2 {
		var _
		module conv {
			var _

			/**
			 * Grammar subclass that reads classic pgen output files.
			 * 
			 *     The run() method reads the tables as produced by the pgen parser
			 *     generator, typically contained in two C files, graminit.h and
			 *     graminit.c.  The other methods are for internal use only.
			 * 
			 *     See the base class for more documentation.
			 * 
			 *     
			 */
			interface IConverter {

				/**
				 * Load the grammar tables from the text files written by pgen.
				 */
				run(graminit_h, graminit_c): Promise<any>
				run$({ graminit_h, graminit_c }): Promise<any>

				/**
				 * Parse the .h file written by pgen.  (Internal)
				 * 
				 *         This file is a sequence of #define statements defining the
				 *         nonterminals of the grammar as numbers.  We build two tables
				 *         mapping the numbers to names and back.
				 * 
				 *         
				 */
				parse_graminit_h(filename): Promise<any>
				parse_graminit_h$({ filename }): Promise<any>

				/**
				 * Parse the .c file written by pgen.  (Internal)
				 * 
				 *         The file looks as follows.  The first two lines are always this:
				 * 
				 *         #include "pgenheaders.h"
				 *         #include "grammar.h"
				 * 
				 *         After that come four blocks:
				 * 
				 *         1) one or more state definitions
				 *         2) a table defining dfas
				 *         3) a table defining labels
				 *         4) a struct defining the grammar
				 * 
				 *         A state definition has the following form:
				 *         - one or more arc arrays, each of the form:
				 *           static arc arcs_<n>_<m>[<k>] = {
				 *                   {<i>, <j>},
				 *                   ...
				 *           };
				 *         - followed by a state array, of the form:
				 *           static state states_<s>[<t>] = {
				 *                   {<k>, arcs_<n>_<m>},
				 *                   ...
				 *           };
				 * 
				 *         
				 */
				parse_graminit_c(filename): Promise<any>
				parse_graminit_c$({ filename }): Promise<any>

				/**
				 * Create additional useful structures.  (Internal).
				 */
				finish_off(): Promise<any>
				finish_off$($: {}): Promise<any>
			}
		}
		module driver {
			var _

			/**
			 * Load the grammar (maybe from a pickle).
			 */
			function load_grammar(gt?, gp?, save?: boolean, force?: boolean, logger?): Promise<any>
			function load_grammar$({ gt, gp, save, force, logger }: { gt?, gp?, save?, force?, logger?}): Promise<any>

			/**
			 * Normally, loads a pickled grammar by doing
			 *         pkgutil.get_data(package, pickled_grammar)
			 *     where *pickled_grammar* is computed from *grammar_source* by adding the
			 *     Python version and using a ``.pickle`` extension.
			 * 
			 *     However, if *grammar_source* is an extant file, load_grammar(grammar_source)
			 *     is called instead. This facilitates using a packaged grammar file when needed
			 *     but preserves load_grammar's automatic regeneration behavior when possible.
			 * 
			 *     
			 */
			function load_packaged_grammar(package, grammar_source): Promise<any>
			function load_packaged_grammar$({ package, grammar_source }): Promise<any>

			/**
			 * Main program, when run as a script: produce grammar pickle files.
			 * 
			 *     Calls load_grammar for each argument, a path to a grammar text file.
			 *     
			 */
			function main(): Promise<any>
			function main$($: {}): Promise<any>
			function Driver(grammar, convert?, logger?): Promise<IDriver>
			function Driver$({ grammar, convert, logger }: { grammar, convert?, logger?}): Promise<IDriver>
			interface IDriver {

				/**
				 * Parse a series of tokens and return the syntax tree.
				 */
				parse_tokens(tokens, debug?: boolean): Promise<any>
				parse_tokens$({ tokens, debug }: { tokens, debug?}): Promise<any>

				/**
				 * Parse a stream and return the syntax tree.
				 */
				parse_stream_raw(stream, debug?: boolean): Promise<any>
				parse_stream_raw$({ stream, debug }: { stream, debug?}): Promise<any>

				/**
				 * Parse a stream and return the syntax tree.
				 */
				parse_stream(stream, debug?: boolean): Promise<any>
				parse_stream$({ stream, debug }: { stream, debug?}): Promise<any>

				/**
				 * Parse a file and return the syntax tree.
				 */
				parse_file(filename, encoding?, debug?: boolean): Promise<any>
				parse_file$({ filename, encoding, debug }: { filename, encoding?, debug?}): Promise<any>

				/**
				 * Parse a string and return the syntax tree.
				 */
				parse_string(text, debug?: boolean): Promise<any>
				parse_string$({ text, debug }: { text, debug?}): Promise<any>
			}
		}
		module grammar {
			var _

			/**
			 * Pgen parsing tables conversion class.
			 * 
			 *     Once initialized, this class supplies the grammar tables for the
			 *     parsing engine implemented by parse.py.  The parsing engine
			 *     accesses the instance variables directly.  The class here does not
			 *     provide initialization of the tables; several subclasses exist to
			 *     do this (see the conv and pgen modules).
			 * 
			 *     The load() method reads the tables from a pickle file, which is
			 *     much faster than the other ways offered by subclasses.  The pickle
			 *     file is written by calling dump() (after loading the grammar
			 *     tables using a subclass).  The report() method prints a readable
			 *     representation of the tables to stdout, for debugging.
			 * 
			 *     The instance variables are as follows:
			 * 
			 *     symbol2number -- a dict mapping symbol names to numbers.  Symbol
			 *                      numbers are always 256 or higher, to distinguish
			 *                      them from token numbers, which are between 0 and
			 *                      255 (inclusive).
			 * 
			 *     number2symbol -- a dict mapping numbers to symbol names;
			 *                      these two are each other's inverse.
			 * 
			 *     states        -- a list of DFAs, where each DFA is a list of
			 *                      states, each state is a list of arcs, and each
			 *                      arc is a (i, j) pair where i is a label and j is
			 *                      a state number.  The DFA number is the index into
			 *                      this list.  (This name is slightly confusing.)
			 *                      Final states are represented by a special arc of
			 *                      the form (0, j) where j is its own state number.
			 * 
			 *     dfas          -- a dict mapping symbol numbers to (DFA, first)
			 *                      pairs, where DFA is an item from the states list
			 *                      above, and first is a set of tokens that can
			 *                      begin this grammar rule (represented by a dict
			 *                      whose values are always 1).
			 * 
			 *     labels        -- a list of (x, y) pairs where x is either a token
			 *                      number or a symbol number, and y is either None
			 *                      or a string; the strings are keywords.  The label
			 *                      number is the index in this list; label numbers
			 *                      are used to mark state transitions (arcs) in the
			 *                      DFAs.
			 * 
			 *     start         -- the number of the grammar's start symbol.
			 * 
			 *     keywords      -- a dict mapping keyword strings to arc labels.
			 * 
			 *     tokens        -- a dict mapping token numbers to arc labels.
			 * 
			 *     
			 */
			function Grammar(): Promise<IGrammar>
			function Grammar$({ }): Promise<IGrammar>
			interface IGrammar {

				/**
				 * Dump the grammar tables to a pickle file.
				 */
				dump(filename): Promise<any>
				dump$({ filename }): Promise<any>

				/**
				 * Load the grammar tables from a pickle file.
				 */
				load(filename): Promise<any>
				load$({ filename }): Promise<any>

				/**
				 * Load the grammar tables from a pickle bytes object.
				 */
				loads(pkl): Promise<any>
				loads$({ pkl }): Promise<any>

				/**
				 * 
				 *         Copy the grammar.
				 *         
				 */
				copy(): Promise<any>
				copy$($: {}): Promise<any>

				/**
				 * Dump the grammar tables to standard output, for debugging.
				 */
				report(): Promise<any>
				report$($: {}): Promise<any>
			}
			let opmap_raw: Promise<any>
			let opmap: Promise<any>
		}
		module literals {
			var _
			function escape(m): Promise<any>
			function escape$({ m }): Promise<any>
			function evalString(s): Promise<any>
			function evalString$({ s }): Promise<any>
			function test(): Promise<any>
			function test$($: {}): Promise<any>
			let simple_escapes: Promise<any>
		}
		module parse {
			var _

			/**
			 * Exception to signal the parser is stuck.
			 */
			function ParseError(msg, type, value, context): Promise<IParseError>
			function ParseError$({ msg, type, value, context }): Promise<IParseError>
			interface IParseError {
			}

			/**
			 * Parser engine.
			 * 
			 *     The proper usage sequence is:
			 * 
			 *     p = Parser(grammar, [converter])  # create instance
			 *     p.setup([start])                  # prepare for parsing
			 *     <for each input token>:
			 *         if p.addtoken(...):           # parse a token; may raise ParseError
			 *             break
			 *     root = p.rootnode                 # root of abstract syntax tree
			 * 
			 *     A Parser instance may be reused by calling setup() repeatedly.
			 * 
			 *     A Parser instance contains state pertaining to the current token
			 *     sequence, and should not be used concurrently by different threads
			 *     to parse separate token sequences.
			 * 
			 *     See driver.py for how to get input tokens by tokenizing a file or
			 *     string.
			 * 
			 *     Parsing is complete when addtoken() returns True; the root of the
			 *     abstract syntax tree can then be retrieved from the rootnode
			 *     instance variable.  When a syntax error occurs, addtoken() raises
			 *     the ParseError exception.  There is no error recovery; the parser
			 *     cannot be used after a syntax error was reported (but it can be
			 *     reinitialized by calling setup()).
			 * 
			 *     
			 */

			/**
			 * Constructor.
			 * 
			 *         The grammar argument is a grammar.Grammar instance; see the
			 *         grammar module for more information.
			 * 
			 *         The parser is not ready yet for parsing; you must call the
			 *         setup() method to get it started.
			 * 
			 *         The optional convert argument is a function mapping concrete
			 *         syntax tree nodes to abstract syntax tree nodes.  If not
			 *         given, no conversion is done and the syntax tree produced is
			 *         the concrete syntax tree.  If given, it must be a function of
			 *         two arguments, the first being the grammar (a grammar.Grammar
			 *         instance), and the second being the concrete syntax tree node
			 *         to be converted.  The syntax tree is converted from the bottom
			 *         up.
			 * 
			 *         A concrete syntax tree node is a (type, value, context, nodes)
			 *         tuple, where type is the node type (a token or symbol number),
			 *         value is None for symbols and a string for tokens, context is
			 *         None or an opaque value used for error reporting (typically a
			 *         (lineno, offset) pair), and nodes is a list of children for
			 *         symbols, and None for tokens.
			 * 
			 *         An abstract syntax tree node may be anything; this is entirely
			 *         up to the converter function.
			 * 
			 *         
			 */
			function Parser(grammar, convert?): Promise<IParser>
			function Parser$({ grammar, convert }: { grammar, convert?}): Promise<IParser>
			interface IParser {

				/**
				 * Prepare for parsing.
				 * 
				 *         This *must* be called before starting to parse.
				 * 
				 *         The optional argument is an alternative start symbol; it
				 *         defaults to the grammar's start symbol.
				 * 
				 *         You can use a Parser instance to parse any number of programs;
				 *         each time you call setup() the parser is reset to an initial
				 *         state determined by the (implicit or explicit) start symbol.
				 * 
				 *         
				 */
				setup(start?): Promise<any>
				setup$({ start }: { start?}): Promise<any>

				/**
				 * Add a token; return True iff this is the end of the program.
				 */
				addtoken(type, value, context): Promise<any>
				addtoken$({ type, value, context }): Promise<any>

				/**
				 * Turn a token into a label.  (Internal)
				 */
				classify(type, value, context): Promise<any>
				classify$({ type, value, context }): Promise<any>

				/**
				 * Shift a token.  (Internal)
				 */
				shift(type, value, newstate, context): Promise<any>
				shift$({ type, value, newstate, context }): Promise<any>

				/**
				 * Push a nonterminal.  (Internal)
				 */
				push(type, newdfa, newstate, context): Promise<any>
				push$({ type, newdfa, newstate, context }): Promise<any>

				/**
				 * Pop a nonterminal.  (Internal)
				 */
				pop(): Promise<any>
				pop$($: {}): Promise<any>
			}
		}
		module pgen {
			var _
			function generate_grammar(filename?): Promise<any>
			function generate_grammar$({ filename }: { filename?}): Promise<any>
			interface IPgenGrammar {
			}
			function ParserGenerator(filename, stream?): Promise<IParserGenerator>
			function ParserGenerator$({ filename, stream }: { filename, stream?}): Promise<IParserGenerator>
			interface IParserGenerator {
				make_grammar(): Promise<any>
				make_grammar$($: {}): Promise<any>
				make_first(c, name): Promise<any>
				make_first$({ c, name }): Promise<any>
				make_label(c, label): Promise<any>
				make_label$({ c, label }): Promise<any>
				addfirstsets(): Promise<any>
				addfirstsets$($: {}): Promise<any>
				calcfirst(name): Promise<any>
				calcfirst$({ name }): Promise<any>
				parse(): Promise<any>
				parse$($: {}): Promise<any>
				make_dfa(start, finish): Promise<any>
				make_dfa$({ start, finish }): Promise<any>
				dump_nfa(name, start, finish): Promise<any>
				dump_nfa$({ name, start, finish }): Promise<any>
				dump_dfa(name, dfa): Promise<any>
				dump_dfa$({ name, dfa }): Promise<any>
				simplify_dfa(dfa): Promise<any>
				simplify_dfa$({ dfa }): Promise<any>
				parse_rhs(): Promise<any>
				parse_rhs$($: {}): Promise<any>
				parse_alt(): Promise<any>
				parse_alt$($: {}): Promise<any>
				parse_item(): Promise<any>
				parse_item$($: {}): Promise<any>
				parse_atom(): Promise<any>
				parse_atom$($: {}): Promise<any>
				expect(type, value?): Promise<any>
				expect$({ type, value }: { type, value?}): Promise<any>
				gettoken(): Promise<any>
				gettoken$($: {}): Promise<any>
				raise_error(msg): Promise<any>
				raise_error$({ msg }): Promise<any>
			}
			function NFAState(): Promise<INFAState>
			function NFAState$({ }): Promise<INFAState>
			interface INFAState {
				addarc(next, label?): Promise<any>
				addarc$({ next, label }: { next, label?}): Promise<any>
			}
			function DFAState(nfaset, final): Promise<IDFAState>
			function DFAState$({ nfaset, final }): Promise<IDFAState>
			interface IDFAState {
				addarc(next, label): Promise<any>
				addarc$({ next, label }): Promise<any>
				unifystate(old, New): Promise<any>
				unifystate$({ old, New }): Promise<any>
			}
		}
		module token {
			var _
			function ISTERMINAL(x): Promise<any>
			function ISTERMINAL$({ x }): Promise<any>
			function ISNONTERMINAL(x): Promise<any>
			function ISNONTERMINAL$({ x }): Promise<any>
			function ISEOF(x): Promise<any>
			function ISEOF$({ x }): Promise<any>
			let ENDMARKER: Promise<any>
			let NAME: Promise<any>
			let NUMBER: Promise<any>
			let STRING: Promise<any>
			let NEWLINE: Promise<any>
			let INDENT: Promise<any>
			let DEDENT: Promise<any>
			let LPAR: Promise<any>
			let RPAR: Promise<any>
			let LSQB: Promise<any>
			let RSQB: Promise<any>
			let COLON: Promise<any>
			let COMMA: Promise<any>
			let SEMI: Promise<any>
			let PLUS: Promise<any>
			let MINUS: Promise<any>
			let STAR: Promise<any>
			let SLASH: Promise<any>
			let VBAR: Promise<any>
			let AMPER: Promise<any>
			let LESS: Promise<any>
			let GREATER: Promise<any>
			let EQUAL: Promise<any>
			let DOT: Promise<any>
			let PERCENT: Promise<any>
			let BACKQUOTE: Promise<any>
			let LBRACE: Promise<any>
			let RBRACE: Promise<any>
			let EQEQUAL: Promise<any>
			let NOTEQUAL: Promise<any>
			let LESSEQUAL: Promise<any>
			let GREATEREQUAL: Promise<any>
			let TILDE: Promise<any>
			let CIRCUMFLEX: Promise<any>
			let LEFTSHIFT: Promise<any>
			let RIGHTSHIFT: Promise<any>
			let DOUBLESTAR: Promise<any>
			let PLUSEQUAL: Promise<any>
			let MINEQUAL: Promise<any>
			let STAREQUAL: Promise<any>
			let SLASHEQUAL: Promise<any>
			let PERCENTEQUAL: Promise<any>
			let AMPEREQUAL: Promise<any>
			let VBAREQUAL: Promise<any>
			let CIRCUMFLEXEQUAL: Promise<any>
			let LEFTSHIFTEQUAL: Promise<any>
			let RIGHTSHIFTEQUAL: Promise<any>
			let DOUBLESTAREQUAL: Promise<any>
			let DOUBLESLASH: Promise<any>
			let DOUBLESLASHEQUAL: Promise<any>
			let AT: Promise<any>
			let ATEQUAL: Promise<any>
			let OP: Promise<any>
			let COMMENT: Promise<any>
			let NL: Promise<any>
			let RARROW: Promise<any>
			let AWAIT: Promise<any>
			let ASYNC: Promise<any>
			let ERRORTOKEN: Promise<any>
			let COLONEQUAL: Promise<any>
			let N_TOKENS: Promise<any>
			let NT_OFFSET: Promise<any>
			let tok_name: Promise<any>
		}
		module tokenize {
			var _
			function group(): Promise<any>
			function group$($: {}): Promise<any>
			function any(): Promise<any>
			function any$($: {}): Promise<any>
			function maybe(): Promise<any>
			function maybe$($: {}): Promise<any>
			function printtoken(type, token, xxx_todo_changeme, xxx_todo_changeme1, line): Promise<any>
			function printtoken$({ type, token, xxx_todo_changeme, xxx_todo_changeme1, line }): Promise<any>

			/**
			 * 
			 *     The tokenize() function accepts two parameters: one representing the
			 *     input stream, and one providing an output mechanism for tokenize().
			 * 
			 *     The first parameter, readline, must be a callable object which provides
			 *     the same interface as the readline() method of built-in file objects.
			 *     Each call to the function should return one line of input as a string.
			 * 
			 *     The second parameter, tokeneater, must also be a callable object. It is
			 *     called once for each token, with five arguments, corresponding to the
			 *     tuples generated by generate_tokens().
			 *     
			 */
			function tokenize(readline, tokeneater?): Promise<any>
			function tokenize$({ readline, tokeneater }: { readline, tokeneater?}): Promise<any>
			function tokenize_loop(readline, tokeneater): Promise<any>
			function tokenize_loop$({ readline, tokeneater }): Promise<any>

			/**
			 * 
			 *     The detect_encoding() function is used to detect the encoding that should
			 *     be used to decode a Python source file. It requires one argument, readline,
			 *     in the same way as the tokenize() generator.
			 * 
			 *     It will call readline a maximum of twice, and return the encoding used
			 *     (as a string) and a list of any lines (left as bytes) it has read
			 *     in.
			 * 
			 *     It detects the encoding from the presence of a utf-8 bom or an encoding
			 *     cookie as specified in pep-0263. If both a bom and a cookie are present, but
			 *     disagree, a SyntaxError will be raised. If the encoding cookie is an invalid
			 *     charset, raise a SyntaxError.  Note that if a utf-8 bom is found,
			 *     'utf-8-sig' is returned.
			 * 
			 *     If no encoding is specified, then the default of 'utf-8' will be returned.
			 *     
			 */
			function detect_encoding(readline): Promise<any>
			function detect_encoding$({ readline }): Promise<any>

			/**
			 * Transform tokens back into Python source code.
			 * 
			 *     Each element returned by the iterable must be a token sequence
			 *     with at least two elements, a token number and token value.  If
			 *     only two tokens are passed, the resulting output is poor.
			 * 
			 *     Round-trip invariant for full input:
			 *         Untokenized source will match input source exactly
			 * 
			 *     Round-trip invariant for limited input:
			 *         # Output text will tokenize the back to the input
			 *         t1 = [tok[:2] for tok in generate_tokens(f.readline)]
			 *         newcode = untokenize(t1)
			 *         readline = iter(newcode.splitlines(1)).next
			 *         t2 = [tok[:2] for tokin generate_tokens(readline)]
			 *         assert t1 == t2
			 *     
			 */
			function untokenize(iterable): Promise<any>
			function untokenize$({ iterable }): Promise<any>

			/**
			 * 
			 *     The generate_tokens() generator requires one argument, readline, which
			 *     must be a callable object which provides the same interface as the
			 *     readline() method of built-in file objects. Each call to the function
			 *     should return one line of input as a string.  Alternately, readline
			 *     can be a callable function terminating with StopIteration:
			 *         readline = open(myfile).next    # Example of alternate readline
			 * 
			 *     The generator produces 5-tuples with these members: the token type; the
			 *     token string; a 2-tuple (srow, scol) of ints specifying the row and
			 *     column where the token begins in the source; a 2-tuple (erow, ecol) of
			 *     ints specifying the row and column where the token ends in the source;
			 *     and the line on which the token was found. The line passed is the
			 *     physical line.
			 *     
			 */
			function generate_tokens(readline): Promise<any>
			function generate_tokens$({ readline }): Promise<any>
			interface ITokenError {
			}
			interface IStopTokenizing {
			}
			function Untokenizer(): Promise<IUntokenizer>
			function Untokenizer$({ }): Promise<IUntokenizer>
			interface IUntokenizer {
				add_whitespace(start): Promise<any>
				add_whitespace$({ start }): Promise<any>
				untokenize(iterable): Promise<any>
				untokenize$({ iterable }): Promise<any>
				compat(token, iterable): Promise<any>
				compat$({ token, iterable }): Promise<any>
			}
			let Whitespace: Promise<any>
			let Comment: Promise<any>
			let Ignore: Promise<any>
			let Name: Promise<any>
			let Binnumber: Promise<any>
			let Hexnumber: Promise<any>
			let Octnumber: Promise<any>
			let Decnumber: Promise<any>
			let Intnumber: Promise<any>
			let Exponent: Promise<any>
			let Pointfloat: Promise<any>
			let Expfloat: Promise<any>
			let Floatnumber: Promise<any>
			let Imagnumber: Promise<any>
			let Number: Promise<any>
			let Single: Promise<any>
			let Double: Promise<any>
			let Single3: Promise<any>
			let Double3: Promise<any>
			let Triple: Promise<any>
			let String: Promise<any>
			let Operator: Promise<any>
			let Bracket: Promise<any>
			let Special: Promise<any>
			let Funny: Promise<any>
			let PlainToken: Promise<any>
			let Token: Promise<any>
			let ContStr: Promise<any>
			let PseudoExtras: Promise<any>
			let PseudoToken: Promise<any>
			let endprogs: Promise<any>
			let triple_quoted: Promise<any>
			let single_quoted: Promise<any>
			let tabsize: Promise<any>
			let cookie_re: Promise<any>
			let blank_re: Promise<any>
		}
	}
	module pygram {
		var _

		/**
		 * Initializer.
		 * 
		 *         Creates an attribute for each grammar symbol (nonterminal),
		 *         whose value is the symbol's type (an int >= 256).
		 *         
		 */
		function Symbols(grammar): Promise<ISymbols>
		function Symbols$({ grammar }): Promise<ISymbols>
		interface ISymbols {
		}
		let python_grammar: Promise<any>
		let python_symbols: Promise<any>
		let python_grammar_no_print_statement: Promise<any>
		let python_grammar_no_print_and_exec_statement: Promise<any>
		let pattern_grammar: Promise<any>
		let pattern_symbols: Promise<any>
	}
	module pytree {
		var _
		function type_repr(type_num): Promise<any>
		function type_repr$({ type_num }): Promise<any>

		/**
		 * 
		 *     Convert raw node information to a Node or Leaf instance.
		 * 
		 *     This is passed to the parser driver which calls it whenever a reduction of a
		 *     grammar rule produces a new complete node, so that the tree is build
		 *     strictly bottom-up.
		 *     
		 */
		function convert(gr, raw_node): Promise<any>
		function convert$({ gr, raw_node }): Promise<any>

		/**
		 * 
		 *     Generator yielding matches for a sequence of patterns and nodes.
		 * 
		 *     Args:
		 *         patterns: a sequence of patterns
		 *         nodes: a sequence of nodes
		 * 
		 *     Yields:
		 *         (count, results) tuples where:
		 *         count: the entire sequence of patterns matches nodes[:count];
		 *         results: dict containing named submatches.
		 *         
		 */
		function generate_matches(patterns, nodes): Promise<any>
		function generate_matches$({ patterns, nodes }): Promise<any>

		/**
		 * 
		 *     Abstract base class for Node and Leaf.
		 * 
		 *     This provides some default functionality and boilerplate using the
		 *     template pattern.
		 * 
		 *     A node may be a subnode of at most one parent.
		 *     
		 */
		interface IBase {

			/**
			 * 
			 *         Return a cloned (deep) copy of self.
			 * 
			 *         This must be implemented by the concrete subclass.
			 *         
			 */
			clone(): Promise<any>
			clone$($: {}): Promise<any>

			/**
			 * 
			 *         Return a post-order iterator for the tree.
			 * 
			 *         This must be implemented by the concrete subclass.
			 *         
			 */
			post_order(): Promise<any>
			post_order$($: {}): Promise<any>

			/**
			 * 
			 *         Return a pre-order iterator for the tree.
			 * 
			 *         This must be implemented by the concrete subclass.
			 *         
			 */
			pre_order(): Promise<any>
			pre_order$($: {}): Promise<any>

			/**
			 * Replace this node with a new one in the parent.
			 */
			replace(New): Promise<any>
			replace$({ New }): Promise<any>

			/**
			 * Return the line number which generated the invocant node.
			 */
			get_lineno(): Promise<any>
			get_lineno$($: {}): Promise<any>
			changed(): Promise<any>
			changed$($: {}): Promise<any>

			/**
			 * 
			 *         Remove the node from the tree. Returns the position of the node in its
			 *         parent's children before it was removed.
			 *         
			 */
			remove(): Promise<any>
			remove$($: {}): Promise<any>

			/**
			 * 
			 *         The node immediately following the invocant in their parent's children
			 *         list. If the invocant does not have a next sibling, it is None
			 *         
			 */
			next_sibling(): Promise<any>
			next_sibling$($: {}): Promise<any>

			/**
			 * 
			 *         The node immediately preceding the invocant in their parent's children
			 *         list. If the invocant does not have a previous sibling, it is None.
			 *         
			 */
			prev_sibling(): Promise<any>
			prev_sibling$($: {}): Promise<any>
			leaves(): Promise<any>
			leaves$($: {}): Promise<any>
			depth(): Promise<any>
			depth$($: {}): Promise<any>

			/**
			 * 
			 *         Return the string immediately following the invocant node. This is
			 *         effectively equivalent to node.next_sibling.prefix
			 *         
			 */
			get_suffix(): Promise<any>
			get_suffix$($: {}): Promise<any>
			type
			parent
			children
			was_changed
			was_checked
		}

		/**
		 * Concrete implementation for interior nodes.
		 */

		/**
		 * 
		 *         Initializer.
		 * 
		 *         Takes a type constant (a symbol number >= 256), a sequence of
		 *         child nodes, and an optional context keyword argument.
		 * 
		 *         As a side effect, the parent pointers of the children are updated.
		 *         
		 */
		function Node(type, children, context?, prefix?, fixers_applied?): Promise<INode>
		function Node$({ type, children, context, prefix, fixers_applied }: { type, children, context?, prefix?, fixers_applied?}): Promise<INode>
		interface INode extends IBase {

			/**
			 * Return a cloned (deep) copy of self.
			 */
			clone(): Promise<any>
			clone$($: {}): Promise<any>

			/**
			 * Return a post-order iterator for the tree.
			 */
			post_order(): Promise<any>
			post_order$($: {}): Promise<any>

			/**
			 * Return a pre-order iterator for the tree.
			 */
			pre_order(): Promise<any>
			pre_order$($: {}): Promise<any>

			/**
			 * 
			 *         The whitespace and comments preceding this node in the input.
			 *         
			 */
			prefix(): Promise<any>
			prefix$($: {}): Promise<any>
			prefix(prefix): Promise<any>
			prefix$({ prefix }): Promise<any>

			/**
			 * 
			 *         Equivalent to 'node.children[i] = child'. This method also sets the
			 *         child's parent attribute appropriately.
			 *         
			 */
			set_child(i, child): Promise<any>
			set_child$({ i, child }): Promise<any>

			/**
			 * 
			 *         Equivalent to 'node.children.insert(i, child)'. This method also sets
			 *         the child's parent attribute appropriately.
			 *         
			 */
			insert_child(i, child): Promise<any>
			insert_child$({ i, child }): Promise<any>

			/**
			 * 
			 *         Equivalent to 'node.children.append(child)'. This method also sets the
			 *         child's parent attribute appropriately.
			 *         
			 */
			append_child(child): Promise<any>
			append_child$({ child }): Promise<any>
		}

		/**
		 * Concrete implementation for leaf nodes.
		 */

		/**
		 * 
		 *         Initializer.
		 * 
		 *         Takes a type constant (a token number < 256), a string value, and an
		 *         optional context keyword argument.
		 *         
		 */
		function Leaf(type, value, context?, prefix?, fixers_applied?): Promise<ILeaf>
		function Leaf$({ type, value, context, prefix, fixers_applied }: { type, value, context?, prefix?, fixers_applied?}): Promise<ILeaf>
		interface ILeaf extends IBase {

			/**
			 * Return a cloned (deep) copy of self.
			 */
			clone(): Promise<any>
			clone$($: {}): Promise<any>
			leaves(): Promise<any>
			leaves$($: {}): Promise<any>

			/**
			 * Return a post-order iterator for the tree.
			 */
			post_order(): Promise<any>
			post_order$($: {}): Promise<any>

			/**
			 * Return a pre-order iterator for the tree.
			 */
			pre_order(): Promise<any>
			pre_order$($: {}): Promise<any>

			/**
			 * 
			 *         The whitespace and comments preceding this token in the input.
			 *         
			 */
			prefix(): Promise<any>
			prefix$($: {}): Promise<any>
			prefix(prefix): Promise<any>
			prefix$({ prefix }): Promise<any>
			lineno
			column
		}

		/**
		 * 
		 *     A pattern is a tree matching pattern.
		 * 
		 *     It looks for a specific node type (token or symbol), and
		 *     optionally for a specific content.
		 * 
		 *     This is an abstract base class.  There are three concrete
		 *     subclasses:
		 * 
		 *     - LeafPattern matches a single leaf node;
		 *     - NodePattern matches a single node (usually non-leaf);
		 *     - WildcardPattern matches a sequence of nodes of variable length.
		 *     
		 */
		interface IBasePattern {

			/**
			 * 
			 *         A subclass can define this as a hook for optimizations.
			 * 
			 *         Returns either self or another node with the same effect.
			 *         
			 */
			optimize(): Promise<any>
			optimize$($: {}): Promise<any>

			/**
			 * 
			 *         Does this pattern exactly match a node?
			 * 
			 *         Returns True if it matches, False if not.
			 * 
			 *         If results is not None, it must be a dict which will be
			 *         updated with the nodes matching named subpatterns.
			 * 
			 *         Default implementation for non-wildcard patterns.
			 *         
			 */
			match(node, results?): Promise<any>
			match$({ node, results }: { node, results?}): Promise<any>

			/**
			 * 
			 *         Does this pattern exactly match a sequence of nodes?
			 * 
			 *         Default implementation for non-wildcard patterns.
			 *         
			 */
			match_seq(nodes, results?): Promise<any>
			match_seq$({ nodes, results }: { nodes, results?}): Promise<any>

			/**
			 * 
			 *         Generator yielding all matches for this pattern.
			 * 
			 *         Default implementation for non-wildcard patterns.
			 *         
			 */
			generate_matches(nodes): Promise<any>
			generate_matches$({ nodes }): Promise<any>
			content
			name
		}

		/**
		 * 
		 *         Initializer.  Takes optional type, content, and name.
		 * 
		 *         The type, if given must be a token type (< 256).  If not given,
		 *         this matches any *leaf* node; the content may still be required.
		 * 
		 *         The content, if given, must be a string.
		 * 
		 *         If a name is given, the matching node is stored in the results
		 *         dict under that key.
		 *         
		 */
		function LeafPattern(type?, content?, name?): Promise<ILeafPattern>
		function LeafPattern$({ type, content, name }: { type?, content?, name?}): Promise<ILeafPattern>
		interface ILeafPattern extends IBasePattern {

			/**
			 * Override match() to insist on a leaf node.
			 */
			match(node, results?): Promise<any>
			match$({ node, results }: { node, results?}): Promise<any>
		}

		/**
		 * 
		 *         Initializer.  Takes optional type, content, and name.
		 * 
		 *         The type, if given, must be a symbol type (>= 256).  If the
		 *         type is None this matches *any* single node (leaf or not),
		 *         except if content is not None, in which it only matches
		 *         non-leaf nodes that also match the content pattern.
		 * 
		 *         The content, if not None, must be a sequence of Patterns that
		 *         must match the node's children exactly.  If the content is
		 *         given, the type must not be None.
		 * 
		 *         If a name is given, the matching node is stored in the results
		 *         dict under that key.
		 *         
		 */
		function NodePattern(type?, content?, name?): Promise<INodePattern>
		function NodePattern$({ type, content, name }: { type?, content?, name?}): Promise<INodePattern>
		interface INodePattern extends IBasePattern {
			wildcards
		}

		/**
		 * 
		 *     A wildcard pattern can match zero or more nodes.
		 * 
		 *     This has all the flexibility needed to implement patterns like:
		 * 
		 *     .*      .+      .?      .{m,n}
		 *     (a b c | d e | f)
		 *     (...)*  (...)+  (...)?  (...){m,n}
		 * 
		 *     except it always uses non-greedy matching.
		 *     
		 */

		/**
		 * 
		 *         Initializer.
		 * 
		 *         Args:
		 *             content: optional sequence of subsequences of patterns;
		 *                      if absent, matches one node;
		 *                      if present, each subsequence is an alternative [*]
		 *             min: optional minimum number of times to match, default 0
		 *             max: optional maximum number of times to match, default HUGE
		 *             name: optional name assigned to this match
		 * 
		 *         [*] Thus, if content is [[a, b, c], [d, e], [f, g, h]] this is
		 *             equivalent to (a b c | d e | f g h); if content is None,
		 *             this is equivalent to '.' in regular expression terms.
		 *             The min and max parameters work as follows:
		 *                 min=0, max=maxint: .*
		 *                 min=1, max=maxint: .+
		 *                 min=0, max=1: .?
		 *                 min=1, max=1: .
		 *             If content is not None, replace the dot with the parenthesized
		 *             list of alternatives, e.g. (a b c | d e | f g h)*
		 *         
		 */
		function WildcardPattern(content?, min?, max?, name?): Promise<IWildcardPattern>
		function WildcardPattern$({ content, min, max, name }: { content?, min?, max?, name?}): Promise<IWildcardPattern>
		interface IWildcardPattern extends IBasePattern {

			/**
			 * Optimize certain stacked wildcard patterns.
			 */
			optimize(): Promise<any>
			optimize$($: {}): Promise<any>

			/**
			 * Does this pattern exactly match a node?
			 */
			match(node, results?): Promise<any>
			match$({ node, results }: { node, results?}): Promise<any>

			/**
			 * Does this pattern exactly match a sequence of nodes?
			 */
			match_seq(nodes, results?): Promise<any>
			match_seq$({ nodes, results }: { nodes, results?}): Promise<any>

			/**
			 * 
			 *         Generator yielding matches for a sequence of nodes.
			 * 
			 *         Args:
			 *             nodes: sequence of nodes
			 * 
			 *         Yields:
			 *             (count, results) tuples where:
			 *             count: the match comprises nodes[:count];
			 *             results: dict containing named submatches.
			 *         
			 */
			generate_matches(nodes): Promise<any>
			generate_matches$({ nodes }): Promise<any>
		}

		/**
		 * 
		 *         Initializer.
		 * 
		 *         The argument is either a pattern or None.  If it is None, this
		 *         only matches an empty sequence (effectively '$' in regex
		 *         lingo).  If it is not None, this matches whenever the argument
		 *         pattern doesn't have any matches.
		 *         
		 */
		function NegatedPattern(content?): Promise<INegatedPattern>
		function NegatedPattern$({ content }: { content?}): Promise<INegatedPattern>
		interface INegatedPattern extends IBasePattern {
			match(node): Promise<any>
			match$({ node }): Promise<any>
			match_seq(nodes): Promise<any>
			match_seq$({ nodes }): Promise<any>
			generate_matches(nodes): Promise<any>
			generate_matches$({ nodes }): Promise<any>
		}
		let HUGE: Promise<any>
	}
	module refactor {
		var _

		/**
		 * Return a sorted list of all available fix names in the given package.
		 */
		function get_all_fix_names(fixer_pkg, remove_prefix?: boolean): Promise<any>
		function get_all_fix_names$({ fixer_pkg, remove_prefix }: { fixer_pkg, remove_prefix?}): Promise<any>

		/**
		 * 
		 *     Return the fully qualified names for fixers in the package pkg_name.
		 *     
		 */
		function get_fixers_from_package(pkg_name): Promise<any>
		function get_fixers_from_package$({ pkg_name }): Promise<any>
		interface I_EveryNode {
		}

		/**
		 * A fixer could not be loaded.
		 */
		interface IFixerError {
		}

		/**
		 * Initializer.
		 * 
		 *         Args:
		 *             fixer_names: a list of fixers to import
		 *             options: a dict with configuration.
		 *             explicit: a list of fixers to run even if they are explicit.
		 *         
		 */
		function RefactoringTool(fixer_names, options?, explicit?): Promise<IRefactoringTool>
		function RefactoringTool$({ fixer_names, options, explicit }: { fixer_names, options?, explicit?}): Promise<IRefactoringTool>
		interface IRefactoringTool {

			/**
			 * Inspects the options to load the requested patterns and handlers.
			 * 
			 *         Returns:
			 *           (pre_order, post_order), where pre_order is the list of fixers that
			 *           want a pre-order AST traversal, and post_order is the list that want
			 *           post-order traversal.
			 *         
			 */
			get_fixers(): Promise<any>
			get_fixers$($: {}): Promise<any>

			/**
			 * Called when an error occurs.
			 */
			log_error(msg): Promise<any>
			log_error$({ msg }): Promise<any>

			/**
			 * Hook to log a message.
			 */
			log_message(msg): Promise<any>
			log_message$({ msg }): Promise<any>
			log_debug(msg): Promise<any>
			log_debug$({ msg }): Promise<any>

			/**
			 * Called with the old version, new version, and filename of a
			 *         refactored file.
			 */
			print_output(old_text, new_text, filename, equal): Promise<any>
			print_output$({ old_text, new_text, filename, equal }): Promise<any>

			/**
			 * Refactor a list of files and directories.
			 */
			refactor(items, write?: boolean, doctests_only?: boolean): Promise<any>
			refactor$({ items, write, doctests_only }: { items, write?, doctests_only?}): Promise<any>

			/**
			 * Descends down a directory and refactor every Python file found.
			 * 
			 *         Python files are assumed to have a .py extension.
			 * 
			 *         Files and subdirectories starting with '.' are skipped.
			 *         
			 */
			refactor_dir(dir_name, write?: boolean, doctests_only?: boolean): Promise<any>
			refactor_dir$({ dir_name, write, doctests_only }: { dir_name, write?, doctests_only?}): Promise<any>

			/**
			 * Refactors a file.
			 */
			refactor_file(filename, write?: boolean, doctests_only?: boolean): Promise<any>
			refactor_file$({ filename, write, doctests_only }: { filename, write?, doctests_only?}): Promise<any>

			/**
			 * Refactor a given input string.
			 * 
			 *         Args:
			 *             data: a string holding the code to be refactored.
			 *             name: a human-readable name for use in error/log messages.
			 * 
			 *         Returns:
			 *             An AST corresponding to the refactored input stream; None if
			 *             there were errors during the parse.
			 *         
			 */
			refactor_string(data, name): Promise<any>
			refactor_string$({ data, name }): Promise<any>
			refactor_stdin(doctests_only?: boolean): Promise<any>
			refactor_stdin$({ doctests_only }: { doctests_only?}): Promise<any>

			/**
			 * Refactors a parse tree (modifying the tree in place).
			 * 
			 *         For compatible patterns the bottom matcher module is
			 *         used. Otherwise the tree is traversed node-to-node for
			 *         matches.
			 * 
			 *         Args:
			 *             tree: a pytree.Node instance representing the root of the tree
			 *                   to be refactored.
			 *             name: a human-readable name for this tree.
			 * 
			 *         Returns:
			 *             True if the tree was modified, False otherwise.
			 *         
			 */
			refactor_tree(tree, name): Promise<any>
			refactor_tree$({ tree, name }): Promise<any>

			/**
			 * Traverse an AST, applying a set of fixers to each node.
			 * 
			 *         This is a helper method for refactor_tree().
			 * 
			 *         Args:
			 *             fixers: a list of fixer instances.
			 *             traversal: a generator that yields AST nodes.
			 * 
			 *         Returns:
			 *             None
			 *         
			 */
			traverse_by(fixers, traversal): Promise<any>
			traverse_by$({ fixers, traversal }): Promise<any>

			/**
			 * 
			 *         Called when a file has been refactored and there may be changes.
			 *         
			 */
			processed_file(new_text, filename, old_text?, write?: boolean, encoding?): Promise<any>
			processed_file$({ new_text, filename, old_text, write, encoding }: { new_text, filename, old_text?, write?, encoding?}): Promise<any>

			/**
			 * Writes a string to a file.
			 * 
			 *         It first shows a unified diff between the old text and the new text, and
			 *         then rewrites the file; the latter is only done if the write option is
			 *         set.
			 *         
			 */
			write_file(new_text, filename, old_text, encoding?): Promise<any>
			write_file$({ new_text, filename, old_text, encoding }: { new_text, filename, old_text, encoding?}): Promise<any>

			/**
			 * Refactors a docstring, looking for doctests.
			 * 
			 *         This returns a modified version of the input string.  It looks
			 *         for doctests, which start with a ">>>" prompt, and may be
			 *         continued with "..." prompts, as long as the "..." is indented
			 *         the same as the ">>>".
			 * 
			 *         (Unfortunately we can't use the doctest module's parser,
			 *         since, like most parsers, it is not geared towards preserving
			 *         the original source.)
			 *         
			 */
			refactor_docstring(input, filename): Promise<any>
			refactor_docstring$({ input, filename }): Promise<any>

			/**
			 * Refactors one doctest.
			 * 
			 *         A doctest is given as a block of lines, the first of which starts
			 *         with ">>>" (possibly indented), while the remaining lines start
			 *         with "..." (identically indented).
			 * 
			 *         
			 */
			refactor_doctest(block, lineno, indent, filename): Promise<any>
			refactor_doctest$({ block, lineno, indent, filename }): Promise<any>
			summarize(): Promise<any>
			summarize$($: {}): Promise<any>

			/**
			 * Parses a block into a tree.
			 * 
			 *         This is necessary to get correct line number / offset information
			 *         in the parser diagnostics and embedded into the parse tree.
			 *         
			 */
			parse_block(block, lineno, indent): Promise<any>
			parse_block$({ block, lineno, indent }): Promise<any>

			/**
			 * Wraps a tokenize stream to systematically modify start/end.
			 */
			wrap_toks(block, lineno, indent): Promise<any>
			wrap_toks$({ block, lineno, indent }): Promise<any>

			/**
			 * Generates lines as expected by tokenize from a list of lines.
			 * 
			 *         This strips the first len(indent + self.PS1) characters off each line.
			 *         
			 */
			gen_lines(block, indent): Promise<any>
			gen_lines$({ block, indent }): Promise<any>
			CLASS_PREFIX
			FILE_PREFIX
			PS1
			PS2
		}
		interface IMultiprocessingUnsupported {
		}
		function MultiprocessRefactoringTool(): Promise<IMultiprocessRefactoringTool>
		function MultiprocessRefactoringTool$({ }): Promise<IMultiprocessRefactoringTool>
		interface IMultiprocessRefactoringTool extends IRefactoringTool {
			refactor(items, write?: boolean, doctests_only?: boolean, num_processes?): Promise<any>
			refactor$({ items, write, doctests_only, num_processes }: { items, write?, doctests_only?, num_processes?}): Promise<any>
			refactor_file(): Promise<any>
			refactor_file$($: {}): Promise<any>
		}
	}
}
declare module linecache {
	var _

	/**
	 * Clear the cache entirely.
	 */
	function clearcache(): Promise<any>
	function clearcache$($: {}): Promise<any>

	/**
	 * Get a line for a Python source file from the cache.
	 *     Update the cache if it doesn't contain an entry for this file already.
	 */
	function getline(filename, lineno, module_globals?): Promise<any>
	function getline$({ filename, lineno, module_globals }: { filename, lineno, module_globals?}): Promise<any>

	/**
	 * Get the lines for a Python source file from the cache.
	 *     Update the cache if it doesn't contain an entry for this file already.
	 */
	function getlines(filename, module_globals?): Promise<any>
	function getlines$({ filename, module_globals }: { filename, module_globals?}): Promise<any>

	/**
	 * Discard cache entries that are out of date.
	 *     (This is not checked upon each call!)
	 */
	function checkcache(filename?): Promise<any>
	function checkcache$({ filename }: { filename?}): Promise<any>

	/**
	 * Update a cache entry and return its list of lines.
	 *     If something's wrong, print a message, discard the cache entry,
	 *     and return an empty list.
	 */
	function updatecache(filename, module_globals?): Promise<any>
	function updatecache$({ filename, module_globals }: { filename, module_globals?}): Promise<any>

	/**
	 * Seed the cache for filename with module_globals.
	 * 
	 *     The module loader will be asked for the source only when getlines is
	 *     called, not immediately.
	 * 
	 *     If there is an entry in the cache already, it is not altered.
	 * 
	 *     :return: True if a lazy load is registered in the cache,
	 *         otherwise False. To register such a load a module loader with a
	 *         get_source method must be found, the filename must be a cachable
	 *         filename, and the filename must not be already cached.
	 *     
	 */
	function lazycache(filename, module_globals): Promise<any>
	function lazycache$({ filename, module_globals }): Promise<any>
	let cache: Promise<any>
}
declare module locale {
	var _
	function localeconv(): Promise<any>
	function localeconv$($: {}): Promise<any>

	/**
	 * Formats a string in the same way that the % formatting would use,
	 *     but takes the current locale into account.
	 * 
	 *     Grouping is applied if the third parameter is true.
	 *     Conversion uses monetary thousands separator and grouping strings if
	 *     forth parameter monetary is true.
	 */
	function format_string(f, val, grouping?: boolean, monetary?: boolean): Promise<any>
	function format_string$({ f, val, grouping, monetary }: { f, val, grouping?, monetary?}): Promise<any>

	/**
	 * Deprecated, use format_string instead.
	 */
	function format(percent, value, grouping?: boolean, monetary?: boolean): Promise<any>
	function format$({ percent, value, grouping, monetary }: { percent, value, grouping?, monetary?}): Promise<any>

	/**
	 * Formats val according to the currency settings
	 *     in the current locale.
	 */
	function currency(val, symbol?: boolean, grouping?: boolean, international?: boolean): Promise<any>
	function currency$({ val, symbol, grouping, international }: { val, symbol?, grouping?, international?}): Promise<any>

	/**
	 * Convert float to string, taking the locale into account.
	 */
	function str(val): Promise<any>
	function str$({ val }): Promise<any>

	/**
	 * Parses a string as a normalized number according to the locale settings.
	 */
	function delocalize(string): Promise<any>
	function delocalize$({ string }): Promise<any>

	/**
	 * Parses a string as locale number according to the locale settings.
	 */
	function localize(string, grouping?: boolean, monetary?: boolean): Promise<any>
	function localize$({ string, grouping, monetary }: { string, grouping?, monetary?}): Promise<any>

	/**
	 * Parses a string as a float according to the locale settings.
	 */
	function atof(string, func?): Promise<any>
	function atof$({ string, func }: { string, func?}): Promise<any>

	/**
	 * Converts a string to an integer according to the locale settings.
	 */
	function atoi(string): Promise<any>
	function atoi$({ string }): Promise<any>

	/**
	 *  Returns a normalized locale code for the given locale
	 *         name.
	 * 
	 *         The returned locale code is formatted for use with
	 *         setlocale().
	 * 
	 *         If normalization fails, the original name is returned
	 *         unchanged.
	 * 
	 *         If the given encoding is not known, the function defaults to
	 *         the default encoding for the locale code just like setlocale()
	 *         does.
	 * 
	 *     
	 */
	function normalize(localename): Promise<any>
	function normalize$({ localename }): Promise<any>

	/**
	 *  Tries to determine the default locale settings and returns
	 *         them as tuple (language code, encoding).
	 * 
	 *         According to POSIX, a program which has not called
	 *         setlocale(LC_ALL, "") runs using the portable 'C' locale.
	 *         Calling setlocale(LC_ALL, "") lets it use the default locale as
	 *         defined by the LANG variable. Since we don't want to interfere
	 *         with the current locale setting we thus emulate the behavior
	 *         in the way described above.
	 * 
	 *         To maintain compatibility with other platforms, not only the
	 *         LANG variable is tested, but a list of variables given as
	 *         envvars parameter. The first found to be defined will be
	 *         used. envvars defaults to the search path used in GNU gettext;
	 *         it must always contain the variable name 'LANG'.
	 * 
	 *         Except for the code 'C', the language code corresponds to RFC
	 *         1766.  code and encoding can be None in case the values cannot
	 *         be determined.
	 * 
	 *     
	 */
	function getdefaultlocale(envvars?): Promise<any>
	function getdefaultlocale$({ envvars }: { envvars?}): Promise<any>

	/**
	 *  Returns the current setting for the given locale category as
	 *         tuple (language code, encoding).
	 * 
	 *         category may be one of the LC_* value except LC_ALL. It
	 *         defaults to LC_CTYPE.
	 * 
	 *         Except for the code 'C', the language code corresponds to RFC
	 *         1766.  code and encoding can be None in case the values cannot
	 *         be determined.
	 * 
	 *     
	 */
	function getlocale(category?): Promise<any>
	function getlocale$({ category }: { category?}): Promise<any>

	/**
	 *  Set the locale for the given category.  The locale can be
	 *         a string, an iterable of two strings (language code and encoding),
	 *         or None.
	 * 
	 *         Iterables are converted to strings using the locale aliasing
	 *         engine.  Locale strings are passed directly to the C lib.
	 * 
	 *         category may be given as one of the LC_* values.
	 * 
	 *     
	 */
	function setlocale(category, locale?): Promise<any>
	function setlocale$({ category, locale }: { category, locale?}): Promise<any>

	/**
	 *  Sets the locale for category to the default setting.
	 * 
	 *         The default setting is determined by calling
	 *         getdefaultlocale(). category defaults to LC_ALL.
	 * 
	 *     
	 */
	function resetlocale(category?): Promise<any>
	function resetlocale$({ category }: { category?}): Promise<any>

	/**
	 * Return the charset that the user is likely using,
	 *         according to the system configuration.
	 */
	function getpreferredencoding(do_setlocale?: boolean): Promise<any>
	function getpreferredencoding$({ do_setlocale }: { do_setlocale?}): Promise<any>
	let strxfrm: Promise<any>
	let strcoll: Promise<any>
	let locale_encoding_alias: Promise<any>
	let k: Promise<any>
	let locale_alias: Promise<any>
	let windows_locale: Promise<any>
}
declare module logging {
	var _
	function getLevelNamesMapping(): Promise<any>
	function getLevelNamesMapping$($: {}): Promise<any>

	/**
	 * 
	 *     Return the textual or numeric representation of logging level 'level'.
	 * 
	 *     If the level is one of the predefined levels (CRITICAL, ERROR, WARNING,
	 *     INFO, DEBUG) then you get the corresponding string. If you have
	 *     associated levels with names using addLevelName then the name you have
	 *     associated with 'level' is returned.
	 * 
	 *     If a numeric value corresponding to one of the defined levels is passed
	 *     in, the corresponding string representation is returned.
	 * 
	 *     If a string representation of the level is passed in, the corresponding
	 *     numeric value is returned.
	 * 
	 *     If no matching numeric or string value is passed in, the string
	 *     'Level %s' % level is returned.
	 *     
	 */
	function getLevelName(level): Promise<any>
	function getLevelName$({ level }): Promise<any>

	/**
	 * 
	 *     Associate 'levelName' with 'level'.
	 * 
	 *     This is used when converting levels to text during message formatting.
	 *     
	 */
	function addLevelName(level, levelName): Promise<any>
	function addLevelName$({ level, levelName }): Promise<any>

	/**
	 * Return the frame object for the caller's stack frame.
	 */
	function currentframe(): Promise<any>
	function currentframe$($: {}): Promise<any>

	/**
	 * 
	 *     Set the factory to be used when instantiating a log record.
	 * 
	 *     :param factory: A callable which will be called to instantiate
	 *     a log record.
	 *     
	 */
	function setLogRecordFactory(factory): Promise<any>
	function setLogRecordFactory$({ factory }): Promise<any>

	/**
	 * 
	 *     Return the factory to be used when instantiating a log record.
	 *     
	 */
	function getLogRecordFactory(): Promise<any>
	function getLogRecordFactory$($: {}): Promise<any>

	/**
	 * 
	 *     Make a LogRecord whose attributes are defined by the specified dictionary,
	 *     This function is useful for converting a logging event received over
	 *     a socket connection (which is sent as a dictionary) into a LogRecord
	 *     instance.
	 *     
	 */
	function makeLogRecord(dict): Promise<any>
	function makeLogRecord$({ dict }): Promise<any>

	/**
	 * 
	 *     Set the class to be used when instantiating a logger. The class should
	 *     define __init__() such that only a name argument is required, and the
	 *     __init__() should call Logger.__init__()
	 *     
	 */
	function setLoggerClass(klass): Promise<any>
	function setLoggerClass$({ klass }): Promise<any>

	/**
	 * 
	 *     Return the class to be used when instantiating a logger.
	 *     
	 */
	function getLoggerClass(): Promise<any>
	function getLoggerClass$($: {}): Promise<any>

	/**
	 * 
	 *     Do basic configuration for the logging system.
	 * 
	 *     This function does nothing if the root logger already has handlers
	 *     configured, unless the keyword argument *force* is set to ``True``.
	 *     It is a convenience method intended for use by simple scripts
	 *     to do one-shot configuration of the logging package.
	 * 
	 *     The default behaviour is to create a StreamHandler which writes to
	 *     sys.stderr, set a formatter using the BASIC_FORMAT format string, and
	 *     add the handler to the root logger.
	 * 
	 *     A number of optional keyword arguments may be specified, which can alter
	 *     the default behaviour.
	 * 
	 *     filename  Specifies that a FileHandler be created, using the specified
	 *               filename, rather than a StreamHandler.
	 *     filemode  Specifies the mode to open the file, if filename is specified
	 *               (if filemode is unspecified, it defaults to 'a').
	 *     format    Use the specified format string for the handler.
	 *     datefmt   Use the specified date/time format.
	 *     style     If a format string is specified, use this to specify the
	 *               type of format string (possible values '%', '{', '$', for
	 *               %-formatting, :meth:`str.format` and :class:`string.Template`
	 *               - defaults to '%').
	 *     level     Set the root logger level to the specified level.
	 *     stream    Use the specified stream to initialize the StreamHandler. Note
	 *               that this argument is incompatible with 'filename' - if both
	 *               are present, 'stream' is ignored.
	 *     handlers  If specified, this should be an iterable of already created
	 *               handlers, which will be added to the root handler. Any handler
	 *               in the list which does not have a formatter assigned will be
	 *               assigned the formatter created in this function.
	 *     force     If this keyword  is specified as true, any existing handlers
	 *               attached to the root logger are removed and closed, before
	 *               carrying out the configuration as specified by the other
	 *               arguments.
	 *     encoding  If specified together with a filename, this encoding is passed to
	 *               the created FileHandler, causing it to be used when the file is
	 *               opened.
	 *     errors    If specified together with a filename, this value is passed to the
	 *               created FileHandler, causing it to be used when the file is
	 *               opened in text mode. If not specified, the default value is
	 *               `backslashreplace`.
	 * 
	 *     Note that you could specify a stream created using open(filename, mode)
	 *     rather than passing the filename and mode in. However, it should be
	 *     remembered that StreamHandler does not close its stream (since it may be
	 *     using sys.stdout or sys.stderr), whereas FileHandler closes its stream
	 *     when the handler is closed.
	 * 
	 *     .. versionchanged:: 3.2
	 *        Added the ``style`` parameter.
	 * 
	 *     .. versionchanged:: 3.3
	 *        Added the ``handlers`` parameter. A ``ValueError`` is now thrown for
	 *        incompatible arguments (e.g. ``handlers`` specified together with
	 *        ``filename``/``filemode``, or ``filename``/``filemode`` specified
	 *        together with ``stream``, or ``handlers`` specified together with
	 *        ``stream``.
	 * 
	 *     .. versionchanged:: 3.8
	 *        Added the ``force`` parameter.
	 * 
	 *     .. versionchanged:: 3.9
	 *        Added the ``encoding`` and ``errors`` parameters.
	 *     
	 */
	function basicConfig(): Promise<any>
	function basicConfig$($: {}): Promise<any>

	/**
	 * 
	 *     Return a logger with the specified name, creating it if necessary.
	 * 
	 *     If no name is specified, return the root logger.
	 *     
	 */
	function getLogger(name?): Promise<any>
	function getLogger$({ name }: { name?}): Promise<any>

	/**
	 * 
	 *     Log a message with severity 'CRITICAL' on the root logger. If the logger
	 *     has no handlers, call basicConfig() to add a console handler with a
	 *     pre-defined format.
	 *     
	 */
	function critical(msg): Promise<any>
	function critical$({ msg }): Promise<any>

	/**
	 * 
	 *     Don't use this function, use critical() instead.
	 *     
	 */
	function fatal(msg): Promise<any>
	function fatal$({ msg }): Promise<any>

	/**
	 * 
	 *     Log a message with severity 'ERROR' on the root logger. If the logger has
	 *     no handlers, call basicConfig() to add a console handler with a pre-defined
	 *     format.
	 *     
	 */
	function error(msg): Promise<any>
	function error$({ msg }): Promise<any>

	/**
	 * 
	 *     Log a message with severity 'ERROR' on the root logger, with exception
	 *     information. If the logger has no handlers, basicConfig() is called to add
	 *     a console handler with a pre-defined format.
	 *     
	 */
	function exception(msg): Promise<any>
	function exception$({ msg }): Promise<any>

	/**
	 * 
	 *     Log a message with severity 'WARNING' on the root logger. If the logger has
	 *     no handlers, call basicConfig() to add a console handler with a pre-defined
	 *     format.
	 *     
	 */
	function warning(msg): Promise<any>
	function warning$({ msg }): Promise<any>
	function warn(msg): Promise<any>
	function warn$({ msg }): Promise<any>

	/**
	 * 
	 *     Log a message with severity 'INFO' on the root logger. If the logger has
	 *     no handlers, call basicConfig() to add a console handler with a pre-defined
	 *     format.
	 *     
	 */
	function info(msg): Promise<any>
	function info$({ msg }): Promise<any>

	/**
	 * 
	 *     Log a message with severity 'DEBUG' on the root logger. If the logger has
	 *     no handlers, call basicConfig() to add a console handler with a pre-defined
	 *     format.
	 *     
	 */
	function debug(msg): Promise<any>
	function debug$({ msg }): Promise<any>

	/**
	 * 
	 *     Log 'msg % args' with the integer severity 'level' on the root logger. If
	 *     the logger has no handlers, call basicConfig() to add a console handler
	 *     with a pre-defined format.
	 *     
	 */
	function log(level, msg): Promise<any>
	function log$({ level, msg }): Promise<any>

	/**
	 * 
	 *     Disable all logging calls of severity 'level' and below.
	 *     
	 */
	function disable(level?): Promise<any>
	function disable$({ level }: { level?}): Promise<any>

	/**
	 * 
	 *     Perform any cleanup actions in the logging system (e.g. flushing
	 *     buffers).
	 * 
	 *     Should be called at application exit.
	 *     
	 */
	function shutdown(handlerList?): Promise<any>
	function shutdown$({ handlerList }: { handlerList?}): Promise<any>

	/**
	 * 
	 *     If capture is true, redirect all warnings to the logging package.
	 *     If capture is False, ensure that warnings are not redirected to logging
	 *     but to their original destinations.
	 *     
	 */
	function captureWarnings(capture): Promise<any>
	function captureWarnings$({ capture }): Promise<any>

	/**
	 * 
	 *     A LogRecord instance represents an event being logged.
	 * 
	 *     LogRecord instances are created every time something is logged. They
	 *     contain all the information pertinent to the event being logged. The
	 *     main information passed in is in msg and args, which are combined
	 *     using str(msg) % args to create the message field of the record. The
	 *     record also includes information such as when the record was created,
	 *     the source line where the logging call was made, and any exception
	 *     information to be logged.
	 *     
	 */

	/**
	 * 
	 *         Initialize a logging record with interesting information.
	 *         
	 */
	function LogRecord(name, level, pathname, lineno, msg, args, exc_info, func?, sinfo?): Promise<ILogRecord>
	function LogRecord$({ name, level, pathname, lineno, msg, args, exc_info, func, sinfo }: { name, level, pathname, lineno, msg, args, exc_info, func?, sinfo?}): Promise<ILogRecord>
	interface ILogRecord {

		/**
		 * 
		 *         Return the message for this LogRecord.
		 * 
		 *         Return the message for this LogRecord after merging any user-supplied
		 *         arguments with the message.
		 *         
		 */
		getMessage(): Promise<any>
		getMessage$($: {}): Promise<any>
	}
	function PercentStyle(fmt): Promise<IPercentStyle>
	function PercentStyle$({ fmt }): Promise<IPercentStyle>
	interface IPercentStyle {
		usesTime(): Promise<any>
		usesTime$($: {}): Promise<any>

		/**
		 * Validate the input format, ensure it matches the correct style
		 */
		validate(): Promise<any>
		validate$($: {}): Promise<any>
		format(record): Promise<any>
		format$({ record }): Promise<any>
		default_format
		asctime_format
		asctime_search
		validation_pattern
	}
	interface IStrFormatStyle extends IPercentStyle {

		/**
		 * Validate the input format, ensure it is the correct string formatting style
		 */
		validate(): Promise<any>
		validate$($: {}): Promise<any>
		fmt_spec
		field_spec
	}
	function StringTemplateStyle(): Promise<IStringTemplateStyle>
	function StringTemplateStyle$({ }): Promise<IStringTemplateStyle>
	interface IStringTemplateStyle extends IPercentStyle {
		usesTime(): Promise<any>
		usesTime$($: {}): Promise<any>
		validate(): Promise<any>
		validate$($: {}): Promise<any>
	}

	/**
	 * 
	 *     Formatter instances are used to convert a LogRecord to text.
	 * 
	 *     Formatters need to know how a LogRecord is constructed. They are
	 *     responsible for converting a LogRecord to (usually) a string which can
	 *     be interpreted by either a human or an external system. The base Formatter
	 *     allows a formatting string to be specified. If none is supplied, the
	 *     style-dependent default value, "%(message)s", "{message}", or
	 *     "${message}", is used.
	 * 
	 *     The Formatter can be initialized with a format string which makes use of
	 *     knowledge of the LogRecord attributes - e.g. the default value mentioned
	 *     above makes use of the fact that the user's message and arguments are pre-
	 *     formatted into a LogRecord's message attribute. Currently, the useful
	 *     attributes in a LogRecord are described by:
	 * 
	 *     %(name)s            Name of the logger (logging channel)
	 *     %(levelno)s         Numeric logging level for the message (DEBUG, INFO,
	 *                         WARNING, ERROR, CRITICAL)
	 *     %(levelname)s       Text logging level for the message ("DEBUG", "INFO",
	 *                         "WARNING", "ERROR", "CRITICAL")
	 *     %(pathname)s        Full pathname of the source file where the logging
	 *                         call was issued (if available)
	 *     %(filename)s        Filename portion of pathname
	 *     %(module)s          Module (name portion of filename)
	 *     %(lineno)d          Source line number where the logging call was issued
	 *                         (if available)
	 *     %(funcName)s        Function name
	 *     %(created)f         Time when the LogRecord was created (time.time()
	 *                         return value)
	 *     %(asctime)s         Textual time when the LogRecord was created
	 *     %(msecs)d           Millisecond portion of the creation time
	 *     %(relativeCreated)d Time in milliseconds when the LogRecord was created,
	 *                         relative to the time the logging module was loaded
	 *                         (typically at application startup time)
	 *     %(thread)d          Thread ID (if available)
	 *     %(threadName)s      Thread name (if available)
	 *     %(process)d         Process ID (if available)
	 *     %(message)s         The result of record.getMessage(), computed just as
	 *                         the record is emitted
	 *     
	 */

	/**
	 * 
	 *         Initialize the formatter with specified format strings.
	 * 
	 *         Initialize the formatter either with the specified format string, or a
	 *         default as described above. Allow for specialized date formatting with
	 *         the optional datefmt argument. If datefmt is omitted, you get an
	 *         ISO8601-like (or RFC 3339-like) format.
	 * 
	 *         Use a style parameter of '%', '{' or '$' to specify that you want to
	 *         use one of %-formatting, :meth:`str.format` (``{}``) formatting or
	 *         :class:`string.Template` formatting in your format string.
	 * 
	 *         .. versionchanged:: 3.2
	 *            Added the ``style`` parameter.
	 *         
	 */
	function Formatter(fmt?, datefmt?, style?, validate?: boolean): Promise<IFormatter>
	function Formatter$({ fmt, datefmt, style, validate }: { fmt?, datefmt?, style?, validate?}): Promise<IFormatter>
	interface IFormatter {

		/**
		 * 
		 *         Return the creation time of the specified LogRecord as formatted text.
		 * 
		 *         This method should be called from format() by a formatter which
		 *         wants to make use of a formatted time. This method can be overridden
		 *         in formatters to provide for any specific requirement, but the
		 *         basic behaviour is as follows: if datefmt (a string) is specified,
		 *         it is used with time.strftime() to format the creation time of the
		 *         record. Otherwise, an ISO8601-like (or RFC 3339-like) format is used.
		 *         The resulting string is returned. This function uses a user-configurable
		 *         function to convert the creation time to a tuple. By default,
		 *         time.localtime() is used; to change this for a particular formatter
		 *         instance, set the 'converter' attribute to a function with the same
		 *         signature as time.localtime() or time.gmtime(). To change it for all
		 *         formatters, for example if you want all logging times to be shown in GMT,
		 *         set the 'converter' attribute in the Formatter class.
		 *         
		 */
		formatTime(record, datefmt?): Promise<any>
		formatTime$({ record, datefmt }: { record, datefmt?}): Promise<any>

		/**
		 * 
		 *         Format and return the specified exception information as a string.
		 * 
		 *         This default implementation just uses
		 *         traceback.print_exception()
		 *         
		 */
		formatException(ei): Promise<any>
		formatException$({ ei }): Promise<any>

		/**
		 * 
		 *         Check if the format uses the creation time of the record.
		 *         
		 */
		usesTime(): Promise<any>
		usesTime$($: {}): Promise<any>
		formatMessage(record): Promise<any>
		formatMessage$({ record }): Promise<any>

		/**
		 * 
		 *         This method is provided as an extension point for specialized
		 *         formatting of stack information.
		 * 
		 *         The input data is a string as returned from a call to
		 *         :func:`traceback.print_stack`, but with the last trailing newline
		 *         removed.
		 * 
		 *         The base implementation just returns the value passed in.
		 *         
		 */
		formatStack(stack_info): Promise<any>
		formatStack$({ stack_info }): Promise<any>

		/**
		 * 
		 *         Format the specified record as text.
		 * 
		 *         The record's attribute dictionary is used as the operand to a
		 *         string formatting operation which yields the returned string.
		 *         Before formatting the dictionary, a couple of preparatory steps
		 *         are carried out. The message attribute of the record is computed
		 *         using LogRecord.getMessage(). If the formatting string uses the
		 *         time (as determined by a call to usesTime(), formatTime() is
		 *         called to format the event time. If there is exception information,
		 *         it is formatted using formatException() and appended to the message.
		 *         
		 */
		format(record): Promise<any>
		format$({ record }): Promise<any>
		converter
		default_time_format
		default_msec_format
	}

	/**
	 * 
	 *     A formatter suitable for formatting a number of records.
	 *     
	 */

	/**
	 * 
	 *         Optionally specify a formatter which will be used to format each
	 *         individual record.
	 *         
	 */
	function BufferingFormatter(linefmt?): Promise<IBufferingFormatter>
	function BufferingFormatter$({ linefmt }: { linefmt?}): Promise<IBufferingFormatter>
	interface IBufferingFormatter {

		/**
		 * 
		 *         Return the header string for the specified records.
		 *         
		 */
		formatHeader(records): Promise<any>
		formatHeader$({ records }): Promise<any>

		/**
		 * 
		 *         Return the footer string for the specified records.
		 *         
		 */
		formatFooter(records): Promise<any>
		formatFooter$({ records }): Promise<any>

		/**
		 * 
		 *         Format the specified records and return the result as a string.
		 *         
		 */
		format(records): Promise<any>
		format$({ records }): Promise<any>
	}

	/**
	 * 
	 *     Filter instances are used to perform arbitrary filtering of LogRecords.
	 * 
	 *     Loggers and Handlers can optionally use Filter instances to filter
	 *     records as desired. The base filter class only allows events which are
	 *     below a certain point in the logger hierarchy. For example, a filter
	 *     initialized with "A.B" will allow events logged by loggers "A.B",
	 *     "A.B.C", "A.B.C.D", "A.B.D" etc. but not "A.BB", "B.A.B" etc. If
	 *     initialized with the empty string, all events are passed.
	 *     
	 */

	/**
	 * 
	 *         Initialize a filter.
	 * 
	 *         Initialize with the name of the logger which, together with its
	 *         children, will have its events allowed through the filter. If no
	 *         name is specified, allow every event.
	 *         
	 */
	function Filter(name?): Promise<IFilter>
	function Filter$({ name }: { name?}): Promise<IFilter>
	interface IFilter {

		/**
		 * 
		 *         Determine if the specified record is to be logged.
		 * 
		 *         Returns True if the record should be logged, or False otherwise.
		 *         If deemed appropriate, the record may be modified in-place.
		 *         
		 */
		filter(record): Promise<any>
		filter$({ record }): Promise<any>
	}

	/**
	 * 
	 *     A base class for loggers and handlers which allows them to share
	 *     common code.
	 *     
	 */

	/**
	 * 
	 *         Initialize the list of filters to be an empty list.
	 *         
	 */
	function Filterer(): Promise<IFilterer>
	function Filterer$({ }): Promise<IFilterer>
	interface IFilterer {

		/**
		 * 
		 *         Add the specified filter to this handler.
		 *         
		 */
		addFilter(filter): Promise<any>
		addFilter$({ filter }): Promise<any>

		/**
		 * 
		 *         Remove the specified filter from this handler.
		 *         
		 */
		removeFilter(filter): Promise<any>
		removeFilter$({ filter }): Promise<any>

		/**
		 * 
		 *         Determine if a record is loggable by consulting all the filters.
		 * 
		 *         The default is to allow the record to be logged; any filter can veto
		 *         this and the record is then dropped. Returns a zero value if a record
		 *         is to be dropped, else non-zero.
		 * 
		 *         .. versionchanged:: 3.2
		 * 
		 *            Allow filters to be just callables.
		 *         
		 */
		filter(record): Promise<any>
		filter$({ record }): Promise<any>
	}

	/**
	 * 
	 *     Handler instances dispatch logging events to specific destinations.
	 * 
	 *     The base handler class. Acts as a placeholder which defines the Handler
	 *     interface. Handlers can optionally use Formatter instances to format
	 *     records as desired. By default, no formatter is specified; in this case,
	 *     the 'raw' message as determined by record.message is logged.
	 *     
	 */

	/**
	 * 
	 *         Initializes the instance - basically setting the formatter to None
	 *         and the filter list to empty.
	 *         
	 */
	function Handler(level?): Promise<IHandler>
	function Handler$({ level }: { level?}): Promise<IHandler>
	interface IHandler extends IFilterer {
		get_name(): Promise<any>
		get_name$($: {}): Promise<any>
		set_name(name): Promise<any>
		set_name$({ name }): Promise<any>

		/**
		 * 
		 *         Acquire a thread lock for serializing access to the underlying I/O.
		 *         
		 */
		createLock(): Promise<any>
		createLock$($: {}): Promise<any>

		/**
		 * 
		 *         Acquire the I/O thread lock.
		 *         
		 */
		acquire(): Promise<any>
		acquire$($: {}): Promise<any>

		/**
		 * 
		 *         Release the I/O thread lock.
		 *         
		 */
		release(): Promise<any>
		release$($: {}): Promise<any>

		/**
		 * 
		 *         Set the logging level of this handler.  level must be an int or a str.
		 *         
		 */
		setLevel(level): Promise<any>
		setLevel$({ level }): Promise<any>

		/**
		 * 
		 *         Format the specified record.
		 * 
		 *         If a formatter is set, use it. Otherwise, use the default formatter
		 *         for the module.
		 *         
		 */
		format(record): Promise<any>
		format$({ record }): Promise<any>

		/**
		 * 
		 *         Do whatever it takes to actually log the specified logging record.
		 * 
		 *         This version is intended to be implemented by subclasses and so
		 *         raises a NotImplementedError.
		 *         
		 */
		emit(record): Promise<any>
		emit$({ record }): Promise<any>

		/**
		 * 
		 *         Conditionally emit the specified logging record.
		 * 
		 *         Emission depends on filters which may have been added to the handler.
		 *         Wrap the actual emission of the record with acquisition/release of
		 *         the I/O thread lock. Returns whether the filter passed the record for
		 *         emission.
		 *         
		 */
		handle(record): Promise<any>
		handle$({ record }): Promise<any>

		/**
		 * 
		 *         Set the formatter for this handler.
		 *         
		 */
		setFormatter(fmt): Promise<any>
		setFormatter$({ fmt }): Promise<any>

		/**
		 * 
		 *         Ensure all logging output has been flushed.
		 * 
		 *         This version does nothing and is intended to be implemented by
		 *         subclasses.
		 *         
		 */
		flush(): Promise<any>
		flush$($: {}): Promise<any>

		/**
		 * 
		 *         Tidy up any resources used by the handler.
		 * 
		 *         This version removes the handler from an internal map of handlers,
		 *         _handlers, which is used for handler lookup by name. Subclasses
		 *         should ensure that this gets called from overridden close()
		 *         methods.
		 *         
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>

		/**
		 * 
		 *         Handle errors which occur during an emit() call.
		 * 
		 *         This method should be called from handlers when an exception is
		 *         encountered during an emit() call. If raiseExceptions is false,
		 *         exceptions get silently ignored. This is what is mostly wanted
		 *         for a logging system - most users will not care about errors in
		 *         the logging system, they are more interested in application errors.
		 *         You could, however, replace this with a custom handler if you wish.
		 *         The record which was being processed is passed in to this method.
		 *         
		 */
		handleError(record): Promise<any>
		handleError$({ record }): Promise<any>
		name
	}

	/**
	 * 
	 *     A handler class which writes logging records, appropriately formatted,
	 *     to a stream. Note that this class does not close the stream, as
	 *     sys.stdout or sys.stderr may be used.
	 *     
	 */

	/**
	 * 
	 *         Initialize the handler.
	 * 
	 *         If stream is not specified, sys.stderr is used.
	 *         
	 */
	function StreamHandler(stream?): Promise<IStreamHandler>
	function StreamHandler$({ stream }: { stream?}): Promise<IStreamHandler>
	interface IStreamHandler extends IHandler {

		/**
		 * 
		 *         Flushes the stream.
		 *         
		 */
		flush(): Promise<any>
		flush$($: {}): Promise<any>

		/**
		 * 
		 *         Emit a record.
		 * 
		 *         If a formatter is specified, it is used to format the record.
		 *         The record is then written to the stream with a trailing newline.  If
		 *         exception information is present, it is formatted using
		 *         traceback.print_exception and appended to the stream.  If the stream
		 *         has an 'encoding' attribute, it is used to determine how to do the
		 *         output to the stream.
		 *         
		 */
		emit(record): Promise<any>
		emit$({ record }): Promise<any>

		/**
		 * 
		 *         Sets the StreamHandler's stream to the specified value,
		 *         if it is different.
		 * 
		 *         Returns the old stream, if the stream was changed, or None
		 *         if it wasn't.
		 *         
		 */
		setStream(stream): Promise<any>
		setStream$({ stream }): Promise<any>
		terminator
	}

	/**
	 * 
	 *     A handler class which writes formatted logging records to disk files.
	 *     
	 */

	/**
	 * 
	 *         Open the specified file and use it as the stream for logging.
	 *         
	 */
	function FileHandler(filename, mode?, encoding?, delay?: boolean, errors?): Promise<IFileHandler>
	function FileHandler$({ filename, mode, encoding, delay, errors }: { filename, mode?, encoding?, delay?, errors?}): Promise<IFileHandler>
	interface IFileHandler extends IStreamHandler {

		/**
		 * 
		 *         Closes the stream.
		 *         
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>

		/**
		 * 
		 *         Emit a record.
		 * 
		 *         If the stream was not opened because 'delay' was specified in the
		 *         constructor, open it before calling the superclass's emit.
		 *         
		 */
		emit(record): Promise<any>
		emit$({ record }): Promise<any>
	}

	/**
	 * 
	 *     This class is like a StreamHandler using sys.stderr, but always uses
	 *     whatever sys.stderr is currently set to rather than the value of
	 *     sys.stderr at handler construction time.
	 *     
	 */
	interface I_StderrHandler extends IStreamHandler {
		stream(): Promise<any>
		stream$($: {}): Promise<any>
	}

	/**
	 * 
	 *     PlaceHolder instances are used in the Manager logger hierarchy to take
	 *     the place of nodes for which no loggers have been defined. This class is
	 *     intended for internal use only and not as part of the public API.
	 *     
	 */

	/**
	 * 
	 *         Initialize with the specified logger being a child of this placeholder.
	 *         
	 */
	function PlaceHolder(alogger): Promise<IPlaceHolder>
	function PlaceHolder$({ alogger }): Promise<IPlaceHolder>
	interface IPlaceHolder {

		/**
		 * 
		 *         Add the specified logger as a child of this placeholder.
		 *         
		 */
		append(alogger): Promise<any>
		append$({ alogger }): Promise<any>
	}

	/**
	 * 
	 *     There is [under normal circumstances] just one Manager instance, which
	 *     holds the hierarchy of loggers.
	 *     
	 */

	/**
	 * 
	 *         Initialize the manager with the root node of the logger hierarchy.
	 *         
	 */
	function Manager(rootnode): Promise<IManager>
	function Manager$({ rootnode }): Promise<IManager>
	interface IManager {
		disable(): Promise<any>
		disable$($: {}): Promise<any>
		disable(value): Promise<any>
		disable$({ value }): Promise<any>

		/**
		 * 
		 *         Get a logger with the specified name (channel name), creating it
		 *         if it doesn't yet exist. This name is a dot-separated hierarchical
		 *         name, such as "a", "a.b", "a.b.c" or similar.
		 * 
		 *         If a PlaceHolder existed for the specified name [i.e. the logger
		 *         didn't exist but a child of it did], replace it with the created
		 *         logger and fix up the parent/child references which pointed to the
		 *         placeholder to now point to the logger.
		 *         
		 */
		getLogger(name): Promise<any>
		getLogger$({ name }): Promise<any>

		/**
		 * 
		 *         Set the class to be used when instantiating a logger with this Manager.
		 *         
		 */
		setLoggerClass(klass): Promise<any>
		setLoggerClass$({ klass }): Promise<any>

		/**
		 * 
		 *         Set the factory to be used when instantiating a log record with this
		 *         Manager.
		 *         
		 */
		setLogRecordFactory(factory): Promise<any>
		setLogRecordFactory$({ factory }): Promise<any>
	}

	/**
	 * 
	 *     Instances of the Logger class represent a single logging channel. A
	 *     "logging channel" indicates an area of an application. Exactly how an
	 *     "area" is defined is up to the application developer. Since an
	 *     application can have any number of areas, logging channels are identified
	 *     by a unique string. Application areas can be nested (e.g. an area
	 *     of "input processing" might include sub-areas "read CSV files", "read
	 *     XLS files" and "read Gnumeric files"). To cater for this natural nesting,
	 *     channel names are organized into a namespace hierarchy where levels are
	 *     separated by periods, much like the Java or Python package namespace. So
	 *     in the instance given above, channel names might be "input" for the upper
	 *     level, and "input.csv", "input.xls" and "input.gnu" for the sub-levels.
	 *     There is no arbitrary limit to the depth of nesting.
	 *     
	 */

	/**
	 * 
	 *         Initialize the logger with a name and an optional level.
	 *         
	 */
	function Logger(name, level?): Promise<ILogger>
	function Logger$({ name, level }: { name, level?}): Promise<ILogger>
	interface ILogger extends IFilterer {

		/**
		 * 
		 *         Set the logging level of this logger.  level must be an int or a str.
		 *         
		 */
		setLevel(level): Promise<any>
		setLevel$({ level }): Promise<any>

		/**
		 * 
		 *         Log 'msg % args' with severity 'DEBUG'.
		 * 
		 *         To pass exception information, use the keyword argument exc_info with
		 *         a true value, e.g.
		 * 
		 *         logger.debug("Houston, we have a %s", "thorny problem", exc_info=1)
		 *         
		 */
		debug(msg): Promise<any>
		debug$({ msg }): Promise<any>

		/**
		 * 
		 *         Log 'msg % args' with severity 'INFO'.
		 * 
		 *         To pass exception information, use the keyword argument exc_info with
		 *         a true value, e.g.
		 * 
		 *         logger.info("Houston, we have a %s", "interesting problem", exc_info=1)
		 *         
		 */
		info(msg): Promise<any>
		info$({ msg }): Promise<any>

		/**
		 * 
		 *         Log 'msg % args' with severity 'WARNING'.
		 * 
		 *         To pass exception information, use the keyword argument exc_info with
		 *         a true value, e.g.
		 * 
		 *         logger.warning("Houston, we have a %s", "bit of a problem", exc_info=1)
		 *         
		 */
		warning(msg): Promise<any>
		warning$({ msg }): Promise<any>
		warn(msg): Promise<any>
		warn$({ msg }): Promise<any>

		/**
		 * 
		 *         Log 'msg % args' with severity 'ERROR'.
		 * 
		 *         To pass exception information, use the keyword argument exc_info with
		 *         a true value, e.g.
		 * 
		 *         logger.error("Houston, we have a %s", "major problem", exc_info=1)
		 *         
		 */
		error(msg): Promise<any>
		error$({ msg }): Promise<any>

		/**
		 * 
		 *         Convenience method for logging an ERROR with exception information.
		 *         
		 */
		exception(msg): Promise<any>
		exception$({ msg }): Promise<any>

		/**
		 * 
		 *         Log 'msg % args' with severity 'CRITICAL'.
		 * 
		 *         To pass exception information, use the keyword argument exc_info with
		 *         a true value, e.g.
		 * 
		 *         logger.critical("Houston, we have a %s", "major disaster", exc_info=1)
		 *         
		 */
		critical(msg): Promise<any>
		critical$({ msg }): Promise<any>

		/**
		 * 
		 *         Don't use this method, use critical() instead.
		 *         
		 */
		fatal(msg): Promise<any>
		fatal$({ msg }): Promise<any>

		/**
		 * 
		 *         Log 'msg % args' with the integer severity 'level'.
		 * 
		 *         To pass exception information, use the keyword argument exc_info with
		 *         a true value, e.g.
		 * 
		 *         logger.log(level, "We have a %s", "mysterious problem", exc_info=1)
		 *         
		 */
		log(level, msg): Promise<any>
		log$({ level, msg }): Promise<any>

		/**
		 * 
		 *         Find the stack frame of the caller so that we can note the source
		 *         file name, line number and function name.
		 *         
		 */
		findCaller(stack_info?: boolean, stacklevel?): Promise<any>
		findCaller$({ stack_info, stacklevel }: { stack_info?, stacklevel?}): Promise<any>

		/**
		 * 
		 *         A factory method which can be overridden in subclasses to create
		 *         specialized LogRecords.
		 *         
		 */
		makeRecord(name, level, fn, lno, msg, args, exc_info, func?, extra?, sinfo?): Promise<any>
		makeRecord$({ name, level, fn, lno, msg, args, exc_info, func, extra, sinfo }: { name, level, fn, lno, msg, args, exc_info, func?, extra?, sinfo?}): Promise<any>

		/**
		 * 
		 *         Call the handlers for the specified record.
		 * 
		 *         This method is used for unpickled records received from a socket, as
		 *         well as those created locally. Logger-level filtering is applied.
		 *         
		 */
		handle(record): Promise<any>
		handle$({ record }): Promise<any>

		/**
		 * 
		 *         Add the specified handler to this logger.
		 *         
		 */
		addHandler(hdlr): Promise<any>
		addHandler$({ hdlr }): Promise<any>

		/**
		 * 
		 *         Remove the specified handler from this logger.
		 *         
		 */
		removeHandler(hdlr): Promise<any>
		removeHandler$({ hdlr }): Promise<any>

		/**
		 * 
		 *         See if this logger has any handlers configured.
		 * 
		 *         Loop through all handlers for this logger and its parents in the
		 *         logger hierarchy. Return True if a handler was found, else False.
		 *         Stop searching up the hierarchy whenever a logger with the "propagate"
		 *         attribute set to zero is found - that will be the last logger which
		 *         is checked for the existence of handlers.
		 *         
		 */
		hasHandlers(): Promise<any>
		hasHandlers$($: {}): Promise<any>

		/**
		 * 
		 *         Pass a record to all relevant handlers.
		 * 
		 *         Loop through all handlers for this logger and its parents in the
		 *         logger hierarchy. If no handler was found, output a one-off error
		 *         message to sys.stderr. Stop searching up the hierarchy whenever a
		 *         logger with the "propagate" attribute set to zero is found - that
		 *         will be the last logger whose handlers are called.
		 *         
		 */
		callHandlers(record): Promise<any>
		callHandlers$({ record }): Promise<any>

		/**
		 * 
		 *         Get the effective level for this logger.
		 * 
		 *         Loop through this logger and its parents in the logger hierarchy,
		 *         looking for a non-zero logging level. Return the first one found.
		 *         
		 */
		getEffectiveLevel(): Promise<any>
		getEffectiveLevel$($: {}): Promise<any>

		/**
		 * 
		 *         Is this logger enabled for level 'level'?
		 *         
		 */
		isEnabledFor(level): Promise<any>
		isEnabledFor$({ level }): Promise<any>

		/**
		 * 
		 *         Get a logger which is a descendant to this one.
		 * 
		 *         This is a convenience method, such that
		 * 
		 *         logging.getLogger('abc').getChild('def.ghi')
		 * 
		 *         is the same as
		 * 
		 *         logging.getLogger('abc.def.ghi')
		 * 
		 *         It's useful, for example, when the parent logger is named using
		 *         __name__ rather than a literal string.
		 *         
		 */
		getChild(suffix): Promise<any>
		getChild$({ suffix }): Promise<any>
	}

	/**
	 * 
	 *     A root logger is not that different to any other logger, except that
	 *     it must have a logging level and there is only one instance of it in
	 *     the hierarchy.
	 *     
	 */

	/**
	 * 
	 *         Initialize the logger with the name "root".
	 *         
	 */
	function RootLogger(level): Promise<IRootLogger>
	function RootLogger$({ level }): Promise<IRootLogger>
	interface IRootLogger extends ILogger {
	}

	/**
	 * 
	 *     An adapter for loggers which makes it easier to specify contextual
	 *     information in logging output.
	 *     
	 */

	/**
	 * 
	 *         Initialize the adapter with a logger and a dict-like object which
	 *         provides contextual information. This constructor signature allows
	 *         easy stacking of LoggerAdapters, if so desired.
	 * 
	 *         You can effectively pass keyword arguments as shown in the
	 *         following example:
	 * 
	 *         adapter = LoggerAdapter(someLogger, dict(p1=v1, p2="v2"))
	 *         
	 */
	function LoggerAdapter(logger, extra?): Promise<ILoggerAdapter>
	function LoggerAdapter$({ logger, extra }: { logger, extra?}): Promise<ILoggerAdapter>
	interface ILoggerAdapter {

		/**
		 * 
		 *         Process the logging message and keyword arguments passed in to
		 *         a logging call to insert contextual information. You can either
		 *         manipulate the message itself, the keyword args or both. Return
		 *         the message and kwargs modified (or not) to suit your needs.
		 * 
		 *         Normally, you'll only need to override this one method in a
		 *         LoggerAdapter subclass for your specific needs.
		 *         
		 */
		process(msg, kwargs): Promise<any>
		process$({ msg, kwargs }): Promise<any>

		/**
		 * 
		 *         Delegate a debug call to the underlying logger.
		 *         
		 */
		debug(msg): Promise<any>
		debug$({ msg }): Promise<any>

		/**
		 * 
		 *         Delegate an info call to the underlying logger.
		 *         
		 */
		info(msg): Promise<any>
		info$({ msg }): Promise<any>

		/**
		 * 
		 *         Delegate a warning call to the underlying logger.
		 *         
		 */
		warning(msg): Promise<any>
		warning$({ msg }): Promise<any>
		warn(msg): Promise<any>
		warn$({ msg }): Promise<any>

		/**
		 * 
		 *         Delegate an error call to the underlying logger.
		 *         
		 */
		error(msg): Promise<any>
		error$({ msg }): Promise<any>

		/**
		 * 
		 *         Delegate an exception call to the underlying logger.
		 *         
		 */
		exception(msg): Promise<any>
		exception$({ msg }): Promise<any>

		/**
		 * 
		 *         Delegate a critical call to the underlying logger.
		 *         
		 */
		critical(msg): Promise<any>
		critical$({ msg }): Promise<any>

		/**
		 * 
		 *         Delegate a log call to the underlying logger, after adding
		 *         contextual information from this adapter instance.
		 *         
		 */
		log(level, msg): Promise<any>
		log$({ level, msg }): Promise<any>

		/**
		 * 
		 *         Is this logger enabled for level 'level'?
		 *         
		 */
		isEnabledFor(level): Promise<any>
		isEnabledFor$({ level }): Promise<any>

		/**
		 * 
		 *         Set the specified level on the underlying logger.
		 *         
		 */
		setLevel(level): Promise<any>
		setLevel$({ level }): Promise<any>

		/**
		 * 
		 *         Get the effective level for the underlying logger.
		 *         
		 */
		getEffectiveLevel(): Promise<any>
		getEffectiveLevel$($: {}): Promise<any>

		/**
		 * 
		 *         See if the underlying logger has any handlers.
		 *         
		 */
		hasHandlers(): Promise<any>
		hasHandlers$($: {}): Promise<any>
		manager(): Promise<any>
		manager$($: {}): Promise<any>
		manager(value): Promise<any>
		manager$({ value }): Promise<any>
		name(): Promise<any>
		name$($: {}): Promise<any>
	}

	/**
	 * 
	 *     This handler does nothing. It's intended to be used to avoid the
	 *     "No handlers could be found for logger XXX" one-off warning. This is
	 *     important for library code, which may contain code to log events. If a user
	 *     of the library does not configure logging, the one-off warning might be
	 *     produced; to avoid this, the library developer simply needs to instantiate
	 *     a NullHandler and add it to the top-level logger of the library module or
	 *     package.
	 *     
	 */
	interface INullHandler extends IHandler {

		/**
		 * Stub.
		 */
		handle(record): Promise<any>
		handle$({ record }): Promise<any>

		/**
		 * Stub.
		 */
		emit(record): Promise<any>
		emit$({ record }): Promise<any>
		createLock(): Promise<any>
		createLock$($: {}): Promise<any>
	}
	let raiseExceptions: Promise<any>
	let logThreads: Promise<any>
	let logMultiprocessing: Promise<any>
	let logProcesses: Promise<any>
	let CRITICAL: Promise<any>
	let FATAL: Promise<any>
	let ERROR: Promise<any>
	let WARNING: Promise<any>
	let WARN: Promise<any>
	let INFO: Promise<any>
	let DEBUG: Promise<any>
	let NOTSET: Promise<any>
	let BASIC_FORMAT: Promise<any>
	let lastResort: Promise<any>
	let root: Promise<any>
	module config {
		var _

		/**
		 * 
		 *     Read the logging configuration from a ConfigParser-format file.
		 * 
		 *     This can be called several times from an application, allowing an end user
		 *     the ability to select from various pre-canned configurations (if the
		 *     developer provides a mechanism to present the choices and load the chosen
		 *     configuration).
		 *     
		 */
		function fileConfig(fname, defaults?, disable_existing_loggers?: boolean, encoding?): Promise<any>
		function fileConfig$({ fname, defaults, disable_existing_loggers, encoding }: { fname, defaults?, disable_existing_loggers?, encoding?}): Promise<any>
		function valid_ident(s): Promise<any>
		function valid_ident$({ s }): Promise<any>

		/**
		 * Configure logging using a dictionary.
		 */
		function dictConfig(config): Promise<any>
		function dictConfig$({ config }): Promise<any>

		/**
		 * 
		 *     Start up a socket server on the specified port, and listen for new
		 *     configurations.
		 * 
		 *     These will be sent as a file suitable for processing by fileConfig().
		 *     Returns a Thread object on which you can call start() to start the server,
		 *     and which you can join() when appropriate. To stop the server, call
		 *     stopListening().
		 * 
		 *     Use the ``verify`` argument to verify any bytes received across the wire
		 *     from a client. If specified, it should be a callable which receives a
		 *     single argument - the bytes of configuration data received across the
		 *     network - and it should return either ``None``, to indicate that the
		 *     passed in bytes could not be verified and should be discarded, or a
		 *     byte string which is then passed to the configuration machinery as
		 *     normal. Note that you can return transformed bytes, e.g. by decrypting
		 *     the bytes passed in.
		 *     
		 */
		function listen(port?, verify?): Promise<any>
		function listen$({ port, verify }: { port?, verify?}): Promise<any>

		/**
		 * 
		 *     Stop the listening server which was created with a call to listen().
		 *     
		 */
		function stopListening(): Promise<any>
		function stopListening$($: {}): Promise<any>

		/**
		 * For ConvertingXXX's, this mixin class provides common functions
		 */
		interface IConvertingMixin {
			convert_with_key(key, value, replace?: boolean): Promise<any>
			convert_with_key$({ key, value, replace }: { key, value, replace?}): Promise<any>
			convert(value): Promise<any>
			convert$({ value }): Promise<any>
		}

		/**
		 * A converting dictionary wrapper.
		 */
		interface IConvertingDict extends IConvertingMixin {
			get(key, def?): Promise<any>
			get$({ key, def }: { key, def?}): Promise<any>
			pop(key, def?): Promise<any>
			pop$({ key, def }: { key, def?}): Promise<any>
		}

		/**
		 * A converting list wrapper.
		 */
		interface IConvertingList extends IConvertingMixin {
			pop(idx?): Promise<any>
			pop$({ idx }: { idx?}): Promise<any>
		}

		/**
		 * A converting tuple wrapper.
		 */
		interface IConvertingTuple extends IConvertingMixin {
		}

		/**
		 * 
		 *     The configurator base class which defines some useful defaults.
		 *     
		 */
		function BaseConfigurator(config): Promise<IBaseConfigurator>
		function BaseConfigurator$({ config }): Promise<IBaseConfigurator>
		interface IBaseConfigurator {

			/**
			 * 
			 *         Resolve strings to objects using standard import and attribute
			 *         syntax.
			 *         
			 */
			resolve(s): Promise<any>
			resolve$({ s }): Promise<any>

			/**
			 * Default converter for the ext:// protocol.
			 */
			ext_convert(value): Promise<any>
			ext_convert$({ value }): Promise<any>

			/**
			 * Default converter for the cfg:// protocol.
			 */
			cfg_convert(value): Promise<any>
			cfg_convert$({ value }): Promise<any>

			/**
			 * 
			 *         Convert values to an appropriate type. dicts, lists and tuples are
			 *         replaced by their converting alternatives. Strings are checked to
			 *         see if they have a conversion format and are converted if they do.
			 *         
			 */
			convert(value): Promise<any>
			convert$({ value }): Promise<any>

			/**
			 * Configure an object with a user-supplied factory.
			 */
			configure_custom(config): Promise<any>
			configure_custom$({ config }): Promise<any>

			/**
			 * Utility function which converts lists to tuples.
			 */
			as_tuple(value): Promise<any>
			as_tuple$({ value }): Promise<any>
			CONVERT_PATTERN
			WORD_PATTERN
			DOT_PATTERN
			INDEX_PATTERN
			DIGIT_PATTERN
			value_converters
			importer
		}

		/**
		 * 
		 *     Configure logging using a dictionary-like object to describe the
		 *     configuration.
		 *     
		 */
		interface IDictConfigurator extends IBaseConfigurator {

			/**
			 * Do the configuration.
			 */
			configure(): Promise<any>
			configure$($: {}): Promise<any>

			/**
			 * Configure a formatter from a dictionary.
			 */
			configure_formatter(config): Promise<any>
			configure_formatter$({ config }): Promise<any>

			/**
			 * Configure a filter from a dictionary.
			 */
			configure_filter(config): Promise<any>
			configure_filter$({ config }): Promise<any>

			/**
			 * Add filters to a filterer from a list of names.
			 */
			add_filters(filterer, filters): Promise<any>
			add_filters$({ filterer, filters }): Promise<any>

			/**
			 * Configure a handler from a dictionary.
			 */
			configure_handler(config): Promise<any>
			configure_handler$({ config }): Promise<any>

			/**
			 * Add handlers to a logger from a list of names.
			 */
			add_handlers(logger, handlers): Promise<any>
			add_handlers$({ logger, handlers }): Promise<any>

			/**
			 * 
			 *         Perform configuration which is common to root and non-root loggers.
			 *         
			 */
			common_logger_config(logger, config, incremental?: boolean): Promise<any>
			common_logger_config$({ logger, config, incremental }: { logger, config, incremental?}): Promise<any>

			/**
			 * Configure a non-root logger from a dictionary.
			 */
			configure_logger(name, config, incremental?: boolean): Promise<any>
			configure_logger$({ name, config, incremental }: { name, config, incremental?}): Promise<any>

			/**
			 * Configure a root logger from a dictionary.
			 */
			configure_root(config, incremental?: boolean): Promise<any>
			configure_root$({ config, incremental }: { config, incremental?}): Promise<any>
		}
		let DEFAULT_LOGGING_CONFIG_PORT: Promise<any>
		let RESET_ERROR: Promise<any>
		let IDENTIFIER: Promise<any>
		let dictConfigClass: Promise<any>
	}
	module handlers {
		var _

		/**
		 * 
		 *     Base class for handlers that rotate log files at a certain point.
		 *     Not meant to be instantiated directly.  Instead, use RotatingFileHandler
		 *     or TimedRotatingFileHandler.
		 *     
		 */

		/**
		 * 
		 *         Use the specified filename for streamed logging
		 *         
		 */
		function BaseRotatingHandler(filename, mode, encoding?, delay?: boolean, errors?): Promise<IBaseRotatingHandler>
		function BaseRotatingHandler$({ filename, mode, encoding, delay, errors }: { filename, mode, encoding?, delay?, errors?}): Promise<IBaseRotatingHandler>
		interface IBaseRotatingHandler {

			/**
			 * 
			 *         Emit a record.
			 * 
			 *         Output the record to the file, catering for rollover as described
			 *         in doRollover().
			 *         
			 */
			emit(record): Promise<any>
			emit$({ record }): Promise<any>

			/**
			 * 
			 *         Modify the filename of a log file when rotating.
			 * 
			 *         This is provided so that a custom filename can be provided.
			 * 
			 *         The default implementation calls the 'namer' attribute of the
			 *         handler, if it's callable, passing the default name to
			 *         it. If the attribute isn't callable (the default is None), the name
			 *         is returned unchanged.
			 * 
			 *         :param default_name: The default name for the log file.
			 *         
			 */
			rotation_filename(default_name): Promise<any>
			rotation_filename$({ default_name }): Promise<any>

			/**
			 * 
			 *         When rotating, rotate the current log.
			 * 
			 *         The default implementation calls the 'rotator' attribute of the
			 *         handler, if it's callable, passing the source and dest arguments to
			 *         it. If the attribute isn't callable (the default is None), the source
			 *         is simply renamed to the destination.
			 * 
			 *         :param source: The source filename. This is normally the base
			 *                        filename, e.g. 'test.log'
			 *         :param dest:   The destination filename. This is normally
			 *                        what the source is rotated to, e.g. 'test.log.1'.
			 *         
			 */
			rotate(source, dest): Promise<any>
			rotate$({ source, dest }): Promise<any>
			namer
			rotator
		}

		/**
		 * 
		 *     Handler for logging to a set of files, which switches from one file
		 *     to the next when the current file reaches a certain size.
		 *     
		 */

		/**
		 * 
		 *         Open the specified file and use it as the stream for logging.
		 * 
		 *         By default, the file grows indefinitely. You can specify particular
		 *         values of maxBytes and backupCount to allow the file to rollover at
		 *         a predetermined size.
		 * 
		 *         Rollover occurs whenever the current log file is nearly maxBytes in
		 *         length. If backupCount is >= 1, the system will successively create
		 *         new files with the same pathname as the base file, but with extensions
		 *         ".1", ".2" etc. appended to it. For example, with a backupCount of 5
		 *         and a base file name of "app.log", you would get "app.log",
		 *         "app.log.1", "app.log.2", ... through to "app.log.5". The file being
		 *         written to is always "app.log" - when it gets filled up, it is closed
		 *         and renamed to "app.log.1", and if files "app.log.1", "app.log.2" etc.
		 *         exist, then they are renamed to "app.log.2", "app.log.3" etc.
		 *         respectively.
		 * 
		 *         If maxBytes is zero, rollover never occurs.
		 *         
		 */
		function RotatingFileHandler(filename, mode?, maxBytes?, backupCount?, encoding?, delay?: boolean, errors?): Promise<IRotatingFileHandler>
		function RotatingFileHandler$({ filename, mode, maxBytes, backupCount, encoding, delay, errors }: { filename, mode?, maxBytes?, backupCount?, encoding?, delay?, errors?}): Promise<IRotatingFileHandler>
		interface IRotatingFileHandler extends IBaseRotatingHandler {

			/**
			 * 
			 *         Do a rollover, as described in __init__().
			 *         
			 */
			doRollover(): Promise<any>
			doRollover$($: {}): Promise<any>

			/**
			 * 
			 *         Determine if rollover should occur.
			 * 
			 *         Basically, see if the supplied record would cause the file to exceed
			 *         the size limit we have.
			 *         
			 */
			shouldRollover(record): Promise<any>
			shouldRollover$({ record }): Promise<any>
		}

		/**
		 * 
		 *     Handler for logging to a file, rotating the log file at certain timed
		 *     intervals.
		 * 
		 *     If backupCount is > 0, when rollover is done, no more than backupCount
		 *     files are kept - the oldest ones are deleted.
		 *     
		 */
		function TimedRotatingFileHandler(filename, when?, interval?, backupCount?, encoding?, delay?: boolean, utc?: boolean, atTime?, errors?): Promise<ITimedRotatingFileHandler>
		function TimedRotatingFileHandler$({ filename, when, interval, backupCount, encoding, delay, utc, atTime, errors }: { filename, when?, interval?, backupCount?, encoding?, delay?, utc?, atTime?, errors?}): Promise<ITimedRotatingFileHandler>
		interface ITimedRotatingFileHandler extends IBaseRotatingHandler {

			/**
			 * 
			 *         Work out the rollover time based on the specified time.
			 *         
			 */
			computeRollover(currentTime): Promise<any>
			computeRollover$({ currentTime }): Promise<any>

			/**
			 * 
			 *         Determine if rollover should occur.
			 * 
			 *         record is not used, as we are just comparing times, but it is needed so
			 *         the method signatures are the same
			 *         
			 */
			shouldRollover(record): Promise<any>
			shouldRollover$({ record }): Promise<any>

			/**
			 * 
			 *         Determine the files to delete when rolling over.
			 * 
			 *         More specific than the earlier method, which just used glob.glob().
			 *         
			 */
			getFilesToDelete(): Promise<any>
			getFilesToDelete$($: {}): Promise<any>

			/**
			 * 
			 *         do a rollover; in this case, a date/time stamp is appended to the filename
			 *         when the rollover happens.  However, you want the file to be named for the
			 *         start of the interval, not the current time.  If there is a backup count,
			 *         then we have to get a list of matching filenames, sort them and remove
			 *         the one with the oldest suffix.
			 *         
			 */
			doRollover(): Promise<any>
			doRollover$($: {}): Promise<any>
		}

		/**
		 * 
		 *     A handler for logging to a file, which watches the file
		 *     to see if it has changed while in use. This can happen because of
		 *     usage of programs such as newsyslog and logrotate which perform
		 *     log file rotation. This handler, intended for use under Unix,
		 *     watches the file to see if it has changed since the last emit.
		 *     (A file has changed if its device or inode have changed.)
		 *     If it has changed, the old file stream is closed, and the file
		 *     opened to get a new stream.
		 * 
		 *     This handler is not appropriate for use under Windows, because
		 *     under Windows open files cannot be moved or renamed - logging
		 *     opens the files with exclusive locks - and so there is no need
		 *     for such a handler. Furthermore, ST_INO is not supported under
		 *     Windows; stat always returns zero for this value.
		 * 
		 *     This handler is based on a suggestion and patch by Chad J.
		 *     Schroeder.
		 *     
		 */
		function WatchedFileHandler(filename, mode?, encoding?, delay?: boolean, errors?): Promise<IWatchedFileHandler>
		function WatchedFileHandler$({ filename, mode, encoding, delay, errors }: { filename, mode?, encoding?, delay?, errors?}): Promise<IWatchedFileHandler>
		interface IWatchedFileHandler {

			/**
			 * 
			 *         Reopen log file if needed.
			 * 
			 *         Checks if the underlying file has changed, and if it
			 *         has, close the old stream and reopen the file to get the
			 *         current stream.
			 *         
			 */
			reopenIfNeeded(): Promise<any>
			reopenIfNeeded$($: {}): Promise<any>

			/**
			 * 
			 *         Emit a record.
			 * 
			 *         If underlying file has changed, reopen the file before emitting the
			 *         record to it.
			 *         
			 */
			emit(record): Promise<any>
			emit$({ record }): Promise<any>
		}

		/**
		 * 
		 *     A handler class which writes logging records, in pickle format, to
		 *     a streaming socket. The socket is kept open across logging calls.
		 *     If the peer resets it, an attempt is made to reconnect on the next call.
		 *     The pickle which is sent is that of the LogRecord's attribute dictionary
		 *     (__dict__), so that the receiver does not need to have the logging module
		 *     installed in order to process the logging event.
		 * 
		 *     To unpickle the record at the receiving end into a LogRecord, use the
		 *     makeLogRecord function.
		 *     
		 */

		/**
		 * 
		 *         Initializes the handler with a specific host address and port.
		 * 
		 *         When the attribute *closeOnError* is set to True - if a socket error
		 *         occurs, the socket is silently closed and then reopened on the next
		 *         logging call.
		 *         
		 */
		function SocketHandler(host, port): Promise<ISocketHandler>
		function SocketHandler$({ host, port }): Promise<ISocketHandler>
		interface ISocketHandler {

			/**
			 * 
			 *         A factory method which allows subclasses to define the precise
			 *         type of socket they want.
			 *         
			 */
			makeSocket(timeout?): Promise<any>
			makeSocket$({ timeout }: { timeout?}): Promise<any>

			/**
			 * 
			 *         Try to create a socket, using an exponential backoff with
			 *         a max retry time. Thanks to Robert Olson for the original patch
			 *         (SF #815911) which has been slightly refactored.
			 *         
			 */
			createSocket(): Promise<any>
			createSocket$($: {}): Promise<any>

			/**
			 * 
			 *         Send a pickled string to the socket.
			 * 
			 *         This function allows for partial sends which can happen when the
			 *         network is busy.
			 *         
			 */
			send(s): Promise<any>
			send$({ s }): Promise<any>

			/**
			 * 
			 *         Pickles the record in binary format with a length prefix, and
			 *         returns it ready for transmission across the socket.
			 *         
			 */
			makePickle(record): Promise<any>
			makePickle$({ record }): Promise<any>

			/**
			 * 
			 *         Handle an error during logging.
			 * 
			 *         An error has occurred during logging. Most likely cause -
			 *         connection lost. Close the socket so that we can retry on the
			 *         next event.
			 *         
			 */
			handleError(record): Promise<any>
			handleError$({ record }): Promise<any>

			/**
			 * 
			 *         Emit a record.
			 * 
			 *         Pickles the record and writes it to the socket in binary format.
			 *         If there is an error with the socket, silently drop the packet.
			 *         If there was a problem with the socket, re-establishes the
			 *         socket.
			 *         
			 */
			emit(record): Promise<any>
			emit$({ record }): Promise<any>

			/**
			 * 
			 *         Closes the socket.
			 *         
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>
		}

		/**
		 * 
		 *     A handler class which writes logging records, in pickle format, to
		 *     a datagram socket.  The pickle which is sent is that of the LogRecord's
		 *     attribute dictionary (__dict__), so that the receiver does not need to
		 *     have the logging module installed in order to process the logging event.
		 * 
		 *     To unpickle the record at the receiving end into a LogRecord, use the
		 *     makeLogRecord function.
		 * 
		 *     
		 */

		/**
		 * 
		 *         Initializes the handler with a specific host address and port.
		 *         
		 */
		function DatagramHandler(host, port): Promise<IDatagramHandler>
		function DatagramHandler$({ host, port }): Promise<IDatagramHandler>
		interface IDatagramHandler extends ISocketHandler {

			/**
			 * 
			 *         The factory method of SocketHandler is here overridden to create
			 *         a UDP socket (SOCK_DGRAM).
			 *         
			 */
			makeSocket(): Promise<any>
			makeSocket$($: {}): Promise<any>

			/**
			 * 
			 *         Send a pickled string to a socket.
			 * 
			 *         This function no longer allows for partial sends which can happen
			 *         when the network is busy - UDP does not guarantee delivery and
			 *         can deliver packets out of sequence.
			 *         
			 */
			send(s): Promise<any>
			send$({ s }): Promise<any>
		}

		/**
		 * 
		 *     A handler class which sends formatted logging records to a syslog
		 *     server. Based on Sam Rushing's syslog module:
		 *     http://www.nightmare.com/squirl/python-ext/misc/syslog.py
		 *     Contributed by Nicolas Untz (after which minor refactoring changes
		 *     have been made).
		 *     
		 */

		/**
		 * 
		 *         Initialize a handler.
		 * 
		 *         If address is specified as a string, a UNIX socket is used. To log to a
		 *         local syslogd, "SysLogHandler(address="/dev/log")" can be used.
		 *         If facility is not specified, LOG_USER is used. If socktype is
		 *         specified as socket.SOCK_DGRAM or socket.SOCK_STREAM, that specific
		 *         socket type will be used. For Unix sockets, you can also specify a
		 *         socktype of None, in which case socket.SOCK_DGRAM will be used, falling
		 *         back to socket.SOCK_STREAM.
		 *         
		 */
		function SysLogHandler(address?, facility?, socktype?): Promise<ISysLogHandler>
		function SysLogHandler$({ address, facility, socktype }: { address?, facility?, socktype?}): Promise<ISysLogHandler>
		interface ISysLogHandler {

			/**
			 * 
			 *         Encode the facility and priority. You can pass in strings or
			 *         integers - if strings are passed, the facility_names and
			 *         priority_names mapping dictionaries are used to convert them to
			 *         integers.
			 *         
			 */
			encodePriority(facility, priority): Promise<any>
			encodePriority$({ facility, priority }): Promise<any>

			/**
			 * 
			 *         Closes the socket.
			 *         
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * 
			 *         Map a logging level name to a key in the priority_names map.
			 *         This is useful in two scenarios: when custom levels are being
			 *         used, and in the case where you can't do a straightforward
			 *         mapping by lowercasing the logging level name because of locale-
			 *         specific issues (see SF #1524081).
			 *         
			 */
			mapPriority(levelName): Promise<any>
			mapPriority$({ levelName }): Promise<any>

			/**
			 * 
			 *         Emit a record.
			 * 
			 *         The record is formatted, and then sent to the syslog server. If
			 *         exception information is present, it is NOT sent to the server.
			 *         
			 */
			emit(record): Promise<any>
			emit$({ record }): Promise<any>
			LOG_EMERG
			LOG_ALERT
			LOG_CRIT
			LOG_ERR
			LOG_WARNING
			LOG_NOTICE
			LOG_INFO
			LOG_DEBUG
			LOG_KERN
			LOG_USER
			LOG_MAIL
			LOG_DAEMON
			LOG_AUTH
			LOG_SYSLOG
			LOG_LPR
			LOG_NEWS
			LOG_UUCP
			LOG_CRON
			LOG_AUTHPRIV
			LOG_FTP
			LOG_NTP
			LOG_SECURITY
			LOG_CONSOLE
			LOG_SOLCRON
			LOG_LOCAL0
			LOG_LOCAL1
			LOG_LOCAL2
			LOG_LOCAL3
			LOG_LOCAL4
			LOG_LOCAL5
			LOG_LOCAL6
			LOG_LOCAL7
			priority_names
			facility_names
			priority_map
			ident
			append_nul
		}

		/**
		 * 
		 *     A handler class which sends an SMTP email for each logging event.
		 *     
		 */

		/**
		 * 
		 *         Initialize the handler.
		 * 
		 *         Initialize the instance with the from and to addresses and subject
		 *         line of the email. To specify a non-standard SMTP port, use the
		 *         (host, port) tuple format for the mailhost argument. To specify
		 *         authentication credentials, supply a (username, password) tuple
		 *         for the credentials argument. To specify the use of a secure
		 *         protocol (TLS), pass in a tuple for the secure argument. This will
		 *         only be used when authentication credentials are supplied. The tuple
		 *         will be either an empty tuple, or a single-value tuple with the name
		 *         of a keyfile, or a 2-value tuple with the names of the keyfile and
		 *         certificate file. (This tuple is passed to the `starttls` method).
		 *         A timeout in seconds can be specified for the SMTP connection (the
		 *         default is one second).
		 *         
		 */
		function SMTPHandler(mailhost, fromaddr, toaddrs, subject, credentials?, secure?, timeout?): Promise<ISMTPHandler>
		function SMTPHandler$({ mailhost, fromaddr, toaddrs, subject, credentials, secure, timeout }: { mailhost, fromaddr, toaddrs, subject, credentials?, secure?, timeout?}): Promise<ISMTPHandler>
		interface ISMTPHandler {

			/**
			 * 
			 *         Determine the subject for the email.
			 * 
			 *         If you want to specify a subject line which is record-dependent,
			 *         override this method.
			 *         
			 */
			getSubject(record): Promise<any>
			getSubject$({ record }): Promise<any>

			/**
			 * 
			 *         Emit a record.
			 * 
			 *         Format the record and send it to the specified addressees.
			 *         
			 */
			emit(record): Promise<any>
			emit$({ record }): Promise<any>
		}

		/**
		 * 
		 *     A handler class which sends events to the NT Event Log. Adds a
		 *     registry entry for the specified application name. If no dllname is
		 *     provided, win32service.pyd (which contains some basic message
		 *     placeholders) is used. Note that use of these placeholders will make
		 *     your event logs big, as the entire message source is held in the log.
		 *     If you want slimmer logs, you have to pass in the name of your own DLL
		 *     which contains the message definitions you want to use in the event log.
		 *     
		 */
		function NTEventLogHandler(appname, dllname?, logtype?): Promise<INTEventLogHandler>
		function NTEventLogHandler$({ appname, dllname, logtype }: { appname, dllname?, logtype?}): Promise<INTEventLogHandler>
		interface INTEventLogHandler {

			/**
			 * 
			 *         Return the message ID for the event record. If you are using your
			 *         own messages, you could do this by having the msg passed to the
			 *         logger being an ID rather than a formatting string. Then, in here,
			 *         you could use a dictionary lookup to get the message ID. This
			 *         version returns 1, which is the base message ID in win32service.pyd.
			 *         
			 */
			getMessageID(record): Promise<any>
			getMessageID$({ record }): Promise<any>

			/**
			 * 
			 *         Return the event category for the record.
			 * 
			 *         Override this if you want to specify your own categories. This version
			 *         returns 0.
			 *         
			 */
			getEventCategory(record): Promise<any>
			getEventCategory$({ record }): Promise<any>

			/**
			 * 
			 *         Return the event type for the record.
			 * 
			 *         Override this if you want to specify your own types. This version does
			 *         a mapping using the handler's typemap attribute, which is set up in
			 *         __init__() to a dictionary which contains mappings for DEBUG, INFO,
			 *         WARNING, ERROR and CRITICAL. If you are using your own levels you will
			 *         either need to override this method or place a suitable dictionary in
			 *         the handler's typemap attribute.
			 *         
			 */
			getEventType(record): Promise<any>
			getEventType$({ record }): Promise<any>

			/**
			 * 
			 *         Emit a record.
			 * 
			 *         Determine the message ID, event category and event type. Then
			 *         log the message in the NT event log.
			 *         
			 */
			emit(record): Promise<any>
			emit$({ record }): Promise<any>

			/**
			 * 
			 *         Clean up this handler.
			 * 
			 *         You can remove the application name from the registry as a
			 *         source of event log entries. However, if you do this, you will
			 *         not be able to see the events as you intended in the Event Log
			 *         Viewer - it needs to be able to access the registry to get the
			 *         DLL name.
			 *         
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>
		}

		/**
		 * 
		 *     A class which sends records to a Web server, using either GET or
		 *     POST semantics.
		 *     
		 */

		/**
		 * 
		 *         Initialize the instance with the host, the request URL, and the method
		 *         ("GET" or "POST")
		 *         
		 */
		function HTTPHandler(host, url, method?, secure?: boolean, credentials?, context?): Promise<IHTTPHandler>
		function HTTPHandler$({ host, url, method, secure, credentials, context }: { host, url, method?, secure?, credentials?, context?}): Promise<IHTTPHandler>
		interface IHTTPHandler {

			/**
			 * 
			 *         Default implementation of mapping the log record into a dict
			 *         that is sent as the CGI data. Overwrite in your class.
			 *         Contributed by Franz Glasner.
			 *         
			 */
			mapLogRecord(record): Promise<any>
			mapLogRecord$({ record }): Promise<any>

			/**
			 * 
			 *         get a HTTP[S]Connection.
			 * 
			 *         Override when a custom connection is required, for example if
			 *         there is a proxy.
			 *         
			 */
			getConnection(host, secure): Promise<any>
			getConnection$({ host, secure }): Promise<any>

			/**
			 * 
			 *         Emit a record.
			 * 
			 *         Send the record to the Web server as a percent-encoded dictionary
			 *         
			 */
			emit(record): Promise<any>
			emit$({ record }): Promise<any>
		}

		/**
		 * 
		 *   A handler class which buffers logging records in memory. Whenever each
		 *   record is added to the buffer, a check is made to see if the buffer should
		 *   be flushed. If it should, then flush() is expected to do what's needed.
		 *     
		 */

		/**
		 * 
		 *         Initialize the handler with the buffer size.
		 *         
		 */
		function BufferingHandler(capacity): Promise<IBufferingHandler>
		function BufferingHandler$({ capacity }): Promise<IBufferingHandler>
		interface IBufferingHandler {

			/**
			 * 
			 *         Should the handler flush its buffer?
			 * 
			 *         Returns true if the buffer is up to capacity. This method can be
			 *         overridden to implement custom flushing strategies.
			 *         
			 */
			shouldFlush(record): Promise<any>
			shouldFlush$({ record }): Promise<any>

			/**
			 * 
			 *         Emit a record.
			 * 
			 *         Append the record. If shouldFlush() tells us to, call flush() to process
			 *         the buffer.
			 *         
			 */
			emit(record): Promise<any>
			emit$({ record }): Promise<any>

			/**
			 * 
			 *         Override to implement custom flushing behaviour.
			 * 
			 *         This version just zaps the buffer to empty.
			 *         
			 */
			flush(): Promise<any>
			flush$($: {}): Promise<any>

			/**
			 * 
			 *         Close the handler.
			 * 
			 *         This version just flushes and chains to the parent class' close().
			 *         
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>
		}

		/**
		 * 
		 *     A handler class which buffers logging records in memory, periodically
		 *     flushing them to a target handler. Flushing occurs whenever the buffer
		 *     is full, or when an event of a certain severity or greater is seen.
		 *     
		 */

		/**
		 * 
		 *         Initialize the handler with the buffer size, the level at which
		 *         flushing should occur and an optional target.
		 * 
		 *         Note that without a target being set either here or via setTarget(),
		 *         a MemoryHandler is no use to anyone!
		 * 
		 *         The ``flushOnClose`` argument is ``True`` for backward compatibility
		 *         reasons - the old behaviour is that when the handler is closed, the
		 *         buffer is flushed, even if the flush level hasn't been exceeded nor the
		 *         capacity exceeded. To prevent this, set ``flushOnClose`` to ``False``.
		 *         
		 */
		function MemoryHandler(capacity, flushLevel?, target?, flushOnClose?: boolean): Promise<IMemoryHandler>
		function MemoryHandler$({ capacity, flushLevel, target, flushOnClose }: { capacity, flushLevel?, target?, flushOnClose?}): Promise<IMemoryHandler>
		interface IMemoryHandler extends IBufferingHandler {

			/**
			 * 
			 *         Check for buffer full or a record at the flushLevel or higher.
			 *         
			 */
			shouldFlush(record): Promise<any>
			shouldFlush$({ record }): Promise<any>

			/**
			 * 
			 *         Set the target handler for this handler.
			 *         
			 */
			setTarget(target): Promise<any>
			setTarget$({ target }): Promise<any>

			/**
			 * 
			 *         For a MemoryHandler, flushing means just sending the buffered
			 *         records to the target, if there is one. Override if you want
			 *         different behaviour.
			 * 
			 *         The record buffer is also cleared by this operation.
			 *         
			 */
			flush(): Promise<any>
			flush$($: {}): Promise<any>

			/**
			 * 
			 *         Flush, if appropriately configured, set the target to None and lose the
			 *         buffer.
			 *         
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>
		}

		/**
		 * 
		 *     This handler sends events to a queue. Typically, it would be used together
		 *     with a multiprocessing Queue to centralise logging to file in one process
		 *     (in a multi-process application), so as to avoid file write contention
		 *     between processes.
		 * 
		 *     This code is new in Python 3.2, but this class can be copy pasted into
		 *     user code for use with earlier Python versions.
		 *     
		 */

		/**
		 * 
		 *         Initialise an instance, using the passed queue.
		 *         
		 */
		function QueueHandler(queue): Promise<IQueueHandler>
		function QueueHandler$({ queue }): Promise<IQueueHandler>
		interface IQueueHandler {

			/**
			 * 
			 *         Enqueue a record.
			 * 
			 *         The base implementation uses put_nowait. You may want to override
			 *         this method if you want to use blocking, timeouts or custom queue
			 *         implementations.
			 *         
			 */
			enqueue(record): Promise<any>
			enqueue$({ record }): Promise<any>

			/**
			 * 
			 *         Prepares a record for queuing. The object returned by this method is
			 *         enqueued.
			 * 
			 *         The base implementation formats the record to merge the message
			 *         and arguments, and removes unpickleable items from the record
			 *         in-place.
			 * 
			 *         You might want to override this method if you want to convert
			 *         the record to a dict or JSON string, or send a modified copy
			 *         of the record while leaving the original intact.
			 *         
			 */
			prepare(record): Promise<any>
			prepare$({ record }): Promise<any>

			/**
			 * 
			 *         Emit a record.
			 * 
			 *         Writes the LogRecord to the queue, preparing it for pickling first.
			 *         
			 */
			emit(record): Promise<any>
			emit$({ record }): Promise<any>
		}

		/**
		 * 
		 *     This class implements an internal threaded listener which watches for
		 *     LogRecords being added to a queue, removes them and passes them to a
		 *     list of handlers for processing.
		 *     
		 */

		/**
		 * 
		 *         Initialise an instance with the specified queue and
		 *         handlers.
		 *         
		 */
		function QueueListener(queue): Promise<IQueueListener>
		function QueueListener$({ queue }): Promise<IQueueListener>
		interface IQueueListener {

			/**
			 * 
			 *         Dequeue a record and return it, optionally blocking.
			 * 
			 *         The base implementation uses get. You may want to override this method
			 *         if you want to use timeouts or work with custom queue implementations.
			 *         
			 */
			dequeue(block): Promise<any>
			dequeue$({ block }): Promise<any>

			/**
			 * 
			 *         Start the listener.
			 * 
			 *         This starts up a background thread to monitor the queue for
			 *         LogRecords to process.
			 *         
			 */
			start(): Promise<any>
			start$($: {}): Promise<any>

			/**
			 * 
			 *         Prepare a record for handling.
			 * 
			 *         This method just returns the passed-in record. You may want to
			 *         override this method if you need to do any custom marshalling or
			 *         manipulation of the record before passing it to the handlers.
			 *         
			 */
			prepare(record): Promise<any>
			prepare$({ record }): Promise<any>

			/**
			 * 
			 *         Handle a record.
			 * 
			 *         This just loops through the handlers offering them the record
			 *         to handle.
			 *         
			 */
			handle(record): Promise<any>
			handle$({ record }): Promise<any>

			/**
			 * 
			 *         This is used to enqueue the sentinel record.
			 * 
			 *         The base implementation uses put_nowait. You may want to override this
			 *         method if you want to use timeouts or work with custom queue
			 *         implementations.
			 *         
			 */
			enqueue_sentinel(): Promise<any>
			enqueue_sentinel$($: {}): Promise<any>

			/**
			 * 
			 *         Stop the listener.
			 * 
			 *         This asks the thread to terminate, and then waits for it to do so.
			 *         Note that if you don't call this before your application exits, there
			 *         may be some records still left on the queue, which won't be processed.
			 *         
			 */
			stop(): Promise<any>
			stop$($: {}): Promise<any>
		}
		let DEFAULT_TCP_LOGGING_PORT: Promise<any>
		let DEFAULT_UDP_LOGGING_PORT: Promise<any>
		let DEFAULT_HTTP_LOGGING_PORT: Promise<any>
		let DEFAULT_SOAP_LOGGING_PORT: Promise<any>
		let SYSLOG_UDP_PORT: Promise<any>
		let SYSLOG_TCP_PORT: Promise<any>
	}
}
declare module lzma {
	var _

	/**
	 * Open an LZMA-compressed file in binary or text mode.
	 * 
	 *     filename can be either an actual file name (given as a str, bytes,
	 *     or PathLike object), in which case the named file is opened, or it
	 *     can be an existing file object to read from or write to.
	 * 
	 *     The mode argument can be "r", "rb" (default), "w", "wb", "x", "xb",
	 *     "a", or "ab" for binary mode, or "rt", "wt", "xt", or "at" for text
	 *     mode.
	 * 
	 *     The format, check, preset and filters arguments specify the
	 *     compression settings, as for LZMACompressor, LZMADecompressor and
	 *     LZMAFile.
	 * 
	 *     For binary mode, this function is equivalent to the LZMAFile
	 *     constructor: LZMAFile(filename, mode, ...). In this case, the
	 *     encoding, errors and newline arguments must not be provided.
	 * 
	 *     For text mode, an LZMAFile object is created, and wrapped in an
	 *     io.TextIOWrapper instance with the specified encoding, error
	 *     handling behavior, and line ending(s).
	 * 
	 *     
	 */
	function open(filename, mode?): Promise<any>
	function open$({ filename, mode }: { filename, mode?}): Promise<any>

	/**
	 * Compress a block of data.
	 * 
	 *     Refer to LZMACompressor's docstring for a description of the
	 *     optional arguments *format*, *check*, *preset* and *filters*.
	 * 
	 *     For incremental compression, use an LZMACompressor instead.
	 *     
	 */
	function compress(data, format?, check?, preset?, filters?): Promise<any>
	function compress$({ data, format, check, preset, filters }: { data, format?, check?, preset?, filters?}): Promise<any>

	/**
	 * Decompress a block of data.
	 * 
	 *     Refer to LZMADecompressor's docstring for a description of the
	 *     optional arguments *format*, *check* and *filters*.
	 * 
	 *     For incremental decompression, use an LZMADecompressor instead.
	 *     
	 */
	function decompress(data, format?, memlimit?, filters?): Promise<any>
	function decompress$({ data, format, memlimit, filters }: { data, format?, memlimit?, filters?}): Promise<any>

	/**
	 * A file object providing transparent LZMA (de)compression.
	 * 
	 *     An LZMAFile can act as a wrapper for an existing file object, or
	 *     refer directly to a named file on disk.
	 * 
	 *     Note that LZMAFile provides a *binary* file interface - data read
	 *     is returned as bytes, and data to be written must be given as bytes.
	 *     
	 */

	/**
	 * Open an LZMA-compressed file in binary mode.
	 * 
	 *         filename can be either an actual file name (given as a str,
	 *         bytes, or PathLike object), in which case the named file is
	 *         opened, or it can be an existing file object to read from or
	 *         write to.
	 * 
	 *         mode can be "r" for reading (default), "w" for (over)writing,
	 *         "x" for creating exclusively, or "a" for appending. These can
	 *         equivalently be given as "rb", "wb", "xb" and "ab" respectively.
	 * 
	 *         format specifies the container format to use for the file.
	 *         If mode is "r", this defaults to FORMAT_AUTO. Otherwise, the
	 *         default is FORMAT_XZ.
	 * 
	 *         check specifies the integrity check to use. This argument can
	 *         only be used when opening a file for writing. For FORMAT_XZ,
	 *         the default is CHECK_CRC64. FORMAT_ALONE and FORMAT_RAW do not
	 *         support integrity checks - for these formats, check must be
	 *         omitted, or be CHECK_NONE.
	 * 
	 *         When opening a file for reading, the *preset* argument is not
	 *         meaningful, and should be omitted. The *filters* argument should
	 *         also be omitted, except when format is FORMAT_RAW (in which case
	 *         it is required).
	 * 
	 *         When opening a file for writing, the settings used by the
	 *         compressor can be specified either as a preset compression
	 *         level (with the *preset* argument), or in detail as a custom
	 *         filter chain (with the *filters* argument). For FORMAT_XZ and
	 *         FORMAT_ALONE, the default is to use the PRESET_DEFAULT preset
	 *         level. For FORMAT_RAW, the caller must always specify a filter
	 *         chain; the raw compressor does not support preset compression
	 *         levels.
	 * 
	 *         preset (if provided) should be an integer in the range 0-9,
	 *         optionally OR-ed with the constant PRESET_EXTREME.
	 * 
	 *         filters (if provided) should be a sequence of dicts. Each dict
	 *         should have an entry for "id" indicating ID of the filter, plus
	 *         additional entries for options to the filter.
	 *         
	 */
	function LZMAFile(filename?, mode?): Promise<ILZMAFile>
	function LZMAFile$({ filename, mode }: { filename?, mode?}): Promise<ILZMAFile>
	interface ILZMAFile {

		/**
		 * Flush and close the file.
		 * 
		 *         May be called more than once without error. Once the file is
		 *         closed, any other operation on it will raise a ValueError.
		 *         
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>

		/**
		 * True if this file is closed.
		 */
		closed(): Promise<any>
		closed$($: {}): Promise<any>

		/**
		 * Return the file descriptor for the underlying file.
		 */
		fileno(): Promise<any>
		fileno$($: {}): Promise<any>

		/**
		 * Return whether the file supports seeking.
		 */
		seekable(): Promise<any>
		seekable$($: {}): Promise<any>

		/**
		 * Return whether the file was opened for reading.
		 */
		readable(): Promise<any>
		readable$($: {}): Promise<any>

		/**
		 * Return whether the file was opened for writing.
		 */
		writable(): Promise<any>
		writable$($: {}): Promise<any>

		/**
		 * Return buffered data without advancing the file position.
		 * 
		 *         Always returns at least one byte of data, unless at EOF.
		 *         The exact number of bytes returned is unspecified.
		 *         
		 */
		peek(size?): Promise<any>
		peek$({ size }: { size?}): Promise<any>

		/**
		 * Read up to size uncompressed bytes from the file.
		 * 
		 *         If size is negative or omitted, read until EOF is reached.
		 *         Returns b"" if the file is already at EOF.
		 *         
		 */
		read(size?): Promise<any>
		read$({ size }: { size?}): Promise<any>

		/**
		 * Read up to size uncompressed bytes, while trying to avoid
		 *         making multiple reads from the underlying stream. Reads up to a
		 *         buffer's worth of data if size is negative.
		 * 
		 *         Returns b"" if the file is at EOF.
		 *         
		 */
		read1(size?): Promise<any>
		read1$({ size }: { size?}): Promise<any>

		/**
		 * Read a line of uncompressed bytes from the file.
		 * 
		 *         The terminating newline (if present) is retained. If size is
		 *         non-negative, no more than size bytes will be read (in which
		 *         case the line may be incomplete). Returns b'' if already at EOF.
		 *         
		 */
		readline(size?): Promise<any>
		readline$({ size }: { size?}): Promise<any>

		/**
		 * Write a bytes object to the file.
		 * 
		 *         Returns the number of uncompressed bytes written, which is
		 *         always len(data). Note that due to buffering, the file on disk
		 *         may not reflect the data written until close() is called.
		 *         
		 */
		write(data): Promise<any>
		write$({ data }): Promise<any>

		/**
		 * Change the file position.
		 * 
		 *         The new position is specified by offset, relative to the
		 *         position indicated by whence. Possible values for whence are:
		 * 
		 *             0: start of stream (default): offset must not be negative
		 *             1: current stream position
		 *             2: end of stream; offset must not be positive
		 * 
		 *         Returns the new file position.
		 * 
		 *         Note that seeking is emulated, so depending on the parameters,
		 *         this operation may be extremely slow.
		 *         
		 */
		seek(offset, whence?): Promise<any>
		seek$({ offset, whence }: { offset, whence?}): Promise<any>

		/**
		 * Return the current file position.
		 */
		tell(): Promise<any>
		tell$($: {}): Promise<any>
	}
}
declare module mailbox {
	var _

	/**
	 * A group of messages in a particular place.
	 */

	/**
	 * Initialize a Mailbox instance.
	 */
	function Mailbox(path, factory?, create?: boolean): Promise<IMailbox>
	function Mailbox$({ path, factory, create }: { path, factory?, create?}): Promise<IMailbox>
	interface IMailbox {

		/**
		 * Add message and return assigned key.
		 */
		add(message): Promise<any>
		add$({ message }): Promise<any>

		/**
		 * Remove the keyed message; raise KeyError if it doesn't exist.
		 */
		remove(key): Promise<any>
		remove$({ key }): Promise<any>

		/**
		 * If the keyed message exists, remove it.
		 */
		discard(key): Promise<any>
		discard$({ key }): Promise<any>

		/**
		 * Return the keyed message, or default if it doesn't exist.
		 */
		get(key, def?): Promise<any>
		get$({ key, def }: { key, def?}): Promise<any>

		/**
		 * Return a Message representation or raise a KeyError.
		 */
		get_message(key): Promise<any>
		get_message$({ key }): Promise<any>

		/**
		 * Return a string representation or raise a KeyError.
		 * 
		 *         Uses email.message.Message to create a 7bit clean string
		 *         representation of the message.
		 */
		get_string(key): Promise<any>
		get_string$({ key }): Promise<any>

		/**
		 * Return a byte string representation or raise a KeyError.
		 */
		get_bytes(key): Promise<any>
		get_bytes$({ key }): Promise<any>

		/**
		 * Return a file-like representation or raise a KeyError.
		 */
		get_file(key): Promise<any>
		get_file$({ key }): Promise<any>

		/**
		 * Return an iterator over keys.
		 */
		iterkeys(): Promise<any>
		iterkeys$($: {}): Promise<any>

		/**
		 * Return a list of keys.
		 */
		keys(): Promise<any>
		keys$($: {}): Promise<any>

		/**
		 * Return an iterator over all messages.
		 */
		itervalues(): Promise<any>
		itervalues$($: {}): Promise<any>

		/**
		 * Return a list of messages. Memory intensive.
		 */
		values(): Promise<any>
		values$($: {}): Promise<any>

		/**
		 * Return an iterator over (key, message) tuples.
		 */
		iteritems(): Promise<any>
		iteritems$($: {}): Promise<any>

		/**
		 * Return a list of (key, message) tuples. Memory intensive.
		 */
		items(): Promise<any>
		items$($: {}): Promise<any>

		/**
		 * Delete all messages.
		 */
		clear(): Promise<any>
		clear$($: {}): Promise<any>

		/**
		 * Delete the keyed message and return it, or default.
		 */
		pop(key, def?): Promise<any>
		pop$({ key, def }: { key, def?}): Promise<any>

		/**
		 * Delete an arbitrary (key, message) pair and return it.
		 */
		popitem(): Promise<any>
		popitem$($: {}): Promise<any>

		/**
		 * Change the messages that correspond to certain keys.
		 */
		update(arg?): Promise<any>
		update$({ arg }: { arg?}): Promise<any>

		/**
		 * Write any pending changes to the disk.
		 */
		flush(): Promise<any>
		flush$($: {}): Promise<any>

		/**
		 * Lock the mailbox.
		 */
		lock(): Promise<any>
		lock$($: {}): Promise<any>

		/**
		 * Unlock the mailbox if it is locked.
		 */
		unlock(): Promise<any>
		unlock$($: {}): Promise<any>

		/**
		 * Flush and close the mailbox.
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 * A qmail-style Maildir mailbox.
	 */

	/**
	 * Initialize a Maildir instance.
	 */
	function Maildir(dirname, factory?, create?: boolean): Promise<IMaildir>
	function Maildir$({ dirname, factory, create }: { dirname, factory?, create?}): Promise<IMaildir>
	interface IMaildir extends IMailbox {

		/**
		 * Add message and return assigned key.
		 */
		add(message): Promise<any>
		add$({ message }): Promise<any>

		/**
		 * Remove the keyed message; raise KeyError if it doesn't exist.
		 */
		remove(key): Promise<any>
		remove$({ key }): Promise<any>

		/**
		 * If the keyed message exists, remove it.
		 */
		discard(key): Promise<any>
		discard$({ key }): Promise<any>

		/**
		 * Return a Message representation or raise a KeyError.
		 */
		get_message(key): Promise<any>
		get_message$({ key }): Promise<any>

		/**
		 * Return a bytes representation or raise a KeyError.
		 */
		get_bytes(key): Promise<any>
		get_bytes$({ key }): Promise<any>

		/**
		 * Return a file-like representation or raise a KeyError.
		 */
		get_file(key): Promise<any>
		get_file$({ key }): Promise<any>

		/**
		 * Return an iterator over keys.
		 */
		iterkeys(): Promise<any>
		iterkeys$($: {}): Promise<any>

		/**
		 * Write any pending changes to disk.
		 */
		flush(): Promise<any>
		flush$($: {}): Promise<any>

		/**
		 * Lock the mailbox.
		 */
		lock(): Promise<any>
		lock$($: {}): Promise<any>

		/**
		 * Unlock the mailbox if it is locked.
		 */
		unlock(): Promise<any>
		unlock$($: {}): Promise<any>

		/**
		 * Flush and close the mailbox.
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>

		/**
		 * Return a list of folder names.
		 */
		list_folders(): Promise<any>
		list_folders$($: {}): Promise<any>

		/**
		 * Return a Maildir instance for the named folder.
		 */
		get_folder(folder): Promise<any>
		get_folder$({ folder }): Promise<any>

		/**
		 * Create a folder and return a Maildir instance representing it.
		 */
		add_folder(folder): Promise<any>
		add_folder$({ folder }): Promise<any>

		/**
		 * Delete the named folder, which must be empty.
		 */
		remove_folder(folder): Promise<any>
		remove_folder$({ folder }): Promise<any>

		/**
		 * Delete old files in "tmp".
		 */
		clean(): Promise<any>
		clean$($: {}): Promise<any>

		/**
		 * Return the next message in a one-time iteration.
		 */
		next(): Promise<any>
		next$($: {}): Promise<any>
		colon
	}

	/**
	 * A single-file mailbox.
	 */
	interface I_singlefileMailbox extends IMailbox {

		/**
		 * Add message and return assigned key.
		 */
		add(message): Promise<any>
		add$({ message }): Promise<any>

		/**
		 * Remove the keyed message; raise KeyError if it doesn't exist.
		 */
		remove(key): Promise<any>
		remove$({ key }): Promise<any>

		/**
		 * Return an iterator over keys.
		 */
		iterkeys(): Promise<any>
		iterkeys$($: {}): Promise<any>

		/**
		 * Lock the mailbox.
		 */
		lock(): Promise<any>
		lock$($: {}): Promise<any>

		/**
		 * Unlock the mailbox if it is locked.
		 */
		unlock(): Promise<any>
		unlock$($: {}): Promise<any>

		/**
		 * Write any pending changes to disk.
		 */
		flush(): Promise<any>
		flush$($: {}): Promise<any>

		/**
		 * Flush and close the mailbox.
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 * An mbox or MMDF mailbox.
	 */
	interface I_mboxMMDF extends I_singlefileMailbox {

		/**
		 * Return a Message representation or raise a KeyError.
		 */
		get_message(key): Promise<any>
		get_message$({ key }): Promise<any>

		/**
		 * Return a string representation or raise a KeyError.
		 */
		get_string(key, from_?: boolean): Promise<any>
		get_string$({ key, from_ }: { key, from_?}): Promise<any>

		/**
		 * Return a string representation or raise a KeyError.
		 */
		get_bytes(key, from_?: boolean): Promise<any>
		get_bytes$({ key, from_ }: { key, from_?}): Promise<any>

		/**
		 * Return a file-like representation or raise a KeyError.
		 */
		get_file(key, from_?: boolean): Promise<any>
		get_file$({ key, from_ }: { key, from_?}): Promise<any>
	}

	/**
	 * A classic mbox mailbox.
	 */

	/**
	 * Initialize an mbox mailbox.
	 */
	function mbox(path, factory?, create?: boolean): Promise<Imbox>
	function mbox$({ path, factory, create }: { path, factory?, create?}): Promise<Imbox>
	interface Imbox extends I_mboxMMDF {
	}

	/**
	 * An MMDF mailbox.
	 */

	/**
	 * Initialize an MMDF mailbox.
	 */
	function MMDF(path, factory?, create?: boolean): Promise<IMMDF>
	function MMDF$({ path, factory, create }: { path, factory?, create?}): Promise<IMMDF>
	interface IMMDF extends I_mboxMMDF {
	}

	/**
	 * An MH mailbox.
	 */

	/**
	 * Initialize an MH instance.
	 */
	function MH(path, factory?, create?: boolean): Promise<IMH>
	function MH$({ path, factory, create }: { path, factory?, create?}): Promise<IMH>
	interface IMH extends IMailbox {

		/**
		 * Add message and return assigned key.
		 */
		add(message): Promise<any>
		add$({ message }): Promise<any>

		/**
		 * Remove the keyed message; raise KeyError if it doesn't exist.
		 */
		remove(key): Promise<any>
		remove$({ key }): Promise<any>

		/**
		 * Return a Message representation or raise a KeyError.
		 */
		get_message(key): Promise<any>
		get_message$({ key }): Promise<any>

		/**
		 * Return a bytes representation or raise a KeyError.
		 */
		get_bytes(key): Promise<any>
		get_bytes$({ key }): Promise<any>

		/**
		 * Return a file-like representation or raise a KeyError.
		 */
		get_file(key): Promise<any>
		get_file$({ key }): Promise<any>

		/**
		 * Return an iterator over keys.
		 */
		iterkeys(): Promise<any>
		iterkeys$($: {}): Promise<any>

		/**
		 * Lock the mailbox.
		 */
		lock(): Promise<any>
		lock$($: {}): Promise<any>

		/**
		 * Unlock the mailbox if it is locked.
		 */
		unlock(): Promise<any>
		unlock$($: {}): Promise<any>

		/**
		 * Write any pending changes to the disk.
		 */
		flush(): Promise<any>
		flush$($: {}): Promise<any>

		/**
		 * Flush and close the mailbox.
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>

		/**
		 * Return a list of folder names.
		 */
		list_folders(): Promise<any>
		list_folders$($: {}): Promise<any>

		/**
		 * Return an MH instance for the named folder.
		 */
		get_folder(folder): Promise<any>
		get_folder$({ folder }): Promise<any>

		/**
		 * Create a folder and return an MH instance representing it.
		 */
		add_folder(folder): Promise<any>
		add_folder$({ folder }): Promise<any>

		/**
		 * Delete the named folder, which must be empty.
		 */
		remove_folder(folder): Promise<any>
		remove_folder$({ folder }): Promise<any>

		/**
		 * Return a name-to-key-list dictionary to define each sequence.
		 */
		get_sequences(): Promise<any>
		get_sequences$($: {}): Promise<any>

		/**
		 * Set sequences using the given name-to-key-list dictionary.
		 */
		set_sequences(sequences): Promise<any>
		set_sequences$({ sequences }): Promise<any>

		/**
		 * Re-name messages to eliminate numbering gaps. Invalidates keys.
		 */
		pack(): Promise<any>
		pack$($: {}): Promise<any>
	}

	/**
	 * An Rmail-style Babyl mailbox.
	 */

	/**
	 * Initialize a Babyl mailbox.
	 */
	function Babyl(path, factory?, create?: boolean): Promise<IBabyl>
	function Babyl$({ path, factory, create }: { path, factory?, create?}): Promise<IBabyl>
	interface IBabyl extends I_singlefileMailbox {

		/**
		 * Add message and return assigned key.
		 */
		add(message): Promise<any>
		add$({ message }): Promise<any>

		/**
		 * Remove the keyed message; raise KeyError if it doesn't exist.
		 */
		remove(key): Promise<any>
		remove$({ key }): Promise<any>

		/**
		 * Return a Message representation or raise a KeyError.
		 */
		get_message(key): Promise<any>
		get_message$({ key }): Promise<any>

		/**
		 * Return a string representation or raise a KeyError.
		 */
		get_bytes(key): Promise<any>
		get_bytes$({ key }): Promise<any>

		/**
		 * Return a file-like representation or raise a KeyError.
		 */
		get_file(key): Promise<any>
		get_file$({ key }): Promise<any>

		/**
		 * Return a list of user-defined labels in the mailbox.
		 */
		get_labels(): Promise<any>
		get_labels$($: {}): Promise<any>
	}

	/**
	 * Message with mailbox-format-specific properties.
	 */

	/**
	 * Initialize a Message instance.
	 */
	function Message(message?): Promise<IMessage>
	function Message$({ message }: { message?}): Promise<IMessage>
	interface IMessage {
	}

	/**
	 * Message with Maildir-specific properties.
	 */

	/**
	 * Initialize a MaildirMessage instance.
	 */
	function MaildirMessage(message?): Promise<IMaildirMessage>
	function MaildirMessage$({ message }: { message?}): Promise<IMaildirMessage>
	interface IMaildirMessage extends IMessage {

		/**
		 * Return 'new' or 'cur'.
		 */
		get_subdir(): Promise<any>
		get_subdir$($: {}): Promise<any>

		/**
		 * Set subdir to 'new' or 'cur'.
		 */
		set_subdir(subdir): Promise<any>
		set_subdir$({ subdir }): Promise<any>

		/**
		 * Return as a string the flags that are set.
		 */
		get_flags(): Promise<any>
		get_flags$($: {}): Promise<any>

		/**
		 * Set the given flags and unset all others.
		 */
		set_flags(flags): Promise<any>
		set_flags$({ flags }): Promise<any>

		/**
		 * Set the given flag(s) without changing others.
		 */
		add_flag(flag): Promise<any>
		add_flag$({ flag }): Promise<any>

		/**
		 * Unset the given string flag(s) without changing others.
		 */
		remove_flag(flag): Promise<any>
		remove_flag$({ flag }): Promise<any>

		/**
		 * Return delivery date of message, in seconds since the epoch.
		 */
		get_date(): Promise<any>
		get_date$($: {}): Promise<any>

		/**
		 * Set delivery date of message, in seconds since the epoch.
		 */
		set_date(date): Promise<any>
		set_date$({ date }): Promise<any>

		/**
		 * Get the message's "info" as a string.
		 */
		get_info(): Promise<any>
		get_info$($: {}): Promise<any>

		/**
		 * Set the message's "info" string.
		 */
		set_info(info): Promise<any>
		set_info$({ info }): Promise<any>
	}

	/**
	 * Message with mbox- or MMDF-specific properties.
	 */
	interface I_mboxMMDFMessage extends IMessage {

		/**
		 * Return contents of "From " line.
		 */
		get_from(): Promise<any>
		get_from$($: {}): Promise<any>

		/**
		 * Set "From " line, formatting and appending time_ if specified.
		 */
		set_from(from_, time_?): Promise<any>
		set_from$({ from_, time_ }: { from_, time_?}): Promise<any>

		/**
		 * Return as a string the flags that are set.
		 */
		get_flags(): Promise<any>
		get_flags$($: {}): Promise<any>

		/**
		 * Set the given flags and unset all others.
		 */
		set_flags(flags): Promise<any>
		set_flags$({ flags }): Promise<any>

		/**
		 * Set the given flag(s) without changing others.
		 */
		add_flag(flag): Promise<any>
		add_flag$({ flag }): Promise<any>

		/**
		 * Unset the given string flag(s) without changing others.
		 */
		remove_flag(flag): Promise<any>
		remove_flag$({ flag }): Promise<any>
	}

	/**
	 * Message with mbox-specific properties.
	 */
	interface ImboxMessage extends I_mboxMMDFMessage {
	}

	/**
	 * Message with MH-specific properties.
	 */

	/**
	 * Initialize an MHMessage instance.
	 */
	function MHMessage(message?): Promise<IMHMessage>
	function MHMessage$({ message }: { message?}): Promise<IMHMessage>
	interface IMHMessage extends IMessage {

		/**
		 * Return a list of sequences that include the message.
		 */
		get_sequences(): Promise<any>
		get_sequences$($: {}): Promise<any>

		/**
		 * Set the list of sequences that include the message.
		 */
		set_sequences(sequences): Promise<any>
		set_sequences$({ sequences }): Promise<any>

		/**
		 * Add sequence to list of sequences including the message.
		 */
		add_sequence(sequence): Promise<any>
		add_sequence$({ sequence }): Promise<any>

		/**
		 * Remove sequence from the list of sequences including the message.
		 */
		remove_sequence(sequence): Promise<any>
		remove_sequence$({ sequence }): Promise<any>
	}

	/**
	 * Message with Babyl-specific properties.
	 */

	/**
	 * Initialize a BabylMessage instance.
	 */
	function BabylMessage(message?): Promise<IBabylMessage>
	function BabylMessage$({ message }: { message?}): Promise<IBabylMessage>
	interface IBabylMessage extends IMessage {

		/**
		 * Return a list of labels on the message.
		 */
		get_labels(): Promise<any>
		get_labels$($: {}): Promise<any>

		/**
		 * Set the list of labels on the message.
		 */
		set_labels(labels): Promise<any>
		set_labels$({ labels }): Promise<any>

		/**
		 * Add label to list of labels on the message.
		 */
		add_label(label): Promise<any>
		add_label$({ label }): Promise<any>

		/**
		 * Remove label from the list of labels on the message.
		 */
		remove_label(label): Promise<any>
		remove_label$({ label }): Promise<any>

		/**
		 * Return a Message representation of visible headers.
		 */
		get_visible(): Promise<any>
		get_visible$($: {}): Promise<any>

		/**
		 * Set the Message representation of visible headers.
		 */
		set_visible(visible): Promise<any>
		set_visible$({ visible }): Promise<any>

		/**
		 * Update and/or sensibly generate a set of visible headers.
		 */
		update_visible(): Promise<any>
		update_visible$($: {}): Promise<any>
	}

	/**
	 * Message with MMDF-specific properties.
	 */
	interface IMMDFMessage extends I_mboxMMDFMessage {
	}

	/**
	 * A read-only wrapper of a file.
	 */
	interface I_ProxyFile {

		/**
		 * Read bytes.
		 */
		read(size?): Promise<any>
		read$({ size }: { size?}): Promise<any>

		/**
		 * Read bytes.
		 */
		read1(size?): Promise<any>
		read1$({ size }: { size?}): Promise<any>

		/**
		 * Read a line.
		 */
		readline(size?): Promise<any>
		readline$({ size }: { size?}): Promise<any>

		/**
		 * Read multiple lines.
		 */
		readlines(sizehint?): Promise<any>
		readlines$({ sizehint }: { sizehint?}): Promise<any>

		/**
		 * Return the position.
		 */
		tell(): Promise<any>
		tell$($: {}): Promise<any>

		/**
		 * Change position.
		 */
		seek(offset, whence?): Promise<any>
		seek$({ offset, whence }: { offset, whence?}): Promise<any>

		/**
		 * Close the file.
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>
		readable(): Promise<any>
		readable$($: {}): Promise<any>
		writable(): Promise<any>
		writable$($: {}): Promise<any>
		seekable(): Promise<any>
		seekable$($: {}): Promise<any>
		flush(): Promise<any>
		flush$($: {}): Promise<any>
		closed(): Promise<any>
		closed$($: {}): Promise<any>
	}

	/**
	 * A read-only wrapper of part of a file.
	 */
	interface I_PartialFile extends I_ProxyFile {

		/**
		 * Return the position with respect to start.
		 */
		tell(): Promise<any>
		tell$($: {}): Promise<any>

		/**
		 * Change position, possibly with respect to start or stop.
		 */
		seek(offset, whence?): Promise<any>
		seek$({ offset, whence }: { offset, whence?}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 * Raised for module-specific errors.
	 */
	interface IError {
	}

	/**
	 * The specified mailbox does not exist and won't be created.
	 */
	interface INoSuchMailboxError extends IError {
	}

	/**
	 * The specified mailbox is not empty and deletion was requested.
	 */
	interface INotEmptyError extends IError {
	}

	/**
	 * Another process caused an action to fail.
	 */
	interface IExternalClashError extends IError {
	}

	/**
	 * A file appears to have an invalid format.
	 */
	interface IFormatError extends IError {
	}
	let linesep: Promise<any>
}
declare module mailcap {
	var _
	function lineno_sort_key(entry): Promise<any>
	function lineno_sort_key$({ entry }): Promise<any>

	/**
	 * Return a dictionary containing the mailcap database.
	 * 
	 *     The dictionary maps a MIME type (in all lowercase, e.g. 'text/plain')
	 *     to a list of dictionaries corresponding to mailcap entries.  The list
	 *     collects all the entries for that MIME type from all available mailcap
	 *     files.  Each dictionary contains key-value pairs for that MIME type,
	 *     where the viewing command is stored with the key "view".
	 * 
	 *     
	 */
	function getcaps(): Promise<any>
	function getcaps$($: {}): Promise<any>

	/**
	 * Return a list of all mailcap files found on the system.
	 */
	function listmailcapfiles(): Promise<any>
	function listmailcapfiles$($: {}): Promise<any>

	/**
	 * Read a mailcap file and return a dictionary keyed by MIME type.
	 */
	function readmailcapfile(fp): Promise<any>
	function readmailcapfile$({ fp }): Promise<any>

	/**
	 * Parse one entry in a mailcap file and return a dictionary.
	 * 
	 *     The viewing command is stored as the value with the key "view",
	 *     and the rest of the fields produce key-value pairs in the dict.
	 *     
	 */
	function parseline(line): Promise<any>
	function parseline$({ line }): Promise<any>

	/**
	 * Separate one key-value pair in a mailcap entry.
	 */
	function parsefield(line, i, n): Promise<any>
	function parsefield$({ line, i, n }): Promise<any>

	/**
	 * Find a match for a mailcap entry.
	 * 
	 *     Return a tuple containing the command line, and the mailcap entry
	 *     used; (None, None) if no match is found.  This may invoke the
	 *     'test' command of several matching entries before deciding which
	 *     entry to use.
	 * 
	 *     
	 */
	function findmatch(caps, MIMEtype, key?, filename?, plist?): Promise<any>
	function findmatch$({ caps, MIMEtype, key, filename, plist }: { caps, MIMEtype, key?, filename?, plist?}): Promise<any>
	function lookup(caps, MIMEtype, key?): Promise<any>
	function lookup$({ caps, MIMEtype, key }: { caps, MIMEtype, key?}): Promise<any>
	function subst(field, MIMEtype, filename, plist?): Promise<any>
	function subst$({ field, MIMEtype, filename, plist }: { field, MIMEtype, filename, plist?}): Promise<any>
	function findparam(name, plist): Promise<any>
	function findparam$({ name, plist }): Promise<any>
	function test(): Promise<any>
	function test$($: {}): Promise<any>
	function show(caps): Promise<any>
	function show$({ caps }): Promise<any>
}
declare module mimetypes {
	var _

	/**
	 * Guess the type of a file based on its URL.
	 * 
	 *     Return value is a tuple (type, encoding) where type is None if the
	 *     type can't be guessed (no or unknown suffix) or a string of the
	 *     form type/subtype, usable for a MIME Content-type header; and
	 *     encoding is None for no encoding or the name of the program used
	 *     to encode (e.g. compress or gzip).  The mappings are table
	 *     driven.  Encoding suffixes are case sensitive; type suffixes are
	 *     first tried case sensitive, then case insensitive.
	 * 
	 *     The suffixes .tgz, .taz and .tz (case sensitive!) are all mapped
	 *     to ".tar.gz".  (This is table-driven too, using the dictionary
	 *     suffix_map).
	 * 
	 *     Optional `strict' argument when false adds a bunch of commonly found, but
	 *     non-standard types.
	 *     
	 */
	function guess_type(url, strict?: boolean): Promise<any>
	function guess_type$({ url, strict }: { url, strict?}): Promise<any>

	/**
	 * Guess the extensions for a file based on its MIME type.
	 * 
	 *     Return value is a list of strings giving the possible filename
	 *     extensions, including the leading dot ('.').  The extension is not
	 *     guaranteed to have been associated with any particular data
	 *     stream, but would be mapped to the MIME type `type' by
	 *     guess_type().  If no extension can be guessed for `type', None
	 *     is returned.
	 * 
	 *     Optional `strict' argument when false adds a bunch of commonly found,
	 *     but non-standard types.
	 *     
	 */
	function guess_all_extensions(type, strict?: boolean): Promise<any>
	function guess_all_extensions$({ type, strict }: { type, strict?}): Promise<any>

	/**
	 * Guess the extension for a file based on its MIME type.
	 * 
	 *     Return value is a string giving a filename extension, including the
	 *     leading dot ('.').  The extension is not guaranteed to have been
	 *     associated with any particular data stream, but would be mapped to the
	 *     MIME type `type' by guess_type().  If no extension can be guessed for
	 *     `type', None is returned.
	 * 
	 *     Optional `strict' argument when false adds a bunch of commonly found,
	 *     but non-standard types.
	 *     
	 */
	function guess_extension(type, strict?: boolean): Promise<any>
	function guess_extension$({ type, strict }: { type, strict?}): Promise<any>

	/**
	 * Add a mapping between a type and an extension.
	 * 
	 *     When the extension is already known, the new
	 *     type will replace the old one. When the type
	 *     is already known the extension will be added
	 *     to the list of known extensions.
	 * 
	 *     If strict is true, information will be added to
	 *     list of standard types, else to the list of non-standard
	 *     types.
	 *     
	 */
	function add_type(type, ext, strict?: boolean): Promise<any>
	function add_type$({ type, ext, strict }: { type, ext, strict?}): Promise<any>
	function init(files?): Promise<any>
	function init$({ files }: { files?}): Promise<any>
	function read_mime_types(file): Promise<any>
	function read_mime_types$({ file }): Promise<any>

	/**
	 * MIME-types datastore.
	 * 
	 *     This datastore can handle information from mime.types-style files
	 *     and supports basic determination of MIME type from a filename or
	 *     URL, and can guess a reasonable extension given a MIME type.
	 *     
	 */
	function MimeTypes(filenames?, strict?: boolean): Promise<IMimeTypes>
	function MimeTypes$({ filenames, strict }: { filenames?, strict?}): Promise<IMimeTypes>
	interface IMimeTypes {

		/**
		 * Add a mapping between a type and an extension.
		 * 
		 *         When the extension is already known, the new
		 *         type will replace the old one. When the type
		 *         is already known the extension will be added
		 *         to the list of known extensions.
		 * 
		 *         If strict is true, information will be added to
		 *         list of standard types, else to the list of non-standard
		 *         types.
		 *         
		 */
		add_type(type, ext, strict?: boolean): Promise<any>
		add_type$({ type, ext, strict }: { type, ext, strict?}): Promise<any>

		/**
		 * Guess the type of a file which is either a URL or a path-like object.
		 * 
		 *         Return value is a tuple (type, encoding) where type is None if
		 *         the type can't be guessed (no or unknown suffix) or a string
		 *         of the form type/subtype, usable for a MIME Content-type
		 *         header; and encoding is None for no encoding or the name of
		 *         the program used to encode (e.g. compress or gzip).  The
		 *         mappings are table driven.  Encoding suffixes are case
		 *         sensitive; type suffixes are first tried case sensitive, then
		 *         case insensitive.
		 * 
		 *         The suffixes .tgz, .taz and .tz (case sensitive!) are all
		 *         mapped to '.tar.gz'.  (This is table-driven too, using the
		 *         dictionary suffix_map.)
		 * 
		 *         Optional `strict' argument when False adds a bunch of commonly found,
		 *         but non-standard types.
		 *         
		 */
		guess_type(url, strict?: boolean): Promise<any>
		guess_type$({ url, strict }: { url, strict?}): Promise<any>

		/**
		 * Guess the extensions for a file based on its MIME type.
		 * 
		 *         Return value is a list of strings giving the possible filename
		 *         extensions, including the leading dot ('.').  The extension is not
		 *         guaranteed to have been associated with any particular data stream,
		 *         but would be mapped to the MIME type `type' by guess_type().
		 * 
		 *         Optional `strict' argument when false adds a bunch of commonly found,
		 *         but non-standard types.
		 *         
		 */
		guess_all_extensions(type, strict?: boolean): Promise<any>
		guess_all_extensions$({ type, strict }: { type, strict?}): Promise<any>

		/**
		 * Guess the extension for a file based on its MIME type.
		 * 
		 *         Return value is a string giving a filename extension,
		 *         including the leading dot ('.').  The extension is not
		 *         guaranteed to have been associated with any particular data
		 *         stream, but would be mapped to the MIME type `type' by
		 *         guess_type().  If no extension can be guessed for `type', None
		 *         is returned.
		 * 
		 *         Optional `strict' argument when false adds a bunch of commonly found,
		 *         but non-standard types.
		 *         
		 */
		guess_extension(type, strict?: boolean): Promise<any>
		guess_extension$({ type, strict }: { type, strict?}): Promise<any>

		/**
		 * 
		 *         Read a single mime.types-format file, specified by pathname.
		 * 
		 *         If strict is true, information will be added to
		 *         list of standard types, else to the list of non-standard
		 *         types.
		 *         
		 */
		read(filename, strict?: boolean): Promise<any>
		read$({ filename, strict }: { filename, strict?}): Promise<any>

		/**
		 * 
		 *         Read a single mime.types-format file.
		 * 
		 *         If strict is true, information will be added to
		 *         list of standard types, else to the list of non-standard
		 *         types.
		 *         
		 */
		readfp(fp, strict?: boolean): Promise<any>
		readfp$({ fp, strict }: { fp, strict?}): Promise<any>

		/**
		 * 
		 *         Load the MIME types database from Windows registry.
		 * 
		 *         If strict is true, information will be added to
		 *         list of standard types, else to the list of non-standard
		 *         types.
		 *         
		 */
		read_windows_registry(strict?: boolean): Promise<any>
		read_windows_registry$({ strict }: { strict?}): Promise<any>
	}
	let knownfiles: Promise<any>
	let inited: Promise<any>
}
declare module modulefinder {
	var _
	function AddPackagePath(packagename, path): Promise<any>
	function AddPackagePath$({ packagename, path }): Promise<any>
	function ReplacePackage(oldname, newname): Promise<any>
	function ReplacePackage$({ oldname, newname }): Promise<any>
	function test(): Promise<any>
	function test$($: {}): Promise<any>
	function Module(name, file?, path?): Promise<IModule>
	function Module$({ name, file, path }: { name, file?, path?}): Promise<IModule>
	interface IModule {
	}
	function ModuleFinder(path?, debug?, excludes?, replace_paths?): Promise<IModuleFinder>
	function ModuleFinder$({ path, debug, excludes, replace_paths }: { path?, debug?, excludes?, replace_paths?}): Promise<IModuleFinder>
	interface IModuleFinder {
		msg(level, str): Promise<any>
		msg$({ level, str }): Promise<any>
		msgin(): Promise<any>
		msgin$($: {}): Promise<any>
		msgout(): Promise<any>
		msgout$($: {}): Promise<any>
		run_script(pathname): Promise<any>
		run_script$({ pathname }): Promise<any>
		load_file(pathname): Promise<any>
		load_file$({ pathname }): Promise<any>
		import_hook(name, caller?, fromlist?, level?): Promise<any>
		import_hook$({ name, caller, fromlist, level }: { name, caller?, fromlist?, level?}): Promise<any>
		determine_parent(caller, level?): Promise<any>
		determine_parent$({ caller, level }: { caller, level?}): Promise<any>
		find_head_package(parent, name): Promise<any>
		find_head_package$({ parent, name }): Promise<any>
		load_tail(q, tail): Promise<any>
		load_tail$({ q, tail }): Promise<any>
		ensure_fromlist(m, fromlist, recursive?): Promise<any>
		ensure_fromlist$({ m, fromlist, recursive }: { m, fromlist, recursive?}): Promise<any>
		find_all_submodules(m): Promise<any>
		find_all_submodules$({ m }): Promise<any>
		import_module(partname, fqname, parent): Promise<any>
		import_module$({ partname, fqname, parent }): Promise<any>
		load_module(fqname, fp, pathname, file_info): Promise<any>
		load_module$({ fqname, fp, pathname, file_info }): Promise<any>
		scan_opcodes(co): Promise<any>
		scan_opcodes$({ co }): Promise<any>
		scan_code(co, m): Promise<any>
		scan_code$({ co, m }): Promise<any>
		load_package(fqname, pathname): Promise<any>
		load_package$({ fqname, pathname }): Promise<any>
		add_module(fqname): Promise<any>
		add_module$({ fqname }): Promise<any>
		find_module(name, path, parent?): Promise<any>
		find_module$({ name, path, parent }: { name, path, parent?}): Promise<any>

		/**
		 * Print a report to stdout, listing the found modules with their
		 *         paths, as well as modules that are missing, or seem to be missing.
		 *         
		 */
		report(): Promise<any>
		report$($: {}): Promise<any>

		/**
		 * Return a list of modules that appear to be missing. Use
		 *         any_missing_maybe() if you want to know which modules are
		 *         certain to be missing, and which *may* be missing.
		 *         
		 */
		any_missing(): Promise<any>
		any_missing$($: {}): Promise<any>

		/**
		 * Return two lists, one with modules that are certainly missing
		 *         and one with modules that *may* be missing. The latter names could
		 *         either be submodules *or* just global names in the package.
		 * 
		 *         The reason it can't always be determined is that it's impossible to
		 *         tell which names are imported when "from module import *" is done
		 *         with an extension module, short of actually importing it.
		 *         
		 */
		any_missing_maybe(): Promise<any>
		any_missing_maybe$($: {}): Promise<any>
		replace_paths_in_code(co): Promise<any>
		replace_paths_in_code$({ co }): Promise<any>
	}
	let LOAD_CONST: Promise<any>
	let IMPORT_NAME: Promise<any>
	let STORE_NAME: Promise<any>
	let STORE_GLOBAL: Promise<any>
	let STORE_OPS: Promise<any>
	let EXTENDED_ARG: Promise<any>
	let packagePathMap: Promise<any>
	let replacePackageMap: Promise<any>
	let mf: Promise<any>
}
declare module msilib {
	var _

	/**
	 * Change the sequence number of an action in a sequence list
	 */
	function change_sequence(seq, action, seqno?, cond?): Promise<any>
	function change_sequence$({ seq, action, seqno, cond }: { seq, action, seqno?, cond?}): Promise<any>
	function add_data(db, table, values): Promise<any>
	function add_data$({ db, table, values }): Promise<any>
	function add_stream(db, name, path): Promise<any>
	function add_stream$({ db, name, path }): Promise<any>
	function init_database(name, schema, ProductName, ProductCode, ProductVersion, Manufacturer): Promise<any>
	function init_database$({ name, schema, ProductName, ProductCode, ProductVersion, Manufacturer }): Promise<any>
	function add_tables(db, module): Promise<any>
	function add_tables$({ db, module }): Promise<any>
	function make_id(str): Promise<any>
	function make_id$({ str }): Promise<any>
	function gen_uuid(): Promise<any>
	function gen_uuid$($: {}): Promise<any>
	function Table(name): Promise<ITable>
	function Table$({ name }): Promise<ITable>
	interface ITable {
		add_field(index, name, type): Promise<any>
		add_field$({ index, name, type }): Promise<any>
		sql(): Promise<any>
		sql$($: {}): Promise<any>
		create(db): Promise<any>
		create$({ db }): Promise<any>
	}
	interface I_Unspecified {
	}
	function CAB(name): Promise<ICAB>
	function CAB$({ name }): Promise<ICAB>
	interface ICAB {
		gen_id(file): Promise<any>
		gen_id$({ file }): Promise<any>
		append(full, file, logical): Promise<any>
		append$({ full, file, logical }): Promise<any>
		commit(db): Promise<any>
		commit$({ db }): Promise<any>
	}

	/**
	 * Create a new directory in the Directory table. There is a current component
	 *         at each point in time for the directory, which is either explicitly created
	 *         through start_component, or implicitly when files are added for the first
	 *         time. Files are added into the current component, and into the cab file.
	 *         To create a directory, a base directory object needs to be specified (can be
	 *         None), the path to the physical directory, and a logical directory name.
	 *         Default specifies the DefaultDir slot in the directory table. componentflags
	 *         specifies the default flags that new components get.
	 */
	function Directory(db, cab, basedir, physical, _logical, def, componentflags?): Promise<IDirectory>
	function Directory$({ db, cab, basedir, physical, _logical, def, componentflags }: { db, cab, basedir, physical, _logical, def, componentflags?}): Promise<IDirectory>
	interface IDirectory {

		/**
		 * Add an entry to the Component table, and make this component the current for this
		 *         directory. If no component name is given, the directory name is used. If no feature
		 *         is given, the current feature is used. If no flags are given, the directory's default
		 *         flags are used. If no keyfile is given, the KeyPath is left null in the Component
		 *         table.
		 */
		start_component(component?, feature?, flags?, keyfile?, uuid?): Promise<any>
		start_component$({ component, feature, flags, keyfile, uuid }: { component?, feature?, flags?, keyfile?, uuid?}): Promise<any>
		make_short(file): Promise<any>
		make_short$({ file }): Promise<any>

		/**
		 * Add a file to the current component of the directory, starting a new one
		 *         if there is no current component. By default, the file name in the source
		 *         and the file table will be identical. If the src file is specified, it is
		 *         interpreted relative to the current directory. Optionally, a version and a
		 *         language can be specified for the entry in the File table.
		 */
		add_file(file, src?, version?, language?): Promise<any>
		add_file$({ file, src, version, language }: { file, src?, version?, language?}): Promise<any>

		/**
		 * Add a list of files to the current component as specified in the
		 *         glob pattern. Individual files can be excluded in the exclude list.
		 */
		glob(pattern, exclude?): Promise<any>
		glob$({ pattern, exclude }: { pattern, exclude?}): Promise<any>

		/**
		 * Remove .pyc files on uninstall
		 */
		remove_pyc(): Promise<any>
		remove_pyc$($: {}): Promise<any>
	}
	function Binary(fname): Promise<IBinary>
	function Binary$({ fname }): Promise<IBinary>
	interface IBinary {
	}
	function Feature(db, id, title, desc, display, level?, parent?, directory?, attributes?): Promise<IFeature>
	function Feature$({ db, id, title, desc, display, level, parent, directory, attributes }: { db, id, title, desc, display, level?, parent?, directory?, attributes?}): Promise<IFeature>
	interface IFeature {
		set_current(): Promise<any>
		set_current$($: {}): Promise<any>
	}
	function Control(dlg, name): Promise<IControl>
	function Control$({ dlg, name }): Promise<IControl>
	interface IControl {
		event(event, argument, condition?, ordering?): Promise<any>
		event$({ event, argument, condition, ordering }: { event, argument, condition?, ordering?}): Promise<any>
		mapping(event, attribute): Promise<any>
		mapping$({ event, attribute }): Promise<any>
		condition(action, condition): Promise<any>
		condition$({ action, condition }): Promise<any>
	}
	function RadioButtonGroup(dlg, name, property): Promise<IRadioButtonGroup>
	function RadioButtonGroup$({ dlg, name, property }): Promise<IRadioButtonGroup>
	interface IRadioButtonGroup extends IControl {
		add(name, x, y, w, h, text, value?): Promise<any>
		add$({ name, x, y, w, h, text, value }: { name, x, y, w, h, text, value?}): Promise<any>
	}
	function Dialog(db, name, x, y, w, h, attr, title, first, def, cancel): Promise<IDialog>
	function Dialog$({ db, name, x, y, w, h, attr, title, first, def, cancel }): Promise<IDialog>
	interface IDialog {
		control(name, type, x, y, w, h, attr, prop, text, next, help): Promise<any>
		control$({ name, type, x, y, w, h, attr, prop, text, next, help }): Promise<any>
		text(name, x, y, w, h, attr, text): Promise<any>
		text$({ name, x, y, w, h, attr, text }): Promise<any>
		bitmap(name, x, y, w, h, text): Promise<any>
		bitmap$({ name, x, y, w, h, text }): Promise<any>
		line(name, x, y, w, h): Promise<any>
		line$({ name, x, y, w, h }): Promise<any>
		pushbutton(name, x, y, w, h, attr, text, next): Promise<any>
		pushbutton$({ name, x, y, w, h, attr, text, next }): Promise<any>
		radiogroup(name, x, y, w, h, attr, prop, text, next): Promise<any>
		radiogroup$({ name, x, y, w, h, attr, prop, text, next }): Promise<any>
		checkbox(name, x, y, w, h, attr, prop, text, next): Promise<any>
		checkbox$({ name, x, y, w, h, attr, prop, text, next }): Promise<any>
	}
	let AMD64: Promise<any>
	let Win64: Promise<any>
	let datasizemask: Promise<any>
	let type_valid: Promise<any>
	let type_localizable: Promise<any>
	let typemask: Promise<any>
	let type_long: Promise<any>
	let type_short: Promise<any>
	let type_string: Promise<any>
	let type_binary: Promise<any>
	let type_nullable: Promise<any>
	let type_key: Promise<any>
	let knownbits: Promise<any>
	module schema {
		var _
		let ActionText: Promise<any>
		let AdminExecuteSequence: Promise<any>
		let Condition: Promise<any>
		let AdminUISequence: Promise<any>
		let AdvtExecuteSequence: Promise<any>
		let AdvtUISequence: Promise<any>
		let AppId: Promise<any>
		let AppSearch: Promise<any>
		let Property: Promise<any>
		let BBControl: Promise<any>
		let Billboard: Promise<any>
		let Feature: Promise<any>
		let Binary: Promise<any>
		let BindImage: Promise<any>
		let File: Promise<any>
		let CCPSearch: Promise<any>
		let CheckBox: Promise<any>
		let Class: Promise<any>
		let Component: Promise<any>
		let Icon: Promise<any>
		let ProgId: Promise<any>
		let ComboBox: Promise<any>
		let CompLocator: Promise<any>
		let Complus: Promise<any>
		let Directory: Promise<any>
		let Control: Promise<any>
		let Dialog: Promise<any>
		let ControlCondition: Promise<any>
		let ControlEvent: Promise<any>
		let CreateFolder: Promise<any>
		let CustomAction: Promise<any>
		let DrLocator: Promise<any>
		let DuplicateFile: Promise<any>
		let Environment: Promise<any>
		let Error: Promise<any>
		let EventMapping: Promise<any>
		let Extension: Promise<any>
		let MIME: Promise<any>
		let FeatureComponents: Promise<any>
		let FileSFPCatalog: Promise<any>
		let SFPCatalog: Promise<any>
		let Font: Promise<any>
		let IniFile: Promise<any>
		let IniLocator: Promise<any>
		let InstallExecuteSequence: Promise<any>
		let InstallUISequence: Promise<any>
		let IsolatedComponent: Promise<any>
		let LaunchCondition: Promise<any>
		let ListBox: Promise<any>
		let ListView: Promise<any>
		let LockPermissions: Promise<any>
		let Media: Promise<any>
		let MoveFile: Promise<any>
		let MsiAssembly: Promise<any>
		let MsiAssemblyName: Promise<any>
		let MsiDigitalCertificate: Promise<any>
		let MsiDigitalSignature: Promise<any>
		let MsiFileHash: Promise<any>
		let MsiPatchHeaders: Promise<any>
		let ODBCAttribute: Promise<any>
		let ODBCDriver: Promise<any>
		let ODBCDataSource: Promise<any>
		let ODBCSourceAttribute: Promise<any>
		let ODBCTranslator: Promise<any>
		let Patch: Promise<any>
		let PatchPackage: Promise<any>
		let PublishComponent: Promise<any>
		let RadioButton: Promise<any>
		let Registry: Promise<any>
		let RegLocator: Promise<any>
		let RemoveFile: Promise<any>
		let RemoveIniFile: Promise<any>
		let RemoveRegistry: Promise<any>
		let ReserveCost: Promise<any>
		let SelfReg: Promise<any>
		let ServiceControl: Promise<any>
		let ServiceInstall: Promise<any>
		let Shortcut: Promise<any>
		let Signature: Promise<any>
		let TextStyle: Promise<any>
		let TypeLib: Promise<any>
		let UIText: Promise<any>
		let Upgrade: Promise<any>
		let Verb: Promise<any>
		let tables: Promise<any>
	}
	module sequence {
		var _
		let AdminExecuteSequence: Promise<any>
		let AdminUISequence: Promise<any>
		let AdvtExecuteSequence: Promise<any>
		let InstallExecuteSequence: Promise<any>
		let InstallUISequence: Promise<any>
		let tables: Promise<any>
	}
	module text {
		var _
		let dirname: Promise<any>
		let ActionText: Promise<any>
		let UIText: Promise<any>
		let tables: Promise<any>
	}
}
declare module multiprocessing {
	var _
	let SUBDEBUG: Promise<any>
	let SUBWARNING: Promise<any>
	module connection {
		var _

		/**
		 * 
		 *     Return an arbitrary free address for the given family
		 *     
		 */
		function arbitrary_address(family): Promise<any>
		function arbitrary_address$({ family }): Promise<any>

		/**
		 * 
		 *     Return the types of the address
		 * 
		 *     This can be 'AF_INET', 'AF_UNIX', or 'AF_PIPE'
		 *     
		 */
		function address_type(address): Promise<any>
		function address_type$({ address }): Promise<any>

		/**
		 * 
		 *     Returns a connection to the address of a `Listener`
		 *     
		 */
		function Client(address, family?, authkey?): Promise<any>
		function Client$({ address, family, authkey }: { address, family?, authkey?}): Promise<any>

		/**
		 * 
		 *         Returns pair of connection objects at either end of a pipe
		 *         
		 */
		function Pipe(duplex?: boolean): Promise<any>
		function Pipe$({ duplex }: { duplex?}): Promise<any>

		/**
		 * 
		 *         Returns pair of connection objects at either end of a pipe
		 *         
		 */
		function Pipe(duplex?: boolean): Promise<any>
		function Pipe$({ duplex }: { duplex?}): Promise<any>

		/**
		 * 
		 *     Return a connection object connected to the socket given by `address`
		 *     
		 */
		function SocketClient(address): Promise<any>
		function SocketClient$({ address }): Promise<any>

		/**
		 * 
		 *         Return a connection object connected to the pipe given by `address`
		 *         
		 */
		function PipeClient(address): Promise<any>
		function PipeClient$({ address }): Promise<any>
		function deliver_challenge(connection, authkey): Promise<any>
		function deliver_challenge$({ connection, authkey }): Promise<any>
		function answer_challenge(connection, authkey): Promise<any>
		function answer_challenge$({ connection, authkey }): Promise<any>
		function XmlClient(): Promise<any>
		function XmlClient$($: {}): Promise<any>

		/**
		 * 
		 *         Wait till an object in object_list is ready/readable.
		 * 
		 *         Returns list of those objects in object_list which are ready/readable.
		 *         
		 */
		function wait(object_list, timeout?): Promise<any>
		function wait$({ object_list, timeout }: { object_list, timeout?}): Promise<any>

		/**
		 * 
		 *         Wait till an object in object_list is ready/readable.
		 * 
		 *         Returns list of those objects in object_list which are ready/readable.
		 *         
		 */
		function wait(object_list, timeout?): Promise<any>
		function wait$({ object_list, timeout }: { object_list, timeout?}): Promise<any>
		function reduce_connection(conn): Promise<any>
		function reduce_connection$({ conn }): Promise<any>
		function rebuild_connection(ds, readable, writable): Promise<any>
		function rebuild_connection$({ ds, readable, writable }): Promise<any>
		function reduce_pipe_connection(conn): Promise<any>
		function reduce_pipe_connection$({ conn }): Promise<any>
		function rebuild_pipe_connection(dh, readable, writable): Promise<any>
		function rebuild_pipe_connection$({ dh, readable, writable }): Promise<any>
		function reduce_connection(conn): Promise<any>
		function reduce_connection$({ conn }): Promise<any>
		function rebuild_connection(df, readable, writable): Promise<any>
		function rebuild_connection$({ df, readable, writable }): Promise<any>
		interface I_ConnectionBase {

			/**
			 * True if the connection is closed
			 */
			closed(): Promise<any>
			closed$($: {}): Promise<any>

			/**
			 * True if the connection is readable
			 */
			readable(): Promise<any>
			readable$($: {}): Promise<any>

			/**
			 * True if the connection is writable
			 */
			writable(): Promise<any>
			writable$($: {}): Promise<any>

			/**
			 * File descriptor or handle of the connection
			 */
			fileno(): Promise<any>
			fileno$($: {}): Promise<any>

			/**
			 * Close the connection
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Send the bytes data from a bytes-like object
			 */
			send_bytes(buf, offset?, size?): Promise<any>
			send_bytes$({ buf, offset, size }: { buf, offset?, size?}): Promise<any>

			/**
			 * Send a (picklable) object
			 */
			send(obj): Promise<any>
			send$({ obj }): Promise<any>

			/**
			 * 
			 *         Receive bytes data as a bytes object.
			 *         
			 */
			recv_bytes(maxlength?): Promise<any>
			recv_bytes$({ maxlength }: { maxlength?}): Promise<any>

			/**
			 * 
			 *         Receive bytes data into a writeable bytes-like object.
			 *         Return the number of bytes read.
			 *         
			 */
			recv_bytes_into(buf, offset?): Promise<any>
			recv_bytes_into$({ buf, offset }: { buf, offset?}): Promise<any>

			/**
			 * Receive a (picklable) object
			 */
			recv(): Promise<any>
			recv$($: {}): Promise<any>

			/**
			 * Whether there is any input available to be read
			 */
			poll(timeout?): Promise<any>
			poll$({ timeout }: { timeout?}): Promise<any>
		}

		/**
		 * 
		 *         Connection class based on a Windows named pipe.
		 *         Overlapped I/O is used, so the handles must have been created
		 *         with FILE_FLAG_OVERLAPPED.
		 *         
		 */
		interface IPipeConnection extends I_ConnectionBase {
		}

		/**
		 * 
		 *     Connection class based on an arbitrary file descriptor (Unix only), or
		 *     a socket handle (Windows).
		 *     
		 */
		interface IConnection extends I_ConnectionBase {
		}

		/**
		 * 
		 *     Returns a listener object.
		 * 
		 *     This is a wrapper for a bound socket which is 'listening' for
		 *     connections, or for a Windows named pipe.
		 *     
		 */
		function Listener(address?, family?, backlog?, authkey?): Promise<IListener>
		function Listener$({ address, family, backlog, authkey }: { address?, family?, backlog?, authkey?}): Promise<IListener>
		interface IListener {

			/**
			 * 
			 *         Accept a connection on the bound socket or named pipe of `self`.
			 * 
			 *         Returns a `Connection` object.
			 *         
			 */
			accept(): Promise<any>
			accept$($: {}): Promise<any>

			/**
			 * 
			 *         Close the bound socket or named pipe of `self`.
			 *         
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>
			address(): Promise<any>
			address$($: {}): Promise<any>
			last_accepted(): Promise<any>
			last_accepted$($: {}): Promise<any>
		}

		/**
		 * 
		 *     Representation of a socket which is bound to an address and listening
		 *     
		 */
		function SocketListener(address, family, backlog?): Promise<ISocketListener>
		function SocketListener$({ address, family, backlog }: { address, family, backlog?}): Promise<ISocketListener>
		interface ISocketListener {
			accept(): Promise<any>
			accept$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
		}

		/**
		 * 
		 *         Representation of a named pipe
		 *         
		 */
		function PipeListener(address, backlog?): Promise<IPipeListener>
		function PipeListener$({ address, backlog }: { address, backlog?}): Promise<IPipeListener>
		interface IPipeListener {
			accept(): Promise<any>
			accept$($: {}): Promise<any>
		}
		function ConnectionWrapper(conn, dumps, loads): Promise<IConnectionWrapper>
		function ConnectionWrapper$({ conn, dumps, loads }): Promise<IConnectionWrapper>
		interface IConnectionWrapper {
			send(obj): Promise<any>
			send$({ obj }): Promise<any>
			recv(): Promise<any>
			recv$($: {}): Promise<any>
		}
		interface IXmlListener extends IListener {
			accept(): Promise<any>
			accept$($: {}): Promise<any>
		}
		let BUFSIZE: Promise<any>
		let CONNECTION_TIMEOUT: Promise<any>
		let default_family: Promise<any>
		let families: Promise<any>
		let MESSAGE_LENGTH: Promise<any>
		let CHALLENGE: Promise<any>
		let WELCOME: Promise<any>
		let FAILURE: Promise<any>
	}
	module context {
		var _
		function get_spawning_popen(): Promise<any>
		function get_spawning_popen$($: {}): Promise<any>
		function set_spawning_popen(popen): Promise<any>
		function set_spawning_popen$({ popen }): Promise<any>
		function assert_spawning(obj): Promise<any>
		function assert_spawning$({ obj }): Promise<any>
		interface IProcessError {
		}
		interface IBufferTooShort extends IProcessError {
		}
		interface ITimeoutError extends IProcessError {
		}
		interface IAuthenticationError extends IProcessError {
		}
		interface IBaseContext {

			/**
			 * Returns the number of CPUs in the system
			 */
			cpu_count(): Promise<any>
			cpu_count$($: {}): Promise<any>

			/**
			 * Returns a manager associated with a running server process
			 * 
			 *         The managers methods such as `Lock()`, `Condition()` and `Queue()`
			 *         can be used to create shared objects.
			 *         
			 */
			Manager(): Promise<any>
			Manager$($: {}): Promise<any>

			/**
			 * Returns two connection object connected by a pipe
			 */
			Pipe(duplex?: boolean): Promise<any>
			Pipe$({ duplex }: { duplex?}): Promise<any>

			/**
			 * Returns a non-recursive lock object
			 */
			Lock(): Promise<any>
			Lock$($: {}): Promise<any>

			/**
			 * Returns a recursive lock object
			 */
			RLock(): Promise<any>
			RLock$($: {}): Promise<any>

			/**
			 * Returns a condition object
			 */
			Condition(lock?): Promise<any>
			Condition$({ lock }: { lock?}): Promise<any>

			/**
			 * Returns a semaphore object
			 */
			Semaphore(value?): Promise<any>
			Semaphore$({ value }: { value?}): Promise<any>

			/**
			 * Returns a bounded semaphore object
			 */
			BoundedSemaphore(value?): Promise<any>
			BoundedSemaphore$({ value }: { value?}): Promise<any>

			/**
			 * Returns an event object
			 */
			Event(): Promise<any>
			Event$($: {}): Promise<any>

			/**
			 * Returns a barrier object
			 */
			Barrier(parties, action?, timeout?): Promise<any>
			Barrier$({ parties, action, timeout }: { parties, action?, timeout?}): Promise<any>

			/**
			 * Returns a queue object
			 */
			Queue(maxsize?): Promise<any>
			Queue$({ maxsize }: { maxsize?}): Promise<any>

			/**
			 * Returns a queue object
			 */
			JoinableQueue(maxsize?): Promise<any>
			JoinableQueue$({ maxsize }: { maxsize?}): Promise<any>

			/**
			 * Returns a queue object
			 */
			SimpleQueue(): Promise<any>
			SimpleQueue$($: {}): Promise<any>

			/**
			 * Returns a process pool object
			 */
			Pool(processes?, initializer?, initargs?, maxtasksperchild?): Promise<any>
			Pool$({ processes, initializer, initargs, maxtasksperchild }: { processes?, initializer?, initargs?, maxtasksperchild?}): Promise<any>

			/**
			 * Returns a shared object
			 */
			RawValue(typecode_or_type): Promise<any>
			RawValue$({ typecode_or_type }): Promise<any>

			/**
			 * Returns a shared array
			 */
			RawArray(typecode_or_type, size_or_initializer): Promise<any>
			RawArray$({ typecode_or_type, size_or_initializer }): Promise<any>

			/**
			 * Returns a synchronized shared object
			 */
			Value(typecode_or_type): Promise<any>
			Value$({ typecode_or_type }): Promise<any>

			/**
			 * Returns a synchronized shared array
			 */
			Array(typecode_or_type, size_or_initializer): Promise<any>
			Array$({ typecode_or_type, size_or_initializer }): Promise<any>

			/**
			 * Check whether this is a fake forked process in a frozen executable.
			 *         If so then run code specified by commandline and exit.
			 *         
			 */
			freeze_support(): Promise<any>
			freeze_support$($: {}): Promise<any>

			/**
			 * Return package logger -- if it does not already exist then
			 *         it is created.
			 *         
			 */
			get_logger(): Promise<any>
			get_logger$($: {}): Promise<any>

			/**
			 * Turn on logging and add a handler which prints to stderr
			 */
			log_to_stderr(level?): Promise<any>
			log_to_stderr$({ level }: { level?}): Promise<any>

			/**
			 * Install support for sending connections and sockets
			 *         between processes
			 *         
			 */
			allow_connection_pickling(): Promise<any>
			allow_connection_pickling$($: {}): Promise<any>

			/**
			 * Sets the path to a python.exe or pythonw.exe binary used to run
			 *         child processes instead of sys.executable when using the 'spawn'
			 *         start method.  Useful for people embedding Python.
			 *         
			 */
			set_executable(executable): Promise<any>
			set_executable$({ executable }): Promise<any>

			/**
			 * Set list of module names to try to load in forkserver process.
			 *         This is really just a hint.
			 *         
			 */
			set_forkserver_preload(module_names): Promise<any>
			set_forkserver_preload$({ module_names }): Promise<any>
			get_context(method?): Promise<any>
			get_context$({ method }: { method?}): Promise<any>
			get_start_method(allow_none?: boolean): Promise<any>
			get_start_method$({ allow_none }: { allow_none?}): Promise<any>
			set_start_method(method, force?: boolean): Promise<any>
			set_start_method$({ method, force }: { method, force?}): Promise<any>

			/**
			 * Controls how objects will be reduced to a form that can be
			 *         shared with other processes.
			 */
			reducer(): Promise<any>
			reducer$($: {}): Promise<any>
			reducer(reduction): Promise<any>
			reducer$({ reduction }): Promise<any>
			ProcessError
			BufferTooShort
			TimeoutError
			AuthenticationError
			current_process
			parent_process
			active_children
		}
		interface IProcess {
		}
		function DefaultContext(context): Promise<IDefaultContext>
		function DefaultContext$({ context }): Promise<IDefaultContext>
		interface IDefaultContext extends IBaseContext {
			get_context(method?): Promise<any>
			get_context$({ method }: { method?}): Promise<any>
			set_start_method(method, force?: boolean): Promise<any>
			set_start_method$({ method, force }: { method, force?}): Promise<any>
			get_start_method(allow_none?: boolean): Promise<any>
			get_start_method$({ allow_none }: { allow_none?}): Promise<any>
			get_all_start_methods(): Promise<any>
			get_all_start_methods$($: {}): Promise<any>
			Process
		}
		interface IForkProcess {
		}
		interface ISpawnProcess {
		}
		interface IForkServerProcess {
		}
		interface IForkContext extends IBaseContext {
		}
		interface ISpawnContext extends IBaseContext {
		}
		interface IForkServerContext extends IBaseContext {
		}
		interface ISpawnProcess {
		}
		interface ISpawnContext extends IBaseContext {
		}
	}
	module dummy {
		var _
		function active_children(): Promise<any>
		function active_children$($: {}): Promise<any>
		function freeze_support(): Promise<any>
		function freeze_support$($: {}): Promise<any>
		function Array(typecode, sequence, lock?: boolean): Promise<any>
		function Array$({ typecode, sequence, lock }: { typecode, sequence, lock?}): Promise<any>
		function Manager(): Promise<any>
		function Manager$($: {}): Promise<any>
		function shutdown(): Promise<any>
		function shutdown$($: {}): Promise<any>
		function Pool(processes?, initializer?, initargs?): Promise<any>
		function Pool$({ processes, initializer, initargs }: { processes?, initializer?, initargs?}): Promise<any>
		function DummyProcess(group?, target?, name?, args?, kwargs?): Promise<IDummyProcess>
		function DummyProcess$({ group, target, name, args, kwargs }: { group?, target?, name?, args?, kwargs?}): Promise<IDummyProcess>
		interface IDummyProcess {
			start(): Promise<any>
			start$($: {}): Promise<any>
			exitcode(): Promise<any>
			exitcode$($: {}): Promise<any>
		}
		function Namespace(): Promise<INamespace>
		function Namespace$({ }): Promise<INamespace>
		interface INamespace {
		}
		function Value(typecode, value, lock?: boolean): Promise<IValue>
		function Value$({ typecode, value, lock }: { typecode, value, lock?}): Promise<IValue>
		interface IValue {
			value(): Promise<any>
			value$($: {}): Promise<any>
			value(value): Promise<any>
			value$({ value }): Promise<any>
		}
		let Process: Promise<any>
		let current_process: Promise<any>
		let dict: Promise<any>
		let list: Promise<any>
		let JoinableQueue: Promise<any>
		module connection {
			var _
			function Client(address): Promise<any>
			function Client$({ address }): Promise<any>
			function Pipe(duplex?: boolean): Promise<any>
			function Pipe$({ duplex }: { duplex?}): Promise<any>
			function Listener(address?, family?, backlog?): Promise<IListener>
			function Listener$({ address, family, backlog }: { address?, family?, backlog?}): Promise<IListener>
			interface IListener {
				accept(): Promise<any>
				accept$($: {}): Promise<any>
				close(): Promise<any>
				close$($: {}): Promise<any>
				address(): Promise<any>
				address$($: {}): Promise<any>
			}
			function Connection(_in, _out): Promise<IConnection>
			function Connection$({ _in, _out }): Promise<IConnection>
			interface IConnection {
				poll(timeout?): Promise<any>
				poll$({ timeout }: { timeout?}): Promise<any>
				close(): Promise<any>
				close$($: {}): Promise<any>
			}
			let families: Promise<any>
		}
	}
	module forkserver {
		var _

		/**
		 * Run forkserver.
		 */
		function main(listener_fd, alive_r, preload, main_path?, sys_path?): Promise<any>
		function main$({ listener_fd, alive_r, preload, main_path, sys_path }: { listener_fd, alive_r, preload, main_path?, sys_path?}): Promise<any>
		function read_signed(fd): Promise<any>
		function read_signed$({ fd }): Promise<any>
		function write_signed(fd, n): Promise<any>
		function write_signed$({ fd, n }): Promise<any>
		function ForkServer(): Promise<IForkServer>
		function ForkServer$({ }): Promise<IForkServer>
		interface IForkServer {

			/**
			 * Set list of module names to try to load in forkserver process.
			 */
			set_forkserver_preload(modules_names): Promise<any>
			set_forkserver_preload$({ modules_names }): Promise<any>

			/**
			 * Return list of fds inherited from parent process.
			 * 
			 *         This returns None if the current process was not started by fork
			 *         server.
			 *         
			 */
			get_inherited_fds(): Promise<any>
			get_inherited_fds$($: {}): Promise<any>

			/**
			 * Request forkserver to create a child process.
			 * 
			 *         Returns a pair of fds (status_r, data_w).  The calling process can read
			 *         the child process's pid and (eventually) its returncode from status_r.
			 *         The calling process should write to data_w the pickled preparation and
			 *         process data.
			 *         
			 */
			connect_to_new_process(fds): Promise<any>
			connect_to_new_process$({ fds }): Promise<any>

			/**
			 * Make sure that a fork server is running.
			 * 
			 *         This can be called from any process.  Note that usually a child
			 *         process will just reuse the forkserver started by its parent, so
			 *         ensure_running() will do nothing.
			 *         
			 */
			ensure_running(): Promise<any>
			ensure_running$($: {}): Promise<any>
		}
		let MAXFDS_TO_SEND: Promise<any>
		let SIGNED_STRUCT: Promise<any>
	}
	module heap {
		var _
		function reduce_arena(a): Promise<any>
		function reduce_arena$({ a }): Promise<any>
		function rebuild_arena(size, dupfd): Promise<any>
		function rebuild_arena$({ size, dupfd }): Promise<any>

		/**
		 * 
		 *         A shared memory area backed by anonymous memory (Windows).
		 *         
		 */
		function Arena(size): Promise<IArena>
		function Arena$({ size }): Promise<IArena>
		interface IArena {
		}

		/**
		 * 
		 *         A shared memory area backed by a temporary file (POSIX).
		 *         
		 */
		function Arena(size, fd?): Promise<IArena>
		function Arena$({ size, fd }: { size, fd?}): Promise<IArena>
		interface IArena {
		}
		function Heap(size?): Promise<IHeap>
		function Heap$({ size }: { size?}): Promise<IHeap>
		interface IHeap {
			free(block): Promise<any>
			free$({ block }): Promise<any>
			malloc(size): Promise<any>
			malloc$({ size }): Promise<any>
		}
		function BufferWrapper(size): Promise<IBufferWrapper>
		function BufferWrapper$({ size }): Promise<IBufferWrapper>
		interface IBufferWrapper {
			create_memoryview(): Promise<any>
			create_memoryview$($: {}): Promise<any>
		}
	}
	module managers {
		var _
		function reduce_array(a): Promise<any>
		function reduce_array$({ a }): Promise<any>
		function rebuild_as_list(obj): Promise<any>
		function rebuild_as_list$({ obj }): Promise<any>

		/**
		 * 
		 *     Send a message to manager using connection `c` and return response
		 *     
		 */
		function dispatch(c, id, methodname, args?, kwds?): Promise<any>
		function dispatch$({ c, id, methodname, args, kwds }: { c, id, methodname, args?, kwds?}): Promise<any>
		function convert_to_error(kind, result): Promise<any>
		function convert_to_error$({ kind, result }): Promise<any>

		/**
		 * 
		 *     Return a list of names of methods of `obj`
		 *     
		 */
		function all_methods(obj): Promise<any>
		function all_methods$({ obj }): Promise<any>

		/**
		 * 
		 *     Return a list of names of methods of `obj` which do not start with '_'
		 *     
		 */
		function public_methods(obj): Promise<any>
		function public_methods$({ obj }): Promise<any>

		/**
		 * 
		 *     Function used for unpickling proxy objects.
		 *     
		 */
		function RebuildProxy(func, token, serializer, kwds): Promise<any>
		function RebuildProxy$({ func, token, serializer, kwds }): Promise<any>

		/**
		 * 
		 *     Return a proxy type whose methods are given by `exposed`
		 *     
		 */
		function MakeProxyType(name, exposed, _cache?): Promise<any>
		function MakeProxyType$({ name, exposed, _cache }: { name, exposed, _cache?}): Promise<any>

		/**
		 * 
		 *     Return an auto-proxy for `token`
		 *     
		 */
		function AutoProxy(token, serializer, manager?, authkey?, exposed?, incref?: boolean): Promise<any>
		function AutoProxy$({ token, serializer, manager, authkey, exposed, incref }: { token, serializer, manager?, authkey?, exposed?, incref?}): Promise<any>
		function Array(typecode, sequence, lock?: boolean): Promise<any>
		function Array$({ typecode, sequence, lock }: { typecode, sequence, lock?}): Promise<any>

		/**
		 * 
		 *     Type to uniquely identify a shared object
		 *     
		 */
		function Token(typeid, address, id): Promise<IToken>
		function Token$({ typeid, address, id }): Promise<IToken>
		interface IToken {
		}
		interface IRemoteError {
		}

		/**
		 * 
		 *     Server class which runs in a process controlled by a manager object
		 *     
		 */
		function Server(registry, address, authkey, serializer): Promise<IServer>
		function Server$({ registry, address, authkey, serializer }): Promise<IServer>
		interface IServer {

			/**
			 * 
			 *         Run the server forever
			 *         
			 */
			serve_forever(): Promise<any>
			serve_forever$($: {}): Promise<any>
			accepter(): Promise<any>
			accepter$($: {}): Promise<any>

			/**
			 * 
			 *         Handle a new connection
			 *         
			 */
			handle_request(conn): Promise<any>
			handle_request$({ conn }): Promise<any>

			/**
			 * 
			 *         Handle requests from the proxies in a particular process/thread
			 *         
			 */
			serve_client(conn): Promise<any>
			serve_client$({ conn }): Promise<any>
			fallback_getvalue(conn, ident, obj): Promise<any>
			fallback_getvalue$({ conn, ident, obj }): Promise<any>
			fallback_str(conn, ident, obj): Promise<any>
			fallback_str$({ conn, ident, obj }): Promise<any>
			fallback_repr(conn, ident, obj): Promise<any>
			fallback_repr$({ conn, ident, obj }): Promise<any>
			dummy(c): Promise<any>
			dummy$({ c }): Promise<any>

			/**
			 * 
			 *         Return some info --- useful to spot problems with refcounting
			 *         
			 */
			debug_info(c): Promise<any>
			debug_info$({ c }): Promise<any>

			/**
			 * 
			 *         Number of shared objects
			 *         
			 */
			number_of_objects(c): Promise<any>
			number_of_objects$({ c }): Promise<any>

			/**
			 * 
			 *         Shutdown this process
			 *         
			 */
			shutdown(c): Promise<any>
			shutdown$({ c }): Promise<any>

			/**
			 * 
			 *         Create a new shared object and return its id
			 *         
			 */
			create(c, typeid): Promise<any>
			create$({ c, typeid }): Promise<any>

			/**
			 * 
			 *         Return the methods of the shared object indicated by token
			 *         
			 */
			get_methods(c, token): Promise<any>
			get_methods$({ c, token }): Promise<any>

			/**
			 * 
			 *         Spawn a new thread to serve this connection
			 *         
			 */
			accept_connection(c, name): Promise<any>
			accept_connection$({ c, name }): Promise<any>
			incref(c, ident): Promise<any>
			incref$({ c, ident }): Promise<any>
			decref(c, ident): Promise<any>
			decref$({ c, ident }): Promise<any>
			public
			fallback_mapping
		}
		interface IState {
			INITIAL
			STARTED
			SHUTDOWN
		}

		/**
		 * 
		 *     Base class for managers
		 *     
		 */
		function BaseManager(address?, authkey?, serializer?, ctx?): Promise<IBaseManager>
		function BaseManager$({ address, authkey, serializer, ctx }: { address?, authkey?, serializer?, ctx?}): Promise<IBaseManager>
		interface IBaseManager {

			/**
			 * 
			 *         Return server object with serve_forever() method and address attribute
			 *         
			 */
			get_server(): Promise<any>
			get_server$($: {}): Promise<any>

			/**
			 * 
			 *         Connect manager object to the server process
			 *         
			 */
			connect(): Promise<any>
			connect$($: {}): Promise<any>

			/**
			 * 
			 *         Spawn a server process for this manager object
			 *         
			 */
			start(initializer?, initargs?): Promise<any>
			start$({ initializer, initargs }: { initializer?, initargs?}): Promise<any>

			/**
			 * 
			 *         Join the manager process (if it has been spawned)
			 *         
			 */
			join(timeout?): Promise<any>
			join$({ timeout }: { timeout?}): Promise<any>
			address(): Promise<any>
			address$($: {}): Promise<any>

			/**
			 * 
			 *         Register a typeid with the manager type
			 *         
			 */
			register(typeid, callable?, proxytype?, exposed?, method_to_typeid?, create_method?: boolean): Promise<any>
			register$({ typeid, callable, proxytype, exposed, method_to_typeid, create_method }: { typeid, callable?, proxytype?, exposed?, method_to_typeid?, create_method?}): Promise<any>
		}
		function ProcessLocalSet(): Promise<IProcessLocalSet>
		function ProcessLocalSet$({ }): Promise<IProcessLocalSet>
		interface IProcessLocalSet {
		}

		/**
		 * 
		 *     A base for proxies of shared objects
		 *     
		 */
		function BaseProxy(token, serializer, manager?, authkey?, exposed?, incref?: boolean, manager_owned?: boolean): Promise<IBaseProxy>
		function BaseProxy$({ token, serializer, manager, authkey, exposed, incref, manager_owned }: { token, serializer, manager?, authkey?, exposed?, incref?, manager_owned?}): Promise<IBaseProxy>
		interface IBaseProxy {
		}
		function Namespace(): Promise<INamespace>
		function Namespace$({ }): Promise<INamespace>
		interface INamespace {
		}
		function Value(typecode, value, lock?: boolean): Promise<IValue>
		function Value$({ typecode, value, lock }: { typecode, value, lock?}): Promise<IValue>
		interface IValue {
			get(): Promise<any>
			get$($: {}): Promise<any>
			set(value): Promise<any>
			set$({ value }): Promise<any>
			value
		}
		interface IIteratorProxy extends IBaseProxy {
			send(): Promise<any>
			send$($: {}): Promise<any>
			throw(): Promise<any>
			throw$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
		}
		interface IAcquirerProxy extends IBaseProxy {
			acquire(blocking?: boolean, timeout?): Promise<any>
			acquire$({ blocking, timeout }: { blocking?, timeout?}): Promise<any>
			release(): Promise<any>
			release$($: {}): Promise<any>
		}
		interface IConditionProxy extends IAcquirerProxy {
			wait(timeout?): Promise<any>
			wait$({ timeout }: { timeout?}): Promise<any>
			notify(n?): Promise<any>
			notify$({ n }: { n?}): Promise<any>
			notify_all(): Promise<any>
			notify_all$($: {}): Promise<any>
			wait_for(predicate, timeout?): Promise<any>
			wait_for$({ predicate, timeout }: { predicate, timeout?}): Promise<any>
		}
		interface IEventProxy extends IBaseProxy {
			is_set(): Promise<any>
			is_set$($: {}): Promise<any>
			set(): Promise<any>
			set$($: {}): Promise<any>
			clear(): Promise<any>
			clear$($: {}): Promise<any>
			wait(timeout?): Promise<any>
			wait$({ timeout }: { timeout?}): Promise<any>
		}
		interface IBarrierProxy extends IBaseProxy {
			wait(timeout?): Promise<any>
			wait$({ timeout }: { timeout?}): Promise<any>
			abort(): Promise<any>
			abort$($: {}): Promise<any>
			reset(): Promise<any>
			reset$($: {}): Promise<any>
			parties(): Promise<any>
			parties$($: {}): Promise<any>
			n_waiting(): Promise<any>
			n_waiting$($: {}): Promise<any>
			broken(): Promise<any>
			broken$($: {}): Promise<any>
		}
		interface INamespaceProxy extends IBaseProxy {
		}
		interface IValueProxy extends IBaseProxy {
			get(): Promise<any>
			get$($: {}): Promise<any>
			set(value): Promise<any>
			set$({ value }): Promise<any>
		}
		interface IListProxy {
		}
		interface IPoolProxy {
		}

		/**
		 * 
		 *     Subclass of `BaseManager` which supports a number of shared object types.
		 * 
		 *     The types registered are those intended for the synchronization
		 *     of threads, plus `dict`, `list` and `Namespace`.
		 * 
		 *     The `multiprocessing.Manager()` function creates started instances of
		 *     this class.
		 *     
		 */
		interface ISyncManager extends IBaseManager {
		}

		/**
		 * Manages one or more shared memory segments.
		 */
		interface I_SharedMemoryTracker {

			/**
			 * Adds the supplied shared memory block name to tracker.
			 */
			register_segment(segment_name): Promise<any>
			register_segment$({ segment_name }): Promise<any>

			/**
			 * Calls unlink() on the shared memory block with the supplied name
			 *             and removes it from the list of blocks being tracked.
			 */
			destroy_segment(segment_name): Promise<any>
			destroy_segment$({ segment_name }): Promise<any>

			/**
			 * Calls destroy_segment() on all tracked shared memory blocks.
			 */
			unlink(): Promise<any>
			unlink$($: {}): Promise<any>
		}
		function SharedMemoryServer(): Promise<ISharedMemoryServer>
		function SharedMemoryServer$({ }): Promise<ISharedMemoryServer>
		interface ISharedMemoryServer extends IServer {

			/**
			 * Create a new distributed-shared object (not backed by a shared
			 *             memory block) and return its id to be used in a Proxy Object.
			 */
			create(c, typeid): Promise<any>
			create$({ c, typeid }): Promise<any>

			/**
			 * Call unlink() on all tracked shared memory, terminate the Server.
			 */
			shutdown(c): Promise<any>
			shutdown$({ c }): Promise<any>

			/**
			 * Adds the supplied shared memory block name to Server's tracker.
			 */
			track_segment(c, segment_name): Promise<any>
			track_segment$({ c, segment_name }): Promise<any>

			/**
			 * Calls unlink() on the shared memory block with the supplied name
			 *             and removes it from the tracker instance inside the Server.
			 */
			release_segment(c, segment_name): Promise<any>
			release_segment$({ c, segment_name }): Promise<any>

			/**
			 * Returns a list of names of shared memory blocks that the Server
			 *             is currently tracking.
			 */
			list_segments(c): Promise<any>
			list_segments$({ c }): Promise<any>
		}

		/**
		 * Like SyncManager but uses SharedMemoryServer instead of Server.
		 * 
		 *         It provides methods for creating and returning SharedMemory instances
		 *         and for creating a list-like object (ShareableList) backed by shared
		 *         memory.  It also provides methods that create and return Proxy Objects
		 *         that support synchronization across processes (i.e. multi-process-safe
		 *         locks and semaphores).
		 *         
		 */
		function SharedMemoryManager(): Promise<ISharedMemoryManager>
		function SharedMemoryManager$({ }): Promise<ISharedMemoryManager>
		interface ISharedMemoryManager extends IBaseManager {

			/**
			 * Better than monkeypatching for now; merge into Server ultimately
			 */
			get_server(): Promise<any>
			get_server$($: {}): Promise<any>

			/**
			 * Returns a new SharedMemory instance with the specified size in
			 *             bytes, to be tracked by the manager.
			 */
			SharedMemory(size): Promise<any>
			SharedMemory$({ size }): Promise<any>

			/**
			 * Returns a new ShareableList instance populated with the values
			 *             from the input sequence, to be tracked by the manager.
			 */
			ShareableList(sequence): Promise<any>
			ShareableList$({ sequence }): Promise<any>
		}
		let HAS_SHMEM: Promise<any>
		let view_types: Promise<any>
		let listener_client: Promise<any>
		let BaseListProxy: Promise<any>
		let DictProxy: Promise<any>
		let ArrayProxy: Promise<any>
		let BasePoolProxy: Promise<any>
	}
	module pool {
		var _
		function mapstar(args): Promise<any>
		function mapstar$({ args }): Promise<any>
		function starmapstar(args): Promise<any>
		function starmapstar$({ args }): Promise<any>
		function rebuild_exc(exc, tb): Promise<any>
		function rebuild_exc$({ exc, tb }): Promise<any>
		function worker(inqueue, outqueue, initializer?, initargs?, maxtasks?, wrap_exception?: boolean): Promise<any>
		function worker$({ inqueue, outqueue, initializer, initargs, maxtasks, wrap_exception }: { inqueue, outqueue, initializer?, initargs?, maxtasks?, wrap_exception?}): Promise<any>
		function RemoteTraceback(tb): Promise<IRemoteTraceback>
		function RemoteTraceback$({ tb }): Promise<IRemoteTraceback>
		interface IRemoteTraceback {
		}
		function ExceptionWithTraceback(exc, tb): Promise<IExceptionWithTraceback>
		function ExceptionWithTraceback$({ exc, tb }): Promise<IExceptionWithTraceback>
		interface IExceptionWithTraceback {
		}

		/**
		 * Wraps possible unpickleable errors, so they can be
		 *     safely sent through the socket.
		 */
		function MaybeEncodingError(exc, value): Promise<IMaybeEncodingError>
		function MaybeEncodingError$({ exc, value }): Promise<IMaybeEncodingError>
		interface IMaybeEncodingError {
		}

		/**
		 * 
		 *     Class that implements a cache for the Pool class that will notify
		 *     the pool management threads every time the cache is emptied. The
		 *     notification is done by the use of a queue that is provided when
		 *     instantiating the cache.
		 *     
		 */
		interface I_PoolCache {
		}

		/**
		 * 
		 *     Class which supports an async version of applying functions to arguments.
		 *     
		 */
		function Pool(processes?, initializer?, initargs?, maxtasksperchild?, context?): Promise<IPool>
		function Pool$({ processes, initializer, initargs, maxtasksperchild, context }: { processes?, initializer?, initargs?, maxtasksperchild?, context?}): Promise<IPool>
		interface IPool {
			Process(): Promise<any>
			Process$($: {}): Promise<any>

			/**
			 * 
			 *         Equivalent of `func(*args, **kwds)`.
			 *         Pool must be running.
			 *         
			 */
			apply(func, args?, kwds?): Promise<any>
			apply$({ func, args, kwds }: { func, args?, kwds?}): Promise<any>

			/**
			 * 
			 *         Apply `func` to each element in `iterable`, collecting the results
			 *         in a list that is returned.
			 *         
			 */
			map(func, iterable, chunksize?): Promise<any>
			map$({ func, iterable, chunksize }: { func, iterable, chunksize?}): Promise<any>

			/**
			 * 
			 *         Like `map()` method but the elements of the `iterable` are expected to
			 *         be iterables as well and will be unpacked as arguments. Hence
			 *         `func` and (a, b) becomes func(a, b).
			 *         
			 */
			starmap(func, iterable, chunksize?): Promise<any>
			starmap$({ func, iterable, chunksize }: { func, iterable, chunksize?}): Promise<any>

			/**
			 * 
			 *         Asynchronous version of `starmap()` method.
			 *         
			 */
			starmap_async(func, iterable, chunksize?, callback?, error_callback?): Promise<any>
			starmap_async$({ func, iterable, chunksize, callback, error_callback }: { func, iterable, chunksize?, callback?, error_callback?}): Promise<any>

			/**
			 * 
			 *         Equivalent of `map()` -- can be MUCH slower than `Pool.map()`.
			 *         
			 */
			imap(func, iterable, chunksize?): Promise<any>
			imap$({ func, iterable, chunksize }: { func, iterable, chunksize?}): Promise<any>

			/**
			 * 
			 *         Like `imap()` method but ordering of results is arbitrary.
			 *         
			 */
			imap_unordered(func, iterable, chunksize?): Promise<any>
			imap_unordered$({ func, iterable, chunksize }: { func, iterable, chunksize?}): Promise<any>

			/**
			 * 
			 *         Asynchronous version of `apply()` method.
			 *         
			 */
			apply_async(func, args?, kwds?, callback?, error_callback?): Promise<any>
			apply_async$({ func, args, kwds, callback, error_callback }: { func, args?, kwds?, callback?, error_callback?}): Promise<any>

			/**
			 * 
			 *         Asynchronous version of `map()` method.
			 *         
			 */
			map_async(func, iterable, chunksize?, callback?, error_callback?): Promise<any>
			map_async$({ func, iterable, chunksize, callback, error_callback }: { func, iterable, chunksize?, callback?, error_callback?}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			terminate(): Promise<any>
			terminate$($: {}): Promise<any>
			join(): Promise<any>
			join$($: {}): Promise<any>
		}
		function ApplyResult(pool, callback, error_callback): Promise<IApplyResult>
		function ApplyResult$({ pool, callback, error_callback }): Promise<IApplyResult>
		interface IApplyResult {
			ready(): Promise<any>
			ready$($: {}): Promise<any>
			successful(): Promise<any>
			successful$($: {}): Promise<any>
			wait(timeout?): Promise<any>
			wait$({ timeout }: { timeout?}): Promise<any>
			get(timeout?): Promise<any>
			get$({ timeout }: { timeout?}): Promise<any>
		}
		function MapResult(pool, chunksize, length, callback, error_callback): Promise<IMapResult>
		function MapResult$({ pool, chunksize, length, callback, error_callback }): Promise<IMapResult>
		interface IMapResult extends IApplyResult {
		}
		function IMapIterator(pool): Promise<IIMapIterator>
		function IMapIterator$({ pool }): Promise<IIMapIterator>
		interface IIMapIterator {
			next(timeout?): Promise<any>
			next$({ timeout }: { timeout?}): Promise<any>
		}
		interface IIMapUnorderedIterator extends IIMapIterator {
		}
		function ThreadPool(processes?, initializer?, initargs?): Promise<IThreadPool>
		function ThreadPool$({ processes, initializer, initargs }: { processes?, initializer?, initargs?}): Promise<IThreadPool>
		interface IThreadPool extends IPool {
			Process(): Promise<any>
			Process$($: {}): Promise<any>
		}
		let INIT: Promise<any>
		let RUN: Promise<any>
		let CLOSE: Promise<any>
		let TERMINATE: Promise<any>
		let job_counter: Promise<any>
		let AsyncResult: Promise<any>
	}
	module popen_fork {
		var _
		function Popen(process_obj): Promise<IPopen>
		function Popen$({ process_obj }): Promise<IPopen>
		interface IPopen {
			duplicate_for_child(fd): Promise<any>
			duplicate_for_child$({ fd }): Promise<any>
			poll(flag?): Promise<any>
			poll$({ flag }: { flag?}): Promise<any>
			wait(timeout?): Promise<any>
			wait$({ timeout }: { timeout?}): Promise<any>
			terminate(): Promise<any>
			terminate$($: {}): Promise<any>
			kill(): Promise<any>
			kill$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			method
		}
	}
	module popen_forkserver {
		var _
		interface I_DupFd {
			detach(): Promise<any>
			detach$($: {}): Promise<any>
		}
		function Popen(process_obj): Promise<IPopen>
		function Popen$({ process_obj }): Promise<IPopen>
		interface IPopen {
			duplicate_for_child(fd): Promise<any>
			duplicate_for_child$({ fd }): Promise<any>
			poll(flag?): Promise<any>
			poll$({ flag }: { flag?}): Promise<any>
			method
			DupFd
		}
	}
	module popen_spawn_posix {
		var _
		interface I_DupFd {
			detach(): Promise<any>
			detach$($: {}): Promise<any>
		}
		function Popen(process_obj): Promise<IPopen>
		function Popen$({ process_obj }): Promise<IPopen>
		interface IPopen {
			duplicate_for_child(fd): Promise<any>
			duplicate_for_child$({ fd }): Promise<any>
			method
			DupFd
		}
	}
	module popen_spawn_win32 {
		var _

		/**
		 * 
		 *     Start a subprocess to run the code of a process object
		 *     
		 */
		function Popen(process_obj): Promise<IPopen>
		function Popen$({ process_obj }): Promise<IPopen>
		interface IPopen {
			duplicate_for_child(handle): Promise<any>
			duplicate_for_child$({ handle }): Promise<any>
			wait(timeout?): Promise<any>
			wait$({ timeout }: { timeout?}): Promise<any>
			poll(): Promise<any>
			poll$($: {}): Promise<any>
			terminate(): Promise<any>
			terminate$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			method
			kill
		}
		let TERMINATE: Promise<any>
		let WINEXE: Promise<any>
		let WINSERVICE: Promise<any>
		let WINENV: Promise<any>
	}
	module process {
		var _

		/**
		 * 
		 *     Return process object representing the current process
		 *     
		 */
		function current_process(): Promise<any>
		function current_process$($: {}): Promise<any>

		/**
		 * 
		 *     Return list of process objects corresponding to live child processes
		 *     
		 */
		function active_children(): Promise<any>
		function active_children$($: {}): Promise<any>

		/**
		 * 
		 *     Return process object representing the parent process
		 *     
		 */
		function parent_process(): Promise<any>
		function parent_process$($: {}): Promise<any>

		/**
		 * 
		 *     Process objects represent activity that is run in a separate process
		 * 
		 *     The class is analogous to `threading.Thread`
		 *     
		 */
		function BaseProcess(group?, target?, name?, args?, kwargs?): Promise<IBaseProcess>
		function BaseProcess$({ group, target, name, args, kwargs }: { group?, target?, name?, args?, kwargs?}): Promise<IBaseProcess>
		interface IBaseProcess {

			/**
			 * 
			 *         Method to be run in sub-process; can be overridden in sub-class
			 *         
			 */
			run(): Promise<any>
			run$($: {}): Promise<any>

			/**
			 * 
			 *         Start child process
			 *         
			 */
			start(): Promise<any>
			start$($: {}): Promise<any>

			/**
			 * 
			 *         Terminate process; sends SIGTERM signal or uses TerminateProcess()
			 *         
			 */
			terminate(): Promise<any>
			terminate$($: {}): Promise<any>

			/**
			 * 
			 *         Terminate process; sends SIGKILL signal or uses TerminateProcess()
			 *         
			 */
			kill(): Promise<any>
			kill$($: {}): Promise<any>

			/**
			 * 
			 *         Wait until child process terminates
			 *         
			 */
			join(timeout?): Promise<any>
			join$({ timeout }: { timeout?}): Promise<any>

			/**
			 * 
			 *         Return whether process is alive
			 *         
			 */
			is_alive(): Promise<any>
			is_alive$($: {}): Promise<any>

			/**
			 * 
			 *         Close the Process object.
			 * 
			 *         This method releases resources held by the Process object.  It is
			 *         an error to call this method if the child process is still running.
			 *         
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>
			name(): Promise<any>
			name$($: {}): Promise<any>
			name(name): Promise<any>
			name$({ name }): Promise<any>

			/**
			 * 
			 *         Return whether process is a daemon
			 *         
			 */
			daemon(): Promise<any>
			daemon$($: {}): Promise<any>

			/**
			 * 
			 *         Set whether process is a daemon
			 *         
			 */
			daemon(daemonic): Promise<any>
			daemon$({ daemonic }): Promise<any>
			authkey(): Promise<any>
			authkey$($: {}): Promise<any>

			/**
			 * 
			 *         Set authorization key of process
			 *         
			 */
			authkey(authkey): Promise<any>
			authkey$({ authkey }): Promise<any>

			/**
			 * 
			 *         Return exit code of process or `None` if it has yet to stop
			 *         
			 */
			exitcode(): Promise<any>
			exitcode$($: {}): Promise<any>

			/**
			 * 
			 *         Return identifier (PID) of process or `None` if it has yet to start
			 *         
			 */
			ident(): Promise<any>
			ident$($: {}): Promise<any>

			/**
			 * 
			 *         Return a file descriptor (Unix) or handle (Windows) suitable for
			 *         waiting for process termination.
			 *         
			 */
			sentinel(): Promise<any>
			sentinel$($: {}): Promise<any>
			pid
		}
		interface IAuthenticationString {
		}
		interface I_ParentProcess extends IBaseProcess {
			is_alive(): Promise<any>
			is_alive$($: {}): Promise<any>
			ident(): Promise<any>
			ident$($: {}): Promise<any>

			/**
			 * 
			 *         Wait until parent process terminates
			 *         
			 */
			join(timeout?): Promise<any>
			join$({ timeout }: { timeout?}): Promise<any>
		}
		interface I_MainProcess extends IBaseProcess {
			close(): Promise<any>
			close$($: {}): Promise<any>
		}
		let ORIGINAL_DIR: Promise<any>
	}
	module queues {
		var _
		function Queue(maxsize?): Promise<IQueue>
		function Queue$({ maxsize }: { maxsize?}): Promise<IQueue>
		interface IQueue {
			put(obj, block?: boolean, timeout?): Promise<any>
			put$({ obj, block, timeout }: { obj, block?, timeout?}): Promise<any>
			get(block?: boolean, timeout?): Promise<any>
			get$({ block, timeout }: { block?, timeout?}): Promise<any>
			qsize(): Promise<any>
			qsize$($: {}): Promise<any>
			empty(): Promise<any>
			empty$($: {}): Promise<any>
			full(): Promise<any>
			full$($: {}): Promise<any>
			get_nowait(): Promise<any>
			get_nowait$($: {}): Promise<any>
			put_nowait(obj): Promise<any>
			put_nowait$({ obj }): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			join_thread(): Promise<any>
			join_thread$($: {}): Promise<any>
			cancel_join_thread(): Promise<any>
			cancel_join_thread$($: {}): Promise<any>
		}
		function JoinableQueue(maxsize?): Promise<IJoinableQueue>
		function JoinableQueue$({ maxsize }: { maxsize?}): Promise<IJoinableQueue>
		interface IJoinableQueue extends IQueue {
			put(obj, block?: boolean, timeout?): Promise<any>
			put$({ obj, block, timeout }: { obj, block?, timeout?}): Promise<any>
			task_done(): Promise<any>
			task_done$($: {}): Promise<any>
			join(): Promise<any>
			join$($: {}): Promise<any>
		}
		function SimpleQueue(): Promise<ISimpleQueue>
		function SimpleQueue$({ }): Promise<ISimpleQueue>
		interface ISimpleQueue {
			close(): Promise<any>
			close$($: {}): Promise<any>
			empty(): Promise<any>
			empty$($: {}): Promise<any>
			get(): Promise<any>
			get$($: {}): Promise<any>
			put(obj): Promise<any>
			put$({ obj }): Promise<any>
		}
	}
	module reduction {
		var _

		/**
		 * Replacement for pickle.dump() using ForkingPickler.
		 */
		function dump(obj, file, protocol?): Promise<any>
		function dump$({ obj, file, protocol }: { obj, file, protocol?}): Promise<any>

		/**
		 * Duplicate a handle.  (target_process is a handle not a pid!)
		 */
		function duplicate(handle, target_process?, inheritable?: boolean): Promise<any>
		function duplicate$({ handle, target_process, inheritable }: { handle, target_process?, inheritable?}): Promise<any>

		/**
		 * Steal a handle from process identified by source_pid.
		 */
		function steal_handle(source_pid, handle): Promise<any>
		function steal_handle$({ source_pid, handle }): Promise<any>

		/**
		 * Send a handle over a local connection.
		 */
		function send_handle(conn, handle, destination_pid): Promise<any>
		function send_handle$({ conn, handle, destination_pid }): Promise<any>

		/**
		 * Receive a handle over a local connection.
		 */
		function recv_handle(conn): Promise<any>
		function recv_handle$({ conn }): Promise<any>

		/**
		 * Send an array of fds over an AF_UNIX socket.
		 */
		function sendfds(sock, fds): Promise<any>
		function sendfds$({ sock, fds }): Promise<any>

		/**
		 * Receive an array of fds over an AF_UNIX socket.
		 */
		function recvfds(sock, size): Promise<any>
		function recvfds$({ sock, size }): Promise<any>

		/**
		 * Send a handle over a local connection.
		 */
		function send_handle(conn, handle, destination_pid): Promise<any>
		function send_handle$({ conn, handle, destination_pid }): Promise<any>

		/**
		 * Receive a handle over a local connection.
		 */
		function recv_handle(conn): Promise<any>
		function recv_handle$({ conn }): Promise<any>

		/**
		 * Return a wrapper for an fd.
		 */
		function DupFd(fd): Promise<any>
		function DupFd$({ fd }): Promise<any>

		/**
		 * Pickler subclass used by multiprocessing.
		 */
		function ForkingPickler(): Promise<IForkingPickler>
		function ForkingPickler$({ }): Promise<IForkingPickler>
		interface IForkingPickler {

			/**
			 * Register a reduce function for a type.
			 */
			register(type, reduce): Promise<any>
			register$({ type, reduce }): Promise<any>
			dumps(obj, protocol?): Promise<any>
			dumps$({ obj, protocol }: { obj, protocol?}): Promise<any>
			loads
		}

		/**
		 * Picklable wrapper for a handle.
		 */
		function DupHandle(handle, access, pid?): Promise<IDupHandle>
		function DupHandle$({ handle, access, pid }: { handle, access, pid?}): Promise<IDupHandle>
		interface IDupHandle {

			/**
			 * Get the handle.  This should only be called once.
			 */
			detach(): Promise<any>
			detach$($: {}): Promise<any>
		}
		interface I_C {
			f(): Promise<any>
			f$($: {}): Promise<any>
		}

		/**
		 * Abstract base class for use in implementing a Reduction class
		 *     suitable for use in replacing the standard reduction mechanism
		 *     used in multiprocessing.
		 */
		function AbstractReducer(): Promise<IAbstractReducer>
		function AbstractReducer$({ }): Promise<IAbstractReducer>
		interface IAbstractReducer {
		}
		let HAVE_SEND_HANDLE: Promise<any>
		let ACKNOWLEDGE: Promise<any>
	}
	module resource_sharer {
		var _

		/**
		 * Picklable wrapper for a socket.
		 */
		function DupSocket(sock): Promise<IDupSocket>
		function DupSocket$({ sock }): Promise<IDupSocket>
		interface IDupSocket {

			/**
			 * Get the socket.  This should only be called once.
			 */
			detach(): Promise<any>
			detach$($: {}): Promise<any>
		}

		/**
		 * Wrapper for fd which can be used at any time.
		 */
		function DupFd(fd): Promise<IDupFd>
		function DupFd$({ fd }): Promise<IDupFd>
		interface IDupFd {

			/**
			 * Get the fd.  This should only be called once.
			 */
			detach(): Promise<any>
			detach$($: {}): Promise<any>
		}

		/**
		 * Manager for resources using background thread.
		 */
		interface I_ResourceSharer {

			/**
			 * Register resource, returning an identifier.
			 */
			register(send, close): Promise<any>
			register$({ send, close }): Promise<any>

			/**
			 * Return connection from which to receive identified resource.
			 */
			get_connection(): Promise<any>
			get_connection$($: {}): Promise<any>

			/**
			 * Stop the background thread and clear registered resources.
			 */
			stop(timeout?): Promise<any>
			stop$({ timeout }: { timeout?}): Promise<any>
		}
	}
	module resource_tracker {
		var _

		/**
		 * Run resource tracker.
		 */
		function main(fd): Promise<any>
		function main$({ fd }): Promise<any>
		function ResourceTracker(): Promise<IResourceTracker>
		function ResourceTracker$({ }): Promise<IResourceTracker>
		interface IResourceTracker {
			getfd(): Promise<any>
			getfd$($: {}): Promise<any>

			/**
			 * Make sure that resource tracker process is running.
			 * 
			 *         This can be run from any process.  Usually a child process will use
			 *         the resource created by its parent.
			 */
			ensure_running(): Promise<any>
			ensure_running$($: {}): Promise<any>

			/**
			 * Register name of resource with resource tracker.
			 */
			register(name, rtype): Promise<any>
			register$({ name, rtype }): Promise<any>

			/**
			 * Unregister name of resource with resource tracker.
			 */
			unregister(name, rtype): Promise<any>
			unregister$({ name, rtype }): Promise<any>
		}
	}
	module shared_memory {
		var _

		/**
		 * Creates a new shared memory block or attaches to an existing
		 *     shared memory block.
		 * 
		 *     Every shared memory block is assigned a unique name.  This enables
		 *     one process to create a shared memory block with a particular name
		 *     so that a different process can attach to that same shared memory
		 *     block using that same name.
		 * 
		 *     As a resource for sharing data across processes, shared memory blocks
		 *     may outlive the original process that created them.  When one process
		 *     no longer needs access to a shared memory block that might still be
		 *     needed by other processes, the close() method should be called.
		 *     When a shared memory block is no longer needed by any process, the
		 *     unlink() method should be called to ensure proper cleanup.
		 */
		function SharedMemory(name?, create?: boolean, size?): Promise<ISharedMemory>
		function SharedMemory$({ name, create, size }: { name?, create?, size?}): Promise<ISharedMemory>
		interface ISharedMemory {

			/**
			 * A memoryview of contents of the shared memory block.
			 */
			buf(): Promise<any>
			buf$($: {}): Promise<any>

			/**
			 * Unique name that identifies the shared memory block.
			 */
			name(): Promise<any>
			name$($: {}): Promise<any>

			/**
			 * Size in bytes.
			 */
			size(): Promise<any>
			size$($: {}): Promise<any>

			/**
			 * Closes access to the shared memory from this instance but does
			 *         not destroy the shared memory block.
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Requests that the underlying shared memory block be destroyed.
			 * 
			 *         In order to ensure proper cleanup of resources, unlink should be
			 *         called once (and only once) across all processes which have access
			 *         to the shared memory block.
			 */
			unlink(): Promise<any>
			unlink$($: {}): Promise<any>
		}

		/**
		 * Pattern for a mutable list-like object shareable via a shared
		 *     memory block.  It differs from the built-in list type in that these
		 *     lists can not change their overall length (i.e. no append, insert,
		 *     etc.)
		 * 
		 *     Because values are packed into a memoryview as bytes, the struct
		 *     packing format for any storable value must require no more than 8
		 *     characters to describe its format.
		 */
		function ShareableList(sequence?): Promise<IShareableList>
		function ShareableList$({ sequence }: { sequence?}): Promise<IShareableList>
		interface IShareableList {

			/**
			 * The struct packing format used by all currently stored items.
			 */
			format(): Promise<any>
			format$($: {}): Promise<any>

			/**
			 * L.count(value) -> integer -- return number of occurrences of value.
			 */
			count(value): Promise<any>
			count$({ value }): Promise<any>

			/**
			 * L.index(value) -> integer -- return first index of value.
			 *         Raises ValueError if the value is not present.
			 */
			index(value): Promise<any>
			index$({ value }): Promise<any>
		}
	}
	module sharedctypes {
		var _

		/**
		 * 
		 *     Returns a ctypes object allocated from shared memory
		 *     
		 */
		function RawValue(typecode_or_type): Promise<any>
		function RawValue$({ typecode_or_type }): Promise<any>

		/**
		 * 
		 *     Returns a ctypes array allocated from shared memory
		 *     
		 */
		function RawArray(typecode_or_type, size_or_initializer): Promise<any>
		function RawArray$({ typecode_or_type, size_or_initializer }): Promise<any>

		/**
		 * 
		 *     Return a synchronization wrapper for a Value
		 *     
		 */
		function Value(typecode_or_type): Promise<any>
		function Value$({ typecode_or_type }): Promise<any>

		/**
		 * 
		 *     Return a synchronization wrapper for a RawArray
		 *     
		 */
		function Array(typecode_or_type, size_or_initializer): Promise<any>
		function Array$({ typecode_or_type, size_or_initializer }): Promise<any>
		function copy(obj): Promise<any>
		function copy$({ obj }): Promise<any>
		function synchronized(obj, lock?, ctx?): Promise<any>
		function synchronized$({ obj, lock, ctx }: { obj, lock?, ctx?}): Promise<any>
		function reduce_ctype(obj): Promise<any>
		function reduce_ctype$({ obj }): Promise<any>
		function rebuild_ctype(type_, wrapper, length): Promise<any>
		function rebuild_ctype$({ type_, wrapper, length }): Promise<any>
		function make_property(name): Promise<any>
		function make_property$({ name }): Promise<any>
		function SynchronizedBase(obj, lock?, ctx?): Promise<ISynchronizedBase>
		function SynchronizedBase$({ obj, lock, ctx }: { obj, lock?, ctx?}): Promise<ISynchronizedBase>
		interface ISynchronizedBase {
			get_obj(): Promise<any>
			get_obj$($: {}): Promise<any>
			get_lock(): Promise<any>
			get_lock$($: {}): Promise<any>
		}
		interface ISynchronized extends ISynchronizedBase {
			value
		}
		interface ISynchronizedArray extends ISynchronizedBase {
		}
		interface ISynchronizedString extends ISynchronizedArray {
			raw
		}
		let typecode_to_type: Promise<any>
		let template: Promise<any>
		let prop_cache: Promise<any>
		let class_cache: Promise<any>
	}
	module spawn {
		var _
		function set_executable(exe): Promise<any>
		function set_executable$({ exe }): Promise<any>
		function get_executable(): Promise<any>
		function get_executable$($: {}): Promise<any>

		/**
		 * 
		 *     Return whether commandline indicates we are forking
		 *     
		 */
		function is_forking(argv): Promise<any>
		function is_forking$({ argv }): Promise<any>

		/**
		 * 
		 *     Run code for process object if this in not the main process
		 *     
		 */
		function freeze_support(): Promise<any>
		function freeze_support$($: {}): Promise<any>

		/**
		 * 
		 *     Returns prefix of command line used for spawning a child process
		 *     
		 */
		function get_command_line(): Promise<any>
		function get_command_line$($: {}): Promise<any>

		/**
		 * 
		 *     Run code specified by data received over pipe
		 *     
		 */
		function spawn_main(pipe_handle, parent_pid?, tracker_fd?): Promise<any>
		function spawn_main$({ pipe_handle, parent_pid, tracker_fd }: { pipe_handle, parent_pid?, tracker_fd?}): Promise<any>

		/**
		 * 
		 *     Return info about parent needed by child to unpickle process object
		 *     
		 */
		function get_preparation_data(name): Promise<any>
		function get_preparation_data$({ name }): Promise<any>

		/**
		 * 
		 *     Try to get current process ready to unpickle process object
		 *     
		 */
		function prepare(data): Promise<any>
		function prepare$({ data }): Promise<any>

		/**
		 * 
		 *     Set sys.modules['__main__'] to module at main_path
		 *     
		 */
		function import_main_path(main_path): Promise<any>
		function import_main_path$({ main_path }): Promise<any>
		let WINEXE: Promise<any>
		let WINSERVICE: Promise<any>
		let old_main_modules: Promise<any>
	}
	module synchronize {
		var _
		function SemLock(kind, value, maxvalue): Promise<ISemLock>
		function SemLock$({ kind, value, maxvalue }): Promise<ISemLock>
		interface ISemLock {
		}
		function Semaphore(value?): Promise<ISemaphore>
		function Semaphore$({ value }: { value?}): Promise<ISemaphore>
		interface ISemaphore extends ISemLock {
			get_value(): Promise<any>
			get_value$($: {}): Promise<any>
		}
		function BoundedSemaphore(value?): Promise<IBoundedSemaphore>
		function BoundedSemaphore$({ value }: { value?}): Promise<IBoundedSemaphore>
		interface IBoundedSemaphore extends ISemaphore {
		}
		function Lock(): Promise<ILock>
		function Lock$({ }): Promise<ILock>
		interface ILock extends ISemLock {
		}
		function RLock(): Promise<IRLock>
		function RLock$({ }): Promise<IRLock>
		interface IRLock extends ISemLock {
		}
		function Condition(lock?): Promise<ICondition>
		function Condition$({ lock }: { lock?}): Promise<ICondition>
		interface ICondition {
			wait(timeout?): Promise<any>
			wait$({ timeout }: { timeout?}): Promise<any>
			notify(n?): Promise<any>
			notify$({ n }: { n?}): Promise<any>
			notify_all(): Promise<any>
			notify_all$($: {}): Promise<any>
			wait_for(predicate, timeout?): Promise<any>
			wait_for$({ predicate, timeout }: { predicate, timeout?}): Promise<any>
		}
		function Event(): Promise<IEvent>
		function Event$({ }): Promise<IEvent>
		interface IEvent {
			is_set(): Promise<any>
			is_set$($: {}): Promise<any>
			set(): Promise<any>
			set$($: {}): Promise<any>
			clear(): Promise<any>
			clear$($: {}): Promise<any>
			wait(timeout?): Promise<any>
			wait$({ timeout }: { timeout?}): Promise<any>
		}
		function Barrier(parties, action?, timeout?): Promise<IBarrier>
		function Barrier$({ parties, action, timeout }: { parties, action?, timeout?}): Promise<IBarrier>
		interface IBarrier {
		}
		let SEM_VALUE_MAX: Promise<any>
	}
	module util {
		var _
		function sub_debug(msg): Promise<any>
		function sub_debug$({ msg }): Promise<any>
		function debug(msg): Promise<any>
		function debug$({ msg }): Promise<any>
		function info(msg): Promise<any>
		function info$({ msg }): Promise<any>
		function sub_warning(msg): Promise<any>
		function sub_warning$({ msg }): Promise<any>

		/**
		 * 
		 *     Returns logger used by multiprocessing
		 *     
		 */
		function get_logger(): Promise<any>
		function get_logger$($: {}): Promise<any>

		/**
		 * 
		 *     Turn on logging and add a handler which prints to stderr
		 *     
		 */
		function log_to_stderr(level?): Promise<any>
		function log_to_stderr$({ level }: { level?}): Promise<any>
		function is_abstract_socket_namespace(address): Promise<any>
		function is_abstract_socket_namespace$({ address }): Promise<any>
		function get_temp_dir(): Promise<any>
		function get_temp_dir$($: {}): Promise<any>
		function register_after_fork(obj, func): Promise<any>
		function register_after_fork$({ obj, func }): Promise<any>

		/**
		 * 
		 *     Returns true if the process is shutting down
		 *     
		 */
		function is_exiting(): Promise<any>
		function is_exiting$($: {}): Promise<any>
		function close_all_fds_except(fds): Promise<any>
		function close_all_fds_except$({ fds }): Promise<any>
		function spawnv_passfds(path, args, passfds): Promise<any>
		function spawnv_passfds$({ path, args, passfds }): Promise<any>

		/**
		 * Close each file descriptor given as an argument
		 */
		function close_fds(): Promise<any>
		function close_fds$($: {}): Promise<any>

		/**
		 * 
		 *     Class which supports object finalization using weakrefs
		 *     
		 */
		function Finalize(obj, callback, args?, kwargs?, exitpriority?): Promise<IFinalize>
		function Finalize$({ obj, callback, args, kwargs, exitpriority }: { obj, callback, args?, kwargs?, exitpriority?}): Promise<IFinalize>
		interface IFinalize {

			/**
			 * 
			 *         Cancel finalization of the object
			 *         
			 */
			cancel(): Promise<any>
			cancel$($: {}): Promise<any>

			/**
			 * 
			 *         Return whether this finalizer is still waiting to invoke callback
			 *         
			 */
			still_active(): Promise<any>
			still_active$($: {}): Promise<any>
		}
		function ForkAwareThreadLock(): Promise<IForkAwareThreadLock>
		function ForkAwareThreadLock$({ }): Promise<IForkAwareThreadLock>
		interface IForkAwareThreadLock {
		}
		function ForkAwareLocal(): Promise<IForkAwareLocal>
		function ForkAwareLocal$({ }): Promise<IForkAwareLocal>
		interface IForkAwareLocal {
		}
		let NOTSET: Promise<any>
		let SUBDEBUG: Promise<any>
		let DEBUG: Promise<any>
		let INFO: Promise<any>
		let SUBWARNING: Promise<any>
		let LOGGER_NAME: Promise<any>
		let DEFAULT_LOGGING_FORMAT: Promise<any>
		let abstract_sockets_supported: Promise<any>
		let MAXFD: Promise<any>
	}
}
declare module netrc {
	var _

	/**
	 * Exception raised on syntax errors in the .netrc file.
	 */
	function NetrcParseError(msg, filename?, lineno?): Promise<INetrcParseError>
	function NetrcParseError$({ msg, filename, lineno }: { msg, filename?, lineno?}): Promise<INetrcParseError>
	interface INetrcParseError {
	}
	function netrc(file?): Promise<Inetrc>
	function netrc$({ file }: { file?}): Promise<Inetrc>
	interface Inetrc {

		/**
		 * Return a (user, account, password) tuple for given host.
		 */
		authenticators(host): Promise<any>
		authenticators$({ host }): Promise<any>
	}
}
declare module nntplib {
	var _

	/**
	 * Takes a unicode string representing a munged header value
	 *     and decodes it as a (possibly non-ASCII) readable value.
	 */
	function decode_header(header_str): Promise<any>
	function decode_header$({ header_str }): Promise<any>
	function cut(s, lim): Promise<any>
	function cut$({ s, lim }): Promise<any>

	/**
	 * Base class for all nntplib exceptions
	 */
	function NNTPError(): Promise<INNTPError>
	function NNTPError$({ }): Promise<INNTPError>
	interface INNTPError {
	}

	/**
	 * Unexpected [123]xx reply
	 */
	interface INNTPReplyError extends INNTPError {
	}

	/**
	 * 4xx errors
	 */
	interface INNTPTemporaryError extends INNTPError {
	}

	/**
	 * 5xx errors
	 */
	interface INNTPPermanentError extends INNTPError {
	}

	/**
	 * Response does not begin with [1-5]
	 */
	interface INNTPProtocolError extends INNTPError {
	}

	/**
	 * Error in response data
	 */
	interface INNTPDataError extends INNTPError {
	}

	/**
	 * Initialize an instance.  Arguments:
	 *         - host: hostname to connect to
	 *         - port: port to connect to (default the standard NNTP port)
	 *         - user: username to authenticate with
	 *         - password: password to use with username
	 *         - readermode: if true, send 'mode reader' command after
	 *                       connecting.
	 *         - usenetrc: allow loading username and password from ~/.netrc file
	 *                     if not specified explicitly
	 *         - timeout: timeout (in seconds) used for socket connections
	 * 
	 *         readermode is sometimes necessary if you are connecting to an
	 *         NNTP server on the local machine and intend to call
	 *         reader-specific commands, such as `group'.  If you get
	 *         unexpected NNTPPermanentErrors, you might need to set
	 *         readermode.
	 *         
	 */
	function NNTP(host, port?, user?, password?, readermode?, usenetrc?: boolean, timeout?): Promise<INNTP>
	function NNTP$({ host, port, user, password, readermode, usenetrc, timeout }: { host, port?, user?, password?, readermode?, usenetrc?, timeout?}): Promise<INNTP>
	interface INNTP {

		/**
		 * Get the welcome message from the server
		 *         (this is read and squirreled away by __init__()).
		 *         If the response code is 200, posting is allowed;
		 *         if it 201, posting is not allowed.
		 */
		getwelcome(): Promise<any>
		getwelcome$($: {}): Promise<any>

		/**
		 * Get the server capabilities, as read by __init__().
		 *         If the CAPABILITIES command is not supported, an empty dict is
		 *         returned.
		 */
		getcapabilities(): Promise<any>
		getcapabilities$($: {}): Promise<any>

		/**
		 * Set the debugging level.  Argument 'level' means:
		 *         0: no debugging output (default)
		 *         1: print commands and responses but not body text etc.
		 *         2: also print raw lines read and sent before stripping CR/LF
		 */
		set_debuglevel(level): Promise<any>
		set_debuglevel$({ level }): Promise<any>

		/**
		 * Process a CAPABILITIES command.  Not supported by all servers.
		 *         Return:
		 *         - resp: server response if successful
		 *         - caps: a dictionary mapping capability names to lists of tokens
		 *         (for example {'VERSION': ['2'], 'OVER': [], LIST: ['ACTIVE', 'HEADERS'] })
		 *         
		 */
		capabilities(): Promise<any>
		capabilities$($: {}): Promise<any>

		/**
		 * Process a NEWGROUPS command.  Arguments:
		 *         - date: a date or datetime object
		 *         Return:
		 *         - resp: server response if successful
		 *         - list: list of newsgroup names
		 *         
		 */
		newgroups(date): Promise<any>
		newgroups$({ date }): Promise<any>

		/**
		 * Process a NEWNEWS command.  Arguments:
		 *         - group: group name or '*'
		 *         - date: a date or datetime object
		 *         Return:
		 *         - resp: server response if successful
		 *         - list: list of message ids
		 *         
		 */
		newnews(group, date): Promise<any>
		newnews$({ group, date }): Promise<any>

		/**
		 * Process a LIST or LIST ACTIVE command. Arguments:
		 *         - group_pattern: a pattern indicating which groups to query
		 *         - file: Filename string or file object to store the result in
		 *         Returns:
		 *         - resp: server response if successful
		 *         - list: list of (group, last, first, flag) (strings)
		 *         
		 */
		list(group_pattern?): Promise<any>
		list$({ group_pattern }: { group_pattern?}): Promise<any>

		/**
		 * Get a description for a single group.  If more than one
		 *         group matches ('group' is a pattern), return the first.  If no
		 *         group matches, return an empty string.
		 * 
		 *         This elides the response code from the server, since it can
		 *         only be '215' or '285' (for xgtitle) anyway.  If the response
		 *         code is needed, use the 'descriptions' method.
		 * 
		 *         NOTE: This neither checks for a wildcard in 'group' nor does
		 *         it check whether the group actually exists.
		 */
		description(group): Promise<any>
		description$({ group }): Promise<any>

		/**
		 * Get descriptions for a range of groups.
		 */
		descriptions(group_pattern): Promise<any>
		descriptions$({ group_pattern }): Promise<any>

		/**
		 * Process a GROUP command.  Argument:
		 *         - group: the group name
		 *         Returns:
		 *         - resp: server response if successful
		 *         - count: number of articles
		 *         - first: first article number
		 *         - last: last article number
		 *         - name: the group name
		 *         
		 */
		group(name): Promise<any>
		group$({ name }): Promise<any>

		/**
		 * Process a HELP command. Argument:
		 *         - file: Filename string or file object to store the result in
		 *         Returns:
		 *         - resp: server response if successful
		 *         - list: list of strings returned by the server in response to the
		 *                 HELP command
		 *         
		 */
		help(): Promise<any>
		help$($: {}): Promise<any>

		/**
		 * Process a STAT command.  Argument:
		 *         - message_spec: article number or message id (if not specified,
		 *           the current article is selected)
		 *         Returns:
		 *         - resp: server response if successful
		 *         - art_num: the article number
		 *         - message_id: the message id
		 *         
		 */
		stat(message_spec?): Promise<any>
		stat$({ message_spec }: { message_spec?}): Promise<any>

		/**
		 * Process a NEXT command.  No arguments.  Return as for STAT.
		 */
		next(): Promise<any>
		next$($: {}): Promise<any>

		/**
		 * Process a LAST command.  No arguments.  Return as for STAT.
		 */
		last(): Promise<any>
		last$($: {}): Promise<any>

		/**
		 * Process a HEAD command.  Argument:
		 *         - message_spec: article number or message id
		 *         - file: filename string or file object to store the headers in
		 *         Returns:
		 *         - resp: server response if successful
		 *         - ArticleInfo: (article number, message id, list of header lines)
		 *         
		 */
		head(message_spec?): Promise<any>
		head$({ message_spec }: { message_spec?}): Promise<any>

		/**
		 * Process a BODY command.  Argument:
		 *         - message_spec: article number or message id
		 *         - file: filename string or file object to store the body in
		 *         Returns:
		 *         - resp: server response if successful
		 *         - ArticleInfo: (article number, message id, list of body lines)
		 *         
		 */
		body(message_spec?): Promise<any>
		body$({ message_spec }: { message_spec?}): Promise<any>

		/**
		 * Process an ARTICLE command.  Argument:
		 *         - message_spec: article number or message id
		 *         - file: filename string or file object to store the article in
		 *         Returns:
		 *         - resp: server response if successful
		 *         - ArticleInfo: (article number, message id, list of article lines)
		 *         
		 */
		article(message_spec?): Promise<any>
		article$({ message_spec }: { message_spec?}): Promise<any>

		/**
		 * Process a SLAVE command.  Returns:
		 *         - resp: server response if successful
		 *         
		 */
		slave(): Promise<any>
		slave$($: {}): Promise<any>

		/**
		 * Process an XHDR command (optional server extension).  Arguments:
		 *         - hdr: the header type (e.g. 'subject')
		 *         - str: an article nr, a message id, or a range nr1-nr2
		 *         - file: Filename string or file object to store the result in
		 *         Returns:
		 *         - resp: server response if successful
		 *         - list: list of (nr, value) strings
		 *         
		 */
		xhdr(hdr, str): Promise<any>
		xhdr$({ hdr, str }): Promise<any>

		/**
		 * Process an XOVER command (optional server extension) Arguments:
		 *         - start: start of range
		 *         - end: end of range
		 *         - file: Filename string or file object to store the result in
		 *         Returns:
		 *         - resp: server response if successful
		 *         - list: list of dicts containing the response fields
		 *         
		 */
		xover(start, end): Promise<any>
		xover$({ start, end }): Promise<any>

		/**
		 * Process an OVER command.  If the command isn't supported, fall
		 *         back to XOVER. Arguments:
		 *         - message_spec:
		 *             - either a message id, indicating the article to fetch
		 *               information about
		 *             - or a (start, end) tuple, indicating a range of article numbers;
		 *               if end is None, information up to the newest message will be
		 *               retrieved
		 *             - or None, indicating the current article number must be used
		 *         - file: Filename string or file object to store the result in
		 *         Returns:
		 *         - resp: server response if successful
		 *         - list: list of dicts containing the response fields
		 * 
		 *         NOTE: the "message id" form isn't supported by XOVER
		 *         
		 */
		over(message_spec): Promise<any>
		over$({ message_spec }): Promise<any>

		/**
		 * Process the DATE command.
		 *         Returns:
		 *         - resp: server response if successful
		 *         - date: datetime object
		 *         
		 */
		date(): Promise<any>
		date$($: {}): Promise<any>

		/**
		 * Process a POST command.  Arguments:
		 *         - data: bytes object, iterable or file containing the article
		 *         Returns:
		 *         - resp: server response if successful
		 */
		post(data): Promise<any>
		post$({ data }): Promise<any>

		/**
		 * Process an IHAVE command.  Arguments:
		 *         - message_id: message-id of the article
		 *         - data: file containing the article
		 *         Returns:
		 *         - resp: server response if successful
		 *         Note that if the server refuses the article an exception is raised.
		 */
		ihave(message_id, data): Promise<any>
		ihave$({ message_id, data }): Promise<any>

		/**
		 * Process a QUIT command and close the socket.  Returns:
		 *         - resp: server response if successful
		 */
		quit(): Promise<any>
		quit$($: {}): Promise<any>
		login(user?, password?, usenetrc?: boolean): Promise<any>
		login$({ user, password, usenetrc }: { user?, password?, usenetrc?}): Promise<any>
		encoding
		errors
		debug
	}

	/**
	 * This works identically to NNTP.__init__, except for the change
	 *             in default port and the `ssl_context` argument for SSL connections.
	 *             
	 */
	function NNTP_SSL(host, port?, user?, password?, ssl_context?, readermode?, usenetrc?: boolean, timeout?): Promise<INNTP_SSL>
	function NNTP_SSL$({ host, port, user, password, ssl_context, readermode, usenetrc, timeout }: { host, port?, user?, password?, ssl_context?, readermode?, usenetrc?, timeout?}): Promise<INNTP_SSL>
	interface INNTP_SSL extends INNTP {
	}
	let NNTP_PORT: Promise<any>
	let NNTP_SSL_PORT: Promise<any>
	let GroupInfo: Promise<any>
	let ArticleInfo: Promise<any>
	let parser: Promise<any>
	let args: Promise<any>
	let port: Promise<any>
	let s: Promise<any>
	let caps: Promise<any>
	let first: Promise<any>
	let author: Promise<any>
	let subject: Promise<any>
	let lines: Promise<any>
}
declare module ntpath {
	var _

	/**
	 * Normalize case of pathname.
	 * 
	 *     Makes all characters lowercase and all slashes into backslashes.
	 */
	function normcase(s): Promise<any>
	function normcase$({ s }): Promise<any>

	/**
	 * Test whether a path is absolute
	 */
	function isabs(s): Promise<any>
	function isabs$({ s }): Promise<any>
	function join(path): Promise<any>
	function join$({ path }): Promise<any>

	/**
	 * Split a pathname into drive/UNC sharepoint and relative path specifiers.
	 *     Returns a 2-tuple (drive_or_unc, path); either part may be empty.
	 * 
	 *     If you assign
	 *         result = splitdrive(p)
	 *     It is always true that:
	 *         result[0] + result[1] == p
	 * 
	 *     If the path contained a drive letter, drive_or_unc will contain everything
	 *     up to and including the colon.  e.g. splitdrive("c:/dir") returns ("c:", "/dir")
	 * 
	 *     If the path contained a UNC path, the drive_or_unc will contain the host name
	 *     and share up to but not including the fourth directory separator character.
	 *     e.g. splitdrive("//host/computer/dir") returns ("//host/computer", "/dir")
	 * 
	 *     Paths cannot contain both a drive letter and a UNC path.
	 * 
	 *     
	 */
	function splitdrive(p): Promise<any>
	function splitdrive$({ p }): Promise<any>

	/**
	 * Split a pathname.
	 * 
	 *     Return tuple (head, tail) where tail is everything after the final slash.
	 *     Either part may be empty.
	 */
	function split(p): Promise<any>
	function split$({ p }): Promise<any>
	function splitext(p): Promise<any>
	function splitext$({ p }): Promise<any>

	/**
	 * Returns the final component of a pathname
	 */
	function basename(p): Promise<any>
	function basename$({ p }): Promise<any>

	/**
	 * Returns the directory component of a pathname
	 */
	function dirname(p): Promise<any>
	function dirname$({ p }): Promise<any>

	/**
	 * Test whether a path is a symbolic link.
	 *     This will always return false for Windows prior to 6.0.
	 *     
	 */
	function islink(path): Promise<any>
	function islink$({ path }): Promise<any>

	/**
	 * Test whether a path exists.  Returns True for broken symbolic links
	 */
	function lexists(path): Promise<any>
	function lexists$({ path }): Promise<any>

	/**
	 * Test whether a path is a mount point (a drive root, the root of a
	 *     share, or a mounted volume)
	 */
	function ismount(path): Promise<any>
	function ismount$({ path }): Promise<any>

	/**
	 * Expand ~ and ~user constructs.
	 * 
	 *     If user or $HOME is unknown, do nothing.
	 */
	function expanduser(path): Promise<any>
	function expanduser$({ path }): Promise<any>

	/**
	 * Expand shell variables of the forms $var, ${var} and %var%.
	 * 
	 *     Unknown variables are left unchanged.
	 */
	function expandvars(path): Promise<any>
	function expandvars$({ path }): Promise<any>

	/**
	 * Normalize path, eliminating double slashes, etc.
	 */
	function normpath(path): Promise<any>
	function normpath$({ path }): Promise<any>

	/**
	 * Return the absolute version of a path.
	 */
	function abspath(path): Promise<any>
	function abspath$({ path }): Promise<any>
	function realpath(path): Promise<any>
	function realpath$({ path }): Promise<any>

	/**
	 * Return a relative version of a path
	 */
	function relpath(path, start?): Promise<any>
	function relpath$({ path, start }: { path, start?}): Promise<any>

	/**
	 * Given a sequence of path names, returns the longest common sub-path.
	 */
	function commonpath(paths): Promise<any>
	function commonpath$({ paths }): Promise<any>
	let curdir: Promise<any>
	let pardir: Promise<any>
	let extsep: Promise<any>
	let sep: Promise<any>
	let pathsep: Promise<any>
	let altsep: Promise<any>
	let defpath: Promise<any>
	let devnull: Promise<any>
	let supports_unicode_filenames: Promise<any>
}
declare module nturl2path {
	var _

	/**
	 * OS-specific conversion from a relative URL of the 'file' scheme
	 *     to a file system path; not recommended for general use.
	 */
	function url2pathname(url): Promise<any>
	function url2pathname$({ url }): Promise<any>

	/**
	 * OS-specific conversion from a file system path to a relative URL
	 *     of the 'file' scheme; not recommended for general use.
	 */
	function pathname2url(p): Promise<any>
	function pathname2url$({ p }): Promise<any>
}
declare module numbers {
	var _

	/**
	 * All numbers inherit from this class.
	 * 
	 *     If you just want to check if an argument x is a number, without
	 *     caring what kind, use isinstance(x, Number).
	 *     
	 */
	interface INumber {
	}

	/**
	 * Complex defines the operations that work on the builtin complex type.
	 * 
	 *     In short, those are: a conversion to complex, .real, .imag, +, -,
	 *     *, /, **, abs(), .conjugate, ==, and !=.
	 * 
	 *     If it is given heterogeneous arguments, and doesn't have special
	 *     knowledge about them, it should fall back to the builtin complex
	 *     type as described below.
	 *     
	 */
	interface IComplex extends INumber {

		/**
		 * Retrieve the real component of this number.
		 * 
		 *         This should subclass Real.
		 *         
		 */
		real(): Promise<any>
		real$($: {}): Promise<any>

		/**
		 * Retrieve the imaginary component of this number.
		 * 
		 *         This should subclass Real.
		 *         
		 */
		imag(): Promise<any>
		imag$($: {}): Promise<any>

		/**
		 * (x+y*i).conjugate() returns (x-y*i).
		 */
		conjugate(): Promise<any>
		conjugate$($: {}): Promise<any>
	}

	/**
	 * To Complex, Real adds the operations that work on real numbers.
	 * 
	 *     In short, those are: a conversion to float, trunc(), divmod,
	 *     %, <, <=, >, and >=.
	 * 
	 *     Real also provides defaults for the derived operations.
	 *     
	 */
	interface IReal extends IComplex {

		/**
		 * Real numbers are their real component.
		 */
		real(): Promise<any>
		real$($: {}): Promise<any>

		/**
		 * Real numbers have no imaginary component.
		 */
		imag(): Promise<any>
		imag$($: {}): Promise<any>

		/**
		 * Conjugate is a no-op for Reals.
		 */
		conjugate(): Promise<any>
		conjugate$($: {}): Promise<any>
	}

	/**
	 * .numerator and .denominator should be in lowest terms.
	 */
	interface IRational extends IReal {
		numerator(): Promise<any>
		numerator$($: {}): Promise<any>
		denominator(): Promise<any>
		denominator$($: {}): Promise<any>
	}

	/**
	 * Integral adds methods that work on integral numbers.
	 * 
	 *     In short, these are conversion to int, pow with modulus, and the
	 *     bit-string operations.
	 *     
	 */
	interface IIntegral extends IRational {

		/**
		 * Integers are their own numerators.
		 */
		numerator(): Promise<any>
		numerator$($: {}): Promise<any>

		/**
		 * Integers have a denominator of 1.
		 */
		denominator(): Promise<any>
		denominator$($: {}): Promise<any>
	}
}
declare module opcode {
	var _
	function def_op(name, op): Promise<any>
	function def_op$({ name, op }): Promise<any>
	function name_op(name, op): Promise<any>
	function name_op$({ name, op }): Promise<any>
	function jrel_op(name, op): Promise<any>
	function jrel_op$({ name, op }): Promise<any>
	function jabs_op(name, op): Promise<any>
	function jabs_op$({ name, op }): Promise<any>
	let cmp_op: Promise<any>
	let hasconst: Promise<any>
	let hasname: Promise<any>
	let hasjrel: Promise<any>
	let hasjabs: Promise<any>
	let haslocal: Promise<any>
	let hascompare: Promise<any>
	let hasfree: Promise<any>
	let hasnargs: Promise<any>
	let opmap: Promise<any>
	let opname: Promise<any>
	let HAVE_ARGUMENT: Promise<any>
	let EXTENDED_ARG: Promise<any>
}
declare module operator {
	var _

	/**
	 * Same as a < b.
	 */
	function lt(a, b): Promise<any>
	function lt$({ a, b }): Promise<any>

	/**
	 * Same as a <= b.
	 */
	function le(a, b): Promise<any>
	function le$({ a, b }): Promise<any>

	/**
	 * Same as a == b.
	 */
	function eq(a, b): Promise<any>
	function eq$({ a, b }): Promise<any>

	/**
	 * Same as a != b.
	 */
	function ne(a, b): Promise<any>
	function ne$({ a, b }): Promise<any>

	/**
	 * Same as a >= b.
	 */
	function ge(a, b): Promise<any>
	function ge$({ a, b }): Promise<any>

	/**
	 * Same as a > b.
	 */
	function gt(a, b): Promise<any>
	function gt$({ a, b }): Promise<any>

	/**
	 * Same as not a.
	 */
	function not_(a): Promise<any>
	function not_$({ a }): Promise<any>

	/**
	 * Return True if a is true, False otherwise.
	 */
	function truth(a): Promise<any>
	function truth$({ a }): Promise<any>

	/**
	 * Same as a is b.
	 */
	function is_(a, b): Promise<any>
	function is_$({ a, b }): Promise<any>

	/**
	 * Same as a is not b.
	 */
	function is_not(a, b): Promise<any>
	function is_not$({ a, b }): Promise<any>

	/**
	 * Same as abs(a).
	 */
	function abs(a): Promise<any>
	function abs$({ a }): Promise<any>

	/**
	 * Same as a + b.
	 */
	function add(a, b): Promise<any>
	function add$({ a, b }): Promise<any>

	/**
	 * Same as a & b.
	 */
	function and_(a, b): Promise<any>
	function and_$({ a, b }): Promise<any>

	/**
	 * Same as a // b.
	 */
	function floordiv(a, b): Promise<any>
	function floordiv$({ a, b }): Promise<any>

	/**
	 * Same as a.__index__().
	 */
	function index(a): Promise<any>
	function index$({ a }): Promise<any>

	/**
	 * Same as ~a.
	 */
	function inv(a): Promise<any>
	function inv$({ a }): Promise<any>

	/**
	 * Same as a << b.
	 */
	function lshift(a, b): Promise<any>
	function lshift$({ a, b }): Promise<any>

	/**
	 * Same as a % b.
	 */
	function mod(a, b): Promise<any>
	function mod$({ a, b }): Promise<any>

	/**
	 * Same as a * b.
	 */
	function mul(a, b): Promise<any>
	function mul$({ a, b }): Promise<any>

	/**
	 * Same as a @ b.
	 */
	function matmul(a, b): Promise<any>
	function matmul$({ a, b }): Promise<any>

	/**
	 * Same as -a.
	 */
	function neg(a): Promise<any>
	function neg$({ a }): Promise<any>

	/**
	 * Same as a | b.
	 */
	function or_(a, b): Promise<any>
	function or_$({ a, b }): Promise<any>

	/**
	 * Same as +a.
	 */
	function pos(a): Promise<any>
	function pos$({ a }): Promise<any>

	/**
	 * Same as a ** b.
	 */
	function pow(a, b): Promise<any>
	function pow$({ a, b }): Promise<any>

	/**
	 * Same as a >> b.
	 */
	function rshift(a, b): Promise<any>
	function rshift$({ a, b }): Promise<any>

	/**
	 * Same as a - b.
	 */
	function sub(a, b): Promise<any>
	function sub$({ a, b }): Promise<any>

	/**
	 * Same as a / b.
	 */
	function truediv(a, b): Promise<any>
	function truediv$({ a, b }): Promise<any>

	/**
	 * Same as a ^ b.
	 */
	function xor(a, b): Promise<any>
	function xor$({ a, b }): Promise<any>

	/**
	 * Same as a + b, for a and b sequences.
	 */
	function concat(a, b): Promise<any>
	function concat$({ a, b }): Promise<any>

	/**
	 * Same as b in a (note reversed operands).
	 */
	function contains(a, b): Promise<any>
	function contains$({ a, b }): Promise<any>

	/**
	 * Return the number of times b occurs in a.
	 */
	function countOf(a, b): Promise<any>
	function countOf$({ a, b }): Promise<any>

	/**
	 * Same as del a[b].
	 */
	function delitem(a, b): Promise<any>
	function delitem$({ a, b }): Promise<any>

	/**
	 * Same as a[b].
	 */
	function getitem(a, b): Promise<any>
	function getitem$({ a, b }): Promise<any>

	/**
	 * Return the first index of b in a.
	 */
	function indexOf(a, b): Promise<any>
	function indexOf$({ a, b }): Promise<any>

	/**
	 * Same as a[b] = c.
	 */
	function setitem(a, b, c): Promise<any>
	function setitem$({ a, b, c }): Promise<any>

	/**
	 * 
	 *     Return an estimate of the number of items in obj.
	 *     This is useful for presizing containers when building from an iterable.
	 * 
	 *     If the object supports len(), the result will be exact. Otherwise, it may
	 *     over- or under-estimate by an arbitrary amount. The result will be an
	 *     integer >= 0.
	 *     
	 */
	function length_hint(obj, def?): Promise<any>
	function length_hint$({ obj, def }: { obj, def?}): Promise<any>

	/**
	 * Same as a += b.
	 */
	function iadd(a, b): Promise<any>
	function iadd$({ a, b }): Promise<any>

	/**
	 * Same as a &= b.
	 */
	function iand(a, b): Promise<any>
	function iand$({ a, b }): Promise<any>

	/**
	 * Same as a += b, for a and b sequences.
	 */
	function iconcat(a, b): Promise<any>
	function iconcat$({ a, b }): Promise<any>

	/**
	 * Same as a //= b.
	 */
	function ifloordiv(a, b): Promise<any>
	function ifloordiv$({ a, b }): Promise<any>

	/**
	 * Same as a <<= b.
	 */
	function ilshift(a, b): Promise<any>
	function ilshift$({ a, b }): Promise<any>

	/**
	 * Same as a %= b.
	 */
	function imod(a, b): Promise<any>
	function imod$({ a, b }): Promise<any>

	/**
	 * Same as a *= b.
	 */
	function imul(a, b): Promise<any>
	function imul$({ a, b }): Promise<any>

	/**
	 * Same as a @= b.
	 */
	function imatmul(a, b): Promise<any>
	function imatmul$({ a, b }): Promise<any>

	/**
	 * Same as a |= b.
	 */
	function ior(a, b): Promise<any>
	function ior$({ a, b }): Promise<any>

	/**
	 * Same as a **= b.
	 */
	function ipow(a, b): Promise<any>
	function ipow$({ a, b }): Promise<any>

	/**
	 * Same as a >>= b.
	 */
	function irshift(a, b): Promise<any>
	function irshift$({ a, b }): Promise<any>

	/**
	 * Same as a -= b.
	 */
	function isub(a, b): Promise<any>
	function isub$({ a, b }): Promise<any>

	/**
	 * Same as a /= b.
	 */
	function itruediv(a, b): Promise<any>
	function itruediv$({ a, b }): Promise<any>

	/**
	 * Same as a ^= b.
	 */
	function ixor(a, b): Promise<any>
	function ixor$({ a, b }): Promise<any>

	/**
	 * 
	 *     Return a callable object that fetches the given attribute(s) from its operand.
	 *     After f = attrgetter('name'), the call f(r) returns r.name.
	 *     After g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).
	 *     After h = attrgetter('name.first', 'name.last'), the call h(r) returns
	 *     (r.name.first, r.name.last).
	 *     
	 */
	function attrgetter(attr): Promise<Iattrgetter>
	function attrgetter$({ attr }): Promise<Iattrgetter>
	interface Iattrgetter {
	}

	/**
	 * 
	 *     Return a callable object that fetches the given item(s) from its operand.
	 *     After f = itemgetter(2), the call f(r) returns r[2].
	 *     After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])
	 *     
	 */
	function itemgetter(item): Promise<Iitemgetter>
	function itemgetter$({ item }): Promise<Iitemgetter>
	interface Iitemgetter {
	}

	/**
	 * 
	 *     Return a callable object that calls the given method on its operand.
	 *     After f = methodcaller('name'), the call f(r) returns r.name().
	 *     After g = methodcaller('name', 'date', foo=1), the call g(r) returns
	 *     r.name('date', foo=1).
	 *     
	 */
	function methodcaller(name): Promise<Imethodcaller>
	function methodcaller$({ name }): Promise<Imethodcaller>
	interface Imethodcaller {
	}
	let invert: Promise<any>
}
declare module optparse {
	var _
	function check_builtin(option, opt, value): Promise<any>
	function check_builtin$({ option, opt, value }): Promise<any>
	function check_choice(option, opt, value): Promise<any>
	function check_choice$({ option, opt, value }): Promise<any>
	function OptParseError(msg): Promise<IOptParseError>
	function OptParseError$({ msg }): Promise<IOptParseError>
	interface IOptParseError {
	}

	/**
	 * 
	 *     Raised if an Option instance is created with invalid or
	 *     inconsistent arguments.
	 *     
	 */
	function OptionError(msg, option): Promise<IOptionError>
	function OptionError$({ msg, option }): Promise<IOptionError>
	interface IOptionError extends IOptParseError {
	}

	/**
	 * 
	 *     Raised if conflicting options are added to an OptionParser.
	 *     
	 */
	interface IOptionConflictError extends IOptionError {
	}

	/**
	 * 
	 *     Raised if an invalid option value is encountered on the command
	 *     line.
	 *     
	 */
	interface IOptionValueError extends IOptParseError {
	}

	/**
	 * 
	 *     Raised if an invalid option is seen on the command line.
	 *     
	 */
	function BadOptionError(opt_str): Promise<IBadOptionError>
	function BadOptionError$({ opt_str }): Promise<IBadOptionError>
	interface IBadOptionError extends IOptParseError {
	}

	/**
	 * 
	 *     Raised if an ambiguous option is seen on the command line.
	 *     
	 */
	function AmbiguousOptionError(opt_str, possibilities): Promise<IAmbiguousOptionError>
	function AmbiguousOptionError$({ opt_str, possibilities }): Promise<IAmbiguousOptionError>
	interface IAmbiguousOptionError extends IBadOptionError {
	}

	/**
	 * 
	 *     Abstract base class for formatting option help.  OptionParser
	 *     instances should use one of the HelpFormatter subclasses for
	 *     formatting help; by default IndentedHelpFormatter is used.
	 * 
	 *     Instance attributes:
	 *       parser : OptionParser
	 *         the controlling OptionParser instance
	 *       indent_increment : int
	 *         the number of columns to indent per nesting level
	 *       max_help_position : int
	 *         the maximum starting column for option help text
	 *       help_position : int
	 *         the calculated starting column for option help text;
	 *         initially the same as the maximum
	 *       width : int
	 *         total number of columns for output (pass None to constructor for
	 *         this value to be taken from the $COLUMNS environment variable)
	 *       level : int
	 *         current indentation level
	 *       current_indent : int
	 *         current indentation level (in columns)
	 *       help_width : int
	 *         number of columns available for option help text (calculated)
	 *       default_tag : str
	 *         text to replace with each option's default value, "%default"
	 *         by default.  Set to false value to disable default value expansion.
	 *       option_strings : { Option : str }
	 *         maps Option instances to the snippet of help text explaining
	 *         the syntax of that option, e.g. "-h, --help" or
	 *         "-fFILE, --file=FILE"
	 *       _short_opt_fmt : str
	 *         format string controlling how short options with values are
	 *         printed in help text.  Must be either "%s%s" ("-fFILE") or
	 *         "%s %s" ("-f FILE"), because those are the two syntaxes that
	 *         Optik supports.
	 *       _long_opt_fmt : str
	 *         similar but for long options; must be either "%s %s" ("--file FILE")
	 *         or "%s=%s" ("--file=FILE").
	 *     
	 */
	function HelpFormatter(indent_increment, max_help_position, width, short_first): Promise<IHelpFormatter>
	function HelpFormatter$({ indent_increment, max_help_position, width, short_first }): Promise<IHelpFormatter>
	interface IHelpFormatter {
		set_parser(parser): Promise<any>
		set_parser$({ parser }): Promise<any>
		set_short_opt_delimiter(delim): Promise<any>
		set_short_opt_delimiter$({ delim }): Promise<any>
		set_long_opt_delimiter(delim): Promise<any>
		set_long_opt_delimiter$({ delim }): Promise<any>
		indent(): Promise<any>
		indent$($: {}): Promise<any>
		dedent(): Promise<any>
		dedent$($: {}): Promise<any>
		format_usage(usage): Promise<any>
		format_usage$({ usage }): Promise<any>
		format_heading(heading): Promise<any>
		format_heading$({ heading }): Promise<any>
		format_description(description): Promise<any>
		format_description$({ description }): Promise<any>
		format_epilog(epilog): Promise<any>
		format_epilog$({ epilog }): Promise<any>
		expand_default(option): Promise<any>
		expand_default$({ option }): Promise<any>
		format_option(option): Promise<any>
		format_option$({ option }): Promise<any>
		store_option_strings(parser): Promise<any>
		store_option_strings$({ parser }): Promise<any>

		/**
		 * Return a comma-separated list of option strings & metavariables.
		 */
		format_option_strings(option): Promise<any>
		format_option_strings$({ option }): Promise<any>
		NO_DEFAULT_VALUE
	}

	/**
	 * Format help with indented section bodies.
	 *     
	 */
	function IndentedHelpFormatter(indent_increment?, max_help_position?, width?, short_first?): Promise<IIndentedHelpFormatter>
	function IndentedHelpFormatter$({ indent_increment, max_help_position, width, short_first }: { indent_increment?, max_help_position?, width?, short_first?}): Promise<IIndentedHelpFormatter>
	interface IIndentedHelpFormatter extends IHelpFormatter {
		format_usage(usage): Promise<any>
		format_usage$({ usage }): Promise<any>
		format_heading(heading): Promise<any>
		format_heading$({ heading }): Promise<any>
	}

	/**
	 * Format help with underlined section headers.
	 *     
	 */
	function TitledHelpFormatter(indent_increment?, max_help_position?, width?, short_first?): Promise<ITitledHelpFormatter>
	function TitledHelpFormatter$({ indent_increment, max_help_position, width, short_first }: { indent_increment?, max_help_position?, width?, short_first?}): Promise<ITitledHelpFormatter>
	interface ITitledHelpFormatter extends IHelpFormatter {
		format_usage(usage): Promise<any>
		format_usage$({ usage }): Promise<any>
		format_heading(heading): Promise<any>
		format_heading$({ heading }): Promise<any>
	}

	/**
	 * 
	 *     Instance attributes:
	 *       _short_opts : [string]
	 *       _long_opts : [string]
	 * 
	 *       action : string
	 *       type : string
	 *       dest : string
	 *       default : any
	 *       nargs : int
	 *       const : any
	 *       choices : [string]
	 *       callback : function
	 *       callback_args : (any*)
	 *       callback_kwargs : { string : any }
	 *       help : string
	 *       metavar : string
	 *     
	 */
	function Option(): Promise<IOption>
	function Option$({ }): Promise<IOption>
	interface IOption {
		takes_value(): Promise<any>
		takes_value$($: {}): Promise<any>
		get_opt_string(): Promise<any>
		get_opt_string$($: {}): Promise<any>
		check_value(opt, value): Promise<any>
		check_value$({ opt, value }): Promise<any>
		convert_value(opt, value): Promise<any>
		convert_value$({ opt, value }): Promise<any>
		process(opt, value, values, parser): Promise<any>
		process$({ opt, value, values, parser }): Promise<any>
		take_action(action, dest, opt, value, values, parser): Promise<any>
		take_action$({ action, dest, opt, value, values, parser }): Promise<any>
		ATTRS
		ACTIONS
		STORE_ACTIONS
		TYPED_ACTIONS
		ALWAYS_TYPED_ACTIONS
		CONST_ACTIONS
		TYPES
		TYPE_CHECKER
		CHECK_METHODS
	}
	function Values(defaults?): Promise<IValues>
	function Values$({ defaults }: { defaults?}): Promise<IValues>
	interface IValues {
		read_module(modname, mode?): Promise<any>
		read_module$({ modname, mode }: { modname, mode?}): Promise<any>
		read_file(filename, mode?): Promise<any>
		read_file$({ filename, mode }: { filename, mode?}): Promise<any>
		ensure_value(attr, value): Promise<any>
		ensure_value$({ attr, value }): Promise<any>
	}

	/**
	 * 
	 *     Abstract base class.
	 * 
	 *     Class attributes:
	 *       standard_option_list : [Option]
	 *         list of standard options that will be accepted by all instances
	 *         of this parser class (intended to be overridden by subclasses).
	 * 
	 *     Instance attributes:
	 *       option_list : [Option]
	 *         the list of Option objects contained by this OptionContainer
	 *       _short_opt : { string : Option }
	 *         dictionary mapping short option strings, eg. "-f" or "-X",
	 *         to the Option instances that implement them.  If an Option
	 *         has multiple short option strings, it will appear in this
	 *         dictionary multiple times. [1]
	 *       _long_opt : { string : Option }
	 *         dictionary mapping long option strings, eg. "--file" or
	 *         "--exclude", to the Option instances that implement them.
	 *         Again, a given Option can occur multiple times in this
	 *         dictionary. [1]
	 *       defaults : { string : any }
	 *         dictionary mapping option destination names to default
	 *         values for each destination [1]
	 * 
	 *     [1] These mappings are common to (shared by) all components of the
	 *         controlling OptionParser, where they are initially created.
	 * 
	 *     
	 */
	function OptionContainer(option_class, conflict_handler, description): Promise<IOptionContainer>
	function OptionContainer$({ option_class, conflict_handler, description }): Promise<IOptionContainer>
	interface IOptionContainer {
		set_conflict_handler(handler): Promise<any>
		set_conflict_handler$({ handler }): Promise<any>
		set_description(description): Promise<any>
		set_description$({ description }): Promise<any>
		get_description(): Promise<any>
		get_description$($: {}): Promise<any>

		/**
		 * see OptionParser.destroy().
		 */
		destroy(): Promise<any>
		destroy$($: {}): Promise<any>

		/**
		 * add_option(Option)
		 *            add_option(opt_str, ..., kwarg=val, ...)
		 *         
		 */
		add_option(): Promise<any>
		add_option$($: {}): Promise<any>
		add_options(option_list): Promise<any>
		add_options$({ option_list }): Promise<any>
		get_option(opt_str): Promise<any>
		get_option$({ opt_str }): Promise<any>
		has_option(opt_str): Promise<any>
		has_option$({ opt_str }): Promise<any>
		remove_option(opt_str): Promise<any>
		remove_option$({ opt_str }): Promise<any>
		format_option_help(formatter): Promise<any>
		format_option_help$({ formatter }): Promise<any>
		format_description(formatter): Promise<any>
		format_description$({ formatter }): Promise<any>
		format_help(formatter): Promise<any>
		format_help$({ formatter }): Promise<any>
	}
	function OptionGroup(parser, title, description?): Promise<IOptionGroup>
	function OptionGroup$({ parser, title, description }: { parser, title, description?}): Promise<IOptionGroup>
	interface IOptionGroup extends IOptionContainer {
		set_title(title): Promise<any>
		set_title$({ title }): Promise<any>

		/**
		 * see OptionParser.destroy().
		 */
		destroy(): Promise<any>
		destroy$($: {}): Promise<any>
		format_help(formatter): Promise<any>
		format_help$({ formatter }): Promise<any>
	}

	/**
	 * 
	 *     Class attributes:
	 *       standard_option_list : [Option]
	 *         list of standard options that will be accepted by all instances
	 *         of this parser class (intended to be overridden by subclasses).
	 * 
	 *     Instance attributes:
	 *       usage : string
	 *         a usage string for your program.  Before it is displayed
	 *         to the user, "%prog" will be expanded to the name of
	 *         your program (self.prog or os.path.basename(sys.argv[0])).
	 *       prog : string
	 *         the name of the current program (to override
	 *         os.path.basename(sys.argv[0])).
	 *       description : string
	 *         A paragraph of text giving a brief overview of your program.
	 *         optparse reformats this paragraph to fit the current terminal
	 *         width and prints it when the user requests help (after usage,
	 *         but before the list of options).
	 *       epilog : string
	 *         paragraph of help text to print after option help
	 * 
	 *       option_groups : [OptionGroup]
	 *         list of option groups in this parser (option groups are
	 *         irrelevant for parsing the command-line, but very useful
	 *         for generating help)
	 * 
	 *       allow_interspersed_args : bool = true
	 *         if true, positional arguments may be interspersed with options.
	 *         Assuming -a and -b each take a single argument, the command-line
	 *           -ablah foo bar -bboo baz
	 *         will be interpreted the same as
	 *           -ablah -bboo -- foo bar baz
	 *         If this flag were false, that command line would be interpreted as
	 *           -ablah -- foo bar -bboo baz
	 *         -- ie. we stop processing options as soon as we see the first
	 *         non-option argument.  (This is the tradition followed by
	 *         Python's getopt module, Perl's Getopt::Std, and other argument-
	 *         parsing libraries, but it is generally annoying to users.)
	 * 
	 *       process_default_values : bool = true
	 *         if true, option default values are processed similarly to option
	 *         values from the command line: that is, they are passed to the
	 *         type-checking function for the option's type (as long as the
	 *         default value is a string).  (This really only matters if you
	 *         have defined custom types; see SF bug #955889.)  Set it to false
	 *         to restore the behaviour of Optik 1.4.1 and earlier.
	 * 
	 *       rargs : [string]
	 *         the argument list currently being parsed.  Only set when
	 *         parse_args() is active, and continually trimmed down as
	 *         we consume arguments.  Mainly there for the benefit of
	 *         callback options.
	 *       largs : [string]
	 *         the list of leftover arguments that we have skipped while
	 *         parsing options.  If allow_interspersed_args is false, this
	 *         list is always empty.
	 *       values : Values
	 *         the set of option values currently being accumulated.  Only
	 *         set when parse_args() is active.  Also mainly for callbacks.
	 * 
	 *     Because of the 'rargs', 'largs', and 'values' attributes,
	 *     OptionParser is not thread-safe.  If, for some perverse reason, you
	 *     need to parse command-line arguments simultaneously in different
	 *     threads, use different OptionParser instances.
	 * 
	 *     
	 */
	function OptionParser(usage?, option_list?, option_class?, version?, conflict_handler?, description?, formatter?, add_help_option?: boolean, prog?, epilog?): Promise<IOptionParser>
	function OptionParser$({ usage, option_list, option_class, version, conflict_handler, description, formatter, add_help_option, prog, epilog }: { usage?, option_list?, option_class?, version?, conflict_handler?, description?, formatter?, add_help_option?, prog?, epilog?}): Promise<IOptionParser>
	interface IOptionParser extends IOptionContainer {

		/**
		 * 
		 *         Declare that you are done with this OptionParser.  This cleans up
		 *         reference cycles so the OptionParser (and all objects referenced by
		 *         it) can be garbage-collected promptly.  After calling destroy(), the
		 *         OptionParser is unusable.
		 *         
		 */
		destroy(): Promise<any>
		destroy$($: {}): Promise<any>
		set_usage(usage): Promise<any>
		set_usage$({ usage }): Promise<any>

		/**
		 * Set parsing to not stop on the first non-option, allowing
		 *         interspersing switches with command arguments. This is the
		 *         default behavior. See also disable_interspersed_args() and the
		 *         class documentation description of the attribute
		 *         allow_interspersed_args.
		 */
		enable_interspersed_args(): Promise<any>
		enable_interspersed_args$($: {}): Promise<any>

		/**
		 * Set parsing to stop on the first non-option. Use this if
		 *         you have a command processor which runs another command that
		 *         has options of its own and you want to make sure these options
		 *         don't get confused.
		 *         
		 */
		disable_interspersed_args(): Promise<any>
		disable_interspersed_args$($: {}): Promise<any>
		set_process_default_values(process): Promise<any>
		set_process_default_values$({ process }): Promise<any>
		set_default(dest, value): Promise<any>
		set_default$({ dest, value }): Promise<any>
		set_defaults(): Promise<any>
		set_defaults$($: {}): Promise<any>
		get_default_values(): Promise<any>
		get_default_values$($: {}): Promise<any>
		add_option_group(): Promise<any>
		add_option_group$($: {}): Promise<any>
		get_option_group(opt_str): Promise<any>
		get_option_group$({ opt_str }): Promise<any>

		/**
		 * 
		 *         parse_args(args : [string] = sys.argv[1:],
		 *                    values : Values = None)
		 *         -> (values : Values, args : [string])
		 * 
		 *         Parse the command-line options found in 'args' (default:
		 *         sys.argv[1:]).  Any errors result in a call to 'error()', which
		 *         by default prints the usage message to stderr and calls
		 *         sys.exit() with an error message.  On success returns a pair
		 *         (values, args) where 'values' is a Values instance (with all
		 *         your option values) and 'args' is the list of arguments left
		 *         over after parsing options.
		 *         
		 */
		parse_args(args?, values?): Promise<any>
		parse_args$({ args, values }: { args?, values?}): Promise<any>

		/**
		 * 
		 *         check_values(values : Values, args : [string])
		 *         -> (values : Values, args : [string])
		 * 
		 *         Check that the supplied option values and leftover arguments are
		 *         valid.  Returns the option values and leftover arguments
		 *         (possibly adjusted, possibly completely new -- whatever you
		 *         like).  Default implementation just returns the passed-in
		 *         values; subclasses may override as desired.
		 *         
		 */
		check_values(values, args): Promise<any>
		check_values$({ values, args }): Promise<any>
		get_prog_name(): Promise<any>
		get_prog_name$($: {}): Promise<any>
		expand_prog_name(s): Promise<any>
		expand_prog_name$({ s }): Promise<any>
		get_description(): Promise<any>
		get_description$($: {}): Promise<any>
		exit(status?, msg?): Promise<any>
		exit$({ status, msg }: { status?, msg?}): Promise<any>

		/**
		 * error(msg : string)
		 * 
		 *         Print a usage message incorporating 'msg' to stderr and exit.
		 *         If you override this in a subclass, it should not return -- it
		 *         should either exit or raise an exception.
		 *         
		 */
		error(msg): Promise<any>
		error$({ msg }): Promise<any>
		get_usage(): Promise<any>
		get_usage$($: {}): Promise<any>

		/**
		 * print_usage(file : file = stdout)
		 * 
		 *         Print the usage message for the current program (self.usage) to
		 *         'file' (default stdout).  Any occurrence of the string "%prog" in
		 *         self.usage is replaced with the name of the current program
		 *         (basename of sys.argv[0]).  Does nothing if self.usage is empty
		 *         or not defined.
		 *         
		 */
		print_usage(file?): Promise<any>
		print_usage$({ file }: { file?}): Promise<any>
		get_version(): Promise<any>
		get_version$($: {}): Promise<any>

		/**
		 * print_version(file : file = stdout)
		 * 
		 *         Print the version message for this program (self.version) to
		 *         'file' (default stdout).  As with print_usage(), any occurrence
		 *         of "%prog" in self.version is replaced by the current program's
		 *         name.  Does nothing if self.version is empty or undefined.
		 *         
		 */
		print_version(file?): Promise<any>
		print_version$({ file }: { file?}): Promise<any>
		format_option_help(formatter?): Promise<any>
		format_option_help$({ formatter }: { formatter?}): Promise<any>
		format_epilog(formatter): Promise<any>
		format_epilog$({ formatter }): Promise<any>
		format_help(formatter?): Promise<any>
		format_help$({ formatter }: { formatter?}): Promise<any>

		/**
		 * print_help(file : file = stdout)
		 * 
		 *         Print an extended help message, listing all options and any
		 *         help text provided with them, to 'file' (default stdout).
		 *         
		 */
		print_help(file?): Promise<any>
		print_help$({ file }: { file?}): Promise<any>
		standard_option_list
	}
	let NO_DEFAULT: Promise<any>
	let SUPPRESS_HELP: Promise<any>
	let SUPPRESS_USAGE: Promise<any>
	let make_option: Promise<any>
}
declare module os {
	var _

	/**
	 * makedirs(name [, mode=0o777][, exist_ok=False])
	 * 
	 *     Super-mkdir; create a leaf directory and all intermediate ones.  Works like
	 *     mkdir, except that any intermediate path segment (not just the rightmost)
	 *     will be created if it does not exist. If the target directory already
	 *     exists, raise an OSError if exist_ok is False. Otherwise no exception is
	 *     raised.  This is recursive.
	 * 
	 *     
	 */
	function makedirs(name, mode?, exist_ok?: boolean): Promise<any>
	function makedirs$({ name, mode, exist_ok }: { name, mode?, exist_ok?}): Promise<any>

	/**
	 * removedirs(name)
	 * 
	 *     Super-rmdir; remove a leaf directory and all empty intermediate
	 *     ones.  Works like rmdir except that, if the leaf directory is
	 *     successfully removed, directories corresponding to rightmost path
	 *     segments will be pruned away until either the whole path is
	 *     consumed or an error occurs.  Errors during this latter phase are
	 *     ignored -- they generally mean that a directory was not empty.
	 * 
	 *     
	 */
	function removedirs(name): Promise<any>
	function removedirs$({ name }): Promise<any>

	/**
	 * renames(old, new)
	 * 
	 *     Super-rename; create directories as necessary and delete any left
	 *     empty.  Works like rename, except creation of any intermediate
	 *     directories needed to make the new pathname good is attempted
	 *     first.  After the rename, directories corresponding to rightmost
	 *     path segments of the old name will be pruned until either the
	 *     whole path is consumed or a nonempty directory is found.
	 * 
	 *     Note: this function can fail with the new directory structure made
	 *     if you lack permissions needed to unlink the leaf directory or
	 *     file.
	 * 
	 *     
	 */
	function renames(old, New): Promise<any>
	function renames$({ old, New }): Promise<any>

	/**
	 * Directory tree generator.
	 * 
	 *     For each directory in the directory tree rooted at top (including top
	 *     itself, but excluding '.' and '..'), yields a 3-tuple
	 * 
	 *         dirpath, dirnames, filenames
	 * 
	 *     dirpath is a string, the path to the directory.  dirnames is a list of
	 *     the names of the subdirectories in dirpath (excluding '.' and '..').
	 *     filenames is a list of the names of the non-directory files in dirpath.
	 *     Note that the names in the lists are just names, with no path components.
	 *     To get a full path (which begins with top) to a file or directory in
	 *     dirpath, do os.path.join(dirpath, name).
	 * 
	 *     If optional arg 'topdown' is true or not specified, the triple for a
	 *     directory is generated before the triples for any of its subdirectories
	 *     (directories are generated top down).  If topdown is false, the triple
	 *     for a directory is generated after the triples for all of its
	 *     subdirectories (directories are generated bottom up).
	 * 
	 *     When topdown is true, the caller can modify the dirnames list in-place
	 *     (e.g., via del or slice assignment), and walk will only recurse into the
	 *     subdirectories whose names remain in dirnames; this can be used to prune the
	 *     search, or to impose a specific order of visiting.  Modifying dirnames when
	 *     topdown is false has no effect on the behavior of os.walk(), since the
	 *     directories in dirnames have already been generated by the time dirnames
	 *     itself is generated. No matter the value of topdown, the list of
	 *     subdirectories is retrieved before the tuples for the directory and its
	 *     subdirectories are generated.
	 * 
	 *     By default errors from the os.scandir() call are ignored.  If
	 *     optional arg 'onerror' is specified, it should be a function; it
	 *     will be called with one argument, an OSError instance.  It can
	 *     report the error to continue with the walk, or raise the exception
	 *     to abort the walk.  Note that the filename is available as the
	 *     filename attribute of the exception object.
	 * 
	 *     By default, os.walk does not follow symbolic links to subdirectories on
	 *     systems that support them.  In order to get this functionality, set the
	 *     optional argument 'followlinks' to true.
	 * 
	 *     Caution:  if you pass a relative pathname for top, don't change the
	 *     current working directory between resumptions of walk.  walk never
	 *     changes the current directory, and assumes that the client doesn't
	 *     either.
	 * 
	 *     Example:
	 * 
	 *     import os
	 *     from os.path import join, getsize
	 *     for root, dirs, files in os.walk('python/Lib/email'):
	 *         print(root, "consumes", end="")
	 *         print(sum(getsize(join(root, name)) for name in files), end="")
	 *         print("bytes in", len(files), "non-directory files")
	 *         if 'CVS' in dirs:
	 *             dirs.remove('CVS')  # don't visit CVS directories
	 * 
	 *     
	 */
	function walk(top, topdown?: boolean, onerror?, followlinks?: boolean): Promise<any>
	function walk$({ top, topdown, onerror, followlinks }: { top, topdown?, onerror?, followlinks?}): Promise<any>

	/**
	 * Directory tree generator.
	 * 
	 *         This behaves exactly like walk(), except that it yields a 4-tuple
	 * 
	 *             dirpath, dirnames, filenames, dirfd
	 * 
	 *         `dirpath`, `dirnames` and `filenames` are identical to walk() output,
	 *         and `dirfd` is a file descriptor referring to the directory `dirpath`.
	 * 
	 *         The advantage of fwalk() over walk() is that it's safe against symlink
	 *         races (when follow_symlinks is False).
	 * 
	 *         If dir_fd is not None, it should be a file descriptor open to a directory,
	 *           and top should be relative; top will then be relative to that directory.
	 *           (dir_fd is always supported for fwalk.)
	 * 
	 *         Caution:
	 *         Since fwalk() yields file descriptors, those are only valid until the
	 *         next iteration step, so you should dup() them if you want to keep them
	 *         for a longer period.
	 * 
	 *         Example:
	 * 
	 *         import os
	 *         for root, dirs, files, rootfd in os.fwalk('python/Lib/email'):
	 *             print(root, "consumes", end="")
	 *             print(sum(os.stat(name, dir_fd=rootfd).st_size for name in files),
	 *                   end="")
	 *             print("bytes in", len(files), "non-directory files")
	 *             if 'CVS' in dirs:
	 *                 dirs.remove('CVS')  # don't visit CVS directories
	 *         
	 */
	function fwalk(top?, topdown?: boolean, onerror?): Promise<any>
	function fwalk$({ top, topdown, onerror }: { top?, topdown?, onerror?}): Promise<any>

	/**
	 * execl(file, *args)
	 * 
	 *     Execute the executable file with argument list args, replacing the
	 *     current process. 
	 */
	function execl(file): Promise<any>
	function execl$({ file }): Promise<any>

	/**
	 * execle(file, *args, env)
	 * 
	 *     Execute the executable file with argument list args and
	 *     environment env, replacing the current process. 
	 */
	function execle(file): Promise<any>
	function execle$({ file }): Promise<any>

	/**
	 * execlp(file, *args)
	 * 
	 *     Execute the executable file (which is searched for along $PATH)
	 *     with argument list args, replacing the current process. 
	 */
	function execlp(file): Promise<any>
	function execlp$({ file }): Promise<any>

	/**
	 * execlpe(file, *args, env)
	 * 
	 *     Execute the executable file (which is searched for along $PATH)
	 *     with argument list args and environment env, replacing the current
	 *     process. 
	 */
	function execlpe(file): Promise<any>
	function execlpe$({ file }): Promise<any>

	/**
	 * execvp(file, args)
	 * 
	 *     Execute the executable file (which is searched for along $PATH)
	 *     with argument list args, replacing the current process.
	 *     args may be a list or tuple of strings. 
	 */
	function execvp(file, args): Promise<any>
	function execvp$({ file, args }): Promise<any>

	/**
	 * execvpe(file, args, env)
	 * 
	 *     Execute the executable file (which is searched for along $PATH)
	 *     with argument list args and environment env, replacing the
	 *     current process.
	 *     args may be a list or tuple of strings. 
	 */
	function execvpe(file, args, env): Promise<any>
	function execvpe$({ file, args, env }): Promise<any>

	/**
	 * Returns the sequence of directories that will be searched for the
	 *     named executable (similar to a shell) when launching a process.
	 * 
	 *     *env* must be an environment variable dict or None.  If *env* is None,
	 *     os.environ will be used.
	 *     
	 */
	function get_exec_path(env?): Promise<any>
	function get_exec_path$({ env }: { env?}): Promise<any>

	/**
	 * Get an environment variable, return None if it doesn't exist.
	 *     The optional second argument can specify an alternate default.
	 *     key, default and the result are str.
	 */
	function getenv(key, def?): Promise<any>
	function getenv$({ key, def }: { key, def?}): Promise<any>

	/**
	 * Get an environment variable, return None if it doesn't exist.
	 *         The optional second argument can specify an alternate default.
	 *         key, default and the result are bytes.
	 */
	function getenvb(key, def?): Promise<any>
	function getenvb$({ key, def }: { key, def?}): Promise<any>

	/**
	 * spawnv(mode, file, args) -> integer
	 * 
	 * Execute file with arguments from args in a subprocess.
	 * If mode == P_NOWAIT return the pid of the process.
	 * If mode == P_WAIT return the process's exit code if it exits normally;
	 * otherwise return -SIG, where SIG is the signal that killed it. 
	 */
	function spawnv(mode, file, args): Promise<any>
	function spawnv$({ mode, file, args }): Promise<any>

	/**
	 * spawnve(mode, file, args, env) -> integer
	 * 
	 * Execute file with arguments from args in a subprocess with the
	 * specified environment.
	 * If mode == P_NOWAIT return the pid of the process.
	 * If mode == P_WAIT return the process's exit code if it exits normally;
	 * otherwise return -SIG, where SIG is the signal that killed it. 
	 */
	function spawnve(mode, file, args, env): Promise<any>
	function spawnve$({ mode, file, args, env }): Promise<any>

	/**
	 * spawnvp(mode, file, args) -> integer
	 * 
	 * Execute file (which is looked for along $PATH) with arguments from
	 * args in a subprocess.
	 * If mode == P_NOWAIT return the pid of the process.
	 * If mode == P_WAIT return the process's exit code if it exits normally;
	 * otherwise return -SIG, where SIG is the signal that killed it. 
	 */
	function spawnvp(mode, file, args): Promise<any>
	function spawnvp$({ mode, file, args }): Promise<any>

	/**
	 * spawnvpe(mode, file, args, env) -> integer
	 * 
	 * Execute file (which is looked for along $PATH) with arguments from
	 * args in a subprocess with the supplied environment.
	 * If mode == P_NOWAIT return the pid of the process.
	 * If mode == P_WAIT return the process's exit code if it exits normally;
	 * otherwise return -SIG, where SIG is the signal that killed it. 
	 */
	function spawnvpe(mode, file, args, env): Promise<any>
	function spawnvpe$({ mode, file, args, env }): Promise<any>

	/**
	 * spawnl(mode, file, *args) -> integer
	 * 
	 * Execute file with arguments from args in a subprocess.
	 * If mode == P_NOWAIT return the pid of the process.
	 * If mode == P_WAIT return the process's exit code if it exits normally;
	 * otherwise return -SIG, where SIG is the signal that killed it. 
	 */
	function spawnl(mode, file): Promise<any>
	function spawnl$({ mode, file }): Promise<any>

	/**
	 * spawnle(mode, file, *args, env) -> integer
	 * 
	 * Execute file with arguments from args in a subprocess with the
	 * supplied environment.
	 * If mode == P_NOWAIT return the pid of the process.
	 * If mode == P_WAIT return the process's exit code if it exits normally;
	 * otherwise return -SIG, where SIG is the signal that killed it. 
	 */
	function spawnle(mode, file): Promise<any>
	function spawnle$({ mode, file }): Promise<any>

	/**
	 * spawnlp(mode, file, *args) -> integer
	 * 
	 * Execute file (which is looked for along $PATH) with arguments from
	 * args in a subprocess with the supplied environment.
	 * If mode == P_NOWAIT return the pid of the process.
	 * If mode == P_WAIT return the process's exit code if it exits normally;
	 * otherwise return -SIG, where SIG is the signal that killed it. 
	 */
	function spawnlp(mode, file): Promise<any>
	function spawnlp$({ mode, file }): Promise<any>

	/**
	 * spawnlpe(mode, file, *args, env) -> integer
	 * 
	 * Execute file (which is looked for along $PATH) with arguments from
	 * args in a subprocess with the supplied environment.
	 * If mode == P_NOWAIT return the pid of the process.
	 * If mode == P_WAIT return the process's exit code if it exits normally;
	 * otherwise return -SIG, where SIG is the signal that killed it. 
	 */
	function spawnlpe(mode, file): Promise<any>
	function spawnlpe$({ mode, file }): Promise<any>
	function popen(cmd, mode?, buffering?): Promise<any>
	function popen$({ cmd, mode, buffering }: { cmd, mode?, buffering?}): Promise<any>
	function fdopen(fd, mode?, buffering?, encoding?): Promise<any>
	function fdopen$({ fd, mode, buffering, encoding }: { fd, mode?, buffering?, encoding?}): Promise<any>

	/**
	 * Add a path to the DLL search path.
	 * 
	 *         This search path is used when resolving dependencies for imported
	 *         extension modules (the module itself is resolved through sys.path),
	 *         and also by ctypes.
	 * 
	 *         Remove the directory by calling close() on the returned object or
	 *         using it in a with statement.
	 *         
	 */
	function add_dll_directory(path): Promise<any>
	function add_dll_directory$({ path }): Promise<any>
	interface I_Environ {
		copy(): Promise<any>
		copy$($: {}): Promise<any>
		setdefault(key, value): Promise<any>
		setdefault$({ key, value }): Promise<any>
	}
	interface I_wrap_close {
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 * Abstract base class for implementing the file system path protocol.
	 */
	interface IPathLike {
	}
	interface I_AddedDllDirectory {
		close(): Promise<any>
		close$($: {}): Promise<any>
	}
	let GenericAlias: Promise<any>
	let name: Promise<any>
	let linesep: Promise<any>
	let supports_dir_fd: Promise<any>
	let supports_effective_ids: Promise<any>
	let supports_fd: Promise<any>
	let supports_follow_symlinks: Promise<any>
	let SEEK_SET: Promise<any>
	let SEEK_CUR: Promise<any>
	let SEEK_END: Promise<any>
	let environ: Promise<any>
	let supports_bytes_environ: Promise<any>
	let environb: Promise<any>
	let P_WAIT: Promise<any>
	let P_NOWAIT: Promise<any>
	let P_NOWAITO: Promise<any>
	let fspath: Promise<any>
}
declare module pathlib {
	var _

	/**
	 * A flavour implements a particular (platform-specific) set of path
	 *     semantics.
	 */
	interface I_Flavour {
		parse_parts(parts): Promise<any>
		parse_parts$({ parts }): Promise<any>

		/**
		 * 
		 *         Join the two paths represented by the respective
		 *         (drive, root, parts) tuples.  Return a new (drive, root, parts) tuple.
		 *         
		 */
		join_parsed_parts(drv, root, parts, drv2, root2, parts2): Promise<any>
		join_parsed_parts$({ drv, root, parts, drv2, root2, parts2 }): Promise<any>
	}
	interface I_WindowsFlavour extends I_Flavour {
		splitroot(part, sep?): Promise<any>
		splitroot$({ part, sep }: { part, sep?}): Promise<any>
		casefold(s): Promise<any>
		casefold$({ s }): Promise<any>
		casefold_parts(parts): Promise<any>
		casefold_parts$({ parts }): Promise<any>
		compile_pattern(pattern): Promise<any>
		compile_pattern$({ pattern }): Promise<any>
		is_reserved(parts): Promise<any>
		is_reserved$({ parts }): Promise<any>
		make_uri(path): Promise<any>
		make_uri$({ path }): Promise<any>
		sep
		altsep
		has_drv
		pathmod
		is_supported
		drive_letters
		ext_namespace_prefix
		reserved_names
	}
	interface I_PosixFlavour extends I_Flavour {
		splitroot(part, sep?): Promise<any>
		splitroot$({ part, sep }: { part, sep?}): Promise<any>
		casefold(s): Promise<any>
		casefold$({ s }): Promise<any>
		casefold_parts(parts): Promise<any>
		casefold_parts$({ parts }): Promise<any>
		compile_pattern(pattern): Promise<any>
		compile_pattern$({ pattern }): Promise<any>
		is_reserved(parts): Promise<any>
		is_reserved$({ parts }): Promise<any>
		make_uri(path): Promise<any>
		make_uri$({ path }): Promise<any>
	}

	/**
	 * An accessor implements a particular (system-specific or not) way of
	 *     accessing paths on the filesystem.
	 */
	interface I_Accessor {
	}
	interface I_NormalAccessor extends I_Accessor {
		touch(path, mode?, exist_ok?: boolean): Promise<any>
		touch$({ path, mode, exist_ok }: { path, mode?, exist_ok?}): Promise<any>
		owner(path): Promise<any>
		owner$({ path }): Promise<any>
		group(path): Promise<any>
		group$({ path }): Promise<any>
		stat
		open
		listdir
		scandir
		chmod
		mkdir
		unlink
		rmdir
		rename
		replace
		getcwd
		expanduser
		realpath
	}

	/**
	 * A selector matches a specific glob pattern part against the children
	 *     of a given path.
	 */
	interface I_Selector {

		/**
		 * Iterate over all child paths of `parent_path` matched by this
		 *         selector.  This can contain parent_path itself.
		 */
		select_from(parent_path): Promise<any>
		select_from$({ parent_path }): Promise<any>
	}
	interface I_TerminatingSelector {
	}
	interface I_PreciseSelector extends I_Selector {
	}
	interface I_WildcardSelector extends I_Selector {
	}
	interface I_RecursiveWildcardSelector extends I_Selector {
	}

	/**
	 * This object provides sequence-like access to the logical ancestors
	 *     of a path.  Don't try to construct it yourself.
	 */
	interface I_PathParents {
	}

	/**
	 * Base class for manipulating paths without I/O.
	 * 
	 *     PurePath represents a filesystem path and offers operations which
	 *     don't imply any actual filesystem I/O.  Depending on your system,
	 *     instantiating a PurePath will return either a PurePosixPath or a
	 *     PureWindowsPath object.  You can also instantiate either of these classes
	 *     directly, regardless of your system.
	 *     
	 */
	interface IPurePath {

		/**
		 * Return the string representation of the path with forward (/)
		 *         slashes.
		 */
		as_posix(): Promise<any>
		as_posix$($: {}): Promise<any>

		/**
		 * Return the path as a 'file' URI.
		 */
		as_uri(): Promise<any>
		as_uri$($: {}): Promise<any>

		/**
		 * The concatenation of the drive and root, or ''.
		 */
		anchor(): Promise<any>
		anchor$($: {}): Promise<any>

		/**
		 * The final path component, if any.
		 */
		name(): Promise<any>
		name$($: {}): Promise<any>

		/**
		 * 
		 *         The final component's last suffix, if any.
		 * 
		 *         This includes the leading period. For example: '.txt'
		 *         
		 */
		suffix(): Promise<any>
		suffix$($: {}): Promise<any>

		/**
		 * 
		 *         A list of the final component's suffixes, if any.
		 * 
		 *         These include the leading periods. For example: ['.tar', '.gz']
		 *         
		 */
		suffixes(): Promise<any>
		suffixes$($: {}): Promise<any>

		/**
		 * The final path component, minus its last suffix.
		 */
		stem(): Promise<any>
		stem$($: {}): Promise<any>

		/**
		 * Return a new path with the file name changed.
		 */
		with_name(name): Promise<any>
		with_name$({ name }): Promise<any>

		/**
		 * Return a new path with the stem changed.
		 */
		with_stem(stem): Promise<any>
		with_stem$({ stem }): Promise<any>

		/**
		 * Return a new path with the file suffix changed.  If the path
		 *         has no suffix, add given suffix.  If the given suffix is an empty
		 *         string, remove the suffix from the path.
		 *         
		 */
		with_suffix(suffix): Promise<any>
		with_suffix$({ suffix }): Promise<any>

		/**
		 * Return the relative path to another path identified by the passed
		 *         arguments.  If the operation is not possible (because this is not
		 *         a subpath of the other path), raise ValueError.
		 *         
		 */
		relative_to(): Promise<any>
		relative_to$($: {}): Promise<any>

		/**
		 * Return True if the path is relative to another path or False.
		 *         
		 */
		is_relative_to(): Promise<any>
		is_relative_to$($: {}): Promise<any>

		/**
		 * An object providing sequence-like access to the
		 *         components in the filesystem path.
		 */
		parts(): Promise<any>
		parts$($: {}): Promise<any>

		/**
		 * Combine this path with one or several arguments, and return a
		 *         new path representing either a subpath (if all arguments are relative
		 *         paths) or a totally different path (if one of the arguments is
		 *         anchored).
		 *         
		 */
		joinpath(): Promise<any>
		joinpath$($: {}): Promise<any>

		/**
		 * The logical parent of the path.
		 */
		parent(): Promise<any>
		parent$($: {}): Promise<any>

		/**
		 * A sequence of this path's logical parents.
		 */
		parents(): Promise<any>
		parents$($: {}): Promise<any>

		/**
		 * True if the path is absolute (has both a root and, if applicable,
		 *         a drive).
		 */
		is_absolute(): Promise<any>
		is_absolute$($: {}): Promise<any>

		/**
		 * Return True if the path contains one of the special names reserved
		 *         by the system, if any.
		 */
		is_reserved(): Promise<any>
		is_reserved$($: {}): Promise<any>

		/**
		 * 
		 *         Return True if this path matches the given pattern.
		 *         
		 */
		match(path_pattern): Promise<any>
		match$({ path_pattern }): Promise<any>
		drive
		root
	}

	/**
	 * PurePath subclass for non-Windows systems.
	 * 
	 *     On a POSIX system, instantiating a PurePath should return this object.
	 *     However, you can also instantiate it directly on any system.
	 *     
	 */
	interface IPurePosixPath extends IPurePath {
	}

	/**
	 * PurePath subclass for Windows systems.
	 * 
	 *     On a Windows system, instantiating a PurePath should return this object.
	 *     However, you can also instantiate it directly on any system.
	 *     
	 */
	interface IPureWindowsPath extends IPurePath {
	}

	/**
	 * PurePath subclass that can make system calls.
	 * 
	 *     Path represents a filesystem path but unlike PurePath, also offers
	 *     methods to do system calls on path objects. Depending on your system,
	 *     instantiating a Path will return either a PosixPath or a WindowsPath
	 *     object. You can also instantiate a PosixPath or WindowsPath directly,
	 *     but cannot instantiate a WindowsPath on a POSIX system or vice versa.
	 *     
	 */
	interface IPath extends IPurePath {

		/**
		 * Return a new path pointing to the current working directory
		 *         (as returned by os.getcwd()).
		 *         
		 */
		cwd(): Promise<any>
		cwd$($: {}): Promise<any>

		/**
		 * Return a new path pointing to the user's home directory (as
		 *         returned by os.path.expanduser('~')).
		 *         
		 */
		home(): Promise<any>
		home$($: {}): Promise<any>

		/**
		 * Return whether other_path is the same or not as this file
		 *         (as returned by os.path.samefile()).
		 *         
		 */
		samefile(other_path): Promise<any>
		samefile$({ other_path }): Promise<any>

		/**
		 * Iterate over the files in this directory.  Does not yield any
		 *         result for the special paths '.' and '..'.
		 *         
		 */
		iterdir(): Promise<any>
		iterdir$($: {}): Promise<any>

		/**
		 * Iterate over this subtree and yield all existing files (of any
		 *         kind, including directories) matching the given relative pattern.
		 *         
		 */
		glob(pattern): Promise<any>
		glob$({ pattern }): Promise<any>

		/**
		 * Recursively yield all existing files (of any kind, including
		 *         directories) matching the given relative pattern, anywhere in
		 *         this subtree.
		 *         
		 */
		rglob(pattern): Promise<any>
		rglob$({ pattern }): Promise<any>

		/**
		 * Return an absolute version of this path.  This function works
		 *         even if the path doesn't point to anything.
		 * 
		 *         No normalization is done, i.e. all '.' and '..' will be kept along.
		 *         Use resolve() to get the canonical path to a file.
		 *         
		 */
		absolute(): Promise<any>
		absolute$($: {}): Promise<any>

		/**
		 * 
		 *         Make the path absolute, resolving all symlinks on the way and also
		 *         normalizing it (for example turning slashes into backslashes under
		 *         Windows).
		 *         
		 */
		resolve(strict?: boolean): Promise<any>
		resolve$({ strict }: { strict?}): Promise<any>

		/**
		 * 
		 *         Return the result of the stat() system call on this path, like
		 *         os.stat() does.
		 *         
		 */
		stat(): Promise<any>
		stat$($: {}): Promise<any>

		/**
		 * 
		 *         Return the login name of the file owner.
		 *         
		 */
		owner(): Promise<any>
		owner$($: {}): Promise<any>

		/**
		 * 
		 *         Return the group name of the file gid.
		 *         
		 */
		group(): Promise<any>
		group$($: {}): Promise<any>

		/**
		 * 
		 *         Open the file pointed by this path and return a file object, as
		 *         the built-in open() function does.
		 *         
		 */
		open(mode?, buffering?, encoding?, errors?, newline?): Promise<any>
		open$({ mode, buffering, encoding, errors, newline }: { mode?, buffering?, encoding?, errors?, newline?}): Promise<any>

		/**
		 * 
		 *         Open the file in bytes mode, read it, and close the file.
		 *         
		 */
		read_bytes(): Promise<any>
		read_bytes$($: {}): Promise<any>

		/**
		 * 
		 *         Open the file in text mode, read it, and close the file.
		 *         
		 */
		read_text(encoding?, errors?): Promise<any>
		read_text$({ encoding, errors }: { encoding?, errors?}): Promise<any>

		/**
		 * 
		 *         Open the file in bytes mode, write to it, and close the file.
		 *         
		 */
		write_bytes(data): Promise<any>
		write_bytes$({ data }): Promise<any>

		/**
		 * 
		 *         Open the file in text mode, write to it, and close the file.
		 *         
		 */
		write_text(data, encoding?, errors?, newline?): Promise<any>
		write_text$({ data, encoding, errors, newline }: { data, encoding?, errors?, newline?}): Promise<any>

		/**
		 * 
		 *         Return the path to which the symbolic link points.
		 *         
		 */
		readlink(): Promise<any>
		readlink$($: {}): Promise<any>

		/**
		 * 
		 *         Create this file with the given access mode, if it doesn't exist.
		 *         
		 */
		touch(mode?, exist_ok?: boolean): Promise<any>
		touch$({ mode, exist_ok }: { mode?, exist_ok?}): Promise<any>

		/**
		 * 
		 *         Create a new directory at this given path.
		 *         
		 */
		mkdir(mode?, parents?: boolean, exist_ok?: boolean): Promise<any>
		mkdir$({ mode, parents, exist_ok }: { mode?, parents?, exist_ok?}): Promise<any>

		/**
		 * 
		 *         Change the permissions of the path, like os.chmod().
		 *         
		 */
		chmod(mode): Promise<any>
		chmod$({ mode }): Promise<any>

		/**
		 * 
		 *         Like chmod(), except if the path points to a symlink, the symlink's
		 *         permissions are changed, rather than its target's.
		 *         
		 */
		lchmod(mode): Promise<any>
		lchmod$({ mode }): Promise<any>

		/**
		 * 
		 *         Remove this file or link.
		 *         If the path is a directory, use rmdir() instead.
		 *         
		 */
		unlink(missing_ok?: boolean): Promise<any>
		unlink$({ missing_ok }: { missing_ok?}): Promise<any>

		/**
		 * 
		 *         Remove this directory.  The directory must be empty.
		 *         
		 */
		rmdir(): Promise<any>
		rmdir$($: {}): Promise<any>

		/**
		 * 
		 *         Like stat(), except if the path points to a symlink, the symlink's
		 *         status information is returned, rather than its target's.
		 *         
		 */
		lstat(): Promise<any>
		lstat$($: {}): Promise<any>

		/**
		 * 
		 *         Rename this path to the target path.
		 * 
		 *         The target path may be absolute or relative. Relative paths are
		 *         interpreted relative to the current working directory, *not* the
		 *         directory of the Path object.
		 * 
		 *         Returns the new Path instance pointing to the target path.
		 *         
		 */
		rename(target): Promise<any>
		rename$({ target }): Promise<any>

		/**
		 * 
		 *         Rename this path to the target path, overwriting if that path exists.
		 * 
		 *         The target path may be absolute or relative. Relative paths are
		 *         interpreted relative to the current working directory, *not* the
		 *         directory of the Path object.
		 * 
		 *         Returns the new Path instance pointing to the target path.
		 *         
		 */
		replace(target): Promise<any>
		replace$({ target }): Promise<any>

		/**
		 * 
		 *         Make this path a symlink pointing to the target path.
		 *         Note the order of arguments (link, target) is the reverse of os.symlink.
		 *         
		 */
		symlink_to(target, target_is_directory?: boolean): Promise<any>
		symlink_to$({ target, target_is_directory }: { target, target_is_directory?}): Promise<any>

		/**
		 * 
		 *         Make this path a hard link pointing to the same file as *target*.
		 * 
		 *         Note the order of arguments (self, target) is the reverse of os.link's.
		 *         
		 */
		hardlink_to(target): Promise<any>
		hardlink_to$({ target }): Promise<any>

		/**
		 * 
		 *         Make the target path a hard link pointing to this path.
		 * 
		 *         Note this function does not make this path a hard link to *target*,
		 *         despite the implication of the function and argument names. The order
		 *         of arguments (target, link) is the reverse of Path.symlink_to, but
		 *         matches that of os.link.
		 * 
		 *         Deprecated since Python 3.10 and scheduled for removal in Python 3.12.
		 *         Use `hardlink_to()` instead.
		 *         
		 */
		link_to(target): Promise<any>
		link_to$({ target }): Promise<any>

		/**
		 * 
		 *         Whether this path exists.
		 *         
		 */
		exists(): Promise<any>
		exists$($: {}): Promise<any>

		/**
		 * 
		 *         Whether this path is a directory.
		 *         
		 */
		is_dir(): Promise<any>
		is_dir$($: {}): Promise<any>

		/**
		 * 
		 *         Whether this path is a regular file (also True for symlinks pointing
		 *         to regular files).
		 *         
		 */
		is_file(): Promise<any>
		is_file$($: {}): Promise<any>

		/**
		 * 
		 *         Check if this path is a POSIX mount point
		 *         
		 */
		is_mount(): Promise<any>
		is_mount$($: {}): Promise<any>

		/**
		 * 
		 *         Whether this path is a symbolic link.
		 *         
		 */
		is_symlink(): Promise<any>
		is_symlink$($: {}): Promise<any>

		/**
		 * 
		 *         Whether this path is a block device.
		 *         
		 */
		is_block_device(): Promise<any>
		is_block_device$($: {}): Promise<any>

		/**
		 * 
		 *         Whether this path is a character device.
		 *         
		 */
		is_char_device(): Promise<any>
		is_char_device$($: {}): Promise<any>

		/**
		 * 
		 *         Whether this path is a FIFO.
		 *         
		 */
		is_fifo(): Promise<any>
		is_fifo$($: {}): Promise<any>

		/**
		 * 
		 *         Whether this path is a socket.
		 *         
		 */
		is_socket(): Promise<any>
		is_socket$($: {}): Promise<any>

		/**
		 *  Return a new path with expanded ~ and ~user constructs
		 *         (as returned by os.path.expanduser)
		 *         
		 */
		expanduser(): Promise<any>
		expanduser$($: {}): Promise<any>
	}

	/**
	 * Path subclass for non-Windows systems.
	 * 
	 *     On a POSIX system, instantiating a Path should return this object.
	 *     
	 */
	interface IPosixPath extends IPath, IPurePosixPath {
	}

	/**
	 * Path subclass for Windows systems.
	 * 
	 *     On a Windows system, instantiating a Path should return this object.
	 *     
	 */
	interface IWindowsPath extends IPath, IPureWindowsPath {
		is_mount(): Promise<any>
		is_mount$($: {}): Promise<any>
	}
}
declare module pdb {
	var _
	function find_function(funcname, filename): Promise<any>
	function find_function$({ funcname, filename }): Promise<any>
	function getsourcelines(obj): Promise<any>
	function getsourcelines$({ obj }): Promise<any>
	function lasti2lineno(code, lasti): Promise<any>
	function lasti2lineno$({ code, lasti }): Promise<any>
	function run(statement, globals?, locals?): Promise<any>
	function run$({ statement, globals, locals }: { statement, globals?, locals?}): Promise<any>
	function runeval(expression, globals?, locals?): Promise<any>
	function runeval$({ expression, globals, locals }: { expression, globals?, locals?}): Promise<any>
	function runctx(statement, globals, locals): Promise<any>
	function runctx$({ statement, globals, locals }): Promise<any>
	function runcall(): Promise<any>
	function runcall$($: {}): Promise<any>
	function set_trace(): Promise<any>
	function set_trace$($: {}): Promise<any>
	function post_mortem(t?): Promise<any>
	function post_mortem$({ t }: { t?}): Promise<any>
	function pm(): Promise<any>
	function pm$($: {}): Promise<any>
	function test(): Promise<any>
	function test$($: {}): Promise<any>
	function help(): Promise<any>
	function help$($: {}): Promise<any>
	function main(): Promise<any>
	function main$($: {}): Promise<any>

	/**
	 * Causes a debugger to be restarted for the debugged python program.
	 */
	interface IRestart {
	}

	/**
	 * String that doesn't quote its repr.
	 */
	interface I_rstr {
	}
	function Pdb(completekey?, stdin?, stdout?, skip?, nosigint?: boolean, readrc?: boolean): Promise<IPdb>
	function Pdb$({ completekey, stdin, stdout, skip, nosigint, readrc }: { completekey?, stdin?, stdout?, skip?, nosigint?, readrc?}): Promise<IPdb>
	interface IPdb {
		sigint_handler(signum, frame): Promise<any>
		sigint_handler$({ signum, frame }): Promise<any>
		reset(): Promise<any>
		reset$($: {}): Promise<any>
		forget(): Promise<any>
		forget$($: {}): Promise<any>
		setup(f, tb): Promise<any>
		setup$({ f, tb }): Promise<any>
		execRcLines(): Promise<any>
		execRcLines$($: {}): Promise<any>

		/**
		 * This method is called when there is the remote possibility
		 *         that we ever need to stop in this function.
		 */
		user_call(frame, argument_list): Promise<any>
		user_call$({ frame, argument_list }): Promise<any>

		/**
		 * This function is called when we stop or break at this line.
		 */
		user_line(frame): Promise<any>
		user_line$({ frame }): Promise<any>

		/**
		 * Call every command that was set for the current active breakpoint
		 *         (if there is one).
		 * 
		 *         Returns True if the normal interaction function must be called,
		 *         False otherwise.
		 */
		bp_commands(frame): Promise<any>
		bp_commands$({ frame }): Promise<any>

		/**
		 * This function is called when a return trap is set here.
		 */
		user_return(frame, return_value): Promise<any>
		user_return$({ frame, return_value }): Promise<any>

		/**
		 * This function is called if an exception occurs,
		 *         but only if we are to stop at or just below this level.
		 */
		user_exception(frame, exc_info): Promise<any>
		user_exception$({ frame, exc_info }): Promise<any>
		preloop(): Promise<any>
		preloop$($: {}): Promise<any>
		interaction(frame, traceback): Promise<any>
		interaction$({ frame, traceback }): Promise<any>

		/**
		 * Custom displayhook for the exec in default(), which prevents
		 *         assignment of the _ variable in the builtins.
		 *         
		 */
		displayhook(obj): Promise<any>
		displayhook$({ obj }): Promise<any>
		default(line): Promise<any>
		default$({ line }): Promise<any>

		/**
		 * Handle alias expansion and ';;' separator.
		 */
		precmd(line): Promise<any>
		precmd$({ line }): Promise<any>

		/**
		 * Interpret the argument as though it had been typed in response
		 *         to the prompt.
		 * 
		 *         Checks whether this line is typed at the normal prompt or in
		 *         a breakpoint command list definition.
		 *         
		 */
		onecmd(line): Promise<any>
		onecmd$({ line }): Promise<any>

		/**
		 * Handles one command line during command list definition.
		 */
		handle_command_def(line): Promise<any>
		handle_command_def$({ line }): Promise<any>
		message(msg): Promise<any>
		message$({ msg }): Promise<any>
		error(msg): Promise<any>
		error$({ msg }): Promise<any>

		/**
		 * commands [bpnumber]
		 *         (com) ...
		 *         (com) end
		 *         (Pdb)
		 * 
		 *         Specify a list of commands for breakpoint number bpnumber.
		 *         The commands themselves are entered on the following lines.
		 *         Type a line containing just 'end' to terminate the commands.
		 *         The commands are executed when the breakpoint is hit.
		 * 
		 *         To remove all commands from a breakpoint, type commands and
		 *         follow it immediately with end; that is, give no commands.
		 * 
		 *         With no bpnumber argument, commands refers to the last
		 *         breakpoint set.
		 * 
		 *         You can use breakpoint commands to start your program up
		 *         again.  Simply use the continue command, or step, or any other
		 *         command that resumes execution.
		 * 
		 *         Specifying any command resuming execution (currently continue,
		 *         step, next, return, jump, quit and their abbreviations)
		 *         terminates the command list (as if that command was
		 *         immediately followed by end).  This is because any time you
		 *         resume execution (even with a simple next or step), you may
		 *         encounter another breakpoint -- which could have its own
		 *         command list, leading to ambiguities about which list to
		 *         execute.
		 * 
		 *         If you use the 'silent' command in the command list, the usual
		 *         message about stopping at a breakpoint is not printed.  This
		 *         may be desirable for breakpoints that are to print a specific
		 *         message and then continue.  If none of the other commands
		 *         print anything, you will see no sign that the breakpoint was
		 *         reached.
		 *         
		 */
		do_commands(arg): Promise<any>
		do_commands$({ arg }): Promise<any>

		/**
		 * b(reak) [ ([filename:]lineno | function) [, condition] ]
		 *         Without argument, list all breaks.
		 * 
		 *         With a line number argument, set a break at this line in the
		 *         current file.  With a function name, set a break at the first
		 *         executable line of that function.  If a second argument is
		 *         present, it is a string specifying an expression which must
		 *         evaluate to true before the breakpoint is honored.
		 * 
		 *         The line number may be prefixed with a filename and a colon,
		 *         to specify a breakpoint in another file (probably one that
		 *         hasn't been loaded yet).  The file is searched for on
		 *         sys.path; the .py suffix may be omitted.
		 *         
		 */
		do_break(arg, temporary?): Promise<any>
		do_break$({ arg, temporary }: { arg, temporary?}): Promise<any>

		/**
		 * Produce a reasonable default.
		 */
		defaultFile(): Promise<any>
		defaultFile$($: {}): Promise<any>

		/**
		 * tbreak [ ([filename:]lineno | function) [, condition] ]
		 *         Same arguments as break, but sets a temporary breakpoint: it
		 *         is automatically deleted when first hit.
		 *         
		 */
		do_tbreak(arg): Promise<any>
		do_tbreak$({ arg }): Promise<any>
		lineinfo(identifier): Promise<any>
		lineinfo$({ identifier }): Promise<any>

		/**
		 * Check whether specified line seems to be executable.
		 * 
		 *         Return `lineno` if it is, 0 if not (e.g. a docstring, comment, blank
		 *         line or EOF). Warning: testing is not comprehensive.
		 *         
		 */
		checkline(filename, lineno): Promise<any>
		checkline$({ filename, lineno }): Promise<any>

		/**
		 * enable bpnumber [bpnumber ...]
		 *         Enables the breakpoints given as a space separated list of
		 *         breakpoint numbers.
		 *         
		 */
		do_enable(arg): Promise<any>
		do_enable$({ arg }): Promise<any>

		/**
		 * disable bpnumber [bpnumber ...]
		 *         Disables the breakpoints given as a space separated list of
		 *         breakpoint numbers.  Disabling a breakpoint means it cannot
		 *         cause the program to stop execution, but unlike clearing a
		 *         breakpoint, it remains in the list of breakpoints and can be
		 *         (re-)enabled.
		 *         
		 */
		do_disable(arg): Promise<any>
		do_disable$({ arg }): Promise<any>

		/**
		 * condition bpnumber [condition]
		 *         Set a new condition for the breakpoint, an expression which
		 *         must evaluate to true before the breakpoint is honored.  If
		 *         condition is absent, any existing condition is removed; i.e.,
		 *         the breakpoint is made unconditional.
		 *         
		 */
		do_condition(arg): Promise<any>
		do_condition$({ arg }): Promise<any>

		/**
		 * ignore bpnumber [count]
		 *         Set the ignore count for the given breakpoint number.  If
		 *         count is omitted, the ignore count is set to 0.  A breakpoint
		 *         becomes active when the ignore count is zero.  When non-zero,
		 *         the count is decremented each time the breakpoint is reached
		 *         and the breakpoint is not disabled and any associated
		 *         condition evaluates to true.
		 *         
		 */
		do_ignore(arg): Promise<any>
		do_ignore$({ arg }): Promise<any>

		/**
		 * cl(ear) filename:lineno
		 * cl(ear) [bpnumber [bpnumber...]]
		 *         With a space separated list of breakpoint numbers, clear
		 *         those breakpoints.  Without argument, clear all breaks (but
		 *         first ask confirmation).  With a filename:lineno argument,
		 *         clear all breaks at that line in that file.
		 *         
		 */
		do_clear(arg): Promise<any>
		do_clear$({ arg }): Promise<any>

		/**
		 * w(here)
		 *         Print a stack trace, with the most recent frame at the bottom.
		 *         An arrow indicates the "current frame", which determines the
		 *         context of most commands.  'bt' is an alias for this command.
		 *         
		 */
		do_where(arg): Promise<any>
		do_where$({ arg }): Promise<any>

		/**
		 * u(p) [count]
		 *         Move the current frame count (default one) levels up in the
		 *         stack trace (to an older frame).
		 *         
		 */
		do_up(arg): Promise<any>
		do_up$({ arg }): Promise<any>

		/**
		 * d(own) [count]
		 *         Move the current frame count (default one) levels down in the
		 *         stack trace (to a newer frame).
		 *         
		 */
		do_down(arg): Promise<any>
		do_down$({ arg }): Promise<any>

		/**
		 * unt(il) [lineno]
		 *         Without argument, continue execution until the line with a
		 *         number greater than the current one is reached.  With a line
		 *         number, continue execution until a line with a number greater
		 *         or equal to that is reached.  In both cases, also stop when
		 *         the current frame returns.
		 *         
		 */
		do_until(arg): Promise<any>
		do_until$({ arg }): Promise<any>

		/**
		 * s(tep)
		 *         Execute the current line, stop at the first possible occasion
		 *         (either in a function that is called or in the current
		 *         function).
		 *         
		 */
		do_step(arg): Promise<any>
		do_step$({ arg }): Promise<any>

		/**
		 * n(ext)
		 *         Continue execution until the next line in the current function
		 *         is reached or it returns.
		 *         
		 */
		do_next(arg): Promise<any>
		do_next$({ arg }): Promise<any>

		/**
		 * run [args...]
		 *         Restart the debugged python program. If a string is supplied
		 *         it is split with "shlex", and the result is used as the new
		 *         sys.argv.  History, breakpoints, actions and debugger options
		 *         are preserved.  "restart" is an alias for "run".
		 *         
		 */
		do_run(arg): Promise<any>
		do_run$({ arg }): Promise<any>

		/**
		 * r(eturn)
		 *         Continue execution until the current function returns.
		 *         
		 */
		do_return(arg): Promise<any>
		do_return$({ arg }): Promise<any>

		/**
		 * c(ont(inue))
		 *         Continue execution, only stop when a breakpoint is encountered.
		 *         
		 */
		do_continue(arg): Promise<any>
		do_continue$({ arg }): Promise<any>

		/**
		 * j(ump) lineno
		 *         Set the next line that will be executed.  Only available in
		 *         the bottom-most frame.  This lets you jump back and execute
		 *         code again, or jump forward to skip code that you don't want
		 *         to run.
		 * 
		 *         It should be noted that not all jumps are allowed -- for
		 *         instance it is not possible to jump into the middle of a
		 *         for loop or out of a finally clause.
		 *         
		 */
		do_jump(arg): Promise<any>
		do_jump$({ arg }): Promise<any>

		/**
		 * debug code
		 *         Enter a recursive debugger that steps through the code
		 *         argument (which is an arbitrary expression or statement to be
		 *         executed in the current environment).
		 *         
		 */
		do_debug(arg): Promise<any>
		do_debug$({ arg }): Promise<any>

		/**
		 * q(uit)
		 * exit
		 *         Quit from the debugger. The program being executed is aborted.
		 *         
		 */
		do_quit(arg): Promise<any>
		do_quit$({ arg }): Promise<any>

		/**
		 * EOF
		 *         Handles the receipt of EOF as a command.
		 *         
		 */
		do_EOF(arg): Promise<any>
		do_EOF$({ arg }): Promise<any>

		/**
		 * a(rgs)
		 *         Print the argument list of the current function.
		 *         
		 */
		do_args(arg): Promise<any>
		do_args$({ arg }): Promise<any>

		/**
		 * retval
		 *         Print the return value for the last return of a function.
		 *         
		 */
		do_retval(arg): Promise<any>
		do_retval$({ arg }): Promise<any>

		/**
		 * p expression
		 *         Print the value of the expression.
		 *         
		 */
		do_p(arg): Promise<any>
		do_p$({ arg }): Promise<any>

		/**
		 * pp expression
		 *         Pretty-print the value of the expression.
		 *         
		 */
		do_pp(arg): Promise<any>
		do_pp$({ arg }): Promise<any>

		/**
		 * l(ist) [first [,last] | .]
		 * 
		 *         List source code for the current file.  Without arguments,
		 *         list 11 lines around the current line or continue the previous
		 *         listing.  With . as argument, list 11 lines around the current
		 *         line.  With one argument, list 11 lines starting at that line.
		 *         With two arguments, list the given range; if the second
		 *         argument is less than the first, it is a count.
		 * 
		 *         The current line in the current frame is indicated by "->".
		 *         If an exception is being debugged, the line where the
		 *         exception was originally raised or propagated is indicated by
		 *         ">>", if it differs from the current line.
		 *         
		 */
		do_list(arg): Promise<any>
		do_list$({ arg }): Promise<any>

		/**
		 * longlist | ll
		 *         List the whole source code for the current function or frame.
		 *         
		 */
		do_longlist(arg): Promise<any>
		do_longlist$({ arg }): Promise<any>

		/**
		 * source expression
		 *         Try to get source code for the given object and display it.
		 *         
		 */
		do_source(arg): Promise<any>
		do_source$({ arg }): Promise<any>

		/**
		 * whatis arg
		 *         Print the type of the argument.
		 *         
		 */
		do_whatis(arg): Promise<any>
		do_whatis$({ arg }): Promise<any>

		/**
		 * display [expression]
		 * 
		 *         Display the value of the expression if it changed, each time execution
		 *         stops in the current frame.
		 * 
		 *         Without expression, list all display expressions for the current frame.
		 *         
		 */
		do_display(arg): Promise<any>
		do_display$({ arg }): Promise<any>

		/**
		 * undisplay [expression]
		 * 
		 *         Do not display the expression any more in the current frame.
		 * 
		 *         Without expression, clear all display expressions for the current frame.
		 *         
		 */
		do_undisplay(arg): Promise<any>
		do_undisplay$({ arg }): Promise<any>
		complete_undisplay(text, line, begidx, endidx): Promise<any>
		complete_undisplay$({ text, line, begidx, endidx }): Promise<any>

		/**
		 * interact
		 * 
		 *         Start an interactive interpreter whose global namespace
		 *         contains all the (global and local) names found in the current scope.
		 *         
		 */
		do_interact(arg): Promise<any>
		do_interact$({ arg }): Promise<any>

		/**
		 * alias [name [command [parameter parameter ...] ]]
		 *         Create an alias called 'name' that executes 'command'.  The
		 *         command must *not* be enclosed in quotes.  Replaceable
		 *         parameters can be indicated by %1, %2, and so on, while %* is
		 *         replaced by all the parameters.  If no command is given, the
		 *         current alias for name is shown. If no name is given, all
		 *         aliases are listed.
		 * 
		 *         Aliases may be nested and can contain anything that can be
		 *         legally typed at the pdb prompt.  Note!  You *can* override
		 *         internal pdb commands with aliases!  Those internal commands
		 *         are then hidden until the alias is removed.  Aliasing is
		 *         recursively applied to the first word of the command line; all
		 *         other words in the line are left alone.
		 * 
		 *         As an example, here are two useful aliases (especially when
		 *         placed in the .pdbrc file):
		 * 
		 *         # Print instance variables (usage "pi classInst")
		 *         alias pi for k in %1.__dict__.keys(): print("%1.",k,"=",%1.__dict__[k])
		 *         # Print instance variables in self
		 *         alias ps pi self
		 *         
		 */
		do_alias(arg): Promise<any>
		do_alias$({ arg }): Promise<any>

		/**
		 * unalias name
		 *         Delete the specified alias.
		 *         
		 */
		do_unalias(arg): Promise<any>
		do_unalias$({ arg }): Promise<any>
		complete_unalias(text, line, begidx, endidx): Promise<any>
		complete_unalias$({ text, line, begidx, endidx }): Promise<any>
		print_stack_trace(): Promise<any>
		print_stack_trace$($: {}): Promise<any>
		print_stack_entry(frame_lineno, prompt_prefix?): Promise<any>
		print_stack_entry$({ frame_lineno, prompt_prefix }: { frame_lineno, prompt_prefix?}): Promise<any>

		/**
		 * h(elp)
		 *         Without argument, print the list of available commands.
		 *         With a command name as argument, print help about that command.
		 *         "help pdb" shows the full pdb documentation.
		 *         "help exec" gives help on the ! command.
		 *         
		 */
		do_help(arg): Promise<any>
		do_help$({ arg }): Promise<any>

		/**
		 * (!) statement
		 *         Execute the (one-line) statement in the context of the current
		 *         stack frame.  The exclamation point can be omitted unless the
		 *         first word of the statement resembles a debugger command.  To
		 *         assign to a global variable you must always prefix the command
		 *         with a 'global' command, e.g.:
		 *         (Pdb) global list_options; list_options = ['-l']
		 *         (Pdb)
		 *         
		 */
		help_exec(): Promise<any>
		help_exec$($: {}): Promise<any>
		help_pdb(): Promise<any>
		help_pdb$($: {}): Promise<any>

		/**
		 * Helper function for break/clear parsing -- may be overridden.
		 * 
		 *         lookupmodule() translates (possibly incomplete) file or module name
		 *         into an absolute file name.
		 *         
		 */
		lookupmodule(filename): Promise<any>
		lookupmodule$({ filename }): Promise<any>
		complete_commands
		do_b
		complete_break
		complete_b
		complete_tbreak
		complete_enable
		complete_disable
		complete_condition
		complete_ignore
		do_cl
		complete_clear
		complete_cl
		do_w
		do_bt
		do_u
		do_d
		do_unt
		do_s
		do_n
		do_restart
		do_r
		do_c
		do_cont
		do_j
		complete_debug
		do_q
		do_exit
		do_a
		do_rv
		complete_print
		complete_p
		complete_pp
		do_l
		do_ll
		complete_source
		complete_whatis
		complete_display
		commands_resuming
		do_h
	}
	let line_prefix: Promise<any>
	let TESTCMD: Promise<any>
}
declare module pickle {
	var _

	/**
	 * Find the module an object belong to.
	 */
	function whichmodule(obj, name): Promise<any>
	function whichmodule$({ obj, name }): Promise<any>

	/**
	 * Encode a long to a two's complement little-endian binary string.
	 *     Note that 0 is a special case, returning an empty string, to save a
	 *     byte in the LONG1 pickling context.
	 * 
	 *     >>> encode_long(0)
	 *     b''
	 *     >>> encode_long(255)
	 *     b'\xff\x00'
	 *     >>> encode_long(32767)
	 *     b'\xff\x7f'
	 *     >>> encode_long(-256)
	 *     b'\x00\xff'
	 *     >>> encode_long(-32768)
	 *     b'\x00\x80'
	 *     >>> encode_long(-128)
	 *     b'\x80'
	 *     >>> encode_long(127)
	 *     b'\x7f'
	 *     >>>
	 *     
	 */
	function encode_long(x): Promise<any>
	function encode_long$({ x }): Promise<any>

	/**
	 * Decode a long from a two's complement little-endian binary string.
	 * 
	 *     >>> decode_long(b'')
	 *     0
	 *     >>> decode_long(b"\xff\x00")
	 *     255
	 *     >>> decode_long(b"\xff\x7f")
	 *     32767
	 *     >>> decode_long(b"\x00\xff")
	 *     -256
	 *     >>> decode_long(b"\x00\x80")
	 *     -32768
	 *     >>> decode_long(b"\x80")
	 *     -128
	 *     >>> decode_long(b"\x7f")
	 *     127
	 *     
	 */
	function decode_long(data): Promise<any>
	function decode_long$({ data }): Promise<any>

	/**
	 * A common base class for the other pickling exceptions.
	 */
	interface IPickleError {
	}

	/**
	 * This exception is raised when an unpicklable object is passed to the
	 *     dump() method.
	 * 
	 *     
	 */
	interface IPicklingError extends IPickleError {
	}

	/**
	 * This exception is raised when there is a problem unpickling an object,
	 *     such as a security violation.
	 * 
	 *     Note that other exceptions may also be raised during unpickling, including
	 *     (but not necessarily limited to) AttributeError, EOFError, ImportError,
	 *     and IndexError.
	 * 
	 *     
	 */
	interface IUnpicklingError extends IPickleError {
	}
	interface I_Stop {
	}
	interface I_Framer {
		start_framing(): Promise<any>
		start_framing$($: {}): Promise<any>
		end_framing(): Promise<any>
		end_framing$($: {}): Promise<any>
		commit_frame(force?: boolean): Promise<any>
		commit_frame$({ force }: { force?}): Promise<any>
		write(data): Promise<any>
		write$({ data }): Promise<any>
		write_large_bytes(header, payload): Promise<any>
		write_large_bytes$({ header, payload }): Promise<any>
	}
	interface I_Unframer {
		readinto(buf): Promise<any>
		readinto$({ buf }): Promise<any>
		read(n): Promise<any>
		read$({ n }): Promise<any>
		readline(): Promise<any>
		readline$($: {}): Promise<any>
		load_frame(frame_size): Promise<any>
		load_frame$({ frame_size }): Promise<any>
	}
	interface I_Pickler {

		/**
		 * Clears the pickler's "memo".
		 * 
		 *         The memo is the data structure that remembers which objects the
		 *         pickler has already seen, so that shared or recursive objects
		 *         are pickled by reference and not by value.  This method is
		 *         useful when re-using picklers.
		 *         
		 */
		clear_memo(): Promise<any>
		clear_memo$($: {}): Promise<any>

		/**
		 * Write a pickled representation of obj to the open file.
		 */
		dump(obj): Promise<any>
		dump$({ obj }): Promise<any>

		/**
		 * Store an object in the memo.
		 */
		memoize(obj): Promise<any>
		memoize$({ obj }): Promise<any>
		put(idx): Promise<any>
		put$({ idx }): Promise<any>
		get(i): Promise<any>
		get$({ i }): Promise<any>
		save(obj, save_persistent_id?: boolean): Promise<any>
		save$({ obj, save_persistent_id }: { obj, save_persistent_id?}): Promise<any>
		persistent_id(obj): Promise<any>
		persistent_id$({ obj }): Promise<any>
		save_pers(pid): Promise<any>
		save_pers$({ pid }): Promise<any>
		save_reduce(func, args, state?, listitems?, dictitems?, state_setter?, obj?): Promise<any>
		save_reduce$({ func, args, state, listitems, dictitems, state_setter, obj }: { func, args, state?, listitems?, dictitems?, state_setter?, obj?}): Promise<any>
		save_none(obj): Promise<any>
		save_none$({ obj }): Promise<any>
		save_bool(obj): Promise<any>
		save_bool$({ obj }): Promise<any>
		save_long(obj): Promise<any>
		save_long$({ obj }): Promise<any>
		save_float(obj): Promise<any>
		save_float$({ obj }): Promise<any>
		save_bytes(obj): Promise<any>
		save_bytes$({ obj }): Promise<any>
		save_bytearray(obj): Promise<any>
		save_bytearray$({ obj }): Promise<any>
		save_str(obj): Promise<any>
		save_str$({ obj }): Promise<any>
		save_tuple(obj): Promise<any>
		save_tuple$({ obj }): Promise<any>
		save_list(obj): Promise<any>
		save_list$({ obj }): Promise<any>
		save_dict(obj): Promise<any>
		save_dict$({ obj }): Promise<any>
		save_set(obj): Promise<any>
		save_set$({ obj }): Promise<any>
		save_frozenset(obj): Promise<any>
		save_frozenset$({ obj }): Promise<any>
		save_global(obj, name?): Promise<any>
		save_global$({ obj, name }: { obj, name?}): Promise<any>
		save_type(obj): Promise<any>
		save_type$({ obj }): Promise<any>
		dispatch
	}
	interface I_Unpickler {

		/**
		 * Read a pickled object representation from the open file.
		 * 
		 *         Return the reconstituted object hierarchy specified in the file.
		 *         
		 */
		load(): Promise<any>
		load$($: {}): Promise<any>
		pop_mark(): Promise<any>
		pop_mark$($: {}): Promise<any>
		persistent_load(pid): Promise<any>
		persistent_load$({ pid }): Promise<any>
		load_proto(): Promise<any>
		load_proto$($: {}): Promise<any>
		load_frame(): Promise<any>
		load_frame$($: {}): Promise<any>
		load_persid(): Promise<any>
		load_persid$($: {}): Promise<any>
		load_binpersid(): Promise<any>
		load_binpersid$($: {}): Promise<any>
		load_none(): Promise<any>
		load_none$($: {}): Promise<any>
		load_false(): Promise<any>
		load_false$($: {}): Promise<any>
		load_true(): Promise<any>
		load_true$($: {}): Promise<any>
		load_int(): Promise<any>
		load_int$($: {}): Promise<any>
		load_binint(): Promise<any>
		load_binint$($: {}): Promise<any>
		load_binint1(): Promise<any>
		load_binint1$($: {}): Promise<any>
		load_binint2(): Promise<any>
		load_binint2$($: {}): Promise<any>
		load_long(): Promise<any>
		load_long$($: {}): Promise<any>
		load_long1(): Promise<any>
		load_long1$($: {}): Promise<any>
		load_long4(): Promise<any>
		load_long4$($: {}): Promise<any>
		load_float(): Promise<any>
		load_float$($: {}): Promise<any>
		load_binfloat(): Promise<any>
		load_binfloat$($: {}): Promise<any>
		load_string(): Promise<any>
		load_string$($: {}): Promise<any>
		load_binstring(): Promise<any>
		load_binstring$($: {}): Promise<any>
		load_binbytes(): Promise<any>
		load_binbytes$($: {}): Promise<any>
		load_unicode(): Promise<any>
		load_unicode$($: {}): Promise<any>
		load_binunicode(): Promise<any>
		load_binunicode$($: {}): Promise<any>
		load_binunicode8(): Promise<any>
		load_binunicode8$($: {}): Promise<any>
		load_binbytes8(): Promise<any>
		load_binbytes8$($: {}): Promise<any>
		load_bytearray8(): Promise<any>
		load_bytearray8$($: {}): Promise<any>
		load_next_buffer(): Promise<any>
		load_next_buffer$($: {}): Promise<any>
		load_readonly_buffer(): Promise<any>
		load_readonly_buffer$($: {}): Promise<any>
		load_short_binstring(): Promise<any>
		load_short_binstring$($: {}): Promise<any>
		load_short_binbytes(): Promise<any>
		load_short_binbytes$($: {}): Promise<any>
		load_short_binunicode(): Promise<any>
		load_short_binunicode$($: {}): Promise<any>
		load_tuple(): Promise<any>
		load_tuple$($: {}): Promise<any>
		load_empty_tuple(): Promise<any>
		load_empty_tuple$($: {}): Promise<any>
		load_tuple1(): Promise<any>
		load_tuple1$($: {}): Promise<any>
		load_tuple2(): Promise<any>
		load_tuple2$($: {}): Promise<any>
		load_tuple3(): Promise<any>
		load_tuple3$($: {}): Promise<any>
		load_empty_list(): Promise<any>
		load_empty_list$($: {}): Promise<any>
		load_empty_dictionary(): Promise<any>
		load_empty_dictionary$($: {}): Promise<any>
		load_empty_set(): Promise<any>
		load_empty_set$($: {}): Promise<any>
		load_frozenset(): Promise<any>
		load_frozenset$($: {}): Promise<any>
		load_list(): Promise<any>
		load_list$($: {}): Promise<any>
		load_dict(): Promise<any>
		load_dict$($: {}): Promise<any>
		load_inst(): Promise<any>
		load_inst$($: {}): Promise<any>
		load_obj(): Promise<any>
		load_obj$($: {}): Promise<any>
		load_newobj(): Promise<any>
		load_newobj$($: {}): Promise<any>
		load_newobj_ex(): Promise<any>
		load_newobj_ex$($: {}): Promise<any>
		load_global(): Promise<any>
		load_global$($: {}): Promise<any>
		load_stack_global(): Promise<any>
		load_stack_global$($: {}): Promise<any>
		load_ext1(): Promise<any>
		load_ext1$($: {}): Promise<any>
		load_ext2(): Promise<any>
		load_ext2$($: {}): Promise<any>
		load_ext4(): Promise<any>
		load_ext4$($: {}): Promise<any>
		get_extension(code): Promise<any>
		get_extension$({ code }): Promise<any>
		find_class(module, name): Promise<any>
		find_class$({ module, name }): Promise<any>
		load_reduce(): Promise<any>
		load_reduce$($: {}): Promise<any>
		load_pop(): Promise<any>
		load_pop$($: {}): Promise<any>
		load_pop_mark(): Promise<any>
		load_pop_mark$($: {}): Promise<any>
		load_dup(): Promise<any>
		load_dup$($: {}): Promise<any>
		load_get(): Promise<any>
		load_get$($: {}): Promise<any>
		load_binget(): Promise<any>
		load_binget$($: {}): Promise<any>
		load_long_binget(): Promise<any>
		load_long_binget$($: {}): Promise<any>
		load_put(): Promise<any>
		load_put$($: {}): Promise<any>
		load_binput(): Promise<any>
		load_binput$($: {}): Promise<any>
		load_long_binput(): Promise<any>
		load_long_binput$($: {}): Promise<any>
		load_memoize(): Promise<any>
		load_memoize$($: {}): Promise<any>
		load_append(): Promise<any>
		load_append$($: {}): Promise<any>
		load_appends(): Promise<any>
		load_appends$($: {}): Promise<any>
		load_setitem(): Promise<any>
		load_setitem$($: {}): Promise<any>
		load_setitems(): Promise<any>
		load_setitems$($: {}): Promise<any>
		load_additems(): Promise<any>
		load_additems$($: {}): Promise<any>
		load_build(): Promise<any>
		load_build$($: {}): Promise<any>
		load_mark(): Promise<any>
		load_mark$($: {}): Promise<any>
		load_stop(): Promise<any>
		load_stop$($: {}): Promise<any>
	}
	let bytes_types: Promise<any>
	let format_version: Promise<any>
	let compatible_formats: Promise<any>
	let HIGHEST_PROTOCOL: Promise<any>
	let DEFAULT_PROTOCOL: Promise<any>
	let MARK: Promise<any>
	let STOP: Promise<any>
	let POP: Promise<any>
	let POP_MARK: Promise<any>
	let DUP: Promise<any>
	let FLOAT: Promise<any>
	let INT: Promise<any>
	let BININT: Promise<any>
	let BININT1: Promise<any>
	let LONG: Promise<any>
	let BININT2: Promise<any>
	let NONE: Promise<any>
	let PERSID: Promise<any>
	let BINPERSID: Promise<any>
	let REDUCE: Promise<any>
	let STRING: Promise<any>
	let BINSTRING: Promise<any>
	let SHORT_BINSTRING: Promise<any>
	let UNICODE: Promise<any>
	let BINUNICODE: Promise<any>
	let APPEND: Promise<any>
	let BUILD: Promise<any>
	let GLOBAL: Promise<any>
	let DICT: Promise<any>
	let EMPTY_DICT: Promise<any>
	let APPENDS: Promise<any>
	let GET: Promise<any>
	let BINGET: Promise<any>
	let INST: Promise<any>
	let LONG_BINGET: Promise<any>
	let LIST: Promise<any>
	let EMPTY_LIST: Promise<any>
	let OBJ: Promise<any>
	let PUT: Promise<any>
	let BINPUT: Promise<any>
	let LONG_BINPUT: Promise<any>
	let SETITEM: Promise<any>
	let TUPLE: Promise<any>
	let EMPTY_TUPLE: Promise<any>
	let SETITEMS: Promise<any>
	let BINFLOAT: Promise<any>
	let TRUE: Promise<any>
	let FALSE: Promise<any>
	let PROTO: Promise<any>
	let NEWOBJ: Promise<any>
	let EXT1: Promise<any>
	let EXT2: Promise<any>
	let EXT4: Promise<any>
	let TUPLE1: Promise<any>
	let TUPLE2: Promise<any>
	let TUPLE3: Promise<any>
	let NEWTRUE: Promise<any>
	let NEWFALSE: Promise<any>
	let LONG1: Promise<any>
	let LONG4: Promise<any>
	let BINBYTES: Promise<any>
	let SHORT_BINBYTES: Promise<any>
	let SHORT_BINUNICODE: Promise<any>
	let BINUNICODE8: Promise<any>
	let BINBYTES8: Promise<any>
	let EMPTY_SET: Promise<any>
	let ADDITEMS: Promise<any>
	let FROZENSET: Promise<any>
	let NEWOBJ_EX: Promise<any>
	let STACK_GLOBAL: Promise<any>
	let MEMOIZE: Promise<any>
	let FRAME: Promise<any>
	let BYTEARRAY8: Promise<any>
	let NEXT_BUFFER: Promise<any>
	let READONLY_BUFFER: Promise<any>
	let parser: Promise<any>
	let args: Promise<any>
	let obj: Promise<any>
}
declare module pickletools {
	var _

	/**
	 * 
	 *     >>> import io
	 *     >>> read_uint1(io.BytesIO(b'\xff'))
	 *     255
	 *     
	 */
	function read_uint1(f): Promise<any>
	function read_uint1$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_uint2(io.BytesIO(b'\xff\x00'))
	 *     255
	 *     >>> read_uint2(io.BytesIO(b'\xff\xff'))
	 *     65535
	 *     
	 */
	function read_uint2(f): Promise<any>
	function read_uint2$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_int4(io.BytesIO(b'\xff\x00\x00\x00'))
	 *     255
	 *     >>> read_int4(io.BytesIO(b'\x00\x00\x00\x80')) == -(2**31)
	 *     True
	 *     
	 */
	function read_int4(f): Promise<any>
	function read_int4$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_uint4(io.BytesIO(b'\xff\x00\x00\x00'))
	 *     255
	 *     >>> read_uint4(io.BytesIO(b'\x00\x00\x00\x80')) == 2**31
	 *     True
	 *     
	 */
	function read_uint4(f): Promise<any>
	function read_uint4$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_uint8(io.BytesIO(b'\xff\x00\x00\x00\x00\x00\x00\x00'))
	 *     255
	 *     >>> read_uint8(io.BytesIO(b'\xff' * 8)) == 2**64-1
	 *     True
	 *     
	 */
	function read_uint8(f): Promise<any>
	function read_uint8$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_stringnl(io.BytesIO(b"'abcd'\nefg\n"))
	 *     'abcd'
	 * 
	 *     >>> read_stringnl(io.BytesIO(b"\n"))
	 *     Traceback (most recent call last):
	 *     ...
	 *     ValueError: no string quotes around b''
	 * 
	 *     >>> read_stringnl(io.BytesIO(b"\n"), stripquotes=False)
	 *     ''
	 * 
	 *     >>> read_stringnl(io.BytesIO(b"''\n"))
	 *     ''
	 * 
	 *     >>> read_stringnl(io.BytesIO(b'"abcd"'))
	 *     Traceback (most recent call last):
	 *     ...
	 *     ValueError: no newline found when trying to read stringnl
	 * 
	 *     Embedded escapes are undone in the result.
	 *     >>> read_stringnl(io.BytesIO(br"'a\n\\b\x00c\td'" + b"\n'e'"))
	 *     'a\n\\b\x00c\td'
	 *     
	 */
	function read_stringnl(f, decode?: boolean, stripquotes?: boolean): Promise<any>
	function read_stringnl$({ f, decode, stripquotes }: { f, decode?, stripquotes?}): Promise<any>
	function read_stringnl_noescape(f): Promise<any>
	function read_stringnl_noescape$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_stringnl_noescape_pair(io.BytesIO(b"Queue\nEmpty\njunk"))
	 *     'Queue Empty'
	 *     
	 */
	function read_stringnl_noescape_pair(f): Promise<any>
	function read_stringnl_noescape_pair$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_string1(io.BytesIO(b"\x00"))
	 *     ''
	 *     >>> read_string1(io.BytesIO(b"\x03abcdef"))
	 *     'abc'
	 *     
	 */
	function read_string1(f): Promise<any>
	function read_string1$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_string4(io.BytesIO(b"\x00\x00\x00\x00abc"))
	 *     ''
	 *     >>> read_string4(io.BytesIO(b"\x03\x00\x00\x00abcdef"))
	 *     'abc'
	 *     >>> read_string4(io.BytesIO(b"\x00\x00\x00\x03abcdef"))
	 *     Traceback (most recent call last):
	 *     ...
	 *     ValueError: expected 50331648 bytes in a string4, but only 6 remain
	 *     
	 */
	function read_string4(f): Promise<any>
	function read_string4$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_bytes1(io.BytesIO(b"\x00"))
	 *     b''
	 *     >>> read_bytes1(io.BytesIO(b"\x03abcdef"))
	 *     b'abc'
	 *     
	 */
	function read_bytes1(f): Promise<any>
	function read_bytes1$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_bytes4(io.BytesIO(b"\x00\x00\x00\x00abc"))
	 *     b''
	 *     >>> read_bytes4(io.BytesIO(b"\x03\x00\x00\x00abcdef"))
	 *     b'abc'
	 *     >>> read_bytes4(io.BytesIO(b"\x00\x00\x00\x03abcdef"))
	 *     Traceback (most recent call last):
	 *     ...
	 *     ValueError: expected 50331648 bytes in a bytes4, but only 6 remain
	 *     
	 */
	function read_bytes4(f): Promise<any>
	function read_bytes4$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io, struct, sys
	 *     >>> read_bytes8(io.BytesIO(b"\x00\x00\x00\x00\x00\x00\x00\x00abc"))
	 *     b''
	 *     >>> read_bytes8(io.BytesIO(b"\x03\x00\x00\x00\x00\x00\x00\x00abcdef"))
	 *     b'abc'
	 *     >>> bigsize8 = struct.pack("<Q", sys.maxsize//3)
	 *     >>> read_bytes8(io.BytesIO(bigsize8 + b"abcdef"))  #doctest: +ELLIPSIS
	 *     Traceback (most recent call last):
	 *     ...
	 *     ValueError: expected ... bytes in a bytes8, but only 6 remain
	 *     
	 */
	function read_bytes8(f): Promise<any>
	function read_bytes8$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io, struct, sys
	 *     >>> read_bytearray8(io.BytesIO(b"\x00\x00\x00\x00\x00\x00\x00\x00abc"))
	 *     bytearray(b'')
	 *     >>> read_bytearray8(io.BytesIO(b"\x03\x00\x00\x00\x00\x00\x00\x00abcdef"))
	 *     bytearray(b'abc')
	 *     >>> bigsize8 = struct.pack("<Q", sys.maxsize//3)
	 *     >>> read_bytearray8(io.BytesIO(bigsize8 + b"abcdef"))  #doctest: +ELLIPSIS
	 *     Traceback (most recent call last):
	 *     ...
	 *     ValueError: expected ... bytes in a bytearray8, but only 6 remain
	 *     
	 */
	function read_bytearray8(f): Promise<any>
	function read_bytearray8$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_unicodestringnl(io.BytesIO(b"abc\\uabcd\njunk")) == 'abc\uabcd'
	 *     True
	 *     
	 */
	function read_unicodestringnl(f): Promise<any>
	function read_unicodestringnl$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> s = 'abcd\uabcd'
	 *     >>> enc = s.encode('utf-8')
	 *     >>> enc
	 *     b'abcd\xea\xaf\x8d'
	 *     >>> n = bytes([len(enc)])  # little-endian 1-byte length
	 *     >>> t = read_unicodestring1(io.BytesIO(n + enc + b'junk'))
	 *     >>> s == t
	 *     True
	 * 
	 *     >>> read_unicodestring1(io.BytesIO(n + enc[:-1]))
	 *     Traceback (most recent call last):
	 *     ...
	 *     ValueError: expected 7 bytes in a unicodestring1, but only 6 remain
	 *     
	 */
	function read_unicodestring1(f): Promise<any>
	function read_unicodestring1$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> s = 'abcd\uabcd'
	 *     >>> enc = s.encode('utf-8')
	 *     >>> enc
	 *     b'abcd\xea\xaf\x8d'
	 *     >>> n = bytes([len(enc), 0, 0, 0])  # little-endian 4-byte length
	 *     >>> t = read_unicodestring4(io.BytesIO(n + enc + b'junk'))
	 *     >>> s == t
	 *     True
	 * 
	 *     >>> read_unicodestring4(io.BytesIO(n + enc[:-1]))
	 *     Traceback (most recent call last):
	 *     ...
	 *     ValueError: expected 7 bytes in a unicodestring4, but only 6 remain
	 *     
	 */
	function read_unicodestring4(f): Promise<any>
	function read_unicodestring4$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> s = 'abcd\uabcd'
	 *     >>> enc = s.encode('utf-8')
	 *     >>> enc
	 *     b'abcd\xea\xaf\x8d'
	 *     >>> n = bytes([len(enc)]) + b'\0' * 7  # little-endian 8-byte length
	 *     >>> t = read_unicodestring8(io.BytesIO(n + enc + b'junk'))
	 *     >>> s == t
	 *     True
	 * 
	 *     >>> read_unicodestring8(io.BytesIO(n + enc[:-1]))
	 *     Traceback (most recent call last):
	 *     ...
	 *     ValueError: expected 7 bytes in a unicodestring8, but only 6 remain
	 *     
	 */
	function read_unicodestring8(f): Promise<any>
	function read_unicodestring8$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_decimalnl_short(io.BytesIO(b"1234\n56"))
	 *     1234
	 * 
	 *     >>> read_decimalnl_short(io.BytesIO(b"1234L\n56"))
	 *     Traceback (most recent call last):
	 *     ...
	 *     ValueError: invalid literal for int() with base 10: b'1234L'
	 *     
	 */
	function read_decimalnl_short(f): Promise<any>
	function read_decimalnl_short$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 * 
	 *     >>> read_decimalnl_long(io.BytesIO(b"1234L\n56"))
	 *     1234
	 * 
	 *     >>> read_decimalnl_long(io.BytesIO(b"123456789012345678901234L\n6"))
	 *     123456789012345678901234
	 *     
	 */
	function read_decimalnl_long(f): Promise<any>
	function read_decimalnl_long$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_floatnl(io.BytesIO(b"-1.25\n6"))
	 *     -1.25
	 *     
	 */
	function read_floatnl(f): Promise<any>
	function read_floatnl$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io, struct
	 *     >>> raw = struct.pack(">d", -1.25)
	 *     >>> raw
	 *     b'\xbf\xf4\x00\x00\x00\x00\x00\x00'
	 *     >>> read_float8(io.BytesIO(raw + b"\n"))
	 *     -1.25
	 *     
	 */
	function read_float8(f): Promise<any>
	function read_float8$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_long1(io.BytesIO(b"\x00"))
	 *     0
	 *     >>> read_long1(io.BytesIO(b"\x02\xff\x00"))
	 *     255
	 *     >>> read_long1(io.BytesIO(b"\x02\xff\x7f"))
	 *     32767
	 *     >>> read_long1(io.BytesIO(b"\x02\x00\xff"))
	 *     -256
	 *     >>> read_long1(io.BytesIO(b"\x02\x00\x80"))
	 *     -32768
	 *     
	 */
	function read_long1(f): Promise<any>
	function read_long1$({ f }): Promise<any>

	/**
	 * 
	 *     >>> import io
	 *     >>> read_long4(io.BytesIO(b"\x02\x00\x00\x00\xff\x00"))
	 *     255
	 *     >>> read_long4(io.BytesIO(b"\x02\x00\x00\x00\xff\x7f"))
	 *     32767
	 *     >>> read_long4(io.BytesIO(b"\x02\x00\x00\x00\x00\xff"))
	 *     -256
	 *     >>> read_long4(io.BytesIO(b"\x02\x00\x00\x00\x00\x80"))
	 *     -32768
	 *     >>> read_long1(io.BytesIO(b"\x00\x00\x00\x00"))
	 *     0
	 *     
	 */
	function read_long4(f): Promise<any>
	function read_long4$({ f }): Promise<any>
	function assure_pickle_consistency(verbose?: boolean): Promise<any>
	function assure_pickle_consistency$({ verbose }: { verbose?}): Promise<any>

	/**
	 * Generate all the opcodes in a pickle.
	 * 
	 *     'pickle' is a file-like object, or string, containing the pickle.
	 * 
	 *     Each opcode in the pickle is generated, from the current pickle position,
	 *     stopping after a STOP opcode is delivered.  A triple is generated for
	 *     each opcode:
	 * 
	 *         opcode, arg, pos
	 * 
	 *     opcode is an OpcodeInfo record, describing the current opcode.
	 * 
	 *     If the opcode has an argument embedded in the pickle, arg is its decoded
	 *     value, as a Python object.  If the opcode doesn't have an argument, arg
	 *     is None.
	 * 
	 *     If the pickle has a tell() method, pos was the value of pickle.tell()
	 *     before reading the current opcode.  If the pickle is a bytes object,
	 *     it's wrapped in a BytesIO object, and the latter's tell() result is
	 *     used.  Else (the pickle doesn't have a tell(), and it's not obvious how
	 *     to query its current position) pos is None.
	 *     
	 */
	function genops(pickle): Promise<any>
	function genops$({ pickle }): Promise<any>

	/**
	 * Optimize a pickle string by removing unused PUT opcodes
	 */
	function optimize(p): Promise<any>
	function optimize$({ p }): Promise<any>

	/**
	 * Produce a symbolic disassembly of a pickle.
	 * 
	 *     'pickle' is a file-like object, or string, containing a (at least one)
	 *     pickle.  The pickle is disassembled from the current position, through
	 *     the first STOP opcode encountered.
	 * 
	 *     Optional arg 'out' is a file-like object to which the disassembly is
	 *     printed.  It defaults to sys.stdout.
	 * 
	 *     Optional arg 'memo' is a Python dict, used as the pickle's memo.  It
	 *     may be mutated by dis(), if the pickle contains PUT or BINPUT opcodes.
	 *     Passing the same memo object to another dis() call then allows disassembly
	 *     to proceed across multiple pickles that were all created by the same
	 *     pickler with the same memo.  Ordinarily you don't need to worry about this.
	 * 
	 *     Optional arg 'indentlevel' is the number of blanks by which to indent
	 *     a new MARK level.  It defaults to 4.
	 * 
	 *     Optional arg 'annotate' if nonzero instructs dis() to add short
	 *     description of the opcode on each line of disassembled output.
	 *     The value given to 'annotate' must be an integer and is used as a
	 *     hint for the column where annotation should start.  The default
	 *     value is 0, meaning no annotations.
	 * 
	 *     In addition to printing the disassembly, some sanity checks are made:
	 * 
	 *     + All embedded opcode arguments "make sense".
	 * 
	 *     + Explicit and implicit pop operations have enough items on the stack.
	 * 
	 *     + When an opcode implicitly refers to a markobject, a markobject is
	 *       actually on the stack.
	 * 
	 *     + A memo entry isn't referenced before it's defined.
	 * 
	 *     + The markobject isn't stored in the memo.
	 * 
	 *     + A memo entry isn't redefined.
	 *     
	 */
	function dis(pickle, out?, memo?, indentlevel?, annotate?): Promise<any>
	function dis$({ pickle, out, memo, indentlevel, annotate }: { pickle, out?, memo?, indentlevel?, annotate?}): Promise<any>
	function ArgumentDescriptor(name, n, reader, doc): Promise<IArgumentDescriptor>
	function ArgumentDescriptor$({ name, n, reader, doc }): Promise<IArgumentDescriptor>
	interface IArgumentDescriptor {
	}
	function StackObject(name, obtype, doc): Promise<IStackObject>
	function StackObject$({ name, obtype, doc }): Promise<IStackObject>
	interface IStackObject {
	}
	function OpcodeInfo(name, code, arg, stack_before, stack_after, proto, doc): Promise<IOpcodeInfo>
	function OpcodeInfo$({ name, code, arg, stack_before, stack_after, proto, doc }): Promise<IOpcodeInfo>
	interface IOpcodeInfo {
	}
	interface I_Example {
	}
	let bytes_types: Promise<any>
	let UP_TO_NEWLINE: Promise<any>
	let TAKEN_FROM_ARGUMENT1: Promise<any>
	let TAKEN_FROM_ARGUMENT4: Promise<any>
	let TAKEN_FROM_ARGUMENT4U: Promise<any>
	let TAKEN_FROM_ARGUMENT8U: Promise<any>
	let uint1: Promise<any>
	let uint2: Promise<any>
	let int4: Promise<any>
	let uint4: Promise<any>
	let uint8: Promise<any>
	let stringnl: Promise<any>
	let stringnl_noescape: Promise<any>
	let stringnl_noescape_pair: Promise<any>
	let string1: Promise<any>
	let string4: Promise<any>
	let bytes1: Promise<any>
	let bytes4: Promise<any>
	let bytes8: Promise<any>
	let bytearray8: Promise<any>
	let unicodestringnl: Promise<any>
	let unicodestring1: Promise<any>
	let unicodestring4: Promise<any>
	let unicodestring8: Promise<any>
	let decimalnl_short: Promise<any>
	let decimalnl_long: Promise<any>
	let floatnl: Promise<any>
	let float8: Promise<any>
	let long1: Promise<any>
	let long4: Promise<any>
	let pyint: Promise<any>
	let pylong: Promise<any>
	let pyinteger_or_bool: Promise<any>
	let pybool: Promise<any>
	let pyfloat: Promise<any>
	let pybytes_or_str: Promise<any>
	let pystring: Promise<any>
	let pybytes: Promise<any>
	let pybytearray: Promise<any>
	let pyunicode: Promise<any>
	let pynone: Promise<any>
	let pytuple: Promise<any>
	let pylist: Promise<any>
	let pydict: Promise<any>
	let pyset: Promise<any>
	let pyfrozenset: Promise<any>
	let pybuffer: Promise<any>
	let anyobject: Promise<any>
	let markobject: Promise<any>
	let stackslice: Promise<any>
	let I: Promise<any>
	let opcodes: Promise<any>
	let name2i: Promise<any>
	let code2i: Promise<any>
	let code2op: Promise<any>
	let parser: Promise<any>
	let args: Promise<any>
	let annotate: Promise<any>
	let memo: Promise<any>
	let preamble: Promise<any>
}
declare module pipes {
	var _
	function makepipeline(infile, steps, outfile): Promise<any>
	function makepipeline$({ infile, steps, outfile }): Promise<any>

	/**
	 * Class representing a pipeline template.
	 */

	/**
	 * Template() returns a fresh pipeline template.
	 */
	function Template(): Promise<ITemplate>
	function Template$({ }): Promise<ITemplate>
	interface ITemplate {

		/**
		 * t.reset() restores a pipeline template to its initial state.
		 */
		reset(): Promise<any>
		reset$($: {}): Promise<any>

		/**
		 * t.clone() returns a new pipeline template with identical
		 *         initial state as the current one.
		 */
		clone(): Promise<any>
		clone$($: {}): Promise<any>

		/**
		 * t.debug(flag) turns debugging on or off.
		 */
		debug(flag): Promise<any>
		debug$({ flag }): Promise<any>

		/**
		 * t.append(cmd, kind) adds a new step at the end.
		 */
		append(cmd, kind): Promise<any>
		append$({ cmd, kind }): Promise<any>

		/**
		 * t.prepend(cmd, kind) adds a new step at the front.
		 */
		prepend(cmd, kind): Promise<any>
		prepend$({ cmd, kind }): Promise<any>

		/**
		 * t.open(file, rw) returns a pipe or file object open for
		 *         reading or writing; the file is the other end of the pipeline.
		 */
		open(file, rw): Promise<any>
		open$({ file, rw }): Promise<any>

		/**
		 * t.open_r(file) and t.open_w(file) implement
		 *         t.open(file, 'r') and t.open(file, 'w') respectively.
		 */
		open_r(file): Promise<any>
		open_r$({ file }): Promise<any>
		open_w(file): Promise<any>
		open_w$({ file }): Promise<any>
		copy(infile, outfile): Promise<any>
		copy$({ infile, outfile }): Promise<any>
		makepipeline(infile, outfile): Promise<any>
		makepipeline$({ infile, outfile }): Promise<any>
	}
	let FILEIN_FILEOUT: Promise<any>
	let STDIN_FILEOUT: Promise<any>
	let FILEIN_STDOUT: Promise<any>
	let STDIN_STDOUT: Promise<any>
	let SOURCE: Promise<any>
	let SINK: Promise<any>
	let stepkinds: Promise<any>
}
declare module pkgutil {
	var _
	function read_code(stream): Promise<any>
	function read_code$({ stream }): Promise<any>

	/**
	 * Yields ModuleInfo for all modules recursively
	 *     on path, or, if path is None, all accessible modules.
	 * 
	 *     'path' should be either None or a list of paths to look for
	 *     modules in.
	 * 
	 *     'prefix' is a string to output on the front of every module name
	 *     on output.
	 * 
	 *     Note that this function must import all *packages* (NOT all
	 *     modules!) on the given path, in order to access the __path__
	 *     attribute to find submodules.
	 * 
	 *     'onerror' is a function which gets called with one argument (the
	 *     name of the package which was being imported) if any exception
	 *     occurs while trying to import a package.  If no onerror function is
	 *     supplied, ImportErrors are caught and ignored, while all other
	 *     exceptions are propagated, terminating the search.
	 * 
	 *     Examples:
	 * 
	 *     # list all modules python can access
	 *     walk_packages()
	 * 
	 *     # list all submodules of ctypes
	 *     walk_packages(ctypes.__path__, ctypes.__name__+'.')
	 *     
	 */
	function walk_packages(path?, prefix?, onerror?): Promise<any>
	function walk_packages$({ path, prefix, onerror }: { path?, prefix?, onerror?}): Promise<any>

	/**
	 * Yields ModuleInfo for all submodules on path,
	 *     or, if path is None, all top-level modules on sys.path.
	 * 
	 *     'path' should be either None or a list of paths to look for
	 *     modules in.
	 * 
	 *     'prefix' is a string to output on the front of every module name
	 *     on output.
	 *     
	 */
	function iter_modules(path?, prefix?): Promise<any>
	function iter_modules$({ path, prefix }: { path?, prefix?}): Promise<any>
	function iter_importer_modules(importer, prefix?): Promise<any>
	function iter_importer_modules$({ importer, prefix }: { importer, prefix?}): Promise<any>
	function iter_zipimport_modules(importer, prefix?): Promise<any>
	function iter_zipimport_modules$({ importer, prefix }: { importer, prefix?}): Promise<any>

	/**
	 * Retrieve a finder for the given path item
	 * 
	 *     The returned finder is cached in sys.path_importer_cache
	 *     if it was newly created by a path hook.
	 * 
	 *     The cache (or part of it) can be cleared manually if a
	 *     rescan of sys.path_hooks is necessary.
	 *     
	 */
	function get_importer(path_item): Promise<any>
	function get_importer$({ path_item }): Promise<any>

	/**
	 * Yield finders for the given module name
	 * 
	 *     If fullname contains a '.', the finders will be for the package
	 *     containing fullname, otherwise they will be all registered top level
	 *     finders (i.e. those on both sys.meta_path and sys.path_hooks).
	 * 
	 *     If the named module is in a package, that package is imported as a side
	 *     effect of invoking this function.
	 * 
	 *     If no module name is specified, all top level finders are produced.
	 *     
	 */
	function iter_importers(fullname?): Promise<any>
	function iter_importers$({ fullname }: { fullname?}): Promise<any>

	/**
	 * Get a "loader" object for module_or_name
	 * 
	 *     Returns None if the module cannot be found or imported.
	 *     If the named module is not already imported, its containing package
	 *     (if any) is imported, in order to establish the package __path__.
	 *     
	 */
	function get_loader(module_or_name): Promise<any>
	function get_loader$({ module_or_name }): Promise<any>

	/**
	 * Find a "loader" object for fullname
	 * 
	 *     This is a backwards compatibility wrapper around
	 *     importlib.util.find_spec that converts most failures to ImportError
	 *     and only returns the loader rather than the full spec
	 *     
	 */
	function find_loader(fullname): Promise<any>
	function find_loader$({ fullname }): Promise<any>

	/**
	 * Extend a package's path.
	 * 
	 *     Intended use is to place the following code in a package's __init__.py:
	 * 
	 *         from pkgutil import extend_path
	 *         __path__ = extend_path(__path__, __name__)
	 * 
	 *     This will add to the package's __path__ all subdirectories of
	 *     directories on sys.path named after the package.  This is useful
	 *     if one wants to distribute different parts of a single logical
	 *     package as multiple directories.
	 * 
	 *     It also looks for *.pkg files beginning where * matches the name
	 *     argument.  This feature is similar to *.pth files (see site.py),
	 *     except that it doesn't special-case lines starting with 'import'.
	 *     A *.pkg file is trusted at face value: apart from checking for
	 *     duplicates, all entries found in a *.pkg file are added to the
	 *     path, regardless of whether they are exist the filesystem.  (This
	 *     is a feature.)
	 * 
	 *     If the input path is not a list (as is the case for frozen
	 *     packages) it is returned unchanged.  The input path is not
	 *     modified; an extended copy is returned.  Items are only appended
	 *     to the copy at the end.
	 * 
	 *     It is assumed that sys.path is a sequence.  Items of sys.path that
	 *     are not (unicode or 8-bit) strings referring to existing
	 *     directories are ignored.  Unicode items of sys.path that cause
	 *     errors when used as filenames may cause this function to raise an
	 *     exception (in line with os.path.isdir() behavior).
	 *     
	 */
	function extend_path(path, name): Promise<any>
	function extend_path$({ path, name }): Promise<any>

	/**
	 * Get a resource from a package.
	 * 
	 *     This is a wrapper round the PEP 302 loader get_data API. The package
	 *     argument should be the name of a package, in standard module format
	 *     (foo.bar). The resource argument should be in the form of a relative
	 *     filename, using '/' as the path separator. The parent directory name '..'
	 *     is not allowed, and nor is a rooted name (starting with a '/').
	 * 
	 *     The function returns a binary string, which is the contents of the
	 *     specified resource.
	 * 
	 *     For packages located in the filesystem, which have already been imported,
	 *     this is the rough equivalent of
	 * 
	 *         d = os.path.dirname(sys.modules[package].__file__)
	 *         data = open(os.path.join(d, resource), 'rb').read()
	 * 
	 *     If the package cannot be located or loaded, or it uses a PEP 302 loader
	 *     which does not support get_data(), then None is returned.
	 *     
	 */
	function get_data(package, resource): Promise<any>
	function get_data$({ package, resource }): Promise<any>

	/**
	 * 
	 *     Resolve a name to an object.
	 * 
	 *     It is expected that `name` will be a string in one of the following
	 *     formats, where W is shorthand for a valid Python identifier and dot stands
	 *     for a literal period in these pseudo-regexes:
	 * 
	 *     W(.W)*
	 *     W(.W)*:(W(.W)*)?
	 * 
	 *     The first form is intended for backward compatibility only. It assumes that
	 *     some part of the dotted name is a package, and the rest is an object
	 *     somewhere within that package, possibly nested inside other objects.
	 *     Because the place where the package stops and the object hierarchy starts
	 *     can't be inferred by inspection, repeated attempts to import must be done
	 *     with this form.
	 * 
	 *     In the second form, the caller makes the division point clear through the
	 *     provision of a single colon: the dotted name to the left of the colon is a
	 *     package to be imported, and the dotted name to the right is the object
	 *     hierarchy within that package. Only one import is needed in this form. If
	 *     it ends with the colon, then a module object is returned.
	 * 
	 *     The function will return an object (which might be a module), or raise one
	 *     of the following exceptions:
	 * 
	 *     ValueError - if `name` isn't in a recognised format
	 *     ImportError - if an import failed when it shouldn't have
	 *     AttributeError - if a failure occurred when traversing the object hierarchy
	 *                      within the imported package to get to the desired object)
	 *     
	 */
	function resolve_name(name): Promise<any>
	function resolve_name$({ name }): Promise<any>

	/**
	 * PEP 302 Finder that wraps Python's "classic" import algorithm
	 * 
	 *     ImpImporter(dirname) produces a PEP 302 finder that searches that
	 *     directory.  ImpImporter(None) produces a PEP 302 finder that searches
	 *     the current sys.path, plus any modules that are frozen or built-in.
	 * 
	 *     Note that ImpImporter does not currently support being used by placement
	 *     on sys.meta_path.
	 *     
	 */
	function ImpImporter(path?): Promise<IImpImporter>
	function ImpImporter$({ path }: { path?}): Promise<IImpImporter>
	interface IImpImporter {
		find_module(fullname, path?): Promise<any>
		find_module$({ fullname, path }: { fullname, path?}): Promise<any>
		iter_modules(prefix?): Promise<any>
		iter_modules$({ prefix }: { prefix?}): Promise<any>
	}

	/**
	 * PEP 302 Loader that wraps Python's "classic" import algorithm
	 *     
	 */
	function ImpLoader(fullname, file, filename, etc): Promise<IImpLoader>
	function ImpLoader$({ fullname, file, filename, etc }): Promise<IImpLoader>
	interface IImpLoader {
		load_module(fullname): Promise<any>
		load_module$({ fullname }): Promise<any>
		get_data(pathname): Promise<any>
		get_data$({ pathname }): Promise<any>
		is_package(fullname): Promise<any>
		is_package$({ fullname }): Promise<any>
		get_code(fullname?): Promise<any>
		get_code$({ fullname }: { fullname?}): Promise<any>
		get_source(fullname?): Promise<any>
		get_source$({ fullname }: { fullname?}): Promise<any>
		get_filename(fullname?): Promise<any>
		get_filename$({ fullname }: { fullname?}): Promise<any>
		code
		source
	}
	let ModuleInfo: Promise<any>
}
declare module platform {
	var _

	/**
	 *  Tries to determine the libc version that the file executable
	 *         (which defaults to the Python interpreter) is linked against.
	 * 
	 *         Returns a tuple of strings (lib,version) which default to the
	 *         given parameters in case the lookup fails.
	 * 
	 *         Note that the function has intimate knowledge of how different
	 *         libc versions add symbols to the executable and thus is probably
	 *         only usable for executables compiled using gcc.
	 * 
	 *         The file is read and scanned in chunks of chunksize bytes.
	 * 
	 *     
	 */
	function libc_ver(executable?, lib?, version?, chunksize?): Promise<any>
	function libc_ver$({ executable, lib, version, chunksize }: { executable?, lib?, version?, chunksize?}): Promise<any>
	function win32_is_iot(): Promise<any>
	function win32_is_iot$($: {}): Promise<any>
	function win32_edition(): Promise<any>
	function win32_edition$($: {}): Promise<any>
	function win32_ver(release?, version?, csd?, ptype?): Promise<any>
	function win32_ver$({ release, version, csd, ptype }: { release?, version?, csd?, ptype?}): Promise<any>

	/**
	 *  Get macOS version information and return it as tuple (release,
	 *         versioninfo, machine) with versioninfo being a tuple (version,
	 *         dev_stage, non_release_version).
	 * 
	 *         Entries which cannot be determined are set to the parameter values
	 *         which default to ''. All tuple entries are strings.
	 *     
	 */
	function mac_ver(release?, versioninfo?, machine?): Promise<any>
	function mac_ver$({ release, versioninfo, machine }: { release?, versioninfo?, machine?}): Promise<any>

	/**
	 *  Version interface for Jython.
	 * 
	 *         Returns a tuple (release, vendor, vminfo, osinfo) with vminfo being
	 *         a tuple (vm_name, vm_release, vm_vendor) and osinfo being a
	 *         tuple (os_name, os_version, os_arch).
	 * 
	 *         Values which cannot be determined are set to the defaults
	 *         given as parameters (which all default to '').
	 * 
	 *     
	 */
	function java_ver(release?, vendor?, vminfo?, osinfo?): Promise<any>
	function java_ver$({ release, vendor, vminfo, osinfo }: { release?, vendor?, vminfo?, osinfo?}): Promise<any>

	/**
	 *  Returns (system, release, version) aliased to common
	 *         marketing names used for some systems.
	 * 
	 *         It also does some reordering of the information in some cases
	 *         where it would otherwise cause confusion.
	 * 
	 *     
	 */
	function system_alias(system, release, version): Promise<any>
	function system_alias$({ system, release, version }): Promise<any>

	/**
	 *  Queries the given executable (defaults to the Python interpreter
	 *         binary) for various architecture information.
	 * 
	 *         Returns a tuple (bits, linkage) which contains information about
	 *         the bit architecture and the linkage format used for the
	 *         executable. Both values are returned as strings.
	 * 
	 *         Values that cannot be determined are returned as given by the
	 *         parameter presets. If bits is given as '', the sizeof(pointer)
	 *         (or sizeof(long) on Python version < 1.5.2) is used as
	 *         indicator for the supported pointer size.
	 * 
	 *         The function relies on the system's "file" command to do the
	 *         actual work. This is available on most if not all Unix
	 *         platforms. On some non-Unix platforms where the "file" command
	 *         does not exist and the executable is set to the Python interpreter
	 *         binary defaults from _default_architecture are used.
	 * 
	 *     
	 */
	function architecture(executable?, bits?, linkage?): Promise<any>
	function architecture$({ executable, bits, linkage }: { executable?, bits?, linkage?}): Promise<any>

	/**
	 *  Fairly portable uname interface. Returns a tuple
	 *         of strings (system, node, release, version, machine, processor)
	 *         identifying the underlying platform.
	 * 
	 *         Note that unlike the os.uname function this also returns
	 *         possible processor information as an additional tuple entry.
	 * 
	 *         Entries which cannot be determined are set to ''.
	 * 
	 *     
	 */
	function uname(): Promise<any>
	function uname$($: {}): Promise<any>

	/**
	 *  Returns the system/OS name, e.g. 'Linux', 'Windows' or 'Java'.
	 * 
	 *         An empty string is returned if the value cannot be determined.
	 * 
	 *     
	 */
	function system(): Promise<any>
	function system$($: {}): Promise<any>

	/**
	 *  Returns the computer's network name (which may not be fully
	 *         qualified)
	 * 
	 *         An empty string is returned if the value cannot be determined.
	 * 
	 *     
	 */
	function node(): Promise<any>
	function node$($: {}): Promise<any>

	/**
	 *  Returns the system's release, e.g. '2.2.0' or 'NT'
	 * 
	 *         An empty string is returned if the value cannot be determined.
	 * 
	 *     
	 */
	function release(): Promise<any>
	function release$($: {}): Promise<any>

	/**
	 *  Returns the system's release version, e.g. '#3 on degas'
	 * 
	 *         An empty string is returned if the value cannot be determined.
	 * 
	 *     
	 */
	function version(): Promise<any>
	function version$($: {}): Promise<any>

	/**
	 *  Returns the machine type, e.g. 'i386'
	 * 
	 *         An empty string is returned if the value cannot be determined.
	 * 
	 *     
	 */
	function machine(): Promise<any>
	function machine$($: {}): Promise<any>

	/**
	 *  Returns the (true) processor name, e.g. 'amdk6'
	 * 
	 *         An empty string is returned if the value cannot be
	 *         determined. Note that many platforms do not provide this
	 *         information or simply return the same value as for machine(),
	 *         e.g.  NetBSD does this.
	 * 
	 *     
	 */
	function processor(): Promise<any>
	function processor$($: {}): Promise<any>

	/**
	 *  Returns a string identifying the Python implementation.
	 * 
	 *         Currently, the following implementations are identified:
	 *           'CPython' (C implementation of Python),
	 *           'IronPython' (.NET implementation of Python),
	 *           'Jython' (Java implementation of Python),
	 *           'PyPy' (Python implementation of Python).
	 * 
	 *     
	 */
	function python_implementation(): Promise<any>
	function python_implementation$($: {}): Promise<any>

	/**
	 *  Returns the Python version as string 'major.minor.patchlevel'
	 * 
	 *         Note that unlike the Python sys.version, the returned value
	 *         will always include the patchlevel (it defaults to 0).
	 * 
	 *     
	 */
	function python_version(): Promise<any>
	function python_version$($: {}): Promise<any>

	/**
	 *  Returns the Python version as tuple (major, minor, patchlevel)
	 *         of strings.
	 * 
	 *         Note that unlike the Python sys.version, the returned value
	 *         will always include the patchlevel (it defaults to 0).
	 * 
	 *     
	 */
	function python_version_tuple(): Promise<any>
	function python_version_tuple$($: {}): Promise<any>

	/**
	 *  Returns a string identifying the Python implementation
	 *         branch.
	 * 
	 *         For CPython this is the SCM branch from which the
	 *         Python binary was built.
	 * 
	 *         If not available, an empty string is returned.
	 * 
	 *     
	 */
	function python_branch(): Promise<any>
	function python_branch$($: {}): Promise<any>

	/**
	 *  Returns a string identifying the Python implementation
	 *         revision.
	 * 
	 *         For CPython this is the SCM revision from which the
	 *         Python binary was built.
	 * 
	 *         If not available, an empty string is returned.
	 * 
	 *     
	 */
	function python_revision(): Promise<any>
	function python_revision$($: {}): Promise<any>

	/**
	 *  Returns a tuple (buildno, builddate) stating the Python
	 *         build number and date as strings.
	 * 
	 *     
	 */
	function python_build(): Promise<any>
	function python_build$($: {}): Promise<any>

	/**
	 *  Returns a string identifying the compiler used for compiling
	 *         Python.
	 * 
	 *     
	 */
	function python_compiler(): Promise<any>
	function python_compiler$($: {}): Promise<any>

	/**
	 *  Returns a single string identifying the underlying platform
	 *         with as much useful information as possible (but no more :).
	 * 
	 *         The output is intended to be human readable rather than
	 *         machine parseable. It may look different on different
	 *         platforms and this is intended.
	 * 
	 *         If "aliased" is true, the function will use aliases for
	 *         various platforms that report system names which differ from
	 *         their common names, e.g. SunOS will be reported as
	 *         Solaris. The system_alias() function is used to implement
	 *         this.
	 * 
	 *         Setting terse to true causes the function to return only the
	 *         absolute minimum information needed to identify the platform.
	 * 
	 *     
	 */
	function platform(aliased?, terse?): Promise<any>
	function platform$({ aliased, terse }: { aliased?, terse?}): Promise<any>

	/**
	 * Return operation system identification from freedesktop.org os-release
	 *     
	 */
	function freedesktop_os_release(): Promise<any>
	function freedesktop_os_release$($: {}): Promise<any>
	interface I_Processor {
		get(): Promise<any>
		get$($: {}): Promise<any>
		get_win32(): Promise<any>
		get_win32$($: {}): Promise<any>
		get_OpenVMS(): Promise<any>
		get_OpenVMS$($: {}): Promise<any>

		/**
		 * 
		 *         Fall back to `uname -p`
		 *         
		 */
		from_subprocess(): Promise<any>
		from_subprocess$($: {}): Promise<any>
	}

	/**
	 * 
	 *     A uname_result that's largely compatible with a
	 *     simple namedtuple except that 'processor' is
	 *     resolved late and cached to avoid calling "uname"
	 *     except when needed.
	 *     
	 */
	interface Iuname_result {
		processor(): Promise<any>
		processor$($: {}): Promise<any>
	}
	let terse: Promise<any>
	let aliased: Promise<any>
}
declare module plistlib {
	var _

	/**
	 * Read a .plist file. 'fp' should be a readable and binary file object.
	 *     Return the unpacked root object (which usually is a dictionary).
	 *     
	 */
	function load(fp): Promise<any>
	function load$({ fp }): Promise<any>

	/**
	 * Read a .plist file from a bytes object.
	 *     Return the unpacked root object (which usually is a dictionary).
	 *     
	 */
	function loads(value): Promise<any>
	function loads$({ value }): Promise<any>

	/**
	 * Write 'value' to a .plist file. 'fp' should be a writable,
	 *     binary file object.
	 *     
	 */
	function dump(value, fp): Promise<any>
	function dump$({ value, fp }): Promise<any>

	/**
	 * Return a bytes object with the contents for a .plist file.
	 *     
	 */
	function dumps(value): Promise<any>
	function dumps$({ value }): Promise<any>
	function UID(data): Promise<IUID>
	function UID$({ data }): Promise<IUID>
	interface IUID {
	}
	interface I_PlistParser {
		parse(fileobj): Promise<any>
		parse$({ fileobj }): Promise<any>
		handle_entity_decl(entity_name, is_parameter_entity, value, base, system_id, public_id, notation_name): Promise<any>
		handle_entity_decl$({ entity_name, is_parameter_entity, value, base, system_id, public_id, notation_name }): Promise<any>
		handle_begin_element(element, attrs): Promise<any>
		handle_begin_element$({ element, attrs }): Promise<any>
		handle_end_element(element): Promise<any>
		handle_end_element$({ element }): Promise<any>
		handle_data(data): Promise<any>
		handle_data$({ data }): Promise<any>
		add_object(value): Promise<any>
		add_object$({ value }): Promise<any>
		get_data(): Promise<any>
		get_data$($: {}): Promise<any>
		begin_dict(attrs): Promise<any>
		begin_dict$({ attrs }): Promise<any>
		end_dict(): Promise<any>
		end_dict$($: {}): Promise<any>
		end_key(): Promise<any>
		end_key$($: {}): Promise<any>
		begin_array(attrs): Promise<any>
		begin_array$({ attrs }): Promise<any>
		end_array(): Promise<any>
		end_array$($: {}): Promise<any>
		end_true(): Promise<any>
		end_true$($: {}): Promise<any>
		end_false(): Promise<any>
		end_false$($: {}): Promise<any>
		end_integer(): Promise<any>
		end_integer$($: {}): Promise<any>
		end_real(): Promise<any>
		end_real$($: {}): Promise<any>
		end_string(): Promise<any>
		end_string$($: {}): Promise<any>
		end_data(): Promise<any>
		end_data$($: {}): Promise<any>
		end_date(): Promise<any>
		end_date$($: {}): Promise<any>
	}
	interface I_DumbXMLWriter {
		begin_element(element): Promise<any>
		begin_element$({ element }): Promise<any>
		end_element(element): Promise<any>
		end_element$({ element }): Promise<any>
		simple_element(element, value?): Promise<any>
		simple_element$({ element, value }: { element, value?}): Promise<any>
		writeln(line): Promise<any>
		writeln$({ line }): Promise<any>
	}
	interface I_PlistWriter extends I_DumbXMLWriter {
		write(value): Promise<any>
		write$({ value }): Promise<any>
		write_value(value): Promise<any>
		write_value$({ value }): Promise<any>
		write_bytes(data): Promise<any>
		write_bytes$({ data }): Promise<any>
		write_dict(d): Promise<any>
		write_dict$({ d }): Promise<any>
		write_array(array): Promise<any>
		write_array$({ array }): Promise<any>
	}
	function InvalidFileException(message?): Promise<IInvalidFileException>
	function InvalidFileException$({ message }: { message?}): Promise<IInvalidFileException>
	interface IInvalidFileException {
	}

	/**
	 * 
	 *     Read or write a binary plist file, following the description of the binary
	 *     format.  Raise InvalidFileException in case of error, otherwise return the
	 *     root object.
	 * 
	 *     see also: http://opensource.apple.com/source/CF/CF-744.18/CFBinaryPList.c
	 *     
	 */
	interface I_BinaryPlistParser {
		parse(fp): Promise<any>
		parse$({ fp }): Promise<any>
	}
	interface I_BinaryPlistWriter {
		write(value): Promise<any>
		write$({ value }): Promise<any>
	}
	let PlistFormat: Promise<any>
	let PLISTHEADER: Promise<any>
}
declare module poplib {
	var _
	interface Ierror_proto {
	}

	/**
	 * This class supports both the minimal and optional command sets.
	 *     Arguments can be strings or integers (where appropriate)
	 *     (e.g.: retr(1) and retr('1') both work equally well.
	 * 
	 *     Minimal Command Set:
	 *             USER name               user(name)
	 *             PASS string             pass_(string)
	 *             STAT                    stat()
	 *             LIST [msg]              list(msg = None)
	 *             RETR msg                retr(msg)
	 *             DELE msg                dele(msg)
	 *             NOOP                    noop()
	 *             RSET                    rset()
	 *             QUIT                    quit()
	 * 
	 *     Optional Commands (some servers support these):
	 *             RPOP name               rpop(name)
	 *             APOP name digest        apop(name, digest)
	 *             TOP msg n               top(msg, n)
	 *             UIDL [msg]              uidl(msg = None)
	 *             CAPA                    capa()
	 *             STLS                    stls()
	 *             UTF8                    utf8()
	 * 
	 *     Raises one exception: 'error_proto'.
	 * 
	 *     Instantiate with:
	 *             POP3(hostname, port=110)
	 * 
	 *     NB:     the POP protocol locks the mailbox from user
	 *             authorization until QUIT, so be sure to get in, suck
	 *             the messages, and quit, each time you access the
	 *             mailbox.
	 * 
	 *             POP is a line-based protocol, which means large mail
	 *             messages consume lots of python cycles reading them
	 *             line-by-line.
	 * 
	 *             If it's available on your mail server, use IMAP4
	 *             instead, it doesn't suffer from the two problems
	 *             above.
	 *     
	 */
	function POP3(host, port?, timeout?): Promise<IPOP3>
	function POP3$({ host, port, timeout }: { host, port?, timeout?}): Promise<IPOP3>
	interface IPOP3 {
		getwelcome(): Promise<any>
		getwelcome$($: {}): Promise<any>
		set_debuglevel(level): Promise<any>
		set_debuglevel$({ level }): Promise<any>

		/**
		 * Send user name, return response
		 * 
		 *         (should indicate password required).
		 *         
		 */
		user(user): Promise<any>
		user$({ user }): Promise<any>

		/**
		 * Send password, return response
		 * 
		 *         (response includes message count, mailbox size).
		 * 
		 *         NB: mailbox is locked by server from here to 'quit()'
		 *         
		 */
		pass_(pswd): Promise<any>
		pass_$({ pswd }): Promise<any>

		/**
		 * Get mailbox status.
		 * 
		 *         Result is tuple of 2 ints (message count, mailbox size)
		 *         
		 */
		stat(): Promise<any>
		stat$($: {}): Promise<any>

		/**
		 * Request listing, return result.
		 * 
		 *         Result without a message number argument is in form
		 *         ['response', ['mesg_num octets', ...], octets].
		 * 
		 *         Result when a message number argument is given is a
		 *         single response: the "scan listing" for that message.
		 *         
		 */
		list(which?): Promise<any>
		list$({ which }: { which?}): Promise<any>

		/**
		 * Retrieve whole message number 'which'.
		 * 
		 *         Result is in form ['response', ['line', ...], octets].
		 *         
		 */
		retr(which): Promise<any>
		retr$({ which }): Promise<any>

		/**
		 * Delete message number 'which'.
		 * 
		 *         Result is 'response'.
		 *         
		 */
		dele(which): Promise<any>
		dele$({ which }): Promise<any>

		/**
		 * Does nothing.
		 * 
		 *         One supposes the response indicates the server is alive.
		 *         
		 */
		noop(): Promise<any>
		noop$($: {}): Promise<any>

		/**
		 * Unmark all messages marked for deletion.
		 */
		rset(): Promise<any>
		rset$($: {}): Promise<any>

		/**
		 * Signoff: commit changes on server, unlock mailbox, close connection.
		 */
		quit(): Promise<any>
		quit$($: {}): Promise<any>

		/**
		 * Close the connection without assuming anything about it.
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>

		/**
		 * Not sure what this does.
		 */
		rpop(user): Promise<any>
		rpop$({ user }): Promise<any>

		/**
		 * Authorisation
		 * 
		 *         - only possible if server has supplied a timestamp in initial greeting.
		 * 
		 *         Args:
		 *                 user     - mailbox user;
		 *                 password - mailbox password.
		 * 
		 *         NB: mailbox is locked by server from here to 'quit()'
		 *         
		 */
		apop(user, password): Promise<any>
		apop$({ user, password }): Promise<any>

		/**
		 * Retrieve message header of message number 'which'
		 *         and first 'howmuch' lines of message body.
		 * 
		 *         Result is in form ['response', ['line', ...], octets].
		 *         
		 */
		top(which, howmuch): Promise<any>
		top$({ which, howmuch }): Promise<any>

		/**
		 * Return message digest (unique id) list.
		 * 
		 *         If 'which', result contains unique id for that message
		 *         in the form 'response mesgnum uid', otherwise result is
		 *         the list ['response', ['mesgnum uid', ...], octets]
		 *         
		 */
		uidl(which?): Promise<any>
		uidl$({ which }: { which?}): Promise<any>

		/**
		 * Try to enter UTF-8 mode (see RFC 6856). Returns server response.
		 *         
		 */
		utf8(): Promise<any>
		utf8$($: {}): Promise<any>

		/**
		 * Return server capabilities (RFC 2449) as a dictionary
		 *         >>> c=poplib.POP3('localhost')
		 *         >>> c.capa()
		 *         {'IMPLEMENTATION': ['Cyrus', 'POP3', 'server', 'v2.2.12'],
		 *          'TOP': [], 'LOGIN-DELAY': ['0'], 'AUTH-RESP-CODE': [],
		 *          'EXPIRE': ['NEVER'], 'USER': [], 'STLS': [], 'PIPELINING': [],
		 *          'UIDL': [], 'RESP-CODES': []}
		 *         >>>
		 * 
		 *         Really, according to RFC 2449, the cyrus folks should avoid
		 *         having the implementation split into multiple arguments...
		 *         
		 */
		capa(): Promise<any>
		capa$($: {}): Promise<any>

		/**
		 * Start a TLS session on the active connection as specified in RFC 2595.
		 * 
		 *                 context - a ssl.SSLContext
		 *         
		 */
		stls(context?): Promise<any>
		stls$({ context }: { context?}): Promise<any>
		encoding
		timestamp
	}

	/**
	 * POP3 client class over SSL connection
	 * 
	 *         Instantiate with: POP3_SSL(hostname, port=995, keyfile=None, certfile=None,
	 *                                    context=None)
	 * 
	 *                hostname - the hostname of the pop3 over ssl server
	 *                port - port number
	 *                keyfile - PEM formatted file that contains your private key
	 *                certfile - PEM formatted certificate chain file
	 *                context - a ssl.SSLContext
	 * 
	 *         See the methods of the parent class POP3 for more documentation.
	 *         
	 */
	function POP3_SSL(host, port?, keyfile?, certfile?, timeout?, context?): Promise<IPOP3_SSL>
	function POP3_SSL$({ host, port, keyfile, certfile, timeout, context }: { host, port?, keyfile?, certfile?, timeout?, context?}): Promise<IPOP3_SSL>
	interface IPOP3_SSL extends IPOP3 {

		/**
		 * The method unconditionally raises an exception since the
		 *             STLS command doesn't make any sense on an already established
		 *             SSL/TLS session.
		 *             
		 */
		stls(keyfile?, certfile?, context?): Promise<any>
		stls$({ keyfile, certfile, context }: { keyfile?, certfile?, context?}): Promise<any>
	}
	let HAVE_SSL: Promise<any>
	let POP3_PORT: Promise<any>
	let POP3_SSL_PORT: Promise<any>
	let CR: Promise<any>
	let LF: Promise<any>
	let CRLF: Promise<any>
	let a: Promise<any>
}
declare module posixpath {
	var _

	/**
	 * Normalize case of pathname.  Has no effect under Posix
	 */
	function normcase(s): Promise<any>
	function normcase$({ s }): Promise<any>

	/**
	 * Test whether a path is absolute
	 */
	function isabs(s): Promise<any>
	function isabs$({ s }): Promise<any>

	/**
	 * Join two or more pathname components, inserting '/' as needed.
	 *     If any component is an absolute path, all previous path components
	 *     will be discarded.  An empty last part will result in a path that
	 *     ends with a separator.
	 */
	function join(a): Promise<any>
	function join$({ a }): Promise<any>

	/**
	 * Split a pathname.  Returns tuple "(head, tail)" where "tail" is
	 *     everything after the final slash.  Either part may be empty.
	 */
	function split(p): Promise<any>
	function split$({ p }): Promise<any>
	function splitext(p): Promise<any>
	function splitext$({ p }): Promise<any>

	/**
	 * Split a pathname into drive and path. On Posix, drive is always
	 *     empty.
	 */
	function splitdrive(p): Promise<any>
	function splitdrive$({ p }): Promise<any>

	/**
	 * Returns the final component of a pathname
	 */
	function basename(p): Promise<any>
	function basename$({ p }): Promise<any>

	/**
	 * Returns the directory component of a pathname
	 */
	function dirname(p): Promise<any>
	function dirname$({ p }): Promise<any>

	/**
	 * Test whether a path is a symbolic link
	 */
	function islink(path): Promise<any>
	function islink$({ path }): Promise<any>

	/**
	 * Test whether a path exists.  Returns True for broken symbolic links
	 */
	function lexists(path): Promise<any>
	function lexists$({ path }): Promise<any>

	/**
	 * Test whether a path is a mount point
	 */
	function ismount(path): Promise<any>
	function ismount$({ path }): Promise<any>

	/**
	 * Expand ~ and ~user constructions.  If user or $HOME is unknown,
	 *     do nothing.
	 */
	function expanduser(path): Promise<any>
	function expanduser$({ path }): Promise<any>

	/**
	 * Expand shell variables of form $var and ${var}.  Unknown variables
	 *     are left unchanged.
	 */
	function expandvars(path): Promise<any>
	function expandvars$({ path }): Promise<any>

	/**
	 * Normalize path, eliminating double slashes, etc.
	 */
	function normpath(path): Promise<any>
	function normpath$({ path }): Promise<any>

	/**
	 * Return an absolute path.
	 */
	function abspath(path): Promise<any>
	function abspath$({ path }): Promise<any>

	/**
	 * Return the canonical path of the specified filename, eliminating any
	 * symbolic links encountered in the path.
	 */
	function realpath(filename): Promise<any>
	function realpath$({ filename }): Promise<any>

	/**
	 * Return a relative version of a path
	 */
	function relpath(path, start?): Promise<any>
	function relpath$({ path, start }: { path, start?}): Promise<any>

	/**
	 * Given a sequence of path names, returns the longest common sub-path.
	 */
	function commonpath(paths): Promise<any>
	function commonpath$({ paths }): Promise<any>
	let curdir: Promise<any>
	let pardir: Promise<any>
	let extsep: Promise<any>
	let sep: Promise<any>
	let pathsep: Promise<any>
	let defpath: Promise<any>
	let altsep: Promise<any>
	let devnull: Promise<any>
	let supports_unicode_filenames: Promise<any>
}
declare module pprint {
	var _

	/**
	 * Pretty-print a Python object to a stream [default is sys.stdout].
	 */
	function pprint(object, stream?, indent?, width?, depth?): Promise<any>
	function pprint$({ object, stream, indent, width, depth }: { object, stream?, indent?, width?, depth?}): Promise<any>

	/**
	 * Format a Python object into a pretty-printed representation.
	 */
	function pformat(object, indent?, width?, depth?): Promise<any>
	function pformat$({ object, indent, width, depth }: { object, indent?, width?, depth?}): Promise<any>

	/**
	 * Pretty-print a Python object
	 */
	function pp(object): Promise<any>
	function pp$({ object }): Promise<any>

	/**
	 * Version of repr() which can handle recursive data structures.
	 */
	function saferepr(object): Promise<any>
	function saferepr$({ object }): Promise<any>

	/**
	 * Determine if saferepr(object) is readable by eval().
	 */
	function isreadable(object): Promise<any>
	function isreadable$({ object }): Promise<any>

	/**
	 * Determine if object requires a recursive representation.
	 */
	function isrecursive(object): Promise<any>
	function isrecursive$({ object }): Promise<any>

	/**
	 * Helper function for key functions when sorting unorderable objects.
	 * 
	 *     The wrapped-object will fallback to a Py2.x style comparison for
	 *     unorderable types (sorting first comparing the type name and then by
	 *     the obj ids).  Does not work recursively, so dict.items() must have
	 *     _safe_key applied to both the key and the value.
	 * 
	 *     
	 */
	interface I_safe_key {
	}

	/**
	 * Handle pretty printing operations onto a stream using a set of
	 *         configured parameters.
	 * 
	 *         indent
	 *             Number of spaces to indent for each level of nesting.
	 * 
	 *         width
	 *             Attempted maximum number of columns in the output.
	 * 
	 *         depth
	 *             The maximum depth to print out nested structures.
	 * 
	 *         stream
	 *             The desired output stream.  If omitted (or false), the standard
	 *             output stream available at construction will be used.
	 * 
	 *         compact
	 *             If true, several items will be combined in one line.
	 * 
	 *         sort_dicts
	 *             If true, dict keys are sorted.
	 * 
	 *         
	 */
	function PrettyPrinter(indent?, width?, depth?, stream?): Promise<IPrettyPrinter>
	function PrettyPrinter$({ indent, width, depth, stream }: { indent?, width?, depth?, stream?}): Promise<IPrettyPrinter>
	interface IPrettyPrinter {
		pprint(object): Promise<any>
		pprint$({ object }): Promise<any>
		pformat(object): Promise<any>
		pformat$({ object }): Promise<any>
		isrecursive(object): Promise<any>
		isrecursive$({ object }): Promise<any>
		isreadable(object): Promise<any>
		isreadable$({ object }): Promise<any>

		/**
		 * Format object for a specific context, returning a string
		 *         and flags indicating whether the representation is 'readable'
		 *         and whether the object represents a recursive construct.
		 *         
		 */
		format(object, context, maxlevels, level): Promise<any>
		format$({ object, context, maxlevels, level }): Promise<any>
	}
}
declare module profile {
	var _

	/**
	 * Run statement under profiler optionally saving results in filename
	 * 
	 *     This function takes a single argument that can be passed to the
	 *     "exec" statement, and an optional file name.  In all cases this
	 *     routine attempts to "exec" its first argument and gather profiling
	 *     statistics from the execution. If no file name is present, then this
	 *     function automatically prints a simple profiling report, sorted by the
	 *     standard name string (file/line/function-name) that is presented in
	 *     each line.
	 *     
	 */
	function run(statement, filename?, sort?): Promise<any>
	function run$({ statement, filename, sort }: { statement, filename?, sort?}): Promise<any>

	/**
	 * Run statement under profiler, supplying your own globals and locals,
	 *     optionally saving results in filename.
	 * 
	 *     statement and filename have the same semantics as profile.run
	 *     
	 */
	function runctx(statement, globals, locals, filename?, sort?): Promise<any>
	function runctx$({ statement, globals, locals, filename, sort }: { statement, globals, locals, filename?, sort?}): Promise<any>
	function main(): Promise<any>
	function main$($: {}): Promise<any>

	/**
	 * Support class for utility functions which are shared by
	 *     profile.py and cProfile.py modules.
	 *     Not supposed to be used directly.
	 *     
	 */
	interface I_Utils {
		run(statement, filename, sort): Promise<any>
		run$({ statement, filename, sort }): Promise<any>
		runctx(statement, globals, locals, filename, sort): Promise<any>
		runctx$({ statement, globals, locals, filename, sort }): Promise<any>
	}

	/**
	 * Profiler class.
	 * 
	 *     self.cur is always a tuple.  Each such tuple corresponds to a stack
	 *     frame that is currently active (self.cur[-2]).  The following are the
	 *     definitions of its members.  We use this external "parallel stack" to
	 *     avoid contaminating the program that we are profiling. (old profiler
	 *     used to write into the frames local dictionary!!) Derived classes
	 *     can change the definition of some entries, as long as they leave
	 *     [-2:] intact (frame and previous tuple).  In case an internal error is
	 *     detected, the -3 element is used as the function name.
	 * 
	 *     [ 0] = Time that needs to be charged to the parent frame's function.
	 *            It is used so that a function call will not have to access the
	 *            timing data for the parent frame.
	 *     [ 1] = Total time spent in this frame's function, excluding time in
	 *            subfunctions (this latter is tallied in cur[2]).
	 *     [ 2] = Total time spent in subfunctions, excluding time executing the
	 *            frame's function (this latter is tallied in cur[1]).
	 *     [-3] = Name of the function that corresponds to this frame.
	 *     [-2] = Actual frame that we correspond to (used to sync exception handling).
	 *     [-1] = Our parent 6-tuple (corresponds to frame.f_back).
	 * 
	 *     Timing data for each function is stored as a 5-tuple in the dictionary
	 *     self.timings[].  The index is always the name stored in self.cur[-3].
	 *     The following are the definitions of the members:
	 * 
	 *     [0] = The number of times this function was called, not counting direct
	 *           or indirect recursion,
	 *     [1] = Number of times this function appears on the stack, minus one
	 *     [2] = Total time spent internal to this function
	 *     [3] = Cumulative time that this function was present on the stack.  In
	 *           non-recursive functions, this is the total execution time from start
	 *           to finish of each invocation of a function, including time spent in
	 *           all subfunctions.
	 *     [4] = A dictionary indicating for each function name, the number of times
	 *           it was called by us.
	 *     
	 */
	function Profile(timer?, bias?): Promise<IProfile>
	function Profile$({ timer, bias }: { timer?, bias?}): Promise<IProfile>
	interface IProfile {
		trace_dispatch(frame, event, arg): Promise<any>
		trace_dispatch$({ frame, event, arg }): Promise<any>
		trace_dispatch_i(frame, event, arg): Promise<any>
		trace_dispatch_i$({ frame, event, arg }): Promise<any>
		trace_dispatch_mac(frame, event, arg): Promise<any>
		trace_dispatch_mac$({ frame, event, arg }): Promise<any>
		trace_dispatch_l(frame, event, arg): Promise<any>
		trace_dispatch_l$({ frame, event, arg }): Promise<any>
		trace_dispatch_exception(frame, t): Promise<any>
		trace_dispatch_exception$({ frame, t }): Promise<any>
		trace_dispatch_call(frame, t): Promise<any>
		trace_dispatch_call$({ frame, t }): Promise<any>
		trace_dispatch_c_call(frame, t): Promise<any>
		trace_dispatch_c_call$({ frame, t }): Promise<any>
		trace_dispatch_return(frame, t): Promise<any>
		trace_dispatch_return$({ frame, t }): Promise<any>
		set_cmd(cmd): Promise<any>
		set_cmd$({ cmd }): Promise<any>
		simulate_call(name): Promise<any>
		simulate_call$({ name }): Promise<any>
		simulate_cmd_complete(): Promise<any>
		simulate_cmd_complete$($: {}): Promise<any>
		print_stats(sort?): Promise<any>
		print_stats$({ sort }: { sort?}): Promise<any>
		dump_stats(file): Promise<any>
		dump_stats$({ file }): Promise<any>
		create_stats(): Promise<any>
		create_stats$($: {}): Promise<any>
		snapshot_stats(): Promise<any>
		snapshot_stats$($: {}): Promise<any>
		run(cmd): Promise<any>
		run$({ cmd }): Promise<any>
		runctx(cmd, globals, locals): Promise<any>
		runctx$({ cmd, globals, locals }): Promise<any>
		runcall(func): Promise<any>
		runcall$({ func }): Promise<any>
		calibrate(m, verbose?): Promise<any>
		calibrate$({ m, verbose }: { m, verbose?}): Promise<any>
		bias
		dispatch
	}
}
declare module pstats {
	var _
	function func_strip_path(func_name): Promise<any>
	function func_strip_path$({ func_name }): Promise<any>
	function func_get_function_name(func): Promise<any>
	function func_get_function_name$({ func }): Promise<any>
	function func_std_string(func_name): Promise<any>
	function func_std_string$({ func_name }): Promise<any>

	/**
	 * Add together all the stats for two profile entries.
	 */
	function add_func_stats(target, source): Promise<any>
	function add_func_stats$({ target, source }): Promise<any>

	/**
	 * Combine two caller lists in a single list.
	 */
	function add_callers(target, source): Promise<any>
	function add_callers$({ target, source }): Promise<any>

	/**
	 * Sum the caller statistics to get total number of calls received.
	 */
	function count_calls(callers): Promise<any>
	function count_calls$({ callers }): Promise<any>
	function f8(x): Promise<any>
	function f8$({ x }): Promise<any>
	interface ISortKey {
		CALLS
		CUMULATIVE
		FILENAME
		LINE
		NAME
		NFL
		PCALLS
		STDNAME
		TIME
	}
	interface IFunctionProfile {
	}

	/**
	 * Class for keeping track of an item in inventory.
	 */
	interface IStatsProfile {
	}

	/**
	 * This class is used for creating reports from data generated by the
	 *     Profile class.  It is a "friend" of that class, and imports data either
	 *     by direct access to members of Profile class, or by reading in a dictionary
	 *     that was emitted (via marshal) from the Profile class.
	 * 
	 *     The big change from the previous Profiler (in terms of raw functionality)
	 *     is that an "add()" method has been provided to combine Stats from
	 *     several distinct profile runs.  Both the constructor and the add()
	 *     method now take arbitrarily many file names as arguments.
	 * 
	 *     All the print methods now take an argument that indicates how many lines
	 *     to print.  If the arg is a floating point number between 0 and 1.0, then
	 *     it is taken as a decimal percentage of the available lines to be printed
	 *     (e.g., .1 means print 10% of all available lines).  If it is an integer,
	 *     it is taken to mean the number of lines of data that you wish to have
	 *     printed.
	 * 
	 *     The sort_stats() method now processes some additional options (i.e., in
	 *     addition to the old -1, 0, 1, or 2 that are respectively interpreted as
	 *     'stdname', 'calls', 'time', and 'cumulative').  It takes either an
	 *     arbitrary number of quoted strings or SortKey enum to select the sort
	 *     order.
	 * 
	 *     For example sort_stats('time', 'name') or sort_stats(SortKey.TIME,
	 *     SortKey.NAME) sorts on the major key of 'internal function time', and on
	 *     the minor key of 'the name of the function'.  Look at the two tables in
	 *     sort_stats() and get_sort_arg_defs(self) for more examples.
	 * 
	 *     All methods return self, so you can string together commands like:
	 *         Stats('foo', 'goo').strip_dirs().sort_stats('calls').                            print_stats(5).print_callers(5)
	 *     
	 */
	function Stats(): Promise<IStats>
	function Stats$({ }): Promise<IStats>
	interface IStats {
		init(arg): Promise<any>
		init$({ arg }): Promise<any>
		load_stats(arg): Promise<any>
		load_stats$({ arg }): Promise<any>
		get_top_level_stats(): Promise<any>
		get_top_level_stats$($: {}): Promise<any>
		add(): Promise<any>
		add$($: {}): Promise<any>

		/**
		 * Write the profile data to a file we know how to load back.
		 */
		dump_stats(filename): Promise<any>
		dump_stats$({ filename }): Promise<any>

		/**
		 * Expand all abbreviations that are unique.
		 */
		get_sort_arg_defs(): Promise<any>
		get_sort_arg_defs$($: {}): Promise<any>
		sort_stats(): Promise<any>
		sort_stats$($: {}): Promise<any>
		reverse_order(): Promise<any>
		reverse_order$($: {}): Promise<any>
		strip_dirs(): Promise<any>
		strip_dirs$($: {}): Promise<any>
		calc_callees(): Promise<any>
		calc_callees$($: {}): Promise<any>
		eval_print_amount(sel, list, msg): Promise<any>
		eval_print_amount$({ sel, list, msg }): Promise<any>

		/**
		 * This method returns an instance of StatsProfile, which contains a mapping
		 *         of function names to instances of FunctionProfile. Each FunctionProfile
		 *         instance holds information related to the function's profile such as how
		 *         long the function took to run, how many times it was called, etc...
		 *         
		 */
		get_stats_profile(): Promise<any>
		get_stats_profile$($: {}): Promise<any>
		get_print_list(sel_list): Promise<any>
		get_print_list$({ sel_list }): Promise<any>
		print_stats(): Promise<any>
		print_stats$($: {}): Promise<any>
		print_callees(): Promise<any>
		print_callees$($: {}): Promise<any>
		print_callers(): Promise<any>
		print_callers$($: {}): Promise<any>
		print_call_heading(name_size, column_title): Promise<any>
		print_call_heading$({ name_size, column_title }): Promise<any>
		print_call_line(name_size, source, call_dict, arrow?): Promise<any>
		print_call_line$({ name_size, source, call_dict, arrow }: { name_size, source, call_dict, arrow?}): Promise<any>
		print_title(): Promise<any>
		print_title$($: {}): Promise<any>
		print_line(func): Promise<any>
		print_line$({ func }): Promise<any>
		sort_arg_dict_default
	}

	/**
	 * This class provides a generic function for comparing any two tuples.
	 *     Each instance records a list of tuple-indices (from most significant
	 *     to least significant), and sort direction (ascending or descending) for
	 *     each tuple-index.  The compare functions can then be used as the function
	 *     argument to the system sort() function when a list of tuples need to be
	 *     sorted in the instances order.
	 */
	function TupleComp(comp_select_list): Promise<ITupleComp>
	function TupleComp$({ comp_select_list }): Promise<ITupleComp>
	interface ITupleComp {
		compare(left, right): Promise<any>
		compare$({ left, right }): Promise<any>
	}
	function ProfileBrowser(profile?): Promise<IProfileBrowser>
	function ProfileBrowser$({ profile }: { profile?}): Promise<IProfileBrowser>
	interface IProfileBrowser {
		generic(fn, line): Promise<any>
		generic$({ fn, line }): Promise<any>
		generic_help(): Promise<any>
		generic_help$($: {}): Promise<any>
		do_add(line): Promise<any>
		do_add$({ line }): Promise<any>
		help_add(): Promise<any>
		help_add$($: {}): Promise<any>
		do_callees(line): Promise<any>
		do_callees$({ line }): Promise<any>
		help_callees(): Promise<any>
		help_callees$($: {}): Promise<any>
		do_callers(line): Promise<any>
		do_callers$({ line }): Promise<any>
		help_callers(): Promise<any>
		help_callers$($: {}): Promise<any>
		do_EOF(line): Promise<any>
		do_EOF$({ line }): Promise<any>
		help_EOF(): Promise<any>
		help_EOF$($: {}): Promise<any>
		do_quit(line): Promise<any>
		do_quit$({ line }): Promise<any>
		help_quit(): Promise<any>
		help_quit$($: {}): Promise<any>
		do_read(line): Promise<any>
		do_read$({ line }): Promise<any>
		help_read(): Promise<any>
		help_read$($: {}): Promise<any>
		do_reverse(line): Promise<any>
		do_reverse$({ line }): Promise<any>
		help_reverse(): Promise<any>
		help_reverse$($: {}): Promise<any>
		do_sort(line): Promise<any>
		do_sort$({ line }): Promise<any>
		help_sort(): Promise<any>
		help_sort$($: {}): Promise<any>
		complete_sort(text): Promise<any>
		complete_sort$({ text }): Promise<any>
		do_stats(line): Promise<any>
		do_stats$({ line }): Promise<any>
		help_stats(): Promise<any>
		help_stats$($: {}): Promise<any>
		do_strip(line): Promise<any>
		do_strip$({ line }): Promise<any>
		help_strip(): Promise<any>
		help_strip$($: {}): Promise<any>
		help_help(): Promise<any>
		help_help$($: {}): Promise<any>
		postcmd(stop, line): Promise<any>
		postcmd$({ stop, line }): Promise<any>
	}
	let initprofile: Promise<any>
	let browser: Promise<any>
}
declare module pty {
	var _

	/**
	 * openpty() -> (master_fd, slave_fd)
	 *     Open a pty master/slave pair, using os.openpty() if possible.
	 */
	function openpty(): Promise<any>
	function openpty$($: {}): Promise<any>

	/**
	 * master_open() -> (master_fd, slave_name)
	 *     Open a pty master and return the fd, and the filename of the slave end.
	 *     Deprecated, use openpty() instead.
	 */
	function master_open(): Promise<any>
	function master_open$($: {}): Promise<any>

	/**
	 * slave_open(tty_name) -> slave_fd
	 *     Open the pty slave and acquire the controlling terminal, returning
	 *     opened filedescriptor.
	 *     Deprecated, use openpty() instead.
	 */
	function slave_open(tty_name): Promise<any>
	function slave_open$({ tty_name }): Promise<any>

	/**
	 * fork() -> (pid, master_fd)
	 *     Fork and make the child a session leader with a controlling terminal.
	 */
	function fork(): Promise<any>
	function fork$($: {}): Promise<any>

	/**
	 * Create a spawned process.
	 */
	function spawn(argv, master_read?, stdin_read?): Promise<any>
	function spawn$({ argv, master_read, stdin_read }: { argv, master_read?, stdin_read?}): Promise<any>
	let STDIN_FILENO: Promise<any>
	let STDOUT_FILENO: Promise<any>
	let STDERR_FILENO: Promise<any>
	let CHILD: Promise<any>
}
declare module py_compile {
	var _

	/**
	 * Byte-compile one Python source file to Python bytecode.
	 * 
	 *     :param file: The source file name.
	 *     :param cfile: The target byte compiled file name.  When not given, this
	 *         defaults to the PEP 3147/PEP 488 location.
	 *     :param dfile: Purported file name, i.e. the file name that shows up in
	 *         error messages.  Defaults to the source file name.
	 *     :param doraise: Flag indicating whether or not an exception should be
	 *         raised when a compile error is found.  If an exception occurs and this
	 *         flag is set to False, a string indicating the nature of the exception
	 *         will be printed, and the function will return to the caller. If an
	 *         exception occurs and this flag is set to True, a PyCompileError
	 *         exception will be raised.
	 *     :param optimize: The optimization level for the compiler.  Valid values
	 *         are -1, 0, 1 and 2.  A value of -1 means to use the optimization
	 *         level of the current interpreter, as given by -O command line options.
	 *     :param invalidation_mode:
	 *     :param quiet: Return full output with False or 0, errors only with 1,
	 *         and no output with 2.
	 * 
	 *     :return: Path to the resulting byte compiled file.
	 * 
	 *     Note that it isn't necessary to byte-compile Python modules for
	 *     execution efficiency -- Python itself byte-compiles a module when
	 *     it is loaded, and if it can, writes out the bytecode to the
	 *     corresponding .pyc file.
	 * 
	 *     However, if a Python installation is shared between users, it is a
	 *     good idea to byte-compile all modules upon installation, since
	 *     other users may not be able to write in the source directories,
	 *     and thus they won't be able to write the .pyc file, and then
	 *     they would be byte-compiling every module each time it is loaded.
	 *     This can slow down program start-up considerably.
	 * 
	 *     See compileall.py for a script/module that uses this module to
	 *     byte-compile all installed files (or all files in selected
	 *     directories).
	 * 
	 *     Do note that FileExistsError is raised if cfile ends up pointing at a
	 *     non-regular file or symlink. Because the compilation uses a file renaming,
	 *     the resulting file would be regular and thus not the same type of file as
	 *     it was previously.
	 *     
	 */
	function compile(file, cfile?, dfile?, doraise?: boolean, optimize?, invalidation_mode?, quiet?): Promise<any>
	function compile$({ file, cfile, dfile, doraise, optimize, invalidation_mode, quiet }: { file, cfile?, dfile?, doraise?, optimize?, invalidation_mode?, quiet?}): Promise<any>
	function main(): Promise<any>
	function main$($: {}): Promise<any>

	/**
	 * Exception raised when an error occurs while attempting to
	 *     compile the file.
	 * 
	 *     To raise this exception, use
	 * 
	 *         raise PyCompileError(exc_type,exc_value,file[,msg])
	 * 
	 *     where
	 * 
	 *         exc_type:   exception type to be used in error message
	 *                     type name can be accesses as class variable
	 *                     'exc_type_name'
	 * 
	 *         exc_value:  exception value to be used in error message
	 *                     can be accesses as class variable 'exc_value'
	 * 
	 *         file:       name of file being compiled to be used in error message
	 *                     can be accesses as class variable 'file'
	 * 
	 *         msg:        string message to be written as error message
	 *                     If no value is given, a default exception message will be
	 *                     given, consistent with 'standard' py_compile output.
	 *                     message (or default) can be accesses as class variable
	 *                     'msg'
	 * 
	 *     
	 */
	function PyCompileError(exc_type, exc_value, file, msg?): Promise<IPyCompileError>
	function PyCompileError$({ exc_type, exc_value, file, msg }: { exc_type, exc_value, file, msg?}): Promise<IPyCompileError>
	interface IPyCompileError {
	}
	interface IPycInvalidationMode {
		TIMESTAMP
		CHECKED_HASH
		UNCHECKED_HASH
	}
}
declare module pyclbr {
	var _

	/**
	 * Return Class objects for the top-level classes in module.
	 * 
	 *     This is the original interface, before Functions were added.
	 *     
	 */
	function readmodule(module, path?): Promise<any>
	function readmodule$({ module, path }: { module, path?}): Promise<any>

	/**
	 * Return a dictionary with all functions and classes in module.
	 * 
	 *     Search for module in PATH + sys.path.
	 *     If possible, include imported superclasses.
	 *     Do this by reading source, without importing (and executing) it.
	 *     
	 */
	function readmodule_ex(module, path?): Promise<any>
	function readmodule_ex$({ module, path }: { module, path?}): Promise<any>

	/**
	 * Information about Python class or function.
	 */
	interface I_Object {
	}

	/**
	 * Information about a Python function, including methods.
	 */
	function Function$({ module, name, file, lineno, parent, is_async }: { module, name, file, lineno, parent?, is_async?}): Promise<IFunction>
	interface IFunction extends I_Object {
	}

	/**
	 * Information about a Python class.
	 */
	function Class(module, name, super_, file, lineno, parent?): Promise<IClass>
	function Class$({ module, name, super_, file, lineno, parent }: { module, name, super_, file, lineno, parent?}): Promise<IClass>
	interface IClass extends I_Object {
	}
	interface I_ModuleBrowser {
		visit_ClassDef(node): Promise<any>
		visit_ClassDef$({ node }): Promise<any>
		visit_FunctionDef(node): Promise<any>
		visit_FunctionDef$({ node }): Promise<any>
		visit_AsyncFunctionDef(node): Promise<any>
		visit_AsyncFunctionDef$({ node }): Promise<any>
		visit_Import(node): Promise<any>
		visit_Import$({ node }): Promise<any>
		visit_ImportFrom(node): Promise<any>
		visit_ImportFrom$({ node }): Promise<any>
	}
}
declare module pydoc {
	var _

	/**
	 * Convert sys.path into a list of absolute, existing, unique paths.
	 */
	function pathdirs(): Promise<any>
	function pathdirs$($: {}): Promise<any>

	/**
	 * Get the doc string or comments for an object.
	 */
	function getdoc(object): Promise<any>
	function getdoc$({ object }): Promise<any>

	/**
	 * Split a doc string into a synopsis line (if any) and the rest.
	 */
	function splitdoc(doc): Promise<any>
	function splitdoc$({ doc }): Promise<any>

	/**
	 * Get a class name and qualify it with a module name if necessary.
	 */
	function classname(object, modname): Promise<any>
	function classname$({ object, modname }): Promise<any>

	/**
	 * Check if an object is of a type that probably means it's data.
	 */
	function isdata(object): Promise<any>
	function isdata$({ object }): Promise<any>

	/**
	 * Do a series of global replacements on a string.
	 */
	function replace(text): Promise<any>
	function replace$({ text }): Promise<any>

	/**
	 * Omit part of a string if needed to make it fit in a maximum length.
	 */
	function cram(text, maxlen): Promise<any>
	function cram$({ text, maxlen }): Promise<any>

	/**
	 * Remove the hexadecimal id from a Python object representation.
	 */
	function stripid(text): Promise<any>
	function stripid$({ text }): Promise<any>
	function allmethods(cl): Promise<any>
	function allmethods$({ cl }): Promise<any>

	/**
	 * Decide whether to show documentation on a variable.
	 */
	function visiblename(name, all?, obj?): Promise<any>
	function visiblename$({ name, all, obj }: { name, all?, obj?}): Promise<any>

	/**
	 * Wrap inspect.classify_class_attrs, with fixup for data descriptors.
	 */
	function classify_class_attrs(object): Promise<any>
	function classify_class_attrs$({ object }): Promise<any>

	/**
	 * Sort the attrs list in-place by _fields and then alphabetically by name
	 */
	function sort_attributes(attrs, object): Promise<any>
	function sort_attributes$({ attrs, object }): Promise<any>

	/**
	 * Guess whether a path refers to a package directory.
	 */
	function ispackage(path): Promise<any>
	function ispackage$({ path }): Promise<any>
	function source_synopsis(file): Promise<any>
	function source_synopsis$({ file }): Promise<any>

	/**
	 * Get the one-line summary out of a module file.
	 */
	function synopsis(filename, cache?): Promise<any>
	function synopsis$({ filename, cache }: { filename, cache?}): Promise<any>

	/**
	 * Import a Python source file or compiled file given its path.
	 */
	function importfile(path): Promise<any>
	function importfile$({ path }): Promise<any>

	/**
	 * Import a module; handle errors; return None if the module isn't found.
	 * 
	 *     If the module *is* found but an exception occurs, it's wrapped in an
	 *     ErrorDuringImport exception and reraised.  Unlike __import__, if a
	 *     package path is specified, the module at the end of the path is returned,
	 *     not the package at the beginning.  If the optional 'forceload' argument
	 *     is 1, we reload the module from disk (unless it's a dynamic extension).
	 */
	function safeimport(path, forceload?, cache?): Promise<any>
	function safeimport$({ path, forceload, cache }: { path, forceload?, cache?}): Promise<any>

	/**
	 * The first time this is called, determine what kind of pager to use.
	 */
	function pager(text): Promise<any>
	function pager$({ text }): Promise<any>

	/**
	 * Decide what method to use for paging through text.
	 */
	function getpager(): Promise<any>
	function getpager$($: {}): Promise<any>

	/**
	 * Remove boldface formatting from text.
	 */
	function plain(text): Promise<any>
	function plain$({ text }): Promise<any>

	/**
	 * Page through text by feeding it to another program.
	 */
	function pipepager(text, cmd): Promise<any>
	function pipepager$({ text, cmd }): Promise<any>

	/**
	 * Page through text by invoking a program on a temporary file.
	 */
	function tempfilepager(text, cmd): Promise<any>
	function tempfilepager$({ text, cmd }): Promise<any>

	/**
	 * Page through text on a text terminal.
	 */
	function ttypager(text): Promise<any>
	function ttypager$({ text }): Promise<any>

	/**
	 * Simply print unformatted text.  This is the ultimate fallback.
	 */
	function plainpager(text): Promise<any>
	function plainpager$({ text }): Promise<any>

	/**
	 * Produce a short description of the given thing.
	 */
	function describe(thing): Promise<any>
	function describe$({ thing }): Promise<any>

	/**
	 * Locate an object by name or dotted path, importing as necessary.
	 */
	function locate(path, forceload?): Promise<any>
	function locate$({ path, forceload }: { path, forceload?}): Promise<any>

	/**
	 * Given an object or a path to an object, get the object and its name.
	 */
	function resolve(thing, forceload?): Promise<any>
	function resolve$({ thing, forceload }: { thing, forceload?}): Promise<any>

	/**
	 * Render text documentation, given an object or a path to an object.
	 */
	function render_doc(thing, title?, forceload?, renderer?): Promise<any>
	function render_doc$({ thing, title, forceload, renderer }: { thing, title?, forceload?, renderer?}): Promise<any>

	/**
	 * Display text documentation, given an object or a path to an object.
	 */
	function doc(thing, title?, forceload?, output?): Promise<any>
	function doc$({ thing, title, forceload, output }: { thing, title?, forceload?, output?}): Promise<any>

	/**
	 * Write HTML documentation to a file in the current directory.
	 */
	function writedoc(thing, forceload?): Promise<any>
	function writedoc$({ thing, forceload }: { thing, forceload?}): Promise<any>

	/**
	 * Write out HTML documentation for all modules in a directory tree.
	 */
	function writedocs(dir, pkgpath?, done?): Promise<any>
	function writedocs$({ dir, pkgpath, done }: { dir, pkgpath?, done?}): Promise<any>

	/**
	 * Print all the one-line module summaries that contain a substring.
	 */
	function apropos(key): Promise<any>
	function apropos$({ key }): Promise<any>

	/**
	 * Start the enhanced pydoc Web server and open a Web browser.
	 * 
	 *     Use port '0' to start the server on an arbitrary port.
	 *     Set open_browser to False to suppress opening a browser.
	 *     
	 */
	function browse(port?): Promise<any>
	function browse$({ port }: { port?}): Promise<any>
	function ispath(x): Promise<any>
	function ispath$({ x }): Promise<any>

	/**
	 * Command-line interface (looks at sys.argv to decide what to do).
	 */
	function cli(): Promise<any>
	function cli$($: {}): Promise<any>

	/**
	 * Errors that occurred while trying to import something to document it.
	 */
	function ErrorDuringImport(filename, exc_info): Promise<IErrorDuringImport>
	function ErrorDuringImport$({ filename, exc_info }): Promise<IErrorDuringImport>
	interface IErrorDuringImport {
	}
	interface IDoc {

		/**
		 * Generate documentation for an object.
		 */
		document(object, name?): Promise<any>
		document$({ object, name }: { object, name?}): Promise<any>

		/**
		 * Raise an exception for unimplemented types.
		 */
		fail(object, name?): Promise<any>
		fail$({ object, name }: { object, name?}): Promise<any>

		/**
		 * Return the location of module docs or None
		 */
		getdocloc(object, basedir?): Promise<any>
		getdocloc$({ object, basedir }: { object, basedir?}): Promise<any>
		PYTHONDOCS
		docmodule
		docclass
		docroutine
		docother
		docproperty
		docdata
	}

	/**
	 * Class for safely making an HTML representation of a Python object.
	 */
	function HTMLRepr(): Promise<IHTMLRepr>
	function HTMLRepr$({ }): Promise<IHTMLRepr>
	interface IHTMLRepr {
		escape(text): Promise<any>
		escape$({ text }): Promise<any>
		repr(object): Promise<any>
		repr$({ object }): Promise<any>
		repr1(x, level): Promise<any>
		repr1$({ x, level }): Promise<any>
		repr_string(x, level): Promise<any>
		repr_string$({ x, level }): Promise<any>
		repr_instance(x, level): Promise<any>
		repr_instance$({ x, level }): Promise<any>
		repr_str
		repr_unicode
	}

	/**
	 * Formatter class for HTML documentation.
	 */
	interface IHTMLDoc extends IDoc {

		/**
		 * Format an HTML page.
		 */
		page(title, contents): Promise<any>
		page$({ title, contents }): Promise<any>

		/**
		 * Format a page heading.
		 */
		heading(title, fgcol, bgcol, extras?): Promise<any>
		heading$({ title, fgcol, bgcol, extras }: { title, fgcol, bgcol, extras?}): Promise<any>

		/**
		 * Format a section with a heading.
		 */
		section(title, fgcol, bgcol, contents, width?, prelude?, marginalia?, gap?): Promise<any>
		section$({ title, fgcol, bgcol, contents, width, prelude, marginalia, gap }: { title, fgcol, bgcol, contents, width?, prelude?, marginalia?, gap?}): Promise<any>

		/**
		 * Format a section with a big heading.
		 */
		bigsection(title): Promise<any>
		bigsection$({ title }): Promise<any>

		/**
		 * Format literal preformatted text.
		 */
		preformat(text): Promise<any>
		preformat$({ text }): Promise<any>

		/**
		 * Format a list of items into a multi-column list.
		 */
		multicolumn(list, format, cols?): Promise<any>
		multicolumn$({ list, format, cols }: { list, format, cols?}): Promise<any>
		grey(text): Promise<any>
		grey$({ text }): Promise<any>

		/**
		 * Make a link for an identifier, given name-to-URL mappings.
		 */
		namelink(name): Promise<any>
		namelink$({ name }): Promise<any>

		/**
		 * Make a link for a class.
		 */
		classlink(object, modname): Promise<any>
		classlink$({ object, modname }): Promise<any>

		/**
		 * Make a link for a module.
		 */
		modulelink(object): Promise<any>
		modulelink$({ object }): Promise<any>

		/**
		 * Make a link for a module or package to display in an index.
		 */
		modpkglink(modpkginfo): Promise<any>
		modpkglink$({ modpkginfo }): Promise<any>

		/**
		 * Make a link to source file.
		 */
		filelink(url, path): Promise<any>
		filelink$({ url, path }): Promise<any>

		/**
		 * Mark up some plain text, given a context of symbols to look for.
		 *         Each context dictionary maps object names to anchor names.
		 */
		markup(text, escape?, funcs?, classes?, methods?): Promise<any>
		markup$({ text, escape, funcs, classes, methods }: { text, escape?, funcs?, classes?, methods?}): Promise<any>

		/**
		 * Produce HTML for a class tree as given by inspect.getclasstree().
		 */
		formattree(tree, modname, parent?): Promise<any>
		formattree$({ tree, modname, parent }: { tree, modname, parent?}): Promise<any>

		/**
		 * Produce HTML documentation for a module object.
		 */
		docmodule(object, name?, mod?): Promise<any>
		docmodule$({ object, name, mod }: { object, name?, mod?}): Promise<any>

		/**
		 * Produce HTML documentation for a class object.
		 */
		docclass(object, name?, mod?, funcs?, classes?): Promise<any>
		docclass$({ object, name, mod, funcs, classes }: { object, name?, mod?, funcs?, classes?}): Promise<any>

		/**
		 * Format an argument default value as text.
		 */
		formatvalue(object): Promise<any>
		formatvalue$({ object }): Promise<any>

		/**
		 * Produce HTML documentation for a function or method object.
		 */
		docroutine(object, name?, mod?, funcs?, classes?, methods?, cl?): Promise<any>
		docroutine$({ object, name, mod, funcs, classes, methods, cl }: { object, name?, mod?, funcs?, classes?, methods?, cl?}): Promise<any>

		/**
		 * Produce html documentation for a data descriptor.
		 */
		docdata(object, name?, mod?, cl?): Promise<any>
		docdata$({ object, name, mod, cl }: { object, name?, mod?, cl?}): Promise<any>

		/**
		 * Produce HTML documentation for a data object.
		 */
		docother(object, name?, mod?): Promise<any>
		docother$({ object, name, mod }: { object, name?, mod?}): Promise<any>

		/**
		 * Generate an HTML index for a directory of modules.
		 */
		index(dir, shadowed?): Promise<any>
		index$({ dir, shadowed }: { dir, shadowed?}): Promise<any>
	}

	/**
	 * Class for safely making a text representation of a Python object.
	 */
	function TextRepr(): Promise<ITextRepr>
	function TextRepr$({ }): Promise<ITextRepr>
	interface ITextRepr {
		repr1(x, level): Promise<any>
		repr1$({ x, level }): Promise<any>
		repr_string(x, level): Promise<any>
		repr_string$({ x, level }): Promise<any>
		repr_instance(x, level): Promise<any>
		repr_instance$({ x, level }): Promise<any>
	}

	/**
	 * Formatter class for text documentation.
	 */
	interface ITextDoc extends IDoc {

		/**
		 * Format a string in bold by overstriking.
		 */
		bold(text): Promise<any>
		bold$({ text }): Promise<any>

		/**
		 * Indent text by prepending a given prefix to each line.
		 */
		indent(text, prefix?): Promise<any>
		indent$({ text, prefix }: { text, prefix?}): Promise<any>

		/**
		 * Format a section with a given heading.
		 */
		section(title, contents): Promise<any>
		section$({ title, contents }): Promise<any>

		/**
		 * Render in text a class tree as returned by inspect.getclasstree().
		 */
		formattree(tree, modname, parent?, prefix?): Promise<any>
		formattree$({ tree, modname, parent, prefix }: { tree, modname, parent?, prefix?}): Promise<any>

		/**
		 * Produce text documentation for a given module object.
		 */
		docmodule(object, name?, mod?): Promise<any>
		docmodule$({ object, name, mod }: { object, name?, mod?}): Promise<any>

		/**
		 * Produce text documentation for a given class object.
		 */
		docclass(object, name?, mod?): Promise<any>
		docclass$({ object, name, mod }: { object, name?, mod?}): Promise<any>

		/**
		 * Format an argument default value as text.
		 */
		formatvalue(object): Promise<any>
		formatvalue$({ object }): Promise<any>

		/**
		 * Produce text documentation for a function or method object.
		 */
		docroutine(object, name?, mod?, cl?): Promise<any>
		docroutine$({ object, name, mod, cl }: { object, name?, mod?, cl?}): Promise<any>

		/**
		 * Produce text documentation for a data descriptor.
		 */
		docdata(object, name?, mod?, cl?): Promise<any>
		docdata$({ object, name, mod, cl }: { object, name?, mod?, cl?}): Promise<any>

		/**
		 * Produce text documentation for a data object.
		 */
		docother(object, name?, mod?, parent?, maxlen?, doc?): Promise<any>
		docother$({ object, name, mod, parent, maxlen, doc }: { object, name?, mod?, parent?, maxlen?, doc?}): Promise<any>
	}

	/**
	 * Subclass of TextDoc which overrides string styling
	 */
	interface I_PlainTextDoc extends ITextDoc {
		bold(text): Promise<any>
		bold$({ text }): Promise<any>
	}
	function Helper(input?, output?): Promise<IHelper>
	function Helper$({ input, output }: { input?, output?}): Promise<IHelper>
	interface IHelper {
		input(): Promise<any>
		input$($: {}): Promise<any>
		output(): Promise<any>
		output$($: {}): Promise<any>
		interact(): Promise<any>
		interact$($: {}): Promise<any>

		/**
		 * Read one line, using input() when appropriate.
		 */
		getline(prompt): Promise<any>
		getline$({ prompt }): Promise<any>
		help(request): Promise<any>
		help$({ request }): Promise<any>
		intro(): Promise<any>
		intro$($: {}): Promise<any>
		list(items, columns?, width?): Promise<any>
		list$({ items, columns, width }: { items, columns?, width?}): Promise<any>
		listkeywords(): Promise<any>
		listkeywords$($: {}): Promise<any>
		listsymbols(): Promise<any>
		listsymbols$($: {}): Promise<any>
		listtopics(): Promise<any>
		listtopics$($: {}): Promise<any>
		showtopic(topic, more_xrefs?): Promise<any>
		showtopic$({ topic, more_xrefs }: { topic, more_xrefs?}): Promise<any>
		showsymbol(symbol): Promise<any>
		showsymbol$({ symbol }): Promise<any>
		listmodules(key?): Promise<any>
		listmodules$({ key }: { key?}): Promise<any>
		keywords
		symbols
		topics
	}

	/**
	 * An interruptible scanner that searches module synopses.
	 */
	interface IModuleScanner {
		run(callback, key?, completer?, onerror?): Promise<any>
		run$({ callback, key, completer, onerror }: { callback, key?, completer?, onerror?}): Promise<any>
	}
	let text: Promise<any>
	let plaintext: Promise<any>
	let html: Promise<any>
}
declare module pydoc_data {
	var _
	module topics {
		var _
		let topics: Promise<any>
	}
}
declare module queue {
	var _

	/**
	 * Exception raised by Queue.put(block=0)/put_nowait().
	 */
	interface IFull {
	}

	/**
	 * Create a queue object with a given maximum size.
	 * 
	 *     If maxsize is <= 0, the queue size is infinite.
	 *     
	 */
	function Queue(maxsize?): Promise<IQueue>
	function Queue$({ maxsize }: { maxsize?}): Promise<IQueue>
	interface IQueue {

		/**
		 * Indicate that a formerly enqueued task is complete.
		 * 
		 *         Used by Queue consumer threads.  For each get() used to fetch a task,
		 *         a subsequent call to task_done() tells the queue that the processing
		 *         on the task is complete.
		 * 
		 *         If a join() is currently blocking, it will resume when all items
		 *         have been processed (meaning that a task_done() call was received
		 *         for every item that had been put() into the queue).
		 * 
		 *         Raises a ValueError if called more times than there were items
		 *         placed in the queue.
		 *         
		 */
		task_done(): Promise<any>
		task_done$($: {}): Promise<any>

		/**
		 * Blocks until all items in the Queue have been gotten and processed.
		 * 
		 *         The count of unfinished tasks goes up whenever an item is added to the
		 *         queue. The count goes down whenever a consumer thread calls task_done()
		 *         to indicate the item was retrieved and all work on it is complete.
		 * 
		 *         When the count of unfinished tasks drops to zero, join() unblocks.
		 *         
		 */
		join(): Promise<any>
		join$($: {}): Promise<any>

		/**
		 * Return the approximate size of the queue (not reliable!).
		 */
		qsize(): Promise<any>
		qsize$($: {}): Promise<any>

		/**
		 * Return True if the queue is empty, False otherwise (not reliable!).
		 * 
		 *         This method is likely to be removed at some point.  Use qsize() == 0
		 *         as a direct substitute, but be aware that either approach risks a race
		 *         condition where a queue can grow before the result of empty() or
		 *         qsize() can be used.
		 * 
		 *         To create code that needs to wait for all queued tasks to be
		 *         completed, the preferred technique is to use the join() method.
		 *         
		 */
		empty(): Promise<any>
		empty$($: {}): Promise<any>

		/**
		 * Return True if the queue is full, False otherwise (not reliable!).
		 * 
		 *         This method is likely to be removed at some point.  Use qsize() >= n
		 *         as a direct substitute, but be aware that either approach risks a race
		 *         condition where a queue can shrink before the result of full() or
		 *         qsize() can be used.
		 *         
		 */
		full(): Promise<any>
		full$($: {}): Promise<any>

		/**
		 * Put an item into the queue.
		 * 
		 *         If optional args 'block' is true and 'timeout' is None (the default),
		 *         block if necessary until a free slot is available. If 'timeout' is
		 *         a non-negative number, it blocks at most 'timeout' seconds and raises
		 *         the Full exception if no free slot was available within that time.
		 *         Otherwise ('block' is false), put an item on the queue if a free slot
		 *         is immediately available, else raise the Full exception ('timeout'
		 *         is ignored in that case).
		 *         
		 */
		put(item, block?: boolean, timeout?): Promise<any>
		put$({ item, block, timeout }: { item, block?, timeout?}): Promise<any>

		/**
		 * Remove and return an item from the queue.
		 * 
		 *         If optional args 'block' is true and 'timeout' is None (the default),
		 *         block if necessary until an item is available. If 'timeout' is
		 *         a non-negative number, it blocks at most 'timeout' seconds and raises
		 *         the Empty exception if no item was available within that time.
		 *         Otherwise ('block' is false), return an item if one is immediately
		 *         available, else raise the Empty exception ('timeout' is ignored
		 *         in that case).
		 *         
		 */
		get(block?: boolean, timeout?): Promise<any>
		get$({ block, timeout }: { block?, timeout?}): Promise<any>

		/**
		 * Put an item into the queue without blocking.
		 * 
		 *         Only enqueue the item if a free slot is immediately available.
		 *         Otherwise raise the Full exception.
		 *         
		 */
		put_nowait(item): Promise<any>
		put_nowait$({ item }): Promise<any>

		/**
		 * Remove and return an item from the queue without blocking.
		 * 
		 *         Only get an item if one is immediately available. Otherwise
		 *         raise the Empty exception.
		 *         
		 */
		get_nowait(): Promise<any>
		get_nowait$($: {}): Promise<any>
	}

	/**
	 * Variant of Queue that retrieves open entries in priority order (lowest first).
	 * 
	 *     Entries are typically tuples of the form:  (priority number, data).
	 *     
	 */
	interface IPriorityQueue extends IQueue {
	}

	/**
	 * Variant of Queue that retrieves most recently added entries first.
	 */
	interface ILifoQueue extends IQueue {
	}

	/**
	 * Simple, unbounded FIFO queue.
	 * 
	 *     This pure Python implementation is not reentrant.
	 *     
	 */
	interface I_PySimpleQueue {

		/**
		 * Put the item on the queue.
		 * 
		 *         The optional 'block' and 'timeout' arguments are ignored, as this method
		 *         never blocks.  They are provided for compatibility with the Queue class.
		 *         
		 */
		put(item, block?: boolean, timeout?): Promise<any>
		put$({ item, block, timeout }: { item, block?, timeout?}): Promise<any>

		/**
		 * Remove and return an item from the queue.
		 * 
		 *         If optional args 'block' is true and 'timeout' is None (the default),
		 *         block if necessary until an item is available. If 'timeout' is
		 *         a non-negative number, it blocks at most 'timeout' seconds and raises
		 *         the Empty exception if no item was available within that time.
		 *         Otherwise ('block' is false), return an item if one is immediately
		 *         available, else raise the Empty exception ('timeout' is ignored
		 *         in that case).
		 *         
		 */
		get(block?: boolean, timeout?): Promise<any>
		get$({ block, timeout }: { block?, timeout?}): Promise<any>

		/**
		 * Put an item into the queue without blocking.
		 * 
		 *         This is exactly equivalent to `put(item)` and is only provided
		 *         for compatibility with the Queue class.
		 *         
		 */
		put_nowait(item): Promise<any>
		put_nowait$({ item }): Promise<any>

		/**
		 * Remove and return an item from the queue without blocking.
		 * 
		 *         Only get an item if one is immediately available. Otherwise
		 *         raise the Empty exception.
		 *         
		 */
		get_nowait(): Promise<any>
		get_nowait$($: {}): Promise<any>

		/**
		 * Return True if the queue is empty, False otherwise (not reliable!).
		 */
		empty(): Promise<any>
		empty$($: {}): Promise<any>

		/**
		 * Return the approximate size of the queue (not reliable!).
		 */
		qsize(): Promise<any>
		qsize$($: {}): Promise<any>
	}
	let SimpleQueue: Promise<any>
}
declare module quopri {
	var _

	/**
	 * Decide whether a particular byte ordinal needs to be quoted.
	 * 
	 *     The 'quotetabs' flag indicates whether embedded tabs and spaces should be
	 *     quoted.  Note that line-ending tabs and spaces are always encoded, as per
	 *     RFC 1521.
	 *     
	 */
	function needsquoting(c, quotetabs, header): Promise<any>
	function needsquoting$({ c, quotetabs, header }): Promise<any>

	/**
	 * Quote a single character.
	 */
	function quote(c): Promise<any>
	function quote$({ c }): Promise<any>

	/**
	 * Read 'input', apply quoted-printable encoding, and write to 'output'.
	 * 
	 *     'input' and 'output' are binary file objects. The 'quotetabs' flag
	 *     indicates whether embedded tabs and spaces should be quoted. Note that
	 *     line-ending tabs and spaces are always encoded, as per RFC 1521.
	 *     The 'header' flag indicates whether we are encoding spaces as _ as per RFC
	 *     1522.
	 */
	function encode(input, output, quotetabs, header?: boolean): Promise<any>
	function encode$({ input, output, quotetabs, header }: { input, output, quotetabs, header?}): Promise<any>
	function encodestring(s, quotetabs?: boolean, header?: boolean): Promise<any>
	function encodestring$({ s, quotetabs, header }: { s, quotetabs?, header?}): Promise<any>

	/**
	 * Read 'input', apply quoted-printable decoding, and write to 'output'.
	 *     'input' and 'output' are binary file objects.
	 *     If 'header' is true, decode underscore as space (per RFC 1522).
	 */
	function decode(input, output, header?: boolean): Promise<any>
	function decode$({ input, output, header }: { input, output, header?}): Promise<any>
	function decodestring(s, header?: boolean): Promise<any>
	function decodestring$({ s, header }: { s, header?}): Promise<any>

	/**
	 * Return true if the byte ordinal 'c' is a hexadecimal digit in ASCII.
	 */
	function ishex(c): Promise<any>
	function ishex$({ c }): Promise<any>

	/**
	 * Get the integer value of a hexadecimal number.
	 */
	function unhex(s): Promise<any>
	function unhex$({ s }): Promise<any>
	function main(): Promise<any>
	function main$($: {}): Promise<any>
	let ESCAPE: Promise<any>
	let MAXLINESIZE: Promise<any>
	let HEX: Promise<any>
	let EMPTYSTRING: Promise<any>
}
declare module random {
	var _

	/**
	 * Random number generator base class used by bound module functions.
	 * 
	 *     Used to instantiate instances of Random to get generators that don't
	 *     share state.
	 * 
	 *     Class Random can also be subclassed if you want to use a different basic
	 *     generator of your own devising: in that case, override the following
	 *     methods:  random(), seed(), getstate(), and setstate().
	 *     Optionally, implement a getrandbits() method so that randrange()
	 *     can cover arbitrarily large ranges.
	 * 
	 *     
	 */

	/**
	 * Initialize an instance.
	 * 
	 *         Optional argument x controls seeding, as for Random.seed().
	 *         
	 */
	function Random(x?): Promise<IRandom>
	function Random$({ x }: { x?}): Promise<IRandom>
	interface IRandom {

		/**
		 * Initialize internal state from a seed.
		 * 
		 *         The only supported seed types are None, int, float,
		 *         str, bytes, and bytearray.
		 * 
		 *         None or no argument seeds from current time or from an operating
		 *         system specific randomness source if available.
		 * 
		 *         If *a* is an int, all bits are used.
		 * 
		 *         For version 2 (the default), all of the bits are used if *a* is a str,
		 *         bytes, or bytearray.  For version 1 (provided for reproducing random
		 *         sequences from older versions of Python), the algorithm for str and
		 *         bytes generates a narrower range of seeds.
		 * 
		 *         
		 */
		seed(a?, version?): Promise<any>
		seed$({ a, version }: { a?, version?}): Promise<any>

		/**
		 * Return internal state; can be passed to setstate() later.
		 */
		getstate(): Promise<any>
		getstate$($: {}): Promise<any>

		/**
		 * Restore internal state from object returned by getstate().
		 */
		setstate(state): Promise<any>
		setstate$({ state }): Promise<any>

		/**
		 * Generate n random bytes.
		 */
		randbytes(n): Promise<any>
		randbytes$({ n }): Promise<any>

		/**
		 * Choose a random item from range(start, stop[, step]).
		 * 
		 *         This fixes the problem with randint() which includes the
		 *         endpoint; in Python this is usually not what you want.
		 * 
		 *         
		 */
		randrange(start, stop?, step?): Promise<any>
		randrange$({ start, stop, step }: { start, stop?, step?}): Promise<any>

		/**
		 * Return random integer in range [a, b], including both end points.
		 *         
		 */
		randint(a, b): Promise<any>
		randint$({ a, b }): Promise<any>

		/**
		 * Choose a random element from a non-empty sequence.
		 */
		choice(seq): Promise<any>
		choice$({ seq }): Promise<any>

		/**
		 * Shuffle list x in place, and return None.
		 */
		shuffle(x): Promise<any>
		shuffle$({ x }): Promise<any>

		/**
		 * Chooses k unique random elements from a population sequence.
		 * 
		 *         Returns a new list containing elements from the population while
		 *         leaving the original population unchanged.  The resulting list is
		 *         in selection order so that all sub-slices will also be valid random
		 *         samples.  This allows raffle winners (the sample) to be partitioned
		 *         into grand prize and second place winners (the subslices).
		 * 
		 *         Members of the population need not be hashable or unique.  If the
		 *         population contains repeats, then each occurrence is a possible
		 *         selection in the sample.
		 * 
		 *         Repeated elements can be specified one at a time or with the optional
		 *         counts parameter.  For example:
		 * 
		 *             sample(['red', 'blue'], counts=[4, 2], k=5)
		 * 
		 *         is equivalent to:
		 * 
		 *             sample(['red', 'red', 'red', 'red', 'blue', 'blue'], k=5)
		 * 
		 *         To choose a sample from a range of integers, use range() for the
		 *         population argument.  This is especially fast and space efficient
		 *         for sampling from a large population:
		 * 
		 *             sample(range(10000000), 60)
		 * 
		 *         
		 */
		sample(population, k): Promise<any>
		sample$({ population, k }): Promise<any>

		/**
		 * Return a k sized list of population elements chosen with replacement.
		 * 
		 *         If the relative weights or cumulative weights are not specified,
		 *         the selections are made with equal probability.
		 * 
		 *         
		 */
		choices(population, weights?): Promise<any>
		choices$({ population, weights }: { population, weights?}): Promise<any>

		/**
		 * Get a random number in the range [a, b) or [a, b] depending on rounding.
		 */
		uniform(a, b): Promise<any>
		uniform$({ a, b }): Promise<any>

		/**
		 * Triangular distribution.
		 * 
		 *         Continuous distribution bounded by given lower and upper limits,
		 *         and having a given mode value in-between.
		 * 
		 *         http://en.wikipedia.org/wiki/Triangular_distribution
		 * 
		 *         
		 */
		triangular(low?, high?, mode?): Promise<any>
		triangular$({ low, high, mode }: { low?, high?, mode?}): Promise<any>

		/**
		 * Normal distribution.
		 * 
		 *         mu is the mean, and sigma is the standard deviation.
		 * 
		 *         
		 */
		normalvariate(mu, sigma): Promise<any>
		normalvariate$({ mu, sigma }): Promise<any>

		/**
		 * Gaussian distribution.
		 * 
		 *         mu is the mean, and sigma is the standard deviation.  This is
		 *         slightly faster than the normalvariate() function.
		 * 
		 *         Not thread-safe without a lock around calls.
		 * 
		 *         
		 */
		gauss(mu, sigma): Promise<any>
		gauss$({ mu, sigma }): Promise<any>

		/**
		 * Log normal distribution.
		 * 
		 *         If you take the natural logarithm of this distribution, you'll get a
		 *         normal distribution with mean mu and standard deviation sigma.
		 *         mu can have any value, and sigma must be greater than zero.
		 * 
		 *         
		 */
		lognormvariate(mu, sigma): Promise<any>
		lognormvariate$({ mu, sigma }): Promise<any>

		/**
		 * Exponential distribution.
		 * 
		 *         lambd is 1.0 divided by the desired mean.  It should be
		 *         nonzero.  (The parameter would be called "lambda", but that is
		 *         a reserved word in Python.)  Returned values range from 0 to
		 *         positive infinity if lambd is positive, and from negative
		 *         infinity to 0 if lambd is negative.
		 * 
		 *         
		 */
		expovariate(lambd): Promise<any>
		expovariate$({ lambd }): Promise<any>

		/**
		 * Circular data distribution.
		 * 
		 *         mu is the mean angle, expressed in radians between 0 and 2*pi, and
		 *         kappa is the concentration parameter, which must be greater than or
		 *         equal to zero.  If kappa is equal to zero, this distribution reduces
		 *         to a uniform random angle over the range 0 to 2*pi.
		 * 
		 *         
		 */
		vonmisesvariate(mu, kappa): Promise<any>
		vonmisesvariate$({ mu, kappa }): Promise<any>

		/**
		 * Gamma distribution.  Not the gamma function!
		 * 
		 *         Conditions on the parameters are alpha > 0 and beta > 0.
		 * 
		 *         The probability distribution function is:
		 * 
		 *                     x ** (alpha - 1) * math.exp(-x / beta)
		 *           pdf(x) =  --------------------------------------
		 *                       math.gamma(alpha) * beta ** alpha
		 * 
		 *         
		 */
		gammavariate(alpha, beta): Promise<any>
		gammavariate$({ alpha, beta }): Promise<any>

		/**
		 * Beta distribution.
		 * 
		 *         Conditions on the parameters are alpha > 0 and beta > 0.
		 *         Returned values range between 0 and 1.
		 * 
		 *         
		 */
		betavariate(alpha, beta): Promise<any>
		betavariate$({ alpha, beta }): Promise<any>

		/**
		 * Pareto distribution.  alpha is the shape parameter.
		 */
		paretovariate(alpha): Promise<any>
		paretovariate$({ alpha }): Promise<any>

		/**
		 * Weibull distribution.
		 * 
		 *         alpha is the scale parameter and beta is the shape parameter.
		 * 
		 *         
		 */
		weibullvariate(alpha, beta): Promise<any>
		weibullvariate$({ alpha, beta }): Promise<any>
		VERSION
	}

	/**
	 * Alternate random number generator using sources provided
	 *     by the operating system (such as /dev/urandom on Unix or
	 *     CryptGenRandom on Windows).
	 * 
	 *      Not available on all systems (see os.urandom() for details).
	 * 
	 *     
	 */
	interface ISystemRandom extends IRandom {

		/**
		 * Get the next random number in the range [0.0, 1.0).
		 */
		random(): Promise<any>
		random$($: {}): Promise<any>

		/**
		 * getrandbits(k) -> x.  Generates an int with k random bits.
		 */
		getrandbits(k): Promise<any>
		getrandbits$({ k }): Promise<any>

		/**
		 * Generate n random bytes.
		 */
		randbytes(n): Promise<any>
		randbytes$({ n }): Promise<any>

		/**
		 * Stub method.  Not used for a system random number generator.
		 */
		seed(): Promise<any>
		seed$($: {}): Promise<any>
	}
	let NV_MAGICCONST: Promise<any>
	let LOG4: Promise<any>
	let SG_MAGICCONST: Promise<any>
	let BPF: Promise<any>
	let RECIP_BPF: Promise<any>
}
declare module re {
	var _

	/**
	 * Try to apply the pattern at the start of the string, returning
	 *     a Match object, or None if no match was found.
	 */
	function match(pattern, string, flags?): Promise<any>
	function match$({ pattern, string, flags }: { pattern, string, flags?}): Promise<any>

	/**
	 * Try to apply the pattern to all of the string, returning
	 *     a Match object, or None if no match was found.
	 */
	function fullmatch(pattern, string, flags?): Promise<any>
	function fullmatch$({ pattern, string, flags }: { pattern, string, flags?}): Promise<any>

	/**
	 * Scan through string looking for a match to the pattern, returning
	 *     a Match object, or None if no match was found.
	 */
	function search(pattern, string, flags?): Promise<any>
	function search$({ pattern, string, flags }: { pattern, string, flags?}): Promise<any>

	/**
	 * Return the string obtained by replacing the leftmost
	 *     non-overlapping occurrences of the pattern in string by the
	 *     replacement repl.  repl can be either a string or a callable;
	 *     if a string, backslash escapes in it are processed.  If it is
	 *     a callable, it's passed the Match object and must return
	 *     a replacement string to be used.
	 */
	function sub(pattern, repl, string, count?, flags?): Promise<any>
	function sub$({ pattern, repl, string, count, flags }: { pattern, repl, string, count?, flags?}): Promise<any>

	/**
	 * Return a 2-tuple containing (new_string, number).
	 *     new_string is the string obtained by replacing the leftmost
	 *     non-overlapping occurrences of the pattern in the source
	 *     string by the replacement repl.  number is the number of
	 *     substitutions that were made. repl can be either a string or a
	 *     callable; if a string, backslash escapes in it are processed.
	 *     If it is a callable, it's passed the Match object and must
	 *     return a replacement string to be used.
	 */
	function subn(pattern, repl, string, count?, flags?): Promise<any>
	function subn$({ pattern, repl, string, count, flags }: { pattern, repl, string, count?, flags?}): Promise<any>

	/**
	 * Split the source string by the occurrences of the pattern,
	 *     returning a list containing the resulting substrings.  If
	 *     capturing parentheses are used in pattern, then the text of all
	 *     groups in the pattern are also returned as part of the resulting
	 *     list.  If maxsplit is nonzero, at most maxsplit splits occur,
	 *     and the remainder of the string is returned as the final element
	 *     of the list.
	 */
	function split(pattern, string, maxsplit?, flags?): Promise<any>
	function split$({ pattern, string, maxsplit, flags }: { pattern, string, maxsplit?, flags?}): Promise<any>

	/**
	 * Return a list of all non-overlapping matches in the string.
	 * 
	 *     If one or more capturing groups are present in the pattern, return
	 *     a list of groups; this will be a list of tuples if the pattern
	 *     has more than one group.
	 * 
	 *     Empty matches are included in the result.
	 */
	function findall(pattern, string, flags?): Promise<any>
	function findall$({ pattern, string, flags }: { pattern, string, flags?}): Promise<any>

	/**
	 * Return an iterator over all non-overlapping matches in the
	 *     string.  For each match, the iterator returns a Match object.
	 * 
	 *     Empty matches are included in the result.
	 */
	function finditer(pattern, string, flags?): Promise<any>
	function finditer$({ pattern, string, flags }: { pattern, string, flags?}): Promise<any>

	/**
	 * Compile a regular expression pattern, returning a Pattern object.
	 */
	function compile(pattern, flags?): Promise<any>
	function compile$({ pattern, flags }: { pattern, flags?}): Promise<any>

	/**
	 * Clear the regular expression caches
	 */
	function purge(): Promise<any>
	function purge$($: {}): Promise<any>

	/**
	 * Compile a template pattern, returning a Pattern object
	 */
	function template(pattern, flags?): Promise<any>
	function template$({ pattern, flags }: { pattern, flags?}): Promise<any>

	/**
	 * 
	 *     Escape special characters in a string.
	 *     
	 */
	function escape(pattern): Promise<any>
	function escape$({ pattern }): Promise<any>
	interface IRegexFlag {
		ASCII
		A
		IGNORECASE
		I
		LOCALE
		L
		UNICODE
		U
		MULTILINE
		M
		DOTALL
		S
		VERBOSE
		X
		TEMPLATE
		T
		DEBUG
	}
	function Scanner(lexicon, flags?): Promise<IScanner>
	function Scanner$({ lexicon, flags }: { lexicon, flags?}): Promise<IScanner>
	interface IScanner {
		scan(string): Promise<any>
		scan$({ string }): Promise<any>
	}
	let error: Promise<any>
	let Pattern: Promise<any>
	let Match: Promise<any>
}
declare module reprlib {
	var _

	/**
	 * Decorator to make a repr function return fillvalue for a recursive call
	 */
	function recursive_repr(fillvalue?): Promise<any>
	function recursive_repr$({ fillvalue }: { fillvalue?}): Promise<any>
	function Repr(): Promise<IRepr>
	function Repr$({ }): Promise<IRepr>
	interface IRepr {
		repr(x): Promise<any>
		repr$({ x }): Promise<any>
		repr1(x, level): Promise<any>
		repr1$({ x, level }): Promise<any>
		repr_tuple(x, level): Promise<any>
		repr_tuple$({ x, level }): Promise<any>
		repr_list(x, level): Promise<any>
		repr_list$({ x, level }): Promise<any>
		repr_array(x, level): Promise<any>
		repr_array$({ x, level }): Promise<any>
		repr_set(x, level): Promise<any>
		repr_set$({ x, level }): Promise<any>
		repr_frozenset(x, level): Promise<any>
		repr_frozenset$({ x, level }): Promise<any>
		repr_deque(x, level): Promise<any>
		repr_deque$({ x, level }): Promise<any>
		repr_dict(x, level): Promise<any>
		repr_dict$({ x, level }): Promise<any>
		repr_str(x, level): Promise<any>
		repr_str$({ x, level }): Promise<any>
		repr_int(x, level): Promise<any>
		repr_int$({ x, level }): Promise<any>
		repr_instance(x, level): Promise<any>
		repr_instance$({ x, level }): Promise<any>
	}
	let aRepr: Promise<any>
}
declare module rlcompleter {
	var _
	function get_class_members(klass): Promise<any>
	function get_class_members$({ klass }): Promise<any>

	/**
	 * Create a new completer for the command line.
	 * 
	 *         Completer([namespace]) -> completer instance.
	 * 
	 *         If unspecified, the default namespace where completions are performed
	 *         is __main__ (technically, __main__.__dict__). Namespaces should be
	 *         given as dictionaries.
	 * 
	 *         Completer instances should be used as the completion mechanism of
	 *         readline via the set_completer() call:
	 * 
	 *         readline.set_completer(Completer(my_namespace).complete)
	 *         
	 */
	function Completer(namespace?): Promise<ICompleter>
	function Completer$({ namespace }: { namespace?}): Promise<ICompleter>
	interface ICompleter {

		/**
		 * Return the next possible completion for 'text'.
		 * 
		 *         This is called successively with state == 0, 1, 2, ... until it
		 *         returns None.  The completion should begin with 'text'.
		 * 
		 *         
		 */
		complete(text, state): Promise<any>
		complete$({ text, state }): Promise<any>

		/**
		 * Compute matches when text is a simple name.
		 * 
		 *         Return a list of all keywords, built-in functions and names currently
		 *         defined in self.namespace that match.
		 * 
		 *         
		 */
		global_matches(text): Promise<any>
		global_matches$({ text }): Promise<any>

		/**
		 * Compute matches when text contains a dot.
		 * 
		 *         Assuming the text is of the form NAME.NAME....[NAME], and is
		 *         evaluable in self.namespace, it will be evaluated and its attributes
		 *         (as revealed by dir()) are used as possible completions.  (For class
		 *         instances, class members are also considered.)
		 * 
		 *         WARNING: this can still invoke arbitrary C code, if an object
		 *         with a __getattr__ hook is evaluated.
		 * 
		 *         
		 */
		attr_matches(text): Promise<any>
		attr_matches$({ text }): Promise<any>
	}
}
declare module runpy {
	var _

	/**
	 * Execute a module's code without importing it
	 * 
	 *        Returns the resulting top level namespace dictionary
	 *     
	 */
	function run_module(mod_name, init_globals?, run_name?, alter_sys?: boolean): Promise<any>
	function run_module$({ mod_name, init_globals, run_name, alter_sys }: { mod_name, init_globals?, run_name?, alter_sys?}): Promise<any>

	/**
	 * Execute code located at the specified filesystem location
	 * 
	 *        Returns the resulting top level namespace dictionary
	 * 
	 *        The file path may refer directly to a Python script (i.e.
	 *        one that could be directly executed with execfile) or else
	 *        it may refer to a zipfile or directory containing a top
	 *        level __main__.py script.
	 *     
	 */
	function run_path(path_name, init_globals?, run_name?): Promise<any>
	function run_path$({ path_name, init_globals, run_name }: { path_name, init_globals?, run_name?}): Promise<any>

	/**
	 * Temporarily replace a module in sys.modules with an empty namespace
	 */
	interface I_TempModule {
	}
	interface I_ModifiedArgv0 {
	}

	/**
	 * Error that _run_module_as_main() should report without a traceback
	 */
	interface I_Error {
	}
}
declare module sched {
	var _

	/**
	 * Initialize a new instance, passing the time and delay
	 *         functions
	 */
	function scheduler(timefunc?, delayfunc?): Promise<Ischeduler>
	function scheduler$({ timefunc, delayfunc }: { timefunc?, delayfunc?}): Promise<Ischeduler>
	interface Ischeduler {

		/**
		 * Enter a new event in the queue at an absolute time.
		 * 
		 *         Returns an ID for the event which can be used to remove it,
		 *         if necessary.
		 * 
		 *         
		 */
		enterabs(time, priority, action, argument?, kwargs?): Promise<any>
		enterabs$({ time, priority, action, argument, kwargs }: { time, priority, action, argument?, kwargs?}): Promise<any>

		/**
		 * A variant that specifies the time as a relative time.
		 * 
		 *         This is actually the more commonly used interface.
		 * 
		 *         
		 */
		enter(delay, priority, action, argument?, kwargs?): Promise<any>
		enter$({ delay, priority, action, argument, kwargs }: { delay, priority, action, argument?, kwargs?}): Promise<any>

		/**
		 * Remove an event from the queue.
		 * 
		 *         This must be presented the ID as returned by enter().
		 *         If the event is not in the queue, this raises ValueError.
		 * 
		 *         
		 */
		cancel(event): Promise<any>
		cancel$({ event }): Promise<any>

		/**
		 * Check whether the queue is empty.
		 */
		empty(): Promise<any>
		empty$($: {}): Promise<any>

		/**
		 * Execute events until the queue is empty.
		 *         If blocking is False executes the scheduled events due to
		 *         expire soonest (if any) and then return the deadline of the
		 *         next scheduled call in the scheduler.
		 * 
		 *         When there is a positive delay until the first event, the
		 *         delay function is called and the event is left in the queue;
		 *         otherwise, the event is removed from the queue and executed
		 *         (its action function is called, passing it the argument).  If
		 *         the delay function returns prematurely, it is simply
		 *         restarted.
		 * 
		 *         It is legal for both the delay function and the action
		 *         function to modify the queue or to raise an exception;
		 *         exceptions are not caught but the scheduler's state remains
		 *         well-defined so run() may be called again.
		 * 
		 *         A questionable hack is added to allow other threads to run:
		 *         just after an event is executed, a delay of 0 is executed, to
		 *         avoid monopolizing the CPU when other threads are also
		 *         runnable.
		 * 
		 *         
		 */
		run(blocking?: boolean): Promise<any>
		run$({ blocking }: { blocking?}): Promise<any>

		/**
		 * An ordered list of upcoming events.
		 * 
		 *         Events are named tuples with fields for:
		 *             time, priority, action, arguments, kwargs
		 * 
		 *         
		 */
		queue(): Promise<any>
		queue$($: {}): Promise<any>
	}
	let Event: Promise<any>
}
declare module secrets {
	var _

	/**
	 * Return a random int in the range [0, n).
	 */
	function randbelow(exclusive_upper_bound): Promise<any>
	function randbelow$({ exclusive_upper_bound }): Promise<any>

	/**
	 * Return a random byte string containing *nbytes* bytes.
	 * 
	 *     If *nbytes* is ``None`` or not supplied, a reasonable
	 *     default is used.
	 * 
	 *     >>> token_bytes(16)  #doctest:+SKIP
	 *     b'\xebr\x17D*t\xae\xd4\xe3S\xb6\xe2\xebP1\x8b'
	 * 
	 *     
	 */
	function token_bytes(nbytes?): Promise<any>
	function token_bytes$({ nbytes }: { nbytes?}): Promise<any>

	/**
	 * Return a random text string, in hexadecimal.
	 * 
	 *     The string has *nbytes* random bytes, each byte converted to two
	 *     hex digits.  If *nbytes* is ``None`` or not supplied, a reasonable
	 *     default is used.
	 * 
	 *     >>> token_hex(16)  #doctest:+SKIP
	 *     'f9bf78b9a18ce6d46a0cd2b0b86df9da'
	 * 
	 *     
	 */
	function token_hex(nbytes?): Promise<any>
	function token_hex$({ nbytes }: { nbytes?}): Promise<any>

	/**
	 * Return a random URL-safe text string, in Base64 encoding.
	 * 
	 *     The string has *nbytes* random bytes.  If *nbytes* is ``None``
	 *     or not supplied, a reasonable default is used.
	 * 
	 *     >>> token_urlsafe(16)  #doctest:+SKIP
	 *     'Drmhze6EPcv0fN_81Bj-nA'
	 * 
	 *     
	 */
	function token_urlsafe(nbytes?): Promise<any>
	function token_urlsafe$({ nbytes }: { nbytes?}): Promise<any>
	let randbits: Promise<any>
	let choice: Promise<any>
	let DEFAULT_ENTROPY: Promise<any>
}
declare module selectors {
	var _

	/**
	 * Mapping of file objects to selector keys.
	 */
	interface I_SelectorMapping {
	}

	/**
	 * Selector abstract base class.
	 * 
	 *     A selector supports registering file objects to be monitored for specific
	 *     I/O events.
	 * 
	 *     A file object is a file descriptor or any object with a `fileno()` method.
	 *     An arbitrary object can be attached to the file object, which can be used
	 *     for example to store context information, a callback, etc.
	 * 
	 *     A selector can use various implementations (select(), poll(), epoll()...)
	 *     depending on the platform. The default `Selector` class uses the most
	 *     efficient implementation on the current platform.
	 *     
	 */
	interface IBaseSelector {

		/**
		 * Register a file object.
		 * 
		 *         Parameters:
		 *         fileobj -- file object or file descriptor
		 *         events  -- events to monitor (bitwise mask of EVENT_READ|EVENT_WRITE)
		 *         data    -- attached data
		 * 
		 *         Returns:
		 *         SelectorKey instance
		 * 
		 *         Raises:
		 *         ValueError if events is invalid
		 *         KeyError if fileobj is already registered
		 *         OSError if fileobj is closed or otherwise is unacceptable to
		 *                 the underlying system call (if a system call is made)
		 * 
		 *         Note:
		 *         OSError may or may not be raised
		 *         
		 */
		register(fileobj, events, data?): Promise<any>
		register$({ fileobj, events, data }: { fileobj, events, data?}): Promise<any>

		/**
		 * Unregister a file object.
		 * 
		 *         Parameters:
		 *         fileobj -- file object or file descriptor
		 * 
		 *         Returns:
		 *         SelectorKey instance
		 * 
		 *         Raises:
		 *         KeyError if fileobj is not registered
		 * 
		 *         Note:
		 *         If fileobj is registered but has since been closed this does
		 *         *not* raise OSError (even if the wrapped syscall does)
		 *         
		 */
		unregister(fileobj): Promise<any>
		unregister$({ fileobj }): Promise<any>

		/**
		 * Change a registered file object monitored events or attached data.
		 * 
		 *         Parameters:
		 *         fileobj -- file object or file descriptor
		 *         events  -- events to monitor (bitwise mask of EVENT_READ|EVENT_WRITE)
		 *         data    -- attached data
		 * 
		 *         Returns:
		 *         SelectorKey instance
		 * 
		 *         Raises:
		 *         Anything that unregister() or register() raises
		 *         
		 */
		modify(fileobj, events, data?): Promise<any>
		modify$({ fileobj, events, data }: { fileobj, events, data?}): Promise<any>

		/**
		 * Perform the actual selection, until some monitored file objects are
		 *         ready or a timeout expires.
		 * 
		 *         Parameters:
		 *         timeout -- if timeout > 0, this specifies the maximum wait time, in
		 *                    seconds
		 *                    if timeout <= 0, the select() call won't block, and will
		 *                    report the currently ready file objects
		 *                    if timeout is None, select() will block until a monitored
		 *                    file object becomes ready
		 * 
		 *         Returns:
		 *         list of (key, events) for ready file objects
		 *         `events` is a bitwise mask of EVENT_READ|EVENT_WRITE
		 *         
		 */
		select(timeout?): Promise<any>
		select$({ timeout }: { timeout?}): Promise<any>

		/**
		 * Close the selector.
		 * 
		 *         This must be called to make sure that any underlying resource is freed.
		 *         
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>

		/**
		 * Return the key associated to a registered file object.
		 * 
		 *         Returns:
		 *         SelectorKey for this file object
		 *         
		 */
		get_key(fileobj): Promise<any>
		get_key$({ fileobj }): Promise<any>

		/**
		 * Return a mapping of file objects to selector keys.
		 */
		get_map(): Promise<any>
		get_map$($: {}): Promise<any>
	}

	/**
	 * Base selector implementation.
	 */
	interface I_BaseSelectorImpl extends IBaseSelector {
		register(fileobj, events, data?): Promise<any>
		register$({ fileobj, events, data }: { fileobj, events, data?}): Promise<any>
		unregister(fileobj): Promise<any>
		unregister$({ fileobj }): Promise<any>
		modify(fileobj, events, data?): Promise<any>
		modify$({ fileobj, events, data }: { fileobj, events, data?}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
		get_map(): Promise<any>
		get_map$($: {}): Promise<any>
	}

	/**
	 * Select-based selector.
	 */
	function SelectSelector(): Promise<ISelectSelector>
	function SelectSelector$({ }): Promise<ISelectSelector>
	interface ISelectSelector extends I_BaseSelectorImpl {
		register(fileobj, events, data?): Promise<any>
		register$({ fileobj, events, data }: { fileobj, events, data?}): Promise<any>
		unregister(fileobj): Promise<any>
		unregister$({ fileobj }): Promise<any>
		select(timeout?): Promise<any>
		select$({ timeout }: { timeout?}): Promise<any>
	}

	/**
	 * Base class shared between poll, epoll and devpoll selectors.
	 */
	interface I_PollLikeSelector extends I_BaseSelectorImpl {
		register(fileobj, events, data?): Promise<any>
		register$({ fileobj, events, data }: { fileobj, events, data?}): Promise<any>
		unregister(fileobj): Promise<any>
		unregister$({ fileobj }): Promise<any>
		modify(fileobj, events, data?): Promise<any>
		modify$({ fileobj, events, data }: { fileobj, events, data?}): Promise<any>
		select(timeout?): Promise<any>
		select$({ timeout }: { timeout?}): Promise<any>
	}

	/**
	 * Poll-based selector.
	 */
	interface IPollSelector extends I_PollLikeSelector {
	}

	/**
	 * Epoll-based selector.
	 */
	interface IEpollSelector extends I_PollLikeSelector {
		fileno(): Promise<any>
		fileno$($: {}): Promise<any>
		select(timeout?): Promise<any>
		select$({ timeout }: { timeout?}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 * Solaris /dev/poll selector.
	 */
	interface IDevpollSelector extends I_PollLikeSelector {
		fileno(): Promise<any>
		fileno$($: {}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 * Kqueue-based selector.
	 */
	function KqueueSelector(): Promise<IKqueueSelector>
	function KqueueSelector$({ }): Promise<IKqueueSelector>
	interface IKqueueSelector extends I_BaseSelectorImpl {
		fileno(): Promise<any>
		fileno$($: {}): Promise<any>
		register(fileobj, events, data?): Promise<any>
		register$({ fileobj, events, data }: { fileobj, events, data?}): Promise<any>
		unregister(fileobj): Promise<any>
		unregister$({ fileobj }): Promise<any>
		select(timeout?): Promise<any>
		select$({ timeout }: { timeout?}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}
	let EVENT_READ: Promise<any>
	let EVENT_WRITE: Promise<any>
	let SelectorKey: Promise<any>
	let DefaultSelector: Promise<any>
}
declare module shelve {
	var _

	/**
	 * Open a persistent dictionary for reading and writing.
	 * 
	 *     The filename parameter is the base filename for the underlying
	 *     database.  As a side-effect, an extension may be added to the
	 *     filename and more than one file may be created.  The optional flag
	 *     parameter has the same interpretation as the flag parameter of
	 *     dbm.open(). The optional protocol parameter specifies the
	 *     version of the pickle protocol.
	 * 
	 *     See the module's __doc__ string for an overview of the interface.
	 *     
	 */
	function open(filename, flag?, protocol?, writeback?: boolean): Promise<any>
	function open$({ filename, flag, protocol, writeback }: { filename, flag?, protocol?, writeback?}): Promise<any>

	/**
	 * Marker for a closed dict.  Access attempts raise a ValueError.
	 */
	interface I_ClosedDict {
		closed(): Promise<any>
		closed$($: {}): Promise<any>
		keys
	}

	/**
	 * Base class for shelf implementations.
	 * 
	 *     This is initialized with a dictionary-like object.
	 *     See the module's __doc__ string for an overview of the interface.
	 *     
	 */
	function Shelf(dict, protocol?, writeback?: boolean, keyencoding?): Promise<IShelf>
	function Shelf$({ dict, protocol, writeback, keyencoding }: { dict, protocol?, writeback?, keyencoding?}): Promise<IShelf>
	interface IShelf {
		get(key, def?): Promise<any>
		get$({ key, def }: { key, def?}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
		sync(): Promise<any>
		sync$($: {}): Promise<any>
	}

	/**
	 * Shelf implementation using the "BSD" db interface.
	 * 
	 *     This adds methods first(), next(), previous(), last() and
	 *     set_location() that have no counterpart in [g]dbm databases.
	 * 
	 *     The actual database must be opened using one of the "bsddb"
	 *     modules "open" routines (i.e. bsddb.hashopen, bsddb.btopen or
	 *     bsddb.rnopen) and passed to the constructor.
	 * 
	 *     See the module's __doc__ string for an overview of the interface.
	 *     
	 */
	function BsdDbShelf(dict, protocol?, writeback?: boolean, keyencoding?): Promise<IBsdDbShelf>
	function BsdDbShelf$({ dict, protocol, writeback, keyencoding }: { dict, protocol?, writeback?, keyencoding?}): Promise<IBsdDbShelf>
	interface IBsdDbShelf extends IShelf {
		set_location(key): Promise<any>
		set_location$({ key }): Promise<any>
		next(): Promise<any>
		next$($: {}): Promise<any>
		previous(): Promise<any>
		previous$($: {}): Promise<any>
		first(): Promise<any>
		first$($: {}): Promise<any>
		last(): Promise<any>
		last$($: {}): Promise<any>
	}

	/**
	 * Shelf implementation using the "dbm" generic dbm interface.
	 * 
	 *     This is initialized with the filename for the dbm database.
	 *     See the module's __doc__ string for an overview of the interface.
	 *     
	 */
	function DbfilenameShelf(filename, flag?, protocol?, writeback?: boolean): Promise<IDbfilenameShelf>
	function DbfilenameShelf$({ filename, flag, protocol, writeback }: { filename, flag?, protocol?, writeback?}): Promise<IDbfilenameShelf>
	interface IDbfilenameShelf extends IShelf {
	}
}
declare module shlex {
	var _

	/**
	 * Split the string *s* using shell-like syntax.
	 */
	function split(s, comments?: boolean, posix?: boolean): Promise<any>
	function split$({ s, comments, posix }: { s, comments?, posix?}): Promise<any>

	/**
	 * Return a shell-escaped string from *split_command*.
	 */
	function join(split_command): Promise<any>
	function join$({ split_command }): Promise<any>

	/**
	 * Return a shell-escaped version of the string *s*.
	 */
	function quote(s): Promise<any>
	function quote$({ s }): Promise<any>

	/**
	 * A lexical analyzer class for simple shell-like syntaxes.
	 */
	function shlex(instream?, infile?, posix?: boolean, punctuation_chars?: boolean): Promise<Ishlex>
	function shlex$({ instream, infile, posix, punctuation_chars }: { instream?, infile?, posix?, punctuation_chars?}): Promise<Ishlex>
	interface Ishlex {
		punctuation_chars(): Promise<any>
		punctuation_chars$($: {}): Promise<any>

		/**
		 * Push a token onto the stack popped by the get_token method
		 */
		push_token(tok): Promise<any>
		push_token$({ tok }): Promise<any>

		/**
		 * Push an input source onto the lexer's input source stack.
		 */
		push_source(newstream, newfile?): Promise<any>
		push_source$({ newstream, newfile }: { newstream, newfile?}): Promise<any>

		/**
		 * Pop the input source stack.
		 */
		pop_source(): Promise<any>
		pop_source$($: {}): Promise<any>

		/**
		 * Get a token from the input stream (or from stack if it's nonempty)
		 */
		get_token(): Promise<any>
		get_token$($: {}): Promise<any>
		read_token(): Promise<any>
		read_token$($: {}): Promise<any>

		/**
		 * Hook called on a filename to be sourced.
		 */
		sourcehook(newfile): Promise<any>
		sourcehook$({ newfile }): Promise<any>

		/**
		 * Emit a C-compiler-like, Emacs-friendly error-message leader.
		 */
		error_leader(infile?, lineno?): Promise<any>
		error_leader$({ infile, lineno }: { infile?, lineno?}): Promise<any>
	}
	let fn: Promise<any>
}
declare module shutil {
	var _

	/**
	 * copy data from file-like object fsrc to file-like object fdst
	 */
	function copyfileobj(fsrc, fdst, length?): Promise<any>
	function copyfileobj$({ fsrc, fdst, length }: { fsrc, fdst, length?}): Promise<any>

	/**
	 * Copy data from src to dst in the most efficient way possible.
	 * 
	 *     If follow_symlinks is not set and src is a symbolic link, a new
	 *     symlink will be created instead of copying the file it points to.
	 * 
	 *     
	 */
	function copyfile(src, dst): Promise<any>
	function copyfile$({ src, dst }): Promise<any>

	/**
	 * Copy mode bits from src to dst.
	 * 
	 *     If follow_symlinks is not set, symlinks aren't followed if and only
	 *     if both `src` and `dst` are symlinks.  If `lchmod` isn't available
	 *     (e.g. Linux) this method does nothing.
	 * 
	 *     
	 */
	function copymode(src, dst): Promise<any>
	function copymode$({ src, dst }): Promise<any>

	/**
	 * Copy file metadata
	 * 
	 *     Copy the permission bits, last access time, last modification time, and
	 *     flags from `src` to `dst`. On Linux, copystat() also copies the "extended
	 *     attributes" where possible. The file contents, owner, and group are
	 *     unaffected. `src` and `dst` are path-like objects or path names given as
	 *     strings.
	 * 
	 *     If the optional flag `follow_symlinks` is not set, symlinks aren't
	 *     followed if and only if both `src` and `dst` are symlinks.
	 *     
	 */
	function copystat(src, dst): Promise<any>
	function copystat$({ src, dst }): Promise<any>

	/**
	 * Copy data and mode bits ("cp src dst"). Return the file's destination.
	 * 
	 *     The destination may be a directory.
	 * 
	 *     If follow_symlinks is false, symlinks won't be followed. This
	 *     resembles GNU's "cp -P src dst".
	 * 
	 *     If source and destination are the same file, a SameFileError will be
	 *     raised.
	 * 
	 *     
	 */
	function copy(src, dst): Promise<any>
	function copy$({ src, dst }): Promise<any>

	/**
	 * Copy data and metadata. Return the file's destination.
	 * 
	 *     Metadata is copied with copystat(). Please see the copystat function
	 *     for more information.
	 * 
	 *     The destination may be a directory.
	 * 
	 *     If follow_symlinks is false, symlinks won't be followed. This
	 *     resembles GNU's "cp -P src dst".
	 *     
	 */
	function copy2(src, dst): Promise<any>
	function copy2$({ src, dst }): Promise<any>

	/**
	 * Function that can be used as copytree() ignore parameter.
	 * 
	 *     Patterns is a sequence of glob-style patterns
	 *     that are used to exclude files
	 */
	function ignore_patterns(): Promise<any>
	function ignore_patterns$($: {}): Promise<any>

	/**
	 * Recursively copy a directory tree and return the destination directory.
	 * 
	 *     dirs_exist_ok dictates whether to raise an exception in case dst or any
	 *     missing parent directory already exists.
	 * 
	 *     If exception(s) occur, an Error is raised with a list of reasons.
	 * 
	 *     If the optional symlinks flag is true, symbolic links in the
	 *     source tree result in symbolic links in the destination tree; if
	 *     it is false, the contents of the files pointed to by symbolic
	 *     links are copied. If the file pointed by the symlink doesn't
	 *     exist, an exception will be added in the list of errors raised in
	 *     an Error exception at the end of the copy process.
	 * 
	 *     You can set the optional ignore_dangling_symlinks flag to true if you
	 *     want to silence this exception. Notice that this has no effect on
	 *     platforms that don't support os.symlink.
	 * 
	 *     The optional ignore argument is a callable. If given, it
	 *     is called with the `src` parameter, which is the directory
	 *     being visited by copytree(), and `names` which is the list of
	 *     `src` contents, as returned by os.listdir():
	 * 
	 *         callable(src, names) -> ignored_names
	 * 
	 *     Since copytree() is called recursively, the callable will be
	 *     called once for each directory that is copied. It returns a
	 *     list of names relative to the `src` directory that should
	 *     not be copied.
	 * 
	 *     The optional copy_function argument is a callable that will be used
	 *     to copy each file. It will be called with the source path and the
	 *     destination path as arguments. By default, copy2() is used, but any
	 *     function that supports the same signature (like copy()) can be used.
	 * 
	 *     
	 */
	function copytree(src, dst, symlinks?: boolean, ignore?, copy_function?, ignore_dangling_symlinks?: boolean, dirs_exist_ok?: boolean): Promise<any>
	function copytree$({ src, dst, symlinks, ignore, copy_function, ignore_dangling_symlinks, dirs_exist_ok }: { src, dst, symlinks?, ignore?, copy_function?, ignore_dangling_symlinks?, dirs_exist_ok?}): Promise<any>

	/**
	 * Recursively delete a directory tree.
	 * 
	 *     If ignore_errors is set, errors are ignored; otherwise, if onerror
	 *     is set, it is called to handle the error with arguments (func,
	 *     path, exc_info) where func is platform and implementation dependent;
	 *     path is the argument to that function that caused it to fail; and
	 *     exc_info is a tuple returned by sys.exc_info().  If ignore_errors
	 *     is false and onerror is None, an exception is raised.
	 * 
	 *     
	 */
	function rmtree(path, ignore_errors?: boolean, onerror?): Promise<any>
	function rmtree$({ path, ignore_errors, onerror }: { path, ignore_errors?, onerror?}): Promise<any>

	/**
	 * Recursively move a file or directory to another location. This is
	 *     similar to the Unix "mv" command. Return the file or directory's
	 *     destination.
	 * 
	 *     If the destination is a directory or a symlink to a directory, the source
	 *     is moved inside the directory. The destination path must not already
	 *     exist.
	 * 
	 *     If the destination already exists but is not a directory, it may be
	 *     overwritten depending on os.rename() semantics.
	 * 
	 *     If the destination is on our current filesystem, then rename() is used.
	 *     Otherwise, src is copied to the destination and then removed. Symlinks are
	 *     recreated under the new name if os.rename() fails because of cross
	 *     filesystem renames.
	 * 
	 *     The optional `copy_function` argument is a callable that will be used
	 *     to copy the source or it will be delegated to `copytree`.
	 *     By default, copy2() is used, but any function that supports the same
	 *     signature (like copy()) can be used.
	 * 
	 *     A lot more could be done here...  A look at a mv.c shows a lot of
	 *     the issues this implementation glosses over.
	 * 
	 *     
	 */
	function move(src, dst, copy_function?): Promise<any>
	function move$({ src, dst, copy_function }: { src, dst, copy_function?}): Promise<any>

	/**
	 * Returns a list of supported formats for archiving and unarchiving.
	 * 
	 *     Each element of the returned sequence is a tuple (name, description)
	 *     
	 */
	function get_archive_formats(): Promise<any>
	function get_archive_formats$($: {}): Promise<any>

	/**
	 * Registers an archive format.
	 * 
	 *     name is the name of the format. function is the callable that will be
	 *     used to create archives. If provided, extra_args is a sequence of
	 *     (name, value) tuples that will be passed as arguments to the callable.
	 *     description can be provided to describe the format, and will be returned
	 *     by the get_archive_formats() function.
	 *     
	 */
	function register_archive_format(name, func, extra_args?, description?): Promise<any>
	function register_archive_format$({ name, func, extra_args, description }: { name, func, extra_args?, description?}): Promise<any>
	function unregister_archive_format(name): Promise<any>
	function unregister_archive_format$({ name }): Promise<any>

	/**
	 * Create an archive file (eg. zip or tar).
	 * 
	 *     'base_name' is the name of the file to create, minus any format-specific
	 *     extension; 'format' is the archive format: one of "zip", "tar", "gztar",
	 *     "bztar", or "xztar".  Or any other registered format.
	 * 
	 *     'root_dir' is a directory that will be the root directory of the
	 *     archive; ie. we typically chdir into 'root_dir' before creating the
	 *     archive.  'base_dir' is the directory where we start archiving from;
	 *     ie. 'base_dir' will be the common prefix of all files and
	 *     directories in the archive.  'root_dir' and 'base_dir' both default
	 *     to the current directory.  Returns the name of the archive file.
	 * 
	 *     'owner' and 'group' are used when creating a tar archive. By default,
	 *     uses the current owner and group.
	 *     
	 */
	function make_archive(base_name, format, root_dir?, base_dir?, verbose?, dry_run?, owner?, group?, logger?): Promise<any>
	function make_archive$({ base_name, format, root_dir, base_dir, verbose, dry_run, owner, group, logger }: { base_name, format, root_dir?, base_dir?, verbose?, dry_run?, owner?, group?, logger?}): Promise<any>

	/**
	 * Returns a list of supported formats for unpacking.
	 * 
	 *     Each element of the returned sequence is a tuple
	 *     (name, extensions, description)
	 *     
	 */
	function get_unpack_formats(): Promise<any>
	function get_unpack_formats$($: {}): Promise<any>

	/**
	 * Registers an unpack format.
	 * 
	 *     `name` is the name of the format. `extensions` is a list of extensions
	 *     corresponding to the format.
	 * 
	 *     `function` is the callable that will be
	 *     used to unpack archives. The callable will receive archives to unpack.
	 *     If it's unable to handle an archive, it needs to raise a ReadError
	 *     exception.
	 * 
	 *     If provided, `extra_args` is a sequence of
	 *     (name, value) tuples that will be passed as arguments to the callable.
	 *     description can be provided to describe the format, and will be returned
	 *     by the get_unpack_formats() function.
	 *     
	 */
	function register_unpack_format(name, extensions, func, extra_args?, description?): Promise<any>
	function register_unpack_format$({ name, extensions, func, extra_args, description }: { name, extensions, func, extra_args?, description?}): Promise<any>

	/**
	 * Removes the pack format from the registry.
	 */
	function unregister_unpack_format(name): Promise<any>
	function unregister_unpack_format$({ name }): Promise<any>

	/**
	 * Unpack an archive.
	 * 
	 *     `filename` is the name of the archive.
	 * 
	 *     `extract_dir` is the name of the target directory, where the archive
	 *     is unpacked. If not provided, the current working directory is used.
	 * 
	 *     `format` is the archive format: one of "zip", "tar", "gztar", "bztar",
	 *     or "xztar".  Or any other registered format.  If not provided,
	 *     unpack_archive will use the filename extension and see if an unpacker
	 *     was registered for that extension.
	 * 
	 *     In case none is found, a ValueError is raised.
	 *     
	 */
	function unpack_archive(filename, extract_dir?, format?): Promise<any>
	function unpack_archive$({ filename, extract_dir, format }: { filename, extract_dir?, format?}): Promise<any>

	/**
	 * Return disk usage statistics about the given path.
	 * 
	 *         Returned value is a named tuple with attributes 'total', 'used' and
	 *         'free', which are the amount of total, used and free space, in bytes.
	 *         
	 */
	function disk_usage(path): Promise<any>
	function disk_usage$({ path }): Promise<any>

	/**
	 * Return disk usage statistics about the given path.
	 * 
	 *         Returned values is a named tuple with attributes 'total', 'used' and
	 *         'free', which are the amount of total, used and free space, in bytes.
	 *         
	 */
	function disk_usage(path): Promise<any>
	function disk_usage$({ path }): Promise<any>

	/**
	 * Change owner user and group of the given path.
	 * 
	 *     user and group can be the uid/gid or the user/group names, and in that case,
	 *     they are converted to their respective uid/gid.
	 *     
	 */
	function chown(path, user?, group?): Promise<any>
	function chown$({ path, user, group }: { path, user?, group?}): Promise<any>

	/**
	 * Get the size of the terminal window.
	 * 
	 *     For each of the two dimensions, the environment variable, COLUMNS
	 *     and LINES respectively, is checked. If the variable is defined and
	 *     the value is a positive integer, it is used.
	 * 
	 *     When COLUMNS or LINES is not defined, which is the common case,
	 *     the terminal connected to sys.__stdout__ is queried
	 *     by invoking os.get_terminal_size.
	 * 
	 *     If the terminal size cannot be successfully queried, either because
	 *     the system doesn't support querying, or because we are not
	 *     connected to a terminal, the value given in fallback parameter
	 *     is used. Fallback defaults to (80, 24) which is the default
	 *     size used by many terminal emulators.
	 * 
	 *     The value returned is a named tuple of type os.terminal_size.
	 *     
	 */
	function get_terminal_size(fallback?): Promise<any>
	function get_terminal_size$({ fallback }: { fallback?}): Promise<any>

	/**
	 * Given a command, mode, and a PATH string, return the path which
	 *     conforms to the given mode on the PATH, or None if there is no such
	 *     file.
	 * 
	 *     `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result
	 *     of os.environ.get("PATH"), or can be overridden with a custom search
	 *     path.
	 * 
	 *     
	 */
	function which(cmd, mode?, path?): Promise<any>
	function which$({ cmd, mode, path }: { cmd, mode?, path?}): Promise<any>
	interface IError {
	}

	/**
	 * Raised when source and destination are the same file.
	 */
	interface ISameFileError extends IError {
	}

	/**
	 * Raised when trying to do a kind of operation (e.g. copying) which is
	 *     not supported on a special file (e.g. a named pipe)
	 */
	interface ISpecialFileError {
	}

	/**
	 * Raised when a command could not be executed
	 */
	interface IExecError {
	}

	/**
	 * Raised when an archive cannot be read
	 */
	interface IReadError {
	}

	/**
	 * Raised when a registry operation with the archiving
	 *     and unpacking registries fails
	 */
	interface IRegistryError {
	}

	/**
	 * Raised as a signal to fallback on using raw read()/write()
	 *     file copy when fast-copy functions fail to do so.
	 *     
	 */
	interface I_GiveupOnFastCopy {
	}
	let posix: Promise<any>
	let nt: Promise<any>
	let COPY_BUFSIZE: Promise<any>
}
declare module signal {
	var _
	function signal(signalnum, handler): Promise<any>
	function signal$({ signalnum, handler }): Promise<any>
	function getsignal(signalnum): Promise<any>
	function getsignal$({ signalnum }): Promise<any>
	function pthread_sigmask(how, mask): Promise<any>
	function pthread_sigmask$({ how, mask }): Promise<any>
	function sigpending(): Promise<any>
	function sigpending$($: {}): Promise<any>
	function sigwait(sigset): Promise<any>
	function sigwait$({ sigset }): Promise<any>
	function valid_signals(): Promise<any>
	function valid_signals$($: {}): Promise<any>
}
declare module site {
	var _
	function makepath(): Promise<any>
	function makepath$($: {}): Promise<any>

	/**
	 * Set all module __file__ and __cached__ attributes to an absolute path
	 */
	function abs_paths(): Promise<any>
	function abs_paths$($: {}): Promise<any>

	/**
	 *  Remove duplicate entries from sys.path along with making them
	 *     absolute
	 */
	function removeduppaths(): Promise<any>
	function removeduppaths$($: {}): Promise<any>

	/**
	 * Process a .pth file within the site-packages directory:
	 *        For each line in the file, either combine it with sitedir to a path
	 *        and add that to known_paths, or execute it if it starts with 'import '.
	 *     
	 */
	function addpackage(sitedir, name, known_paths): Promise<any>
	function addpackage$({ sitedir, name, known_paths }): Promise<any>

	/**
	 * Add 'sitedir' argument to sys.path if missing and handle .pth files in
	 *     'sitedir'
	 */
	function addsitedir(sitedir, known_paths?): Promise<any>
	function addsitedir$({ sitedir, known_paths }: { sitedir, known_paths?}): Promise<any>

	/**
	 * Check if user site directory is safe for inclusion
	 * 
	 *     The function tests for the command line flag (including environment var),
	 *     process uid/gid equal to effective uid/gid.
	 * 
	 *     None: Disabled for security reasons
	 *     False: Disabled by user (command line option)
	 *     True: Safe and enabled
	 *     
	 */
	function check_enableusersite(): Promise<any>
	function check_enableusersite$($: {}): Promise<any>

	/**
	 * Returns the `user base` directory path.
	 * 
	 *     The `user base` directory can be used to store data. If the global
	 *     variable ``USER_BASE`` is not initialized yet, this function will also set
	 *     it.
	 *     
	 */
	function getuserbase(): Promise<any>
	function getuserbase$($: {}): Promise<any>

	/**
	 * Returns the user-specific site-packages directory path.
	 * 
	 *     If the global variable ``USER_SITE`` is not initialized yet, this
	 *     function will also set it.
	 *     
	 */
	function getusersitepackages(): Promise<any>
	function getusersitepackages$($: {}): Promise<any>

	/**
	 * Add a per user site-package to sys.path
	 * 
	 *     Each user has its own python directory with site-packages in the
	 *     home directory.
	 *     
	 */
	function addusersitepackages(known_paths): Promise<any>
	function addusersitepackages$({ known_paths }): Promise<any>

	/**
	 * Returns a list containing all global site-packages directories.
	 * 
	 *     For each directory present in ``prefixes`` (or the global ``PREFIXES``),
	 *     this function will find its `site-packages` subdirectory depending on the
	 *     system environment, and will return a list of full paths.
	 *     
	 */
	function getsitepackages(prefixes?): Promise<any>
	function getsitepackages$({ prefixes }: { prefixes?}): Promise<any>

	/**
	 * Add site-packages to sys.path
	 */
	function addsitepackages(known_paths, prefixes?): Promise<any>
	function addsitepackages$({ known_paths, prefixes }: { known_paths, prefixes?}): Promise<any>

	/**
	 * Define new builtins 'quit' and 'exit'.
	 * 
	 *     These are objects which make the interpreter exit when called.
	 *     The repr of each object contains a hint at how it works.
	 * 
	 *     
	 */
	function setquit(): Promise<any>
	function setquit$($: {}): Promise<any>

	/**
	 * Set 'copyright' and 'credits' in builtins
	 */
	function setcopyright(): Promise<any>
	function setcopyright$($: {}): Promise<any>
	function sethelper(): Promise<any>
	function sethelper$($: {}): Promise<any>

	/**
	 * Enable default readline configuration on interactive prompts, by
	 *     registering a sys.__interactivehook__.
	 * 
	 *     If the readline module can be imported, the hook will set the Tab key
	 *     as completion key and register ~/.python_history as history file.
	 *     This can be overridden in the sitecustomize or usercustomize module,
	 *     or in a PYTHONSTARTUP file.
	 *     
	 */
	function enablerlcompleter(): Promise<any>
	function enablerlcompleter$($: {}): Promise<any>
	function venv(known_paths): Promise<any>
	function venv$({ known_paths }): Promise<any>

	/**
	 * Run custom site specific code, if available.
	 */
	function execsitecustomize(): Promise<any>
	function execsitecustomize$($: {}): Promise<any>

	/**
	 * Run custom user specific code, if available.
	 */
	function execusercustomize(): Promise<any>
	function execusercustomize$($: {}): Promise<any>

	/**
	 * Add standard site-specific directories to the module search path.
	 * 
	 *     This function is called automatically when this module is imported,
	 *     unless the python interpreter was started with the -S flag.
	 *     
	 */
	function main(): Promise<any>
	function main$($: {}): Promise<any>
	let PREFIXES: Promise<any>
	let ENABLE_USER_SITE: Promise<any>
	let USER_SITE: Promise<any>
	let USER_BASE: Promise<any>
}
declare module smtpd {
	var _
	function usage(code, msg?): Promise<any>
	function usage$({ code, msg }: { code, msg?}): Promise<any>
	function parseargs(): Promise<any>
	function parseargs$($: {}): Promise<any>
	interface IDevnull {
		write(msg): Promise<any>
		write$({ msg }): Promise<any>
		flush(): Promise<any>
		flush$($: {}): Promise<any>
	}
	function SMTPChannel(server, conn, addr, data_size_limit?, map?, enable_SMTPUTF8?: boolean, decode_data?: boolean): Promise<ISMTPChannel>
	function SMTPChannel$({ server, conn, addr, data_size_limit, map, enable_SMTPUTF8, decode_data }: { server, conn, addr, data_size_limit?, map?, enable_SMTPUTF8?, decode_data?}): Promise<ISMTPChannel>
	interface ISMTPChannel {
		max_command_size_limit(): Promise<any>
		max_command_size_limit$($: {}): Promise<any>
		push(msg): Promise<any>
		push$({ msg }): Promise<any>
		collect_incoming_data(data): Promise<any>
		collect_incoming_data$({ data }): Promise<any>
		found_terminator(): Promise<any>
		found_terminator$($: {}): Promise<any>
		smtp_HELO(arg): Promise<any>
		smtp_HELO$({ arg }): Promise<any>
		smtp_EHLO(arg): Promise<any>
		smtp_EHLO$({ arg }): Promise<any>
		smtp_NOOP(arg): Promise<any>
		smtp_NOOP$({ arg }): Promise<any>
		smtp_QUIT(arg): Promise<any>
		smtp_QUIT$({ arg }): Promise<any>
		smtp_HELP(arg): Promise<any>
		smtp_HELP$({ arg }): Promise<any>
		smtp_VRFY(arg): Promise<any>
		smtp_VRFY$({ arg }): Promise<any>
		smtp_MAIL(arg): Promise<any>
		smtp_MAIL$({ arg }): Promise<any>
		smtp_RCPT(arg): Promise<any>
		smtp_RCPT$({ arg }): Promise<any>
		smtp_RSET(arg): Promise<any>
		smtp_RSET$({ arg }): Promise<any>
		smtp_DATA(arg): Promise<any>
		smtp_DATA$({ arg }): Promise<any>
		smtp_EXPN(arg): Promise<any>
		smtp_EXPN$({ arg }): Promise<any>
		COMMAND
		DATA
		command_size_limit
		command_size_limits
	}
	function SMTPServer(localaddr, remoteaddr, data_size_limit?, map?, enable_SMTPUTF8?: boolean, decode_data?: boolean): Promise<ISMTPServer>
	function SMTPServer$({ localaddr, remoteaddr, data_size_limit, map, enable_SMTPUTF8, decode_data }: { localaddr, remoteaddr, data_size_limit?, map?, enable_SMTPUTF8?, decode_data?}): Promise<ISMTPServer>
	interface ISMTPServer {
		handle_accepted(conn, addr): Promise<any>
		handle_accepted$({ conn, addr }): Promise<any>

		/**
		 * Override this abstract method to handle messages from the client.
		 * 
		 *         peer is a tuple containing (ipaddr, port) of the client that made the
		 *         socket connection to our smtp port.
		 * 
		 *         mailfrom is the raw address the client claims the message is coming
		 *         from.
		 * 
		 *         rcpttos is a list of raw addresses the client wishes to deliver the
		 *         message to.
		 * 
		 *         data is a string containing the entire full text of the message,
		 *         headers (if supplied) and all.  It has been `de-transparencied'
		 *         according to RFC 821, Section 4.5.2.  In other words, a line
		 *         containing a `.' followed by other text has had the leading dot
		 *         removed.
		 * 
		 *         kwargs is a dictionary containing additional information.  It is
		 *         empty if decode_data=True was given as init parameter, otherwise
		 *         it will contain the following keys:
		 *             'mail_options': list of parameters to the mail command.  All
		 *                             elements are uppercase strings.  Example:
		 *                             ['BODY=8BITMIME', 'SMTPUTF8'].
		 *             'rcpt_options': same, for the rcpt command.
		 * 
		 *         This function should return None for a normal `250 Ok' response;
		 *         otherwise, it should return the desired response string in RFC 821
		 *         format.
		 * 
		 *         
		 */
		process_message(peer, mailfrom, rcpttos, data): Promise<any>
		process_message$({ peer, mailfrom, rcpttos, data }): Promise<any>
		channel_class
	}
	interface IDebuggingServer extends ISMTPServer {
		process_message(peer, mailfrom, rcpttos, data): Promise<any>
		process_message$({ peer, mailfrom, rcpttos, data }): Promise<any>
	}
	function PureProxy(): Promise<IPureProxy>
	function PureProxy$({ }): Promise<IPureProxy>
	interface IPureProxy extends ISMTPServer {
		process_message(peer, mailfrom, rcpttos, data): Promise<any>
		process_message$({ peer, mailfrom, rcpttos, data }): Promise<any>
	}
	interface IOptions {
		setuid
		classname
		size_limit
		enable_SMTPUTF8
	}
	let program: Promise<any>
	let DEBUGSTREAM: Promise<any>
	let NEWLINE: Promise<any>
	let COMMASPACE: Promise<any>
	let DATA_SIZE_DEFAULT: Promise<any>
	let options: Promise<any>
	let lastdot: Promise<any>
	let mod: Promise<any>
	let class_: Promise<any>
	let proxy: Promise<any>
	let nobody: Promise<any>
}
declare module smtplib {
	var _

	/**
	 * Quote a subset of the email addresses defined by RFC 821.
	 * 
	 *     Should be able to handle anything email.utils.parseaddr can handle.
	 *     
	 */
	function quoteaddr(addrstring): Promise<any>
	function quoteaddr$({ addrstring }): Promise<any>

	/**
	 * Quote data for email.
	 * 
	 *     Double leading '.', and change Unix newline '\n', or Mac '\r' into
	 *     Internet CRLF end-of-line.
	 *     
	 */
	function quotedata(data): Promise<any>
	function quotedata$({ data }): Promise<any>
	function prompt(prompt): Promise<any>
	function prompt$({ prompt }): Promise<any>

	/**
	 * Base class for all exceptions raised by this module.
	 */
	interface ISMTPException {
	}

	/**
	 * The command or option is not supported by the SMTP server.
	 * 
	 *     This exception is raised when an attempt is made to run a command or a
	 *     command with an option which is not supported by the server.
	 *     
	 */
	interface ISMTPNotSupportedError extends ISMTPException {
	}

	/**
	 * Not connected to any SMTP server.
	 * 
	 *     This exception is raised when the server unexpectedly disconnects,
	 *     or when an attempt is made to use the SMTP instance before
	 *     connecting it to a server.
	 *     
	 */
	interface ISMTPServerDisconnected extends ISMTPException {
	}

	/**
	 * Base class for all exceptions that include an SMTP error code.
	 * 
	 *     These exceptions are generated in some instances when the SMTP
	 *     server returns an error code.  The error code is stored in the
	 *     `smtp_code' attribute of the error, and the `smtp_error' attribute
	 *     is set to the error message.
	 *     
	 */
	function SMTPResponseException(code, msg): Promise<ISMTPResponseException>
	function SMTPResponseException$({ code, msg }): Promise<ISMTPResponseException>
	interface ISMTPResponseException extends ISMTPException {
	}

	/**
	 * Sender address refused.
	 * 
	 *     In addition to the attributes set by on all SMTPResponseException
	 *     exceptions, this sets `sender' to the string that the SMTP refused.
	 *     
	 */
	function SMTPSenderRefused(code, msg, sender): Promise<ISMTPSenderRefused>
	function SMTPSenderRefused$({ code, msg, sender }): Promise<ISMTPSenderRefused>
	interface ISMTPSenderRefused extends ISMTPResponseException {
	}

	/**
	 * All recipient addresses refused.
	 * 
	 *     The errors for each recipient are accessible through the attribute
	 *     'recipients', which is a dictionary of exactly the same sort as
	 *     SMTP.sendmail() returns.
	 *     
	 */
	function SMTPRecipientsRefused(recipients): Promise<ISMTPRecipientsRefused>
	function SMTPRecipientsRefused$({ recipients }): Promise<ISMTPRecipientsRefused>
	interface ISMTPRecipientsRefused extends ISMTPException {
	}

	/**
	 * The SMTP server didn't accept the data.
	 */
	interface ISMTPDataError extends ISMTPResponseException {
	}

	/**
	 * Error during connection establishment.
	 */
	interface ISMTPConnectError extends ISMTPResponseException {
	}

	/**
	 * The server refused our HELO reply.
	 */
	interface ISMTPHeloError extends ISMTPResponseException {
	}

	/**
	 * Authentication error.
	 * 
	 *     Most probably the server didn't accept the username/password
	 *     combination provided.
	 *     
	 */
	interface ISMTPAuthenticationError extends ISMTPResponseException {
	}

	/**
	 * This class manages a connection to an SMTP or ESMTP server.
	 *     SMTP Objects:
	 *         SMTP objects have the following attributes:
	 *             helo_resp
	 *                 This is the message given by the server in response to the
	 *                 most recent HELO command.
	 * 
	 *             ehlo_resp
	 *                 This is the message given by the server in response to the
	 *                 most recent EHLO command. This is usually multiline.
	 * 
	 *             does_esmtp
	 *                 This is a True value _after you do an EHLO command_, if the
	 *                 server supports ESMTP.
	 * 
	 *             esmtp_features
	 *                 This is a dictionary, which, if the server supports ESMTP,
	 *                 will _after you do an EHLO command_, contain the names of the
	 *                 SMTP service extensions this server supports, and their
	 *                 parameters (if any).
	 * 
	 *                 Note, all extension names are mapped to lower case in the
	 *                 dictionary.
	 * 
	 *         See each method's docstrings for details.  In general, there is a
	 *         method of the same name to perform each SMTP command.  There is also a
	 *         method called 'sendmail' that will do an entire mail transaction.
	 *         
	 */

	/**
	 * Initialize a new instance.
	 * 
	 *         If specified, `host` is the name of the remote host to which to
	 *         connect.  If specified, `port` specifies the port to which to connect.
	 *         By default, smtplib.SMTP_PORT is used.  If a host is specified the
	 *         connect method is called, and if it returns anything other than a
	 *         success code an SMTPConnectError is raised.  If specified,
	 *         `local_hostname` is used as the FQDN of the local host in the HELO/EHLO
	 *         command.  Otherwise, the local hostname is found using
	 *         socket.getfqdn(). The `source_address` parameter takes a 2-tuple (host,
	 *         port) for the socket to bind to as its source address before
	 *         connecting. If the host is '' and port is 0, the OS default behavior
	 *         will be used.
	 * 
	 *         
	 */
	function SMTP(host?, port?, local_hostname?, timeout?, source_address?): Promise<ISMTP>
	function SMTP$({ host, port, local_hostname, timeout, source_address }: { host?, port?, local_hostname?, timeout?, source_address?}): Promise<ISMTP>
	interface ISMTP {

		/**
		 * Set the debug output level.
		 * 
		 *         A non-false value results in debug messages for connection and for all
		 *         messages sent to and received from the server.
		 * 
		 *         
		 */
		set_debuglevel(debuglevel): Promise<any>
		set_debuglevel$({ debuglevel }): Promise<any>

		/**
		 * Connect to a host on a given port.
		 * 
		 *         If the hostname ends with a colon (`:') followed by a number, and
		 *         there is no port specified, that suffix will be stripped off and the
		 *         number interpreted as the port number to use.
		 * 
		 *         Note: This method is automatically invoked by __init__, if a host is
		 *         specified during instantiation.
		 * 
		 *         
		 */
		connect(host?, port?, source_address?): Promise<any>
		connect$({ host, port, source_address }: { host?, port?, source_address?}): Promise<any>

		/**
		 * Send `s' to the server.
		 */
		send(s): Promise<any>
		send$({ s }): Promise<any>

		/**
		 * Send a command to the server.
		 */
		putcmd(cmd, args?): Promise<any>
		putcmd$({ cmd, args }: { cmd, args?}): Promise<any>

		/**
		 * Get a reply from the server.
		 * 
		 *         Returns a tuple consisting of:
		 * 
		 *           - server response code (e.g. '250', or such, if all goes well)
		 *             Note: returns -1 if it can't read response code.
		 * 
		 *           - server response string corresponding to response code (multiline
		 *             responses are converted to a single, multiline string).
		 * 
		 *         Raises SMTPServerDisconnected if end-of-file is reached.
		 *         
		 */
		getreply(): Promise<any>
		getreply$($: {}): Promise<any>

		/**
		 * Send a command, and return its response code.
		 */
		docmd(cmd, args?): Promise<any>
		docmd$({ cmd, args }: { cmd, args?}): Promise<any>

		/**
		 * SMTP 'helo' command.
		 *         Hostname to send for this command defaults to the FQDN of the local
		 *         host.
		 *         
		 */
		helo(name?): Promise<any>
		helo$({ name }: { name?}): Promise<any>

		/**
		 *  SMTP 'ehlo' command.
		 *         Hostname to send for this command defaults to the FQDN of the local
		 *         host.
		 *         
		 */
		ehlo(name?): Promise<any>
		ehlo$({ name }: { name?}): Promise<any>

		/**
		 * Does the server support a given SMTP service extension?
		 */
		has_extn(opt): Promise<any>
		has_extn$({ opt }): Promise<any>

		/**
		 * SMTP 'help' command.
		 *         Returns help text from server.
		 */
		help(args?): Promise<any>
		help$({ args }: { args?}): Promise<any>

		/**
		 * SMTP 'rset' command -- resets session.
		 */
		rset(): Promise<any>
		rset$($: {}): Promise<any>

		/**
		 * SMTP 'noop' command -- doesn't do anything :>
		 */
		noop(): Promise<any>
		noop$($: {}): Promise<any>

		/**
		 * SMTP 'mail' command -- begins mail xfer session.
		 * 
		 *         This method may raise the following exceptions:
		 * 
		 *          SMTPNotSupportedError  The options parameter includes 'SMTPUTF8'
		 *                                 but the SMTPUTF8 extension is not supported by
		 *                                 the server.
		 *         
		 */
		mail(sender, options?): Promise<any>
		mail$({ sender, options }: { sender, options?}): Promise<any>

		/**
		 * SMTP 'rcpt' command -- indicates 1 recipient for this mail.
		 */
		rcpt(recip, options?): Promise<any>
		rcpt$({ recip, options }: { recip, options?}): Promise<any>

		/**
		 * SMTP 'DATA' command -- sends message data to server.
		 * 
		 *         Automatically quotes lines beginning with a period per rfc821.
		 *         Raises SMTPDataError if there is an unexpected reply to the
		 *         DATA command; the return value from this method is the final
		 *         response code received when the all data is sent.  If msg
		 *         is a string, lone '\r' and '\n' characters are converted to
		 *         '\r\n' characters.  If msg is bytes, it is transmitted as is.
		 *         
		 */
		data(msg): Promise<any>
		data$({ msg }): Promise<any>

		/**
		 * SMTP 'verify' command -- checks for address validity.
		 */
		verify(address): Promise<any>
		verify$({ address }): Promise<any>

		/**
		 * SMTP 'expn' command -- expands a mailing list.
		 */
		expn(address): Promise<any>
		expn$({ address }): Promise<any>

		/**
		 * Call self.ehlo() and/or self.helo() if needed.
		 * 
		 *         If there has been no previous EHLO or HELO command this session, this
		 *         method tries ESMTP EHLO first.
		 * 
		 *         This method may raise the following exceptions:
		 * 
		 *          SMTPHeloError            The server didn't reply properly to
		 *                                   the helo greeting.
		 *         
		 */
		ehlo_or_helo_if_needed(): Promise<any>
		ehlo_or_helo_if_needed$($: {}): Promise<any>

		/**
		 * Authentication command - requires response processing.
		 * 
		 *         'mechanism' specifies which authentication mechanism is to
		 *         be used - the valid values are those listed in the 'auth'
		 *         element of 'esmtp_features'.
		 * 
		 *         'authobject' must be a callable object taking a single argument:
		 * 
		 *                 data = authobject(challenge)
		 * 
		 *         It will be called to process the server's challenge response; the
		 *         challenge argument it is passed will be a bytes.  It should return
		 *         an ASCII string that will be base64 encoded and sent to the server.
		 * 
		 *         Keyword arguments:
		 *             - initial_response_ok: Allow sending the RFC 4954 initial-response
		 *               to the AUTH command, if the authentication methods supports it.
		 *         
		 */
		auth(mechanism, authobject): Promise<any>
		auth$({ mechanism, authobject }): Promise<any>

		/**
		 *  Authobject to use with CRAM-MD5 authentication. Requires self.user
		 *         and self.password to be set.
		 */
		auth_cram_md5(challenge?): Promise<any>
		auth_cram_md5$({ challenge }: { challenge?}): Promise<any>

		/**
		 *  Authobject to use with PLAIN authentication. Requires self.user and
		 *         self.password to be set.
		 */
		auth_plain(challenge?): Promise<any>
		auth_plain$({ challenge }: { challenge?}): Promise<any>

		/**
		 *  Authobject to use with LOGIN authentication. Requires self.user and
		 *         self.password to be set.
		 */
		auth_login(challenge?): Promise<any>
		auth_login$({ challenge }: { challenge?}): Promise<any>

		/**
		 * Log in on an SMTP server that requires authentication.
		 * 
		 *         The arguments are:
		 *             - user:         The user name to authenticate with.
		 *             - password:     The password for the authentication.
		 * 
		 *         Keyword arguments:
		 *             - initial_response_ok: Allow sending the RFC 4954 initial-response
		 *               to the AUTH command, if the authentication methods supports it.
		 * 
		 *         If there has been no previous EHLO or HELO command this session, this
		 *         method tries ESMTP EHLO first.
		 * 
		 *         This method will return normally if the authentication was successful.
		 * 
		 *         This method may raise the following exceptions:
		 * 
		 *          SMTPHeloError            The server didn't reply properly to
		 *                                   the helo greeting.
		 *          SMTPAuthenticationError  The server didn't accept the username/
		 *                                   password combination.
		 *          SMTPNotSupportedError    The AUTH command is not supported by the
		 *                                   server.
		 *          SMTPException            No suitable authentication method was
		 *                                   found.
		 *         
		 */
		login(user, password): Promise<any>
		login$({ user, password }): Promise<any>

		/**
		 * Puts the connection to the SMTP server into TLS mode.
		 * 
		 *         If there has been no previous EHLO or HELO command this session, this
		 *         method tries ESMTP EHLO first.
		 * 
		 *         If the server supports TLS, this will encrypt the rest of the SMTP
		 *         session. If you provide the keyfile and certfile parameters,
		 *         the identity of the SMTP server and client can be checked. This,
		 *         however, depends on whether the socket module really checks the
		 *         certificates.
		 * 
		 *         This method may raise the following exceptions:
		 * 
		 *          SMTPHeloError            The server didn't reply properly to
		 *                                   the helo greeting.
		 *         
		 */
		starttls(keyfile?, certfile?, context?): Promise<any>
		starttls$({ keyfile, certfile, context }: { keyfile?, certfile?, context?}): Promise<any>

		/**
		 * This command performs an entire mail transaction.
		 * 
		 *         The arguments are:
		 *             - from_addr    : The address sending this mail.
		 *             - to_addrs     : A list of addresses to send this mail to.  A bare
		 *                              string will be treated as a list with 1 address.
		 *             - msg          : The message to send.
		 *             - mail_options : List of ESMTP options (such as 8bitmime) for the
		 *                              mail command.
		 *             - rcpt_options : List of ESMTP options (such as DSN commands) for
		 *                              all the rcpt commands.
		 * 
		 *         msg may be a string containing characters in the ASCII range, or a byte
		 *         string.  A string is encoded to bytes using the ascii codec, and lone
		 *         \r and \n characters are converted to \r\n characters.
		 * 
		 *         If there has been no previous EHLO or HELO command this session, this
		 *         method tries ESMTP EHLO first.  If the server does ESMTP, message size
		 *         and each of the specified options will be passed to it.  If EHLO
		 *         fails, HELO will be tried and ESMTP options suppressed.
		 * 
		 *         This method will return normally if the mail is accepted for at least
		 *         one recipient.  It returns a dictionary, with one entry for each
		 *         recipient that was refused.  Each entry contains a tuple of the SMTP
		 *         error code and the accompanying error message sent by the server.
		 * 
		 *         This method may raise the following exceptions:
		 * 
		 *          SMTPHeloError          The server didn't reply properly to
		 *                                 the helo greeting.
		 *          SMTPRecipientsRefused  The server rejected ALL recipients
		 *                                 (no mail was sent).
		 *          SMTPSenderRefused      The server didn't accept the from_addr.
		 *          SMTPDataError          The server replied with an unexpected
		 *                                 error code (other than a refusal of
		 *                                 a recipient).
		 *          SMTPNotSupportedError  The mail_options parameter includes 'SMTPUTF8'
		 *                                 but the SMTPUTF8 extension is not supported by
		 *                                 the server.
		 * 
		 *         Note: the connection will be open even after an exception is raised.
		 * 
		 *         Example:
		 * 
		 *          >>> import smtplib
		 *          >>> s=smtplib.SMTP("localhost")
		 *          >>> tolist=["one@one.org","two@two.org","three@three.org","four@four.org"]
		 *          >>> msg = '''\
		 *          ... From: Me@my.org
		 *          ... Subject: testin'...
		 *          ...
		 *          ... This is a test '''
		 *          >>> s.sendmail("me@my.org",tolist,msg)
		 *          { "three@three.org" : ( 550 ,"User unknown" ) }
		 *          >>> s.quit()
		 * 
		 *         In the above example, the message was accepted for delivery to three
		 *         of the four addresses, and one was rejected, with the error code
		 *         550.  If all addresses are accepted, then the method will return an
		 *         empty dictionary.
		 * 
		 *         
		 */
		sendmail(from_addr, to_addrs, msg, mail_options?, rcpt_options?): Promise<any>
		sendmail$({ from_addr, to_addrs, msg, mail_options, rcpt_options }: { from_addr, to_addrs, msg, mail_options?, rcpt_options?}): Promise<any>

		/**
		 * Converts message to a bytestring and passes it to sendmail.
		 * 
		 *         The arguments are as for sendmail, except that msg is an
		 *         email.message.Message object.  If from_addr is None or to_addrs is
		 *         None, these arguments are taken from the headers of the Message as
		 *         described in RFC 2822 (a ValueError is raised if there is more than
		 *         one set of 'Resent-' headers).  Regardless of the values of from_addr and
		 *         to_addr, any Bcc field (or Resent-Bcc field, when the Message is a
		 *         resent) of the Message object won't be transmitted.  The Message
		 *         object is then serialized using email.generator.BytesGenerator and
		 *         sendmail is called to transmit the message.  If the sender or any of
		 *         the recipient addresses contain non-ASCII and the server advertises the
		 *         SMTPUTF8 capability, the policy is cloned with utf8 set to True for the
		 *         serialization, and SMTPUTF8 and BODY=8BITMIME are asserted on the send.
		 *         If the server does not support SMTPUTF8, an SMTPNotSupported error is
		 *         raised.  Otherwise the generator is called without modifying the
		 *         policy.
		 * 
		 *         
		 */
		send_message(msg, from_addr?, to_addrs?, mail_options?, rcpt_options?): Promise<any>
		send_message$({ msg, from_addr, to_addrs, mail_options, rcpt_options }: { msg, from_addr?, to_addrs?, mail_options?, rcpt_options?}): Promise<any>

		/**
		 * Close the connection to the SMTP server.
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>

		/**
		 * Terminate the SMTP session.
		 */
		quit(): Promise<any>
		quit$($: {}): Promise<any>
		debuglevel
		sock
		file
		helo_resp
		ehlo_msg
		ehlo_resp
		does_esmtp
		default_port
		vrfy
	}

	/**
	 *  This is a subclass derived from SMTP that connects over an SSL
	 *         encrypted socket (to use this class you need a socket module that was
	 *         compiled with SSL support). If host is not specified, '' (the local
	 *         host) is used. If port is omitted, the standard SMTP-over-SSL port
	 *         (465) is used.  local_hostname and source_address have the same meaning
	 *         as they do in the SMTP class.  keyfile and certfile are also optional -
	 *         they can contain a PEM formatted private key and certificate chain file
	 *         for the SSL connection. context also optional, can contain a
	 *         SSLContext, and is an alternative to keyfile and certfile; If it is
	 *         specified both keyfile and certfile must be None.
	 * 
	 *         
	 */
	function SMTP_SSL(host?, port?, local_hostname?, keyfile?, certfile?, timeout?, source_address?, context?): Promise<ISMTP_SSL>
	function SMTP_SSL$({ host, port, local_hostname, keyfile, certfile, timeout, source_address, context }: { host?, port?, local_hostname?, keyfile?, certfile?, timeout?, source_address?, context?}): Promise<ISMTP_SSL>
	interface ISMTP_SSL extends ISMTP {
	}

	/**
	 * LMTP - Local Mail Transfer Protocol
	 * 
	 *     The LMTP protocol, which is very similar to ESMTP, is heavily based
	 *     on the standard SMTP client. It's common to use Unix sockets for
	 *     LMTP, so our connect() method must support that as well as a regular
	 *     host:port server.  local_hostname and source_address have the same
	 *     meaning as they do in the SMTP class.  To specify a Unix socket,
	 *     you must use an absolute path as the host, starting with a '/'.
	 * 
	 *     Authentication is supported, using the regular SMTP mechanism. When
	 *     using a Unix socket, LMTP generally don't support or require any
	 *     authentication, but your mileage might vary.
	 */

	/**
	 * Initialize a new instance.
	 */
	function LMTP(host?, port?, local_hostname?, source_address?, timeout?): Promise<ILMTP>
	function LMTP$({ host, port, local_hostname, source_address, timeout }: { host?, port?, local_hostname?, source_address?, timeout?}): Promise<ILMTP>
	interface ILMTP extends ISMTP {

		/**
		 * Connect to the LMTP daemon, on either a Unix or a TCP socket.
		 */
		connect(host?, port?, source_address?): Promise<any>
		connect$({ host, port, source_address }: { host?, port?, source_address?}): Promise<any>
	}
	let SMTP_PORT: Promise<any>
	let SMTP_SSL_PORT: Promise<any>
	let CRLF: Promise<any>
	let bCRLF: Promise<any>
	let OLDSTYLE_AUTH: Promise<any>
	let LMTP_PORT: Promise<any>
	let fromaddr: Promise<any>
	let toaddrs: Promise<any>
	let msg: Promise<any>
	let line: Promise<any>
	let server: Promise<any>
}
declare module sndhdr {
	var _

	/**
	 * Guess the type of a sound file.
	 */
	function what(filename): Promise<any>
	function what$({ filename }): Promise<any>

	/**
	 * Recognize sound headers.
	 */
	function whathdr(filename): Promise<any>
	function whathdr$({ filename }): Promise<any>
	function test_aifc(h, f): Promise<any>
	function test_aifc$({ h, f }): Promise<any>
	function test_au(h, f): Promise<any>
	function test_au$({ h, f }): Promise<any>
	function test_hcom(h, f): Promise<any>
	function test_hcom$({ h, f }): Promise<any>
	function test_voc(h, f): Promise<any>
	function test_voc$({ h, f }): Promise<any>
	function test_wav(h, f): Promise<any>
	function test_wav$({ h, f }): Promise<any>
	function test_8svx(h, f): Promise<any>
	function test_8svx$({ h, f }): Promise<any>
	function test_sndt(h, f): Promise<any>
	function test_sndt$({ h, f }): Promise<any>
	function test_sndr(h, f): Promise<any>
	function test_sndr$({ h, f }): Promise<any>
	function get_long_be(b): Promise<any>
	function get_long_be$({ b }): Promise<any>
	function get_long_le(b): Promise<any>
	function get_long_le$({ b }): Promise<any>
	function get_short_be(b): Promise<any>
	function get_short_be$({ b }): Promise<any>
	function get_short_le(b): Promise<any>
	function get_short_le$({ b }): Promise<any>
	function test(): Promise<any>
	function test$($: {}): Promise<any>
	function testall(list, recursive, toplevel): Promise<any>
	function testall$({ list, recursive, toplevel }): Promise<any>
	let SndHeaders: Promise<any>
	let tests: Promise<any>
}
declare module socket {
	var _

	/**
	 *  fromfd(fd, family, type[, proto]) -> socket object
	 * 
	 *     Create a socket object from a duplicate of the given file
	 *     descriptor.  The remaining arguments are the same as for socket().
	 *     
	 */
	function fromfd(fd, family, type, proto?): Promise<any>
	function fromfd$({ fd, family, type, proto }: { fd, family, type, proto?}): Promise<any>

	/**
	 *  send_fds(sock, buffers, fds[, flags[, address]]) -> integer
	 * 
	 *         Send the list of file descriptors fds over an AF_UNIX socket.
	 *         
	 */
	function send_fds(sock, buffers, fds, flags?, address?): Promise<any>
	function send_fds$({ sock, buffers, fds, flags, address }: { sock, buffers, fds, flags?, address?}): Promise<any>

	/**
	 *  recv_fds(sock, bufsize, maxfds[, flags]) -> (data, list of file
	 *         descriptors, msg_flags, address)
	 * 
	 *         Receive up to maxfds file descriptors returning the message
	 *         data and a list containing the descriptors.
	 *         
	 */
	function recv_fds(sock, bufsize, maxfds, flags?): Promise<any>
	function recv_fds$({ sock, bufsize, maxfds, flags }: { sock, bufsize, maxfds, flags?}): Promise<any>

	/**
	 *  fromshare(info) -> socket object
	 * 
	 *         Create a socket object from the bytes object returned by
	 *         socket.share(pid).
	 *         
	 */
	function fromshare(info): Promise<any>
	function fromshare$({ info }): Promise<any>

	/**
	 * socketpair([family[, type[, proto]]]) -> (socket object, socket object)
	 * 
	 *         Create a pair of socket objects from the sockets returned by the platform
	 *         socketpair() function.
	 *         The arguments are the same as for socket() except the default family is
	 *         AF_UNIX if defined on the platform; otherwise, the default is AF_INET.
	 *         
	 */
	function socketpair(family?, type?, proto?): Promise<any>
	function socketpair$({ family, type, proto }: { family?, type?, proto?}): Promise<any>
	function socketpair(family?, type?, proto?): Promise<any>
	function socketpair$({ family, type, proto }: { family?, type?, proto?}): Promise<any>

	/**
	 * Get fully qualified domain name from name.
	 * 
	 *     An empty argument is interpreted as meaning the local host.
	 * 
	 *     First the hostname returned by gethostbyaddr() is checked, then
	 *     possibly existing aliases. In case no FQDN is available, hostname
	 *     from gethostname() is returned.
	 *     
	 */
	function getfqdn(name?): Promise<any>
	function getfqdn$({ name }: { name?}): Promise<any>

	/**
	 * Connect to *address* and return the socket object.
	 * 
	 *     Convenience function.  Connect to *address* (a 2-tuple ``(host,
	 *     port)``) and return the socket object.  Passing the optional
	 *     *timeout* parameter will set the timeout on the socket instance
	 *     before attempting to connect.  If no *timeout* is supplied, the
	 *     global default timeout setting returned by :func:`getdefaulttimeout`
	 *     is used.  If *source_address* is set it must be a tuple of (host, port)
	 *     for the socket to bind as a source address before making the connection.
	 *     A host of '' or port 0 tells the OS to use the default.
	 *     
	 */
	function create_connection(address, timeout?, source_address?): Promise<any>
	function create_connection$({ address, timeout, source_address }: { address, timeout?, source_address?}): Promise<any>

	/**
	 * Return True if the platform supports creating a SOCK_STREAM socket
	 *     which can handle both AF_INET and AF_INET6 (IPv4 / IPv6) connections.
	 *     
	 */
	function has_dualstack_ipv6(): Promise<any>
	function has_dualstack_ipv6$($: {}): Promise<any>

	/**
	 * Convenience function which creates a SOCK_STREAM type socket
	 *     bound to *address* (a 2-tuple (host, port)) and return the socket
	 *     object.
	 * 
	 *     *family* should be either AF_INET or AF_INET6.
	 *     *backlog* is the queue size passed to socket.listen().
	 *     *reuse_port* dictates whether to use the SO_REUSEPORT socket option.
	 *     *dualstack_ipv6*: if true and the platform supports it, it will
	 *     create an AF_INET6 socket able to accept both IPv4 or IPv6
	 *     connections. When false it will explicitly disable this option on
	 *     platforms that enable it by default (e.g. Linux).
	 * 
	 *     >>> with create_server(('', 8000)) as server:
	 *     ...     while True:
	 *     ...         conn, addr = server.accept()
	 *     ...         # handle new connection
	 *     
	 */
	function create_server(address): Promise<any>
	function create_server$({ address }): Promise<any>

	/**
	 * Resolve host and port into list of address info entries.
	 * 
	 *     Translate the host/port argument into a sequence of 5-tuples that contain
	 *     all the necessary arguments for creating a socket connected to that service.
	 *     host is a domain name, a string representation of an IPv4/v6 address or
	 *     None. port is a string service name such as 'http', a numeric port number or
	 *     None. By passing None as the value of host and port, you can pass NULL to
	 *     the underlying C API.
	 * 
	 *     The family, type and proto arguments can be optionally specified in order to
	 *     narrow the list of addresses returned. Passing zero as a value for each of
	 *     these arguments selects the full range of results.
	 *     
	 */
	function getaddrinfo(host, port, family?, type?, proto?, flags?): Promise<any>
	function getaddrinfo$({ host, port, family, type, proto, flags }: { host, port, family?, type?, proto?, flags?}): Promise<any>
	interface I_GiveupOnSendfile {
	}

	/**
	 * A subclass of _socket.socket adding the makefile() method.
	 */
	function socket(family?, type?, proto?, fileno?): Promise<Isocket>
	function socket$({ family, type, proto, fileno }: { family?, type?, proto?, fileno?}): Promise<Isocket>
	interface Isocket {

		/**
		 * dup() -> socket object
		 * 
		 *         Duplicate the socket. Return a new socket object connected to the same
		 *         system resource. The new socket is non-inheritable.
		 *         
		 */
		dup(): Promise<any>
		dup$($: {}): Promise<any>

		/**
		 * accept() -> (socket object, address info)
		 * 
		 *         Wait for an incoming connection.  Return a new socket
		 *         representing the connection, and the address of the client.
		 *         For IP sockets, the address info is a pair (hostaddr, port).
		 *         
		 */
		accept(): Promise<any>
		accept$($: {}): Promise<any>

		/**
		 * makefile(...) -> an I/O stream connected to the socket
		 * 
		 *         The arguments are as for io.open() after the filename, except the only
		 *         supported mode values are 'r' (default), 'w' and 'b'.
		 *         
		 */
		makefile(mode?, buffering?): Promise<any>
		makefile$({ mode, buffering }: { mode?, buffering?}): Promise<any>

		/**
		 * sendfile(file[, offset[, count]]) -> sent
		 * 
		 *         Send a file until EOF is reached by using high-performance
		 *         os.sendfile() and return the total number of bytes which
		 *         were sent.
		 *         *file* must be a regular file object opened in binary mode.
		 *         If os.sendfile() is not available (e.g. Windows) or file is
		 *         not a regular file socket.send() will be used instead.
		 *         *offset* tells from where to start reading the file.
		 *         If specified, *count* is the total number of bytes to transmit
		 *         as opposed to sending the file until EOF is reached.
		 *         File position is updated on return or also in case of error in
		 *         which case file.tell() can be used to figure out the number of
		 *         bytes which were sent.
		 *         The socket must be of SOCK_STREAM type.
		 *         Non-blocking sockets are not supported.
		 *         
		 */
		sendfile(file, offset?, count?): Promise<any>
		sendfile$({ file, offset, count }: { file, offset?, count?}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>

		/**
		 * detach() -> file descriptor
		 * 
		 *         Close the socket object without closing the underlying file descriptor.
		 *         The object cannot be used after this call, but the file descriptor
		 *         can be reused for other purposes.  The file descriptor is returned.
		 *         
		 */
		detach(): Promise<any>
		detach$($: {}): Promise<any>

		/**
		 * Read-only access to the address family for this socket.
		 *         
		 */
		family(): Promise<any>
		family$($: {}): Promise<any>

		/**
		 * Read-only access to the socket type.
		 *         
		 */
		type(): Promise<any>
		type$($: {}): Promise<any>
	}

	/**
	 * Raw I/O implementation for stream sockets.
	 * 
	 *     This class supports the makefile() method on sockets.  It provides
	 *     the raw I/O interface on top of a socket object.
	 *     
	 */
	function SocketIO(sock, mode): Promise<ISocketIO>
	function SocketIO$({ sock, mode }): Promise<ISocketIO>
	interface ISocketIO {

		/**
		 * Read up to len(b) bytes into the writable buffer *b* and return
		 *         the number of bytes read.  If the socket is non-blocking and no bytes
		 *         are available, None is returned.
		 * 
		 *         If *b* is non-empty, a 0 return value indicates that the connection
		 *         was shutdown at the other end.
		 *         
		 */
		readinto(b): Promise<any>
		readinto$({ b }): Promise<any>

		/**
		 * Write the given bytes or bytearray object *b* to the socket
		 *         and return the number of bytes written.  This can be less than
		 *         len(b) if not all data could be written.  If the socket is
		 *         non-blocking and no bytes could be written None is returned.
		 *         
		 */
		write(b): Promise<any>
		write$({ b }): Promise<any>

		/**
		 * True if the SocketIO is open for reading.
		 *         
		 */
		readable(): Promise<any>
		readable$($: {}): Promise<any>

		/**
		 * True if the SocketIO is open for writing.
		 *         
		 */
		writable(): Promise<any>
		writable$($: {}): Promise<any>

		/**
		 * True if the SocketIO is open for seeking.
		 *         
		 */
		seekable(): Promise<any>
		seekable$($: {}): Promise<any>

		/**
		 * Return the file descriptor of the underlying socket.
		 *         
		 */
		fileno(): Promise<any>
		fileno$($: {}): Promise<any>
		name(): Promise<any>
		name$($: {}): Promise<any>
		mode(): Promise<any>
		mode$($: {}): Promise<any>

		/**
		 * Close the SocketIO object.  This doesn't close the underlying
		 *         socket, except if all references to it have disappeared.
		 *         
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>
	}
	let EBADF: Promise<any>
	let EAGAIN: Promise<any>
	let EWOULDBLOCK: Promise<any>
	let errorTab: Promise<any>
}
declare module socketserver {
	var _

	/**
	 * Base class for server classes.
	 * 
	 *     Methods for the caller:
	 * 
	 *     - __init__(server_address, RequestHandlerClass)
	 *     - serve_forever(poll_interval=0.5)
	 *     - shutdown()
	 *     - handle_request()  # if you do not use serve_forever()
	 *     - fileno() -> int   # for selector
	 * 
	 *     Methods that may be overridden:
	 * 
	 *     - server_bind()
	 *     - server_activate()
	 *     - get_request() -> request, client_address
	 *     - handle_timeout()
	 *     - verify_request(request, client_address)
	 *     - server_close()
	 *     - process_request(request, client_address)
	 *     - shutdown_request(request)
	 *     - close_request(request)
	 *     - service_actions()
	 *     - handle_error()
	 * 
	 *     Methods for derived classes:
	 * 
	 *     - finish_request(request, client_address)
	 * 
	 *     Class variables that may be overridden by derived classes or
	 *     instances:
	 * 
	 *     - timeout
	 *     - address_family
	 *     - socket_type
	 *     - allow_reuse_address
	 * 
	 *     Instance variables:
	 * 
	 *     - RequestHandlerClass
	 *     - socket
	 * 
	 *     
	 */

	/**
	 * Constructor.  May be extended, do not override.
	 */
	function BaseServer(server_address, RequestHandlerClass): Promise<IBaseServer>
	function BaseServer$({ server_address, RequestHandlerClass }): Promise<IBaseServer>
	interface IBaseServer {

		/**
		 * Called by constructor to activate the server.
		 * 
		 *         May be overridden.
		 * 
		 *         
		 */
		server_activate(): Promise<any>
		server_activate$($: {}): Promise<any>

		/**
		 * Handle one request at a time until shutdown.
		 * 
		 *         Polls for shutdown every poll_interval seconds. Ignores
		 *         self.timeout. If you need to do periodic tasks, do them in
		 *         another thread.
		 *         
		 */
		serve_forever(poll_interval?): Promise<any>
		serve_forever$({ poll_interval }: { poll_interval?}): Promise<any>

		/**
		 * Stops the serve_forever loop.
		 * 
		 *         Blocks until the loop has finished. This must be called while
		 *         serve_forever() is running in another thread, or it will
		 *         deadlock.
		 *         
		 */
		shutdown(): Promise<any>
		shutdown$($: {}): Promise<any>

		/**
		 * Called by the serve_forever() loop.
		 * 
		 *         May be overridden by a subclass / Mixin to implement any code that
		 *         needs to be run during the loop.
		 *         
		 */
		service_actions(): Promise<any>
		service_actions$($: {}): Promise<any>

		/**
		 * Handle one request, possibly blocking.
		 * 
		 *         Respects self.timeout.
		 *         
		 */
		handle_request(): Promise<any>
		handle_request$($: {}): Promise<any>

		/**
		 * Called if no new request arrives within self.timeout.
		 * 
		 *         Overridden by ForkingMixIn.
		 *         
		 */
		handle_timeout(): Promise<any>
		handle_timeout$($: {}): Promise<any>

		/**
		 * Verify the request.  May be overridden.
		 * 
		 *         Return True if we should proceed with this request.
		 * 
		 *         
		 */
		verify_request(request, client_address): Promise<any>
		verify_request$({ request, client_address }): Promise<any>

		/**
		 * Call finish_request.
		 * 
		 *         Overridden by ForkingMixIn and ThreadingMixIn.
		 * 
		 *         
		 */
		process_request(request, client_address): Promise<any>
		process_request$({ request, client_address }): Promise<any>

		/**
		 * Called to clean-up the server.
		 * 
		 *         May be overridden.
		 * 
		 *         
		 */
		server_close(): Promise<any>
		server_close$($: {}): Promise<any>

		/**
		 * Finish one request by instantiating RequestHandlerClass.
		 */
		finish_request(request, client_address): Promise<any>
		finish_request$({ request, client_address }): Promise<any>

		/**
		 * Called to shutdown and close an individual request.
		 */
		shutdown_request(request): Promise<any>
		shutdown_request$({ request }): Promise<any>

		/**
		 * Called to clean up an individual request.
		 */
		close_request(request): Promise<any>
		close_request$({ request }): Promise<any>

		/**
		 * Handle an error gracefully.  May be overridden.
		 * 
		 *         The default is to print a traceback and continue.
		 * 
		 *         
		 */
		handle_error(request, client_address): Promise<any>
		handle_error$({ request, client_address }): Promise<any>
		timeout
	}

	/**
	 * Base class for various socket-based server classes.
	 * 
	 *     Defaults to synchronous IP stream (i.e., TCP).
	 * 
	 *     Methods for the caller:
	 * 
	 *     - __init__(server_address, RequestHandlerClass, bind_and_activate=True)
	 *     - serve_forever(poll_interval=0.5)
	 *     - shutdown()
	 *     - handle_request()  # if you don't use serve_forever()
	 *     - fileno() -> int   # for selector
	 * 
	 *     Methods that may be overridden:
	 * 
	 *     - server_bind()
	 *     - server_activate()
	 *     - get_request() -> request, client_address
	 *     - handle_timeout()
	 *     - verify_request(request, client_address)
	 *     - process_request(request, client_address)
	 *     - shutdown_request(request)
	 *     - close_request(request)
	 *     - handle_error()
	 * 
	 *     Methods for derived classes:
	 * 
	 *     - finish_request(request, client_address)
	 * 
	 *     Class variables that may be overridden by derived classes or
	 *     instances:
	 * 
	 *     - timeout
	 *     - address_family
	 *     - socket_type
	 *     - request_queue_size (only for stream sockets)
	 *     - allow_reuse_address
	 * 
	 *     Instance variables:
	 * 
	 *     - server_address
	 *     - RequestHandlerClass
	 *     - socket
	 * 
	 *     
	 */

	/**
	 * Constructor.  May be extended, do not override.
	 */
	function TCPServer(server_address, RequestHandlerClass, bind_and_activate?: boolean): Promise<ITCPServer>
	function TCPServer$({ server_address, RequestHandlerClass, bind_and_activate }: { server_address, RequestHandlerClass, bind_and_activate?}): Promise<ITCPServer>
	interface ITCPServer extends IBaseServer {

		/**
		 * Called by constructor to bind the socket.
		 * 
		 *         May be overridden.
		 * 
		 *         
		 */
		server_bind(): Promise<any>
		server_bind$($: {}): Promise<any>

		/**
		 * Called by constructor to activate the server.
		 * 
		 *         May be overridden.
		 * 
		 *         
		 */
		server_activate(): Promise<any>
		server_activate$($: {}): Promise<any>

		/**
		 * Called to clean-up the server.
		 * 
		 *         May be overridden.
		 * 
		 *         
		 */
		server_close(): Promise<any>
		server_close$($: {}): Promise<any>

		/**
		 * Return socket file number.
		 * 
		 *         Interface required by selector.
		 * 
		 *         
		 */
		fileno(): Promise<any>
		fileno$($: {}): Promise<any>

		/**
		 * Get the request and client address from the socket.
		 * 
		 *         May be overridden.
		 * 
		 *         
		 */
		get_request(): Promise<any>
		get_request$($: {}): Promise<any>

		/**
		 * Called to shutdown and close an individual request.
		 */
		shutdown_request(request): Promise<any>
		shutdown_request$({ request }): Promise<any>

		/**
		 * Called to clean up an individual request.
		 */
		close_request(request): Promise<any>
		close_request$({ request }): Promise<any>
		address_family
		socket_type
		request_queue_size
		allow_reuse_address
	}

	/**
	 * UDP server class.
	 */
	interface IUDPServer extends ITCPServer {
		get_request(): Promise<any>
		get_request$($: {}): Promise<any>
		server_activate(): Promise<any>
		server_activate$($: {}): Promise<any>
		shutdown_request(request): Promise<any>
		shutdown_request$({ request }): Promise<any>
		close_request(request): Promise<any>
		close_request$({ request }): Promise<any>
		max_packet_size
	}

	/**
	 * Mix-in class to handle each request in a new process.
	 */
	interface IForkingMixIn {

		/**
		 * Internal routine to wait for children that have exited.
		 */
		collect_children(): Promise<any>
		collect_children$($: {}): Promise<any>

		/**
		 * Wait for zombies after self.timeout seconds of inactivity.
		 * 
		 *             May be extended, do not override.
		 *             
		 */
		handle_timeout(): Promise<any>
		handle_timeout$($: {}): Promise<any>

		/**
		 * Collect the zombie child processes regularly in the ForkingMixIn.
		 * 
		 *             service_actions is called in the BaseServer's serve_forever loop.
		 *             
		 */
		service_actions(): Promise<any>
		service_actions$($: {}): Promise<any>

		/**
		 * Fork a new subprocess to process the request.
		 */
		process_request(request, client_address): Promise<any>
		process_request$({ request, client_address }): Promise<any>
		server_close(): Promise<any>
		server_close$($: {}): Promise<any>
		active_children
		max_children
		block_on_close
	}

	/**
	 * 
	 *     Joinable list of all non-daemon threads.
	 *     
	 */
	interface I_Threads {
		append(thread): Promise<any>
		append$({ thread }): Promise<any>
		pop_all(): Promise<any>
		pop_all$($: {}): Promise<any>
		join(): Promise<any>
		join$($: {}): Promise<any>
		reap(): Promise<any>
		reap$($: {}): Promise<any>
	}

	/**
	 * 
	 *     Degenerate version of _Threads.
	 *     
	 */
	interface I_NoThreads {
		append(thread): Promise<any>
		append$({ thread }): Promise<any>
		join(): Promise<any>
		join$($: {}): Promise<any>
	}

	/**
	 * Mix-in class to handle each request in a new thread.
	 */
	interface IThreadingMixIn {

		/**
		 * Same as in BaseServer but as a thread.
		 * 
		 *         In addition, exception handling is done here.
		 * 
		 *         
		 */
		process_request_thread(request, client_address): Promise<any>
		process_request_thread$({ request, client_address }): Promise<any>

		/**
		 * Start a new thread to process the request.
		 */
		process_request(request, client_address): Promise<any>
		process_request$({ request, client_address }): Promise<any>
		server_close(): Promise<any>
		server_close$($: {}): Promise<any>
		daemon_threads
	}
	interface IForkingUDPServer extends IForkingMixIn, IUDPServer {
	}
	interface IForkingTCPServer extends IForkingMixIn, ITCPServer {
	}
	interface IThreadingUDPServer extends IThreadingMixIn, IUDPServer {
	}
	interface IThreadingTCPServer extends IThreadingMixIn, ITCPServer {
	}
	interface IUnixStreamServer extends ITCPServer {
	}
	interface IUnixDatagramServer extends IUDPServer {
	}
	interface IThreadingUnixStreamServer extends IThreadingMixIn, IUnixStreamServer {
	}
	interface IThreadingUnixDatagramServer extends IThreadingMixIn, IUnixDatagramServer {
	}

	/**
	 * Base class for request handler classes.
	 * 
	 *     This class is instantiated for each request to be handled.  The
	 *     constructor sets the instance variables request, client_address
	 *     and server, and then calls the handle() method.  To implement a
	 *     specific service, all you need to do is to derive a class which
	 *     defines a handle() method.
	 * 
	 *     The handle() method can find the request as self.request, the
	 *     client address as self.client_address, and the server (in case it
	 *     needs access to per-server information) as self.server.  Since a
	 *     separate instance is created for each request, the handle() method
	 *     can define other arbitrary instance variables.
	 * 
	 *     
	 */
	function BaseRequestHandler(request, client_address, server): Promise<IBaseRequestHandler>
	function BaseRequestHandler$({ request, client_address, server }): Promise<IBaseRequestHandler>
	interface IBaseRequestHandler {
		setup(): Promise<any>
		setup$($: {}): Promise<any>
		handle(): Promise<any>
		handle$($: {}): Promise<any>
		finish(): Promise<any>
		finish$($: {}): Promise<any>
	}

	/**
	 * Define self.rfile and self.wfile for stream sockets.
	 */
	interface IStreamRequestHandler extends IBaseRequestHandler {
		setup(): Promise<any>
		setup$($: {}): Promise<any>
		finish(): Promise<any>
		finish$($: {}): Promise<any>
		rbufsize
		wbufsize
		disable_nagle_algorithm
	}

	/**
	 * Simple writable BufferedIOBase implementation for a socket
	 * 
	 *     Does not hold data in a buffer, avoiding any need to call flush().
	 */
	interface I_SocketWriter {
		writable(): Promise<any>
		writable$($: {}): Promise<any>
		write(b): Promise<any>
		write$({ b }): Promise<any>
		fileno(): Promise<any>
		fileno$($: {}): Promise<any>
	}

	/**
	 * Define self.rfile and self.wfile for datagram sockets.
	 */
	interface IDatagramRequestHandler extends IBaseRequestHandler {
		setup(): Promise<any>
		setup$($: {}): Promise<any>
		finish(): Promise<any>
		finish$($: {}): Promise<any>
	}
}
declare module sqlite3 {
	var _
	module dbapi2 {
		var _
		function DateFromTicks(ticks): Promise<any>
		function DateFromTicks$({ ticks }): Promise<any>
		function TimeFromTicks(ticks): Promise<any>
		function TimeFromTicks$({ ticks }): Promise<any>
		function TimestampFromTicks(ticks): Promise<any>
		function TimestampFromTicks$({ ticks }): Promise<any>
		function register_adapters_and_converters(): Promise<any>
		function register_adapters_and_converters$($: {}): Promise<any>
		function enable_shared_cache(enable): Promise<any>
		function enable_shared_cache$({ enable }): Promise<any>
		let paramstyle: Promise<any>
		let threadsafety: Promise<any>
		let apilevel: Promise<any>
		let Date: Promise<any>
		let Time: Promise<any>
		let Timestamp: Promise<any>
		let version_info: Promise<any>
		let sqlite_version_info: Promise<any>
		let Binary: Promise<any>
	}
	module dump {
		var _
	}
}
declare module sre_compile {
	var _
	function isstring(obj): Promise<any>
	function isstring$({ obj }): Promise<any>
	function dis(code): Promise<any>
	function dis$({ code }): Promise<any>
	function compile(p, flags?): Promise<any>
	function compile$({ p, flags }: { p, flags?}): Promise<any>
	let MAXCODE: Promise<any>
}
declare module sre_constants {
	var _
	function dump(f, d, prefix): Promise<any>
	function dump$({ f, d, prefix }): Promise<any>

	/**
	 * Exception raised for invalid regular expressions.
	 * 
	 *     Attributes:
	 * 
	 *         msg: The unformatted error message
	 *         pattern: The regular expression pattern
	 *         pos: The index in the pattern where compilation failed (may be None)
	 *         lineno: The line corresponding to pos (may be None)
	 *         colno: The column corresponding to pos (may be None)
	 *     
	 */
	function error(msg, pattern?, pos?): Promise<Ierror>
	function error$({ msg, pattern, pos }: { msg, pattern?, pos?}): Promise<Ierror>
	interface Ierror {
	}
	interface I_NamedIntConstant {
	}
	let MAGIC: Promise<any>
	let MAXREPEAT: Promise<any>
	let OPCODES: Promise<any>
	let ATCODES: Promise<any>
	let CHCODES: Promise<any>
	let OP_IGNORE: Promise<any>
	let OP_LOCALE_IGNORE: Promise<any>
	let OP_UNICODE_IGNORE: Promise<any>
	let AT_MULTILINE: Promise<any>
	let AT_LOCALE: Promise<any>
	let AT_UNICODE: Promise<any>
	let CH_LOCALE: Promise<any>
	let CH_UNICODE: Promise<any>
	let SRE_FLAG_TEMPLATE: Promise<any>
	let SRE_FLAG_IGNORECASE: Promise<any>
	let SRE_FLAG_LOCALE: Promise<any>
	let SRE_FLAG_MULTILINE: Promise<any>
	let SRE_FLAG_DOTALL: Promise<any>
	let SRE_FLAG_UNICODE: Promise<any>
	let SRE_FLAG_VERBOSE: Promise<any>
	let SRE_FLAG_DEBUG: Promise<any>
	let SRE_FLAG_ASCII: Promise<any>
	let SRE_INFO_PREFIX: Promise<any>
	let SRE_INFO_LITERAL: Promise<any>
	let SRE_INFO_CHARSET: Promise<any>
}
declare module sre_parse {
	var _
	function fix_flags(src, flags): Promise<any>
	function fix_flags$({ src, flags }): Promise<any>
	function parse(str, flags?, state?): Promise<any>
	function parse$({ str, flags, state }: { str, flags?, state?}): Promise<any>
	function parse_template(source, state): Promise<any>
	function parse_template$({ source, state }): Promise<any>
	function expand_template(template, match): Promise<any>
	function expand_template$({ template, match }): Promise<any>
	interface IVerbose {
	}
	function State(): Promise<IState>
	function State$({ }): Promise<IState>
	interface IState {
		groups(): Promise<any>
		groups$($: {}): Promise<any>
		opengroup(name?): Promise<any>
		opengroup$({ name }: { name?}): Promise<any>
		closegroup(gid, p): Promise<any>
		closegroup$({ gid, p }): Promise<any>
		checkgroup(gid): Promise<any>
		checkgroup$({ gid }): Promise<any>
		checklookbehindgroup(gid, source): Promise<any>
		checklookbehindgroup$({ gid, source }): Promise<any>
	}
	function SubPattern(state, data?): Promise<ISubPattern>
	function SubPattern$({ state, data }: { state, data?}): Promise<ISubPattern>
	interface ISubPattern {
		dump(level?): Promise<any>
		dump$({ level }: { level?}): Promise<any>
		insert(index, code): Promise<any>
		insert$({ index, code }): Promise<any>
		append(code): Promise<any>
		append$({ code }): Promise<any>
		getwidth(): Promise<any>
		getwidth$($: {}): Promise<any>
	}
	function Tokenizer(string): Promise<ITokenizer>
	function Tokenizer$({ string }): Promise<ITokenizer>
	interface ITokenizer {
		match(char): Promise<any>
		match$({ char }): Promise<any>
		get(): Promise<any>
		get$($: {}): Promise<any>
		getwhile(n, charset): Promise<any>
		getwhile$({ n, charset }): Promise<any>
		getuntil(terminator, name): Promise<any>
		getuntil$({ terminator, name }): Promise<any>
		pos(): Promise<any>
		pos$($: {}): Promise<any>
		tell(): Promise<any>
		tell$($: {}): Promise<any>
		seek(index): Promise<any>
		seek$({ index }): Promise<any>
		error(msg, offset?): Promise<any>
		error$({ msg, offset }: { msg, offset?}): Promise<any>
	}
	let SPECIAL_CHARS: Promise<any>
	let REPEAT_CHARS: Promise<any>
	let DIGITS: Promise<any>
	let OCTDIGITS: Promise<any>
	let HEXDIGITS: Promise<any>
	let ASCIILETTERS: Promise<any>
	let WHITESPACE: Promise<any>
	let ESCAPES: Promise<any>
	let CATEGORIES: Promise<any>
	let FLAGS: Promise<any>
	let TYPE_FLAGS: Promise<any>
	let GLOBAL_FLAGS: Promise<any>
}
declare module ssl {
	var _

	/**
	 * Verify that *cert* (in decoded format as returned by
	 *     SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125
	 *     rules are followed.
	 * 
	 *     The function matches IP addresses rather than dNSNames if hostname is a
	 *     valid ipaddress string. IPv4 addresses are supported on all platforms.
	 *     IPv6 addresses are supported on platforms with IPv6 support (AF_INET6
	 *     and inet_pton).
	 * 
	 *     CertificateError is raised on failure. On success, the function
	 *     returns nothing.
	 *     
	 */
	function match_hostname(cert, hostname): Promise<any>
	function match_hostname$({ cert, hostname }): Promise<any>

	/**
	 * Return paths to default cafile and capath.
	 *     
	 */
	function get_default_verify_paths(): Promise<any>
	function get_default_verify_paths$($: {}): Promise<any>

	/**
	 * Create a SSLContext object with default settings.
	 * 
	 *     NOTE: The protocol and settings may change anytime without prior
	 *           deprecation. The values represent a fair balance between maximum
	 *           compatibility and security.
	 *     
	 */
	function create_default_context(purpose?): Promise<any>
	function create_default_context$({ purpose }: { purpose?}): Promise<any>
	function wrap_socket(sock, keyfile?, certfile?, server_side?: boolean, cert_reqs?, ssl_version?, ca_certs?, do_handshake_on_connect?: boolean, suppress_ragged_eofs?: boolean, ciphers?): Promise<any>
	function wrap_socket$({ sock, keyfile, certfile, server_side, cert_reqs, ssl_version, ca_certs, do_handshake_on_connect, suppress_ragged_eofs, ciphers }: { sock, keyfile?, certfile?, server_side?, cert_reqs?, ssl_version?, ca_certs?, do_handshake_on_connect?, suppress_ragged_eofs?, ciphers?}): Promise<any>

	/**
	 * Return the time in seconds since the Epoch, given the timestring
	 *     representing the "notBefore" or "notAfter" date from a certificate
	 *     in ``"%b %d %H:%M:%S %Y %Z"`` strptime format (C locale).
	 * 
	 *     "notBefore" or "notAfter" dates must use UTC (RFC 5280).
	 * 
	 *     Month is one of: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
	 *     UTC should be specified as GMT (see ASN1_TIME_print())
	 *     
	 */
	function cert_time_to_seconds(cert_time): Promise<any>
	function cert_time_to_seconds$({ cert_time }): Promise<any>

	/**
	 * Takes a certificate in binary DER format and returns the
	 *     PEM version of it as a string.
	 */
	function DER_cert_to_PEM_cert(der_cert_bytes): Promise<any>
	function DER_cert_to_PEM_cert$({ der_cert_bytes }): Promise<any>

	/**
	 * Takes a certificate in ASCII PEM format and returns the
	 *     DER-encoded version of it as a byte sequence
	 */
	function PEM_cert_to_DER_cert(pem_cert_string): Promise<any>
	function PEM_cert_to_DER_cert$({ pem_cert_string }): Promise<any>

	/**
	 * Retrieve the certificate from the server at the specified address,
	 *     and return it as a PEM-encoded string.
	 *     If 'ca_certs' is specified, validate the server cert against it.
	 *     If 'ssl_version' is specified, use it in the connection attempt.
	 *     If 'timeout' is specified, use it in the connection attempt.
	 *     
	 */
	function get_server_certificate(addr, ssl_version?, ca_certs?, timeout?): Promise<any>
	function get_server_certificate$({ addr, ssl_version, ca_certs, timeout }: { addr, ssl_version?, ca_certs?, timeout?}): Promise<any>
	function get_protocol_name(protocol_code): Promise<any>
	function get_protocol_name$({ protocol_code }): Promise<any>
	interface ITLSVersion {
		MINIMUM_SUPPORTED
		SSLv3
		TLSv1
		TLSv1_1
		TLSv1_2
		TLSv1_3
		MAXIMUM_SUPPORTED
	}

	/**
	 * Content types (record layer)
	 * 
	 *     See RFC 8446, section B.1
	 *     
	 */
	interface I_TLSContentType {
		CHANGE_CIPHER_SPEC
		ALERT
		HANDSHAKE
		APPLICATION_DATA
		HEADER
		INNER_CONTENT_TYPE
	}

	/**
	 * Alert types for TLSContentType.ALERT messages
	 * 
	 *     See RFC 8466, section B.2
	 *     
	 */
	interface I_TLSAlertType {
		CLOSE_NOTIFY
		UNEXPECTED_MESSAGE
		BAD_RECORD_MAC
		DECRYPTION_FAILED
		RECORD_OVERFLOW
		DECOMPRESSION_FAILURE
		HANDSHAKE_FAILURE
		NO_CERTIFICATE
		BAD_CERTIFICATE
		UNSUPPORTED_CERTIFICATE
		CERTIFICATE_REVOKED
		CERTIFICATE_EXPIRED
		CERTIFICATE_UNKNOWN
		ILLEGAL_PARAMETER
		UNKNOWN_CA
		ACCESS_DENIED
		DECODE_ERROR
		DECRYPT_ERROR
		EXPORT_RESTRICTION
		PROTOCOL_VERSION
		INSUFFICIENT_SECURITY
		INTERNAL_ERROR
		INAPPROPRIATE_FALLBACK
		USER_CANCELED
		NO_RENEGOTIATION
		MISSING_EXTENSION
		UNSUPPORTED_EXTENSION
		CERTIFICATE_UNOBTAINABLE
		UNRECOGNIZED_NAME
		BAD_CERTIFICATE_STATUS_RESPONSE
		BAD_CERTIFICATE_HASH_VALUE
		UNKNOWN_PSK_IDENTITY
		CERTIFICATE_REQUIRED
		NO_APPLICATION_PROTOCOL
	}

	/**
	 * Message types (handshake protocol)
	 * 
	 *     See RFC 8446, section B.3
	 *     
	 */
	interface I_TLSMessageType {
		HELLO_REQUEST
		CLIENT_HELLO
		SERVER_HELLO
		HELLO_VERIFY_REQUEST
		NEWSESSION_TICKET
		END_OF_EARLY_DATA
		HELLO_RETRY_REQUEST
		ENCRYPTED_EXTENSIONS
		CERTIFICATE
		SERVER_KEY_EXCHANGE
		CERTIFICATE_REQUEST
		SERVER_DONE
		CERTIFICATE_VERIFY
		CLIENT_KEY_EXCHANGE
		FINISHED
		CERTIFICATE_URL
		CERTIFICATE_STATUS
		SUPPLEMENTAL_DATA
		KEY_UPDATE
		NEXT_PROTO
		MESSAGE_HASH
	}

	/**
	 * ASN.1 object identifier lookup
	 *     
	 */
	interface I_ASN1Object {

		/**
		 * Create _ASN1Object from OpenSSL numeric ID
		 *         
		 */
		fromnid(nid): Promise<any>
		fromnid$({ nid }): Promise<any>

		/**
		 * Create _ASN1Object from short name, long name or OID
		 *         
		 */
		fromname(name): Promise<any>
		fromname$({ name }): Promise<any>
	}

	/**
	 * SSLContext purpose flags with X509v3 Extended Key Usage objects
	 *     
	 */
	interface IPurpose extends I_ASN1Object {
		SERVER_AUTH
		CLIENT_AUTH
	}

	/**
	 * An SSLContext holds various SSL-related configuration options and
	 *     data, such as certificates and possibly a private key.
	 */
	interface ISSLContext {
		wrap_socket(sock, server_side?: boolean, do_handshake_on_connect?: boolean, suppress_ragged_eofs?: boolean, server_hostname?, session?): Promise<any>
		wrap_socket$({ sock, server_side, do_handshake_on_connect, suppress_ragged_eofs, server_hostname, session }: { sock, server_side?, do_handshake_on_connect?, suppress_ragged_eofs?, server_hostname?, session?}): Promise<any>
		wrap_bio(incoming, outgoing, server_side?: boolean, server_hostname?, session?): Promise<any>
		wrap_bio$({ incoming, outgoing, server_side, server_hostname, session }: { incoming, outgoing, server_side?, server_hostname?, session?}): Promise<any>
		set_npn_protocols(npn_protocols): Promise<any>
		set_npn_protocols$({ npn_protocols }): Promise<any>
		set_servername_callback(server_name_callback): Promise<any>
		set_servername_callback$({ server_name_callback }): Promise<any>
		set_alpn_protocols(alpn_protocols): Promise<any>
		set_alpn_protocols$({ alpn_protocols }): Promise<any>
		load_default_certs(purpose?): Promise<any>
		load_default_certs$({ purpose }: { purpose?}): Promise<any>
		options(): Promise<any>
		options$($: {}): Promise<any>
		options(value): Promise<any>
		options$({ value }): Promise<any>
		protocol(): Promise<any>
		protocol$($: {}): Promise<any>
		verify_flags(): Promise<any>
		verify_flags$($: {}): Promise<any>
		verify_flags(value): Promise<any>
		verify_flags$({ value }): Promise<any>
		verify_mode(): Promise<any>
		verify_mode$($: {}): Promise<any>
		verify_mode(value): Promise<any>
		verify_mode$({ value }): Promise<any>
		sslsocket_class
		sslobject_class
	}

	/**
	 * This class implements an interface on top of a low-level SSL object as
	 *     implemented by OpenSSL. This object captures the state of an SSL connection
	 *     but does not provide any network IO itself. IO needs to be performed
	 *     through separate "BIO" objects which are OpenSSL's IO abstraction layer.
	 * 
	 *     This class does not have a public constructor. Instances are returned by
	 *     ``SSLContext.wrap_bio``. This class is typically used by framework authors
	 *     that want to implement asynchronous IO for SSL through memory buffers.
	 * 
	 *     When compared to ``SSLSocket``, this object lacks the following features:
	 * 
	 *      * Any form of network IO, including methods such as ``recv`` and ``send``.
	 *      * The ``do_handshake_on_connect`` and ``suppress_ragged_eofs`` machinery.
	 *     
	 */
	function SSLObject(): Promise<ISSLObject>
	function SSLObject$({ }): Promise<ISSLObject>
	interface ISSLObject {

		/**
		 * The SSLContext that is currently in use.
		 */
		context(): Promise<any>
		context$($: {}): Promise<any>
		context(ctx): Promise<any>
		context$({ ctx }): Promise<any>

		/**
		 * The SSLSession for client socket.
		 */
		session(): Promise<any>
		session$($: {}): Promise<any>
		session(session): Promise<any>
		session$({ session }): Promise<any>

		/**
		 * Was the client session reused during handshake
		 */
		session_reused(): Promise<any>
		session_reused$($: {}): Promise<any>

		/**
		 * Whether this is a server-side socket.
		 */
		server_side(): Promise<any>
		server_side$($: {}): Promise<any>

		/**
		 * The currently set server hostname (for SNI), or ``None`` if no
		 *         server hostname is set.
		 */
		server_hostname(): Promise<any>
		server_hostname$($: {}): Promise<any>

		/**
		 * Read up to 'len' bytes from the SSL object and return them.
		 * 
		 *         If 'buffer' is provided, read into this buffer and return the number of
		 *         bytes read.
		 *         
		 */
		read(len?, buffer?): Promise<any>
		read$({ len, buffer }: { len?, buffer?}): Promise<any>

		/**
		 * Write 'data' to the SSL object and return the number of bytes
		 *         written.
		 * 
		 *         The 'data' argument must support the buffer interface.
		 *         
		 */
		write(data): Promise<any>
		write$({ data }): Promise<any>

		/**
		 * Returns a formatted version of the data in the certificate provided
		 *         by the other end of the SSL channel.
		 * 
		 *         Return None if no certificate was provided, {} if a certificate was
		 *         provided, but not validated.
		 *         
		 */
		getpeercert(binary_form?: boolean): Promise<any>
		getpeercert$({ binary_form }: { binary_form?}): Promise<any>

		/**
		 * Return the currently selected NPN protocol as a string, or ``None``
		 *         if a next protocol was not negotiated or if NPN is not supported by one
		 *         of the peers.
		 */
		selected_npn_protocol(): Promise<any>
		selected_npn_protocol$($: {}): Promise<any>

		/**
		 * Return the currently selected ALPN protocol as a string, or ``None``
		 *         if a next protocol was not negotiated or if ALPN is not supported by one
		 *         of the peers.
		 */
		selected_alpn_protocol(): Promise<any>
		selected_alpn_protocol$($: {}): Promise<any>

		/**
		 * Return the currently selected cipher as a 3-tuple ``(name,
		 *         ssl_version, secret_bits)``.
		 */
		cipher(): Promise<any>
		cipher$($: {}): Promise<any>

		/**
		 * Return a list of ciphers shared by the client during the handshake or
		 *         None if this is not a valid server connection.
		 *         
		 */
		shared_ciphers(): Promise<any>
		shared_ciphers$($: {}): Promise<any>

		/**
		 * Return the current compression algorithm in use, or ``None`` if
		 *         compression was not negotiated or not supported by one of the peers.
		 */
		compression(): Promise<any>
		compression$($: {}): Promise<any>

		/**
		 * Return the number of bytes that can be read immediately.
		 */
		pending(): Promise<any>
		pending$($: {}): Promise<any>

		/**
		 * Start the SSL/TLS handshake.
		 */
		do_handshake(): Promise<any>
		do_handshake$($: {}): Promise<any>

		/**
		 * Start the SSL shutdown handshake.
		 */
		unwrap(): Promise<any>
		unwrap$($: {}): Promise<any>

		/**
		 * Get channel binding data for current connection.  Raise ValueError
		 *         if the requested `cb_type` is not supported.  Return bytes of the data
		 *         or None if the data is not available (e.g. before the handshake).
		 */
		get_channel_binding(cb_type?): Promise<any>
		get_channel_binding$({ cb_type }: { cb_type?}): Promise<any>

		/**
		 * Return a string identifying the protocol version used by the
		 *         current SSL channel. 
		 */
		version(): Promise<any>
		version$($: {}): Promise<any>
		verify_client_post_handshake(): Promise<any>
		verify_client_post_handshake$($: {}): Promise<any>
	}

	/**
	 * This class implements a subtype of socket.socket that wraps
	 *     the underlying OS socket in an SSL context when necessary, and
	 *     provides read and write methods over that channel. 
	 */
	function SSLSocket(): Promise<ISSLSocket>
	function SSLSocket$({ }): Promise<ISSLSocket>
	interface ISSLSocket {
		context(): Promise<any>
		context$($: {}): Promise<any>
		context(ctx): Promise<any>
		context$({ ctx }): Promise<any>
		session(): Promise<any>
		session$($: {}): Promise<any>
		session(session): Promise<any>
		session$({ session }): Promise<any>
		session_reused(): Promise<any>
		session_reused$($: {}): Promise<any>
		dup(): Promise<any>
		dup$($: {}): Promise<any>

		/**
		 * Read up to LEN bytes and return them.
		 *         Return zero-length string on EOF.
		 */
		read(len?, buffer?): Promise<any>
		read$({ len, buffer }: { len?, buffer?}): Promise<any>

		/**
		 * Write DATA to the underlying SSL channel.  Returns
		 *         number of bytes of DATA actually transmitted.
		 */
		write(data): Promise<any>
		write$({ data }): Promise<any>
		getpeercert(binary_form?: boolean): Promise<any>
		getpeercert$({ binary_form }: { binary_form?}): Promise<any>
		selected_npn_protocol(): Promise<any>
		selected_npn_protocol$($: {}): Promise<any>
		selected_alpn_protocol(): Promise<any>
		selected_alpn_protocol$($: {}): Promise<any>
		cipher(): Promise<any>
		cipher$($: {}): Promise<any>
		shared_ciphers(): Promise<any>
		shared_ciphers$($: {}): Promise<any>
		compression(): Promise<any>
		compression$($: {}): Promise<any>
		send(data, flags?): Promise<any>
		send$({ data, flags }: { data, flags?}): Promise<any>
		sendto(data, flags_or_addr, addr?): Promise<any>
		sendto$({ data, flags_or_addr, addr }: { data, flags_or_addr, addr?}): Promise<any>
		sendmsg(): Promise<any>
		sendmsg$($: {}): Promise<any>
		sendall(data, flags?): Promise<any>
		sendall$({ data, flags }: { data, flags?}): Promise<any>

		/**
		 * Send a file, possibly by using os.sendfile() if this is a
		 *         clear-text socket.  Return the total number of bytes sent.
		 *         
		 */
		sendfile(file, offset?, count?): Promise<any>
		sendfile$({ file, offset, count }: { file, offset?, count?}): Promise<any>
		recv(buflen?, flags?): Promise<any>
		recv$({ buflen, flags }: { buflen?, flags?}): Promise<any>
		recv_into(buffer, nbytes?, flags?): Promise<any>
		recv_into$({ buffer, nbytes, flags }: { buffer, nbytes?, flags?}): Promise<any>
		recvfrom(buflen?, flags?): Promise<any>
		recvfrom$({ buflen, flags }: { buflen?, flags?}): Promise<any>
		recvfrom_into(buffer, nbytes?, flags?): Promise<any>
		recvfrom_into$({ buffer, nbytes, flags }: { buffer, nbytes?, flags?}): Promise<any>
		recvmsg(): Promise<any>
		recvmsg$($: {}): Promise<any>
		recvmsg_into(): Promise<any>
		recvmsg_into$($: {}): Promise<any>
		pending(): Promise<any>
		pending$($: {}): Promise<any>
		shutdown(how): Promise<any>
		shutdown$({ how }): Promise<any>
		unwrap(): Promise<any>
		unwrap$($: {}): Promise<any>
		verify_client_post_handshake(): Promise<any>
		verify_client_post_handshake$($: {}): Promise<any>
		do_handshake(block?: boolean): Promise<any>
		do_handshake$({ block }: { block?}): Promise<any>

		/**
		 * Connects to remote ADDR, and then wraps the connection in
		 *         an SSL channel.
		 */
		connect(addr): Promise<any>
		connect$({ addr }): Promise<any>

		/**
		 * Connects to remote ADDR, and then wraps the connection in
		 *         an SSL channel.
		 */
		connect_ex(addr): Promise<any>
		connect_ex$({ addr }): Promise<any>

		/**
		 * Accepts a new connection from a remote client, and returns
		 *         a tuple containing that new connection wrapped with a server-side
		 *         SSL channel, and the address of the remote client.
		 */
		accept(): Promise<any>
		accept$($: {}): Promise<any>
		get_channel_binding(cb_type?): Promise<any>
		get_channel_binding$({ cb_type }: { cb_type?}): Promise<any>
		version(): Promise<any>
		version$($: {}): Promise<any>
	}
	let PROTOCOL_SSLv23: Promise<any>
	let socket_error: Promise<any>
	let CHANNEL_BINDING_TYPES: Promise<any>
	let HAS_NEVER_CHECK_COMMON_NAME: Promise<any>
	let CertificateError: Promise<any>
	let DefaultVerifyPaths: Promise<any>
	let PEM_HEADER: Promise<any>
	let PEM_FOOTER: Promise<any>
}
declare module stat {
	var _

	/**
	 * Return the portion of the file's mode that can be set by
	 *     os.chmod().
	 *     
	 */
	function S_IMODE(mode): Promise<any>
	function S_IMODE$({ mode }): Promise<any>

	/**
	 * Return the portion of the file's mode that describes the
	 *     file type.
	 *     
	 */
	function S_IFMT(mode): Promise<any>
	function S_IFMT$({ mode }): Promise<any>

	/**
	 * Return True if mode is from a directory.
	 */
	function S_ISDIR(mode): Promise<any>
	function S_ISDIR$({ mode }): Promise<any>

	/**
	 * Return True if mode is from a character special device file.
	 */
	function S_ISCHR(mode): Promise<any>
	function S_ISCHR$({ mode }): Promise<any>

	/**
	 * Return True if mode is from a block special device file.
	 */
	function S_ISBLK(mode): Promise<any>
	function S_ISBLK$({ mode }): Promise<any>

	/**
	 * Return True if mode is from a regular file.
	 */
	function S_ISREG(mode): Promise<any>
	function S_ISREG$({ mode }): Promise<any>

	/**
	 * Return True if mode is from a FIFO (named pipe).
	 */
	function S_ISFIFO(mode): Promise<any>
	function S_ISFIFO$({ mode }): Promise<any>

	/**
	 * Return True if mode is from a symbolic link.
	 */
	function S_ISLNK(mode): Promise<any>
	function S_ISLNK$({ mode }): Promise<any>

	/**
	 * Return True if mode is from a socket.
	 */
	function S_ISSOCK(mode): Promise<any>
	function S_ISSOCK$({ mode }): Promise<any>

	/**
	 * Return True if mode is from a door.
	 */
	function S_ISDOOR(mode): Promise<any>
	function S_ISDOOR$({ mode }): Promise<any>

	/**
	 * Return True if mode is from an event port.
	 */
	function S_ISPORT(mode): Promise<any>
	function S_ISPORT$({ mode }): Promise<any>

	/**
	 * Return True if mode is from a whiteout.
	 */
	function S_ISWHT(mode): Promise<any>
	function S_ISWHT$({ mode }): Promise<any>

	/**
	 * Convert a file's mode to a string of the form '-rwxrwxrwx'.
	 */
	function filemode(mode): Promise<any>
	function filemode$({ mode }): Promise<any>
	let ST_MODE: Promise<any>
	let ST_INO: Promise<any>
	let ST_DEV: Promise<any>
	let ST_NLINK: Promise<any>
	let ST_UID: Promise<any>
	let ST_GID: Promise<any>
	let ST_SIZE: Promise<any>
	let ST_ATIME: Promise<any>
	let ST_MTIME: Promise<any>
	let ST_CTIME: Promise<any>
	let S_IFDIR: Promise<any>
	let S_IFCHR: Promise<any>
	let S_IFBLK: Promise<any>
	let S_IFREG: Promise<any>
	let S_IFIFO: Promise<any>
	let S_IFLNK: Promise<any>
	let S_IFSOCK: Promise<any>
	let S_IFDOOR: Promise<any>
	let S_IFPORT: Promise<any>
	let S_IFWHT: Promise<any>
	let S_ISUID: Promise<any>
	let S_ISGID: Promise<any>
	let S_ENFMT: Promise<any>
	let S_ISVTX: Promise<any>
	let S_IREAD: Promise<any>
	let S_IWRITE: Promise<any>
	let S_IEXEC: Promise<any>
	let S_IRWXU: Promise<any>
	let S_IRUSR: Promise<any>
	let S_IWUSR: Promise<any>
	let S_IXUSR: Promise<any>
	let S_IRWXG: Promise<any>
	let S_IRGRP: Promise<any>
	let S_IWGRP: Promise<any>
	let S_IXGRP: Promise<any>
	let S_IRWXO: Promise<any>
	let S_IROTH: Promise<any>
	let S_IWOTH: Promise<any>
	let S_IXOTH: Promise<any>
	let UF_NODUMP: Promise<any>
	let UF_IMMUTABLE: Promise<any>
	let UF_APPEND: Promise<any>
	let UF_OPAQUE: Promise<any>
	let UF_NOUNLINK: Promise<any>
	let UF_COMPRESSED: Promise<any>
	let UF_HIDDEN: Promise<any>
	let SF_ARCHIVED: Promise<any>
	let SF_IMMUTABLE: Promise<any>
	let SF_APPEND: Promise<any>
	let SF_NOUNLINK: Promise<any>
	let SF_SNAPSHOT: Promise<any>
	let FILE_ATTRIBUTE_ARCHIVE: Promise<any>
	let FILE_ATTRIBUTE_COMPRESSED: Promise<any>
	let FILE_ATTRIBUTE_DEVICE: Promise<any>
	let FILE_ATTRIBUTE_DIRECTORY: Promise<any>
	let FILE_ATTRIBUTE_ENCRYPTED: Promise<any>
	let FILE_ATTRIBUTE_HIDDEN: Promise<any>
	let FILE_ATTRIBUTE_INTEGRITY_STREAM: Promise<any>
	let FILE_ATTRIBUTE_NORMAL: Promise<any>
	let FILE_ATTRIBUTE_NOT_CONTENT_INDEXED: Promise<any>
	let FILE_ATTRIBUTE_NO_SCRUB_DATA: Promise<any>
	let FILE_ATTRIBUTE_OFFLINE: Promise<any>
	let FILE_ATTRIBUTE_READONLY: Promise<any>
	let FILE_ATTRIBUTE_REPARSE_POINT: Promise<any>
	let FILE_ATTRIBUTE_SPARSE_FILE: Promise<any>
	let FILE_ATTRIBUTE_SYSTEM: Promise<any>
	let FILE_ATTRIBUTE_TEMPORARY: Promise<any>
	let FILE_ATTRIBUTE_VIRTUAL: Promise<any>
}
declare module statistics {
	var _

	/**
	 * Return the sample arithmetic mean of data.
	 * 
	 *     >>> mean([1, 2, 3, 4, 4])
	 *     2.8
	 * 
	 *     >>> from fractions import Fraction as F
	 *     >>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])
	 *     Fraction(13, 21)
	 * 
	 *     >>> from decimal import Decimal as D
	 *     >>> mean([D("0.5"), D("0.75"), D("0.625"), D("0.375")])
	 *     Decimal('0.5625')
	 * 
	 *     If ``data`` is empty, StatisticsError will be raised.
	 *     
	 */
	function mean(data): Promise<any>
	function mean$({ data }): Promise<any>

	/**
	 * Convert data to floats and compute the arithmetic mean.
	 * 
	 *     This runs faster than the mean() function and it always returns a float.
	 *     If the input dataset is empty, it raises a StatisticsError.
	 * 
	 *     >>> fmean([3.5, 4.0, 5.25])
	 *     4.25
	 *     
	 */
	function fmean(data, weights?): Promise<any>
	function fmean$({ data, weights }: { data, weights?}): Promise<any>

	/**
	 * Convert data to floats and compute the geometric mean.
	 * 
	 *     Raises a StatisticsError if the input dataset is empty,
	 *     if it contains a zero, or if it contains a negative value.
	 * 
	 *     No special efforts are made to achieve exact results.
	 *     (However, this may change in the future.)
	 * 
	 *     >>> round(geometric_mean([54, 24, 36]), 9)
	 *     36.0
	 *     
	 */
	function geometric_mean(data): Promise<any>
	function geometric_mean$({ data }): Promise<any>

	/**
	 * Return the harmonic mean of data.
	 * 
	 *     The harmonic mean is the reciprocal of the arithmetic mean of the
	 *     reciprocals of the data.  It can be used for averaging ratios or
	 *     rates, for example speeds.
	 * 
	 *     Suppose a car travels 40 km/hr for 5 km and then speeds-up to
	 *     60 km/hr for another 5 km. What is the average speed?
	 * 
	 *         >>> harmonic_mean([40, 60])
	 *         48.0
	 * 
	 *     Suppose a car travels 40 km/hr for 5 km, and when traffic clears,
	 *     speeds-up to 60 km/hr for the remaining 30 km of the journey. What
	 *     is the average speed?
	 * 
	 *         >>> harmonic_mean([40, 60], weights=[5, 30])
	 *         56.0
	 * 
	 *     If ``data`` is empty, or any element is less than zero,
	 *     ``harmonic_mean`` will raise ``StatisticsError``.
	 *     
	 */
	function harmonic_mean(data, weights?): Promise<any>
	function harmonic_mean$({ data, weights }: { data, weights?}): Promise<any>

	/**
	 * Return the median (middle value) of numeric data.
	 * 
	 *     When the number of data points is odd, return the middle data point.
	 *     When the number of data points is even, the median is interpolated by
	 *     taking the average of the two middle values:
	 * 
	 *     >>> median([1, 3, 5])
	 *     3
	 *     >>> median([1, 3, 5, 7])
	 *     4.0
	 * 
	 *     
	 */
	function median(data): Promise<any>
	function median$({ data }): Promise<any>

	/**
	 * Return the low median of numeric data.
	 * 
	 *     When the number of data points is odd, the middle value is returned.
	 *     When it is even, the smaller of the two middle values is returned.
	 * 
	 *     >>> median_low([1, 3, 5])
	 *     3
	 *     >>> median_low([1, 3, 5, 7])
	 *     3
	 * 
	 *     
	 */
	function median_low(data): Promise<any>
	function median_low$({ data }): Promise<any>

	/**
	 * Return the high median of data.
	 * 
	 *     When the number of data points is odd, the middle value is returned.
	 *     When it is even, the larger of the two middle values is returned.
	 * 
	 *     >>> median_high([1, 3, 5])
	 *     3
	 *     >>> median_high([1, 3, 5, 7])
	 *     5
	 * 
	 *     
	 */
	function median_high(data): Promise<any>
	function median_high$({ data }): Promise<any>

	/**
	 * Return the 50th percentile (median) of grouped continuous data.
	 * 
	 *     >>> median_grouped([1, 2, 2, 3, 4, 4, 4, 4, 4, 5])
	 *     3.7
	 *     >>> median_grouped([52, 52, 53, 54])
	 *     52.5
	 * 
	 *     This calculates the median as the 50th percentile, and should be
	 *     used when your data is continuous and grouped. In the above example,
	 *     the values 1, 2, 3, etc. actually represent the midpoint of classes
	 *     0.5-1.5, 1.5-2.5, 2.5-3.5, etc. The middle value falls somewhere in
	 *     class 3.5-4.5, and interpolation is used to estimate it.
	 * 
	 *     Optional argument ``interval`` represents the class interval, and
	 *     defaults to 1. Changing the class interval naturally will change the
	 *     interpolated 50th percentile value:
	 * 
	 *     >>> median_grouped([1, 3, 3, 5, 7], interval=1)
	 *     3.25
	 *     >>> median_grouped([1, 3, 3, 5, 7], interval=2)
	 *     3.5
	 * 
	 *     This function does not check whether the data points are at least
	 *     ``interval`` apart.
	 *     
	 */
	function median_grouped(data, interval?): Promise<any>
	function median_grouped$({ data, interval }: { data, interval?}): Promise<any>

	/**
	 * Return the most common data point from discrete or nominal data.
	 * 
	 *     ``mode`` assumes discrete data, and returns a single value. This is the
	 *     standard treatment of the mode as commonly taught in schools:
	 * 
	 *         >>> mode([1, 1, 2, 3, 3, 3, 3, 4])
	 *         3
	 * 
	 *     This also works with nominal (non-numeric) data:
	 * 
	 *         >>> mode(["red", "blue", "blue", "red", "green", "red", "red"])
	 *         'red'
	 * 
	 *     If there are multiple modes with same frequency, return the first one
	 *     encountered:
	 * 
	 *         >>> mode(['red', 'red', 'green', 'blue', 'blue'])
	 *         'red'
	 * 
	 *     If *data* is empty, ``mode``, raises StatisticsError.
	 * 
	 *     
	 */
	function mode(data): Promise<any>
	function mode$({ data }): Promise<any>

	/**
	 * Return a list of the most frequently occurring values.
	 * 
	 *     Will return more than one result if there are multiple modes
	 *     or an empty list if *data* is empty.
	 * 
	 *     >>> multimode('aabbbbbbbbcc')
	 *     ['b']
	 *     >>> multimode('aabbbbccddddeeffffgg')
	 *     ['b', 'd', 'f']
	 *     >>> multimode('')
	 *     []
	 *     
	 */
	function multimode(data): Promise<any>
	function multimode$({ data }): Promise<any>

	/**
	 * Divide *data* into *n* continuous intervals with equal probability.
	 * 
	 *     Returns a list of (n - 1) cut points separating the intervals.
	 * 
	 *     Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles.
	 *     Set *n* to 100 for percentiles which gives the 99 cuts points that
	 *     separate *data* in to 100 equal sized groups.
	 * 
	 *     The *data* can be any iterable containing sample.
	 *     The cut points are linearly interpolated between data points.
	 * 
	 *     If *method* is set to *inclusive*, *data* is treated as population
	 *     data.  The minimum value is treated as the 0th percentile and the
	 *     maximum value is treated as the 100th percentile.
	 *     
	 */
	function quantiles(data): Promise<any>
	function quantiles$({ data }): Promise<any>

	/**
	 * Return the sample variance of data.
	 * 
	 *     data should be an iterable of Real-valued numbers, with at least two
	 *     values. The optional argument xbar, if given, should be the mean of
	 *     the data. If it is missing or None, the mean is automatically calculated.
	 * 
	 *     Use this function when your data is a sample from a population. To
	 *     calculate the variance from the entire population, see ``pvariance``.
	 * 
	 *     Examples:
	 * 
	 *     >>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
	 *     >>> variance(data)
	 *     1.3720238095238095
	 * 
	 *     If you have already calculated the mean of your data, you can pass it as
	 *     the optional second argument ``xbar`` to avoid recalculating it:
	 * 
	 *     >>> m = mean(data)
	 *     >>> variance(data, m)
	 *     1.3720238095238095
	 * 
	 *     This function does not check that ``xbar`` is actually the mean of
	 *     ``data``. Giving arbitrary values for ``xbar`` may lead to invalid or
	 *     impossible results.
	 * 
	 *     Decimals and Fractions are supported:
	 * 
	 *     >>> from decimal import Decimal as D
	 *     >>> variance([D("27.5"), D("30.25"), D("30.25"), D("34.5"), D("41.75")])
	 *     Decimal('31.01875')
	 * 
	 *     >>> from fractions import Fraction as F
	 *     >>> variance([F(1, 6), F(1, 2), F(5, 3)])
	 *     Fraction(67, 108)
	 * 
	 *     
	 */
	function variance(data, xbar?): Promise<any>
	function variance$({ data, xbar }: { data, xbar?}): Promise<any>

	/**
	 * Return the population variance of ``data``.
	 * 
	 *     data should be a sequence or iterable of Real-valued numbers, with at least one
	 *     value. The optional argument mu, if given, should be the mean of
	 *     the data. If it is missing or None, the mean is automatically calculated.
	 * 
	 *     Use this function to calculate the variance from the entire population.
	 *     To estimate the variance from a sample, the ``variance`` function is
	 *     usually a better choice.
	 * 
	 *     Examples:
	 * 
	 *     >>> data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]
	 *     >>> pvariance(data)
	 *     1.25
	 * 
	 *     If you have already calculated the mean of the data, you can pass it as
	 *     the optional second argument to avoid recalculating it:
	 * 
	 *     >>> mu = mean(data)
	 *     >>> pvariance(data, mu)
	 *     1.25
	 * 
	 *     Decimals and Fractions are supported:
	 * 
	 *     >>> from decimal import Decimal as D
	 *     >>> pvariance([D("27.5"), D("30.25"), D("30.25"), D("34.5"), D("41.75")])
	 *     Decimal('24.815')
	 * 
	 *     >>> from fractions import Fraction as F
	 *     >>> pvariance([F(1, 4), F(5, 4), F(1, 2)])
	 *     Fraction(13, 72)
	 * 
	 *     
	 */
	function pvariance(data, mu?): Promise<any>
	function pvariance$({ data, mu }: { data, mu?}): Promise<any>

	/**
	 * Return the square root of the sample variance.
	 * 
	 *     See ``variance`` for arguments and other details.
	 * 
	 *     >>> stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])
	 *     1.0810874155219827
	 * 
	 *     
	 */
	function stdev(data, xbar?): Promise<any>
	function stdev$({ data, xbar }: { data, xbar?}): Promise<any>

	/**
	 * Return the square root of the population variance.
	 * 
	 *     See ``pvariance`` for arguments and other details.
	 * 
	 *     >>> pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])
	 *     0.986893273527251
	 * 
	 *     
	 */
	function pstdev(data, mu?): Promise<any>
	function pstdev$({ data, mu }: { data, mu?}): Promise<any>

	/**
	 * Covariance
	 * 
	 *     Return the sample covariance of two inputs *x* and *y*. Covariance
	 *     is a measure of the joint variability of two inputs.
	 * 
	 *     >>> x = [1, 2, 3, 4, 5, 6, 7, 8, 9]
	 *     >>> y = [1, 2, 3, 1, 2, 3, 1, 2, 3]
	 *     >>> covariance(x, y)
	 *     0.75
	 *     >>> z = [9, 8, 7, 6, 5, 4, 3, 2, 1]
	 *     >>> covariance(x, z)
	 *     -7.5
	 *     >>> covariance(z, x)
	 *     -7.5
	 * 
	 *     
	 */
	function covariance(x, y): Promise<any>
	function covariance$({ x, y }): Promise<any>

	/**
	 * Pearson's correlation coefficient
	 * 
	 *     Return the Pearson's correlation coefficient for two inputs. Pearson's
	 *     correlation coefficient *r* takes values between -1 and +1. It measures the
	 *     strength and direction of the linear relationship, where +1 means very
	 *     strong, positive linear relationship, -1 very strong, negative linear
	 *     relationship, and 0 no linear relationship.
	 * 
	 *     >>> x = [1, 2, 3, 4, 5, 6, 7, 8, 9]
	 *     >>> y = [9, 8, 7, 6, 5, 4, 3, 2, 1]
	 *     >>> correlation(x, x)
	 *     1.0
	 *     >>> correlation(x, y)
	 *     -1.0
	 * 
	 *     
	 */
	function correlation(x, y): Promise<any>
	function correlation$({ x, y }): Promise<any>

	/**
	 * Slope and intercept for simple linear regression.
	 * 
	 *     Return the slope and intercept of simple linear regression
	 *     parameters estimated using ordinary least squares. Simple linear
	 *     regression describes relationship between an independent variable
	 *     *x* and a dependent variable *y* in terms of linear function:
	 * 
	 *         y = slope * x + intercept + noise
	 * 
	 *     where *slope* and *intercept* are the regression parameters that are
	 *     estimated, and noise represents the variability of the data that was
	 *     not explained by the linear regression (it is equal to the
	 *     difference between predicted and actual values of the dependent
	 *     variable).
	 * 
	 *     The parameters are returned as a named tuple.
	 * 
	 *     >>> x = [1, 2, 3, 4, 5]
	 *     >>> noise = NormalDist().samples(5, seed=42)
	 *     >>> y = [3 * x[i] + 2 + noise[i] for i in range(5)]
	 *     >>> linear_regression(x, y)  #doctest: +ELLIPSIS
	 *     LinearRegression(slope=3.09078914170..., intercept=1.75684970486...)
	 * 
	 *     
	 */
	function linear_regression(x, y): Promise<any>
	function linear_regression$({ x, y }): Promise<any>
	interface IStatisticsError {
	}

	/**
	 * Normal distribution of a random variable
	 */

	/**
	 * NormalDist where mu is the mean and sigma is the standard deviation.
	 */
	function NormalDist(mu?, sigma?): Promise<INormalDist>
	function NormalDist$({ mu, sigma }: { mu?, sigma?}): Promise<INormalDist>
	interface INormalDist {

		/**
		 * Make a normal distribution instance from sample data.
		 */
		from_samples(data): Promise<any>
		from_samples$({ data }): Promise<any>

		/**
		 * Generate *n* samples for a given mean and standard deviation.
		 */
		samples(n): Promise<any>
		samples$({ n }): Promise<any>

		/**
		 * Probability density function.  P(x <= X < x+dx) / dx
		 */
		pdf(x): Promise<any>
		pdf$({ x }): Promise<any>

		/**
		 * Cumulative distribution function.  P(X <= x)
		 */
		cdf(x): Promise<any>
		cdf$({ x }): Promise<any>

		/**
		 * Inverse cumulative distribution function.  x : P(X <= x) = p
		 * 
		 *         Finds the value of the random variable such that the probability of
		 *         the variable being less than or equal to that value equals the given
		 *         probability.
		 * 
		 *         This function is also called the percent point function or quantile
		 *         function.
		 *         
		 */
		inv_cdf(p): Promise<any>
		inv_cdf$({ p }): Promise<any>

		/**
		 * Divide into *n* continuous intervals with equal probability.
		 * 
		 *         Returns a list of (n - 1) cut points separating the intervals.
		 * 
		 *         Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles.
		 *         Set *n* to 100 for percentiles which gives the 99 cuts points that
		 *         separate the normal distribution in to 100 equal sized groups.
		 *         
		 */
		quantiles(n?): Promise<any>
		quantiles$({ n }: { n?}): Promise<any>

		/**
		 * Compute the overlapping coefficient (OVL) between two normal distributions.
		 * 
		 *         Measures the agreement between two normal probability distributions.
		 *         Returns a value between 0.0 and 1.0 giving the overlapping area in
		 *         the two underlying probability density functions.
		 * 
		 *             >>> N1 = NormalDist(2.4, 1.6)
		 *             >>> N2 = NormalDist(3.2, 2.0)
		 *             >>> N1.overlap(N2)
		 *             0.8035050657330205
		 *         
		 */
		overlap(other): Promise<any>
		overlap$({ other }): Promise<any>

		/**
		 * Compute the Standard Score.  (x - mean) / stdev
		 * 
		 *         Describes *x* in terms of the number of standard deviations
		 *         above or below the mean of the normal distribution.
		 *         
		 */
		zscore(x): Promise<any>
		zscore$({ x }): Promise<any>

		/**
		 * Arithmetic mean of the normal distribution.
		 */
		mean(): Promise<any>
		mean$($: {}): Promise<any>

		/**
		 * Return the median of the normal distribution
		 */
		median(): Promise<any>
		median$($: {}): Promise<any>

		/**
		 * Return the mode of the normal distribution
		 * 
		 *         The mode is the value x where which the probability density
		 *         function (pdf) takes its maximum value.
		 *         
		 */
		mode(): Promise<any>
		mode$($: {}): Promise<any>

		/**
		 * Standard deviation of the normal distribution.
		 */
		stdev(): Promise<any>
		stdev$($: {}): Promise<any>

		/**
		 * Square of the standard deviation.
		 */
		variance(): Promise<any>
		variance$($: {}): Promise<any>
	}
	let LinearRegression: Promise<any>
}
declare module string {
	var _

	/**
	 * capwords(s [,sep]) -> string
	 * 
	 *     Split the argument into words using split, capitalize each
	 *     word using capitalize, and join the capitalized words using
	 *     join.  If the optional second argument sep is absent or None,
	 *     runs of whitespace characters are replaced by a single space
	 *     and leading and trailing whitespace are removed, otherwise
	 *     sep is used to split and join the words.
	 * 
	 *     
	 */
	function capwords(s, sep?): Promise<any>
	function capwords$({ s, sep }: { s, sep?}): Promise<any>

	/**
	 * A string class for supporting $-substitutions.
	 */
	function Template(template): Promise<ITemplate>
	function Template$({ template }): Promise<ITemplate>
	interface ITemplate {
		substitute(mapping?): Promise<any>
		substitute$({ mapping }: { mapping?}): Promise<any>
		safe_substitute(mapping?): Promise<any>
		safe_substitute$({ mapping }: { mapping?}): Promise<any>
		delimiter
		idpattern
		braceidpattern
		flags
	}
	interface IFormatter {
		format(format_string): Promise<any>
		format$({ format_string }): Promise<any>
		vformat(format_string, args, kwargs): Promise<any>
		vformat$({ format_string, args, kwargs }): Promise<any>
		get_value(key, args, kwargs): Promise<any>
		get_value$({ key, args, kwargs }): Promise<any>
		check_unused_args(used_args, args, kwargs): Promise<any>
		check_unused_args$({ used_args, args, kwargs }): Promise<any>
		format_field(value, format_spec): Promise<any>
		format_field$({ value, format_spec }): Promise<any>
		convert_field(value, conversion): Promise<any>
		convert_field$({ value, conversion }): Promise<any>
		parse(format_string): Promise<any>
		parse$({ format_string }): Promise<any>
		get_field(field_name, args, kwargs): Promise<any>
		get_field$({ field_name, args, kwargs }): Promise<any>
	}
	let whitespace: Promise<any>
	let ascii_lowercase: Promise<any>
	let ascii_uppercase: Promise<any>
	let ascii_letters: Promise<any>
	let digits: Promise<any>
	let hexdigits: Promise<any>
	let octdigits: Promise<any>
	let punctuation: Promise<any>
	let printable: Promise<any>
}
declare module stringprep {
	var _
	function in_table_a1(code): Promise<any>
	function in_table_a1$({ code }): Promise<any>
	function in_table_b1(code): Promise<any>
	function in_table_b1$({ code }): Promise<any>
	function map_table_b3(code): Promise<any>
	function map_table_b3$({ code }): Promise<any>
	function map_table_b2(a): Promise<any>
	function map_table_b2$({ a }): Promise<any>
	function in_table_c11(code): Promise<any>
	function in_table_c11$({ code }): Promise<any>
	function in_table_c12(code): Promise<any>
	function in_table_c12$({ code }): Promise<any>
	function in_table_c11_c12(code): Promise<any>
	function in_table_c11_c12$({ code }): Promise<any>
	function in_table_c21(code): Promise<any>
	function in_table_c21$({ code }): Promise<any>
	function in_table_c22(code): Promise<any>
	function in_table_c22$({ code }): Promise<any>
	function in_table_c21_c22(code): Promise<any>
	function in_table_c21_c22$({ code }): Promise<any>
	function in_table_c3(code): Promise<any>
	function in_table_c3$({ code }): Promise<any>
	function in_table_c4(code): Promise<any>
	function in_table_c4$({ code }): Promise<any>
	function in_table_c5(code): Promise<any>
	function in_table_c5$({ code }): Promise<any>
	function in_table_c6(code): Promise<any>
	function in_table_c6$({ code }): Promise<any>
	function in_table_c7(code): Promise<any>
	function in_table_c7$({ code }): Promise<any>
	function in_table_c8(code): Promise<any>
	function in_table_c8$({ code }): Promise<any>
	function in_table_c9(code): Promise<any>
	function in_table_c9$({ code }): Promise<any>
	function in_table_d1(code): Promise<any>
	function in_table_d1$({ code }): Promise<any>
	function in_table_d2(code): Promise<any>
	function in_table_d2$({ code }): Promise<any>
	let b1_set: Promise<any>
	let b3_exceptions: Promise<any>
	let c22_specials: Promise<any>
	let c6_set: Promise<any>
	let c7_set: Promise<any>
	let c8_set: Promise<any>
	let c9_set: Promise<any>
}
declare module struct {
	var _
}
declare module subprocess {
	var _

	/**
	 * Run command with arguments.  Wait for command to complete or
	 *     timeout, then return the returncode attribute.
	 * 
	 *     The arguments are the same as for the Popen constructor.  Example:
	 * 
	 *     retcode = call(["ls", "-l"])
	 *     
	 */
	function call(): Promise<any>
	function call$($: {}): Promise<any>

	/**
	 * Run command with arguments.  Wait for command to complete.  If
	 *     the exit code was zero then return, otherwise raise
	 *     CalledProcessError.  The CalledProcessError object will have the
	 *     return code in the returncode attribute.
	 * 
	 *     The arguments are the same as for the call function.  Example:
	 * 
	 *     check_call(["ls", "-l"])
	 *     
	 */
	function check_call(): Promise<any>
	function check_call$($: {}): Promise<any>

	/**
	 * Run command with arguments and return its output.
	 * 
	 *     If the exit code was non-zero it raises a CalledProcessError.  The
	 *     CalledProcessError object will have the return code in the returncode
	 *     attribute and output in the output attribute.
	 * 
	 *     The arguments are the same as for the Popen constructor.  Example:
	 * 
	 *     >>> check_output(["ls", "-l", "/dev/null"])
	 *     b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
	 * 
	 *     The stdout argument is not allowed as it is used internally.
	 *     To capture standard error in the result, use stderr=STDOUT.
	 * 
	 *     >>> check_output(["/bin/sh", "-c",
	 *     ...               "ls -l non_existent_file ; exit 0"],
	 *     ...              stderr=STDOUT)
	 *     b'ls: non_existent_file: No such file or directory\n'
	 * 
	 *     There is an additional optional argument, "input", allowing you to
	 *     pass a string to the subprocess's stdin.  If you use this argument
	 *     you may not also use the Popen constructor's "stdin" argument, as
	 *     it too will be used internally.  Example:
	 * 
	 *     >>> check_output(["sed", "-e", "s/foo/bar/"],
	 *     ...              input=b"when in the course of fooman events\n")
	 *     b'when in the course of barman events\n'
	 * 
	 *     By default, all communication is in bytes, and therefore any "input"
	 *     should be bytes, and the return value will be bytes.  If in text mode,
	 *     any "input" should be a string, and the return value will be a string
	 *     decoded according to locale encoding, or by "encoding" if set. Text mode
	 *     is triggered by setting any of text, encoding, errors or universal_newlines.
	 *     
	 */
	function check_output(): Promise<any>
	function check_output$($: {}): Promise<any>

	/**
	 * Run command with arguments and return a CompletedProcess instance.
	 * 
	 *     The returned instance will have attributes args, returncode, stdout and
	 *     stderr. By default, stdout and stderr are not captured, and those attributes
	 *     will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
	 * 
	 *     If check is True and the exit code was non-zero, it raises a
	 *     CalledProcessError. The CalledProcessError object will have the return code
	 *     in the returncode attribute, and output & stderr attributes if those streams
	 *     were captured.
	 * 
	 *     If timeout is given, and the process takes too long, a TimeoutExpired
	 *     exception will be raised.
	 * 
	 *     There is an optional argument "input", allowing you to
	 *     pass bytes or a string to the subprocess's stdin.  If you use this argument
	 *     you may not also use the Popen constructor's "stdin" argument, as
	 *     it will be used internally.
	 * 
	 *     By default, all communication is in bytes, and therefore any "input" should
	 *     be bytes, and the stdout and stderr will be bytes. If in text mode, any
	 *     "input" should be a string, and stdout and stderr will be strings decoded
	 *     according to locale encoding, or by "encoding" if set. Text mode is
	 *     triggered by setting any of text, encoding, errors or universal_newlines.
	 * 
	 *     The other arguments are the same as for the Popen constructor.
	 *     
	 */
	function run(): Promise<any>
	function run$($: {}): Promise<any>

	/**
	 * 
	 *     Translate a sequence of arguments into a command line
	 *     string, using the same rules as the MS C runtime:
	 * 
	 *     1) Arguments are delimited by white space, which is either a
	 *        space or a tab.
	 * 
	 *     2) A string surrounded by double quotation marks is
	 *        interpreted as a single argument, regardless of white space
	 *        contained within.  A quoted string can be embedded in an
	 *        argument.
	 * 
	 *     3) A double quotation mark preceded by a backslash is
	 *        interpreted as a literal double quotation mark.
	 * 
	 *     4) Backslashes are interpreted literally, unless they
	 *        immediately precede a double quotation mark.
	 * 
	 *     5) If backslashes immediately precede a double quotation mark,
	 *        every pair of backslashes is interpreted as a literal
	 *        backslash.  If the number of backslashes is odd, the last
	 *        backslash escapes the next double quotation mark as
	 *        described in rule 3.
	 *     
	 */
	function list2cmdline(seq): Promise<any>
	function list2cmdline$({ seq }): Promise<any>

	/**
	 * Return (exitcode, output) of executing cmd in a shell.
	 * 
	 *     Execute the string 'cmd' in a shell with 'check_output' and
	 *     return a 2-tuple (status, output). The locale encoding is used
	 *     to decode the output and process newlines.
	 * 
	 *     A trailing newline is stripped from the output.
	 *     The exit status for the command can be interpreted
	 *     according to the rules for the function 'wait'. Example:
	 * 
	 *     >>> import subprocess
	 *     >>> subprocess.getstatusoutput('ls /bin/ls')
	 *     (0, '/bin/ls')
	 *     >>> subprocess.getstatusoutput('cat /bin/junk')
	 *     (1, 'cat: /bin/junk: No such file or directory')
	 *     >>> subprocess.getstatusoutput('/bin/junk')
	 *     (127, 'sh: /bin/junk: not found')
	 *     >>> subprocess.getstatusoutput('/bin/kill $$')
	 *     (-15, '')
	 *     
	 */
	function getstatusoutput(cmd): Promise<any>
	function getstatusoutput$({ cmd }): Promise<any>

	/**
	 * Return output (stdout or stderr) of executing cmd in a shell.
	 * 
	 *     Like getstatusoutput(), except the exit status is ignored and the return
	 *     value is a string containing the command's output.  Example:
	 * 
	 *     >>> import subprocess
	 *     >>> subprocess.getoutput('ls /bin/ls')
	 *     '/bin/ls'
	 *     
	 */
	function getoutput(cmd): Promise<any>
	function getoutput$({ cmd }): Promise<any>
	interface ISubprocessError {
	}

	/**
	 * Raised when run() is called with check=True and the process
	 *     returns a non-zero exit status.
	 * 
	 *     Attributes:
	 *       cmd, returncode, stdout, stderr, output
	 *     
	 */
	function CalledProcessError(returncode, cmd, output?, stderr?): Promise<ICalledProcessError>
	function CalledProcessError$({ returncode, cmd, output, stderr }: { returncode, cmd, output?, stderr?}): Promise<ICalledProcessError>
	interface ICalledProcessError extends ISubprocessError {

		/**
		 * Alias for output attribute, to match stderr
		 */
		stdout(): Promise<any>
		stdout$($: {}): Promise<any>
		stdout(value): Promise<any>
		stdout$({ value }): Promise<any>
	}

	/**
	 * This exception is raised when the timeout expires while waiting for a
	 *     child process.
	 * 
	 *     Attributes:
	 *         cmd, output, stdout, stderr, timeout
	 *     
	 */
	function TimeoutExpired(cmd, timeout, output?, stderr?): Promise<ITimeoutExpired>
	function TimeoutExpired$({ cmd, timeout, output, stderr }: { cmd, timeout, output?, stderr?}): Promise<ITimeoutExpired>
	interface ITimeoutExpired extends ISubprocessError {
		stdout(): Promise<any>
		stdout$($: {}): Promise<any>
		stdout(value): Promise<any>
		stdout$({ value }): Promise<any>
	}
	function STARTUPINFO(): Promise<ISTARTUPINFO>
	function STARTUPINFO$({ }): Promise<ISTARTUPINFO>
	interface ISTARTUPINFO {
		copy(): Promise<any>
		copy$($: {}): Promise<any>
	}
	interface IHandle {
		Close(CloseHandle?): Promise<any>
		Close$({ CloseHandle }: { CloseHandle?}): Promise<any>
		Detach(): Promise<any>
		Detach$($: {}): Promise<any>
		closed
	}

	/**
	 * A process that has finished running.
	 * 
	 *     This is returned by run().
	 * 
	 *     Attributes:
	 *       args: The list or str args passed to run().
	 *       returncode: The exit code of the process, negative for signals.
	 *       stdout: The standard output (None if not captured).
	 *       stderr: The standard error (None if not captured).
	 *     
	 */
	function CompletedProcess(args, returncode, stdout?, stderr?): Promise<ICompletedProcess>
	function CompletedProcess$({ args, returncode, stdout, stderr }: { args, returncode, stdout?, stderr?}): Promise<ICompletedProcess>
	interface ICompletedProcess {

		/**
		 * Raise CalledProcessError if the exit code is non-zero.
		 */
		check_returncode(): Promise<any>
		check_returncode$($: {}): Promise<any>
	}

	/**
	 *  Execute a child program in a new process.
	 * 
	 *     For a complete description of the arguments see the Python documentation.
	 * 
	 *     Arguments:
	 *       args: A string, or a sequence of program arguments.
	 * 
	 *       bufsize: supplied as the buffering argument to the open() function when
	 *           creating the stdin/stdout/stderr pipe file objects
	 * 
	 *       executable: A replacement program to execute.
	 * 
	 *       stdin, stdout and stderr: These specify the executed programs' standard
	 *           input, standard output and standard error file handles, respectively.
	 * 
	 *       preexec_fn: (POSIX only) An object to be called in the child process
	 *           just before the child is executed.
	 * 
	 *       close_fds: Controls closing or inheriting of file descriptors.
	 * 
	 *       shell: If true, the command will be executed through the shell.
	 * 
	 *       cwd: Sets the current directory before the child is executed.
	 * 
	 *       env: Defines the environment variables for the new process.
	 * 
	 *       text: If true, decode stdin, stdout and stderr using the given encoding
	 *           (if set) or the system default otherwise.
	 * 
	 *       universal_newlines: Alias of text, provided for backwards compatibility.
	 * 
	 *       startupinfo and creationflags (Windows only)
	 * 
	 *       restore_signals (POSIX only)
	 * 
	 *       start_new_session (POSIX only)
	 * 
	 *       group (POSIX only)
	 * 
	 *       extra_groups (POSIX only)
	 * 
	 *       user (POSIX only)
	 * 
	 *       umask (POSIX only)
	 * 
	 *       pass_fds (POSIX only)
	 * 
	 *       encoding and errors: Text mode encoding and error handling to use for
	 *           file objects stdin, stdout and stderr.
	 * 
	 *     Attributes:
	 *         stdin, stdout, stderr, pid, returncode
	 *     
	 */

	/**
	 * Create new Popen instance.
	 */
	function Popen(args, bufsize?, executable?, stdin?, stdout?, stderr?, preexec_fn?, close_fds?: boolean, shell?: boolean, cwd?, env?, universal_newlines?, startupinfo?, creationflags?, restore_signals?: boolean, start_new_session?: boolean, pass_fds?): Promise<IPopen>
	function Popen$({ args, bufsize, executable, stdin, stdout, stderr, preexec_fn, close_fds, shell, cwd, env, universal_newlines, startupinfo, creationflags, restore_signals, start_new_session, pass_fds }: { args, bufsize?, executable?, stdin?, stdout?, stderr?, preexec_fn?, close_fds?, shell?, cwd?, env?, universal_newlines?, startupinfo?, creationflags?, restore_signals?, start_new_session?, pass_fds?}): Promise<IPopen>
	interface IPopen {
		universal_newlines(): Promise<any>
		universal_newlines$($: {}): Promise<any>
		universal_newlines(universal_newlines): Promise<any>
		universal_newlines$({ universal_newlines }): Promise<any>

		/**
		 * Interact with process: Send data to stdin and close it.
		 *         Read data from stdout and stderr, until end-of-file is
		 *         reached.  Wait for process to terminate.
		 * 
		 *         The optional "input" argument should be data to be sent to the
		 *         child process, or None, if no data should be sent to the child.
		 *         communicate() returns a tuple (stdout, stderr).
		 * 
		 *         By default, all communication is in bytes, and therefore any
		 *         "input" should be bytes, and the (stdout, stderr) will be bytes.
		 *         If in text mode (indicated by self.text_mode), any "input" should
		 *         be a string, and (stdout, stderr) will be strings decoded
		 *         according to locale encoding, or by "encoding" if set. Text mode
		 *         is triggered by setting any of text, encoding, errors or
		 *         universal_newlines.
		 *         
		 */
		communicate(input?, timeout?): Promise<any>
		communicate$({ input, timeout }: { input?, timeout?}): Promise<any>

		/**
		 * Check if child process has terminated. Set and return returncode
		 *         attribute.
		 */
		poll(): Promise<any>
		poll$($: {}): Promise<any>

		/**
		 * Wait for child process to terminate; returns self.returncode.
		 */
		wait(timeout?): Promise<any>
		wait$({ timeout }: { timeout?}): Promise<any>
	}
	let PIPE: Promise<any>
	let STDOUT: Promise<any>
	let DEVNULL: Promise<any>
}
declare module sunau {
	var _
	function open(f, mode?): Promise<any>
	function open$({ f, mode }: { f, mode?}): Promise<any>
	interface IError {
	}
	function Au_read(f): Promise<IAu_read>
	function Au_read$({ f }): Promise<IAu_read>
	interface IAu_read {
		initfp(file): Promise<any>
		initfp$({ file }): Promise<any>
		getfp(): Promise<any>
		getfp$($: {}): Promise<any>
		getnchannels(): Promise<any>
		getnchannels$($: {}): Promise<any>
		getsampwidth(): Promise<any>
		getsampwidth$($: {}): Promise<any>
		getframerate(): Promise<any>
		getframerate$($: {}): Promise<any>
		getnframes(): Promise<any>
		getnframes$($: {}): Promise<any>
		getcomptype(): Promise<any>
		getcomptype$($: {}): Promise<any>
		getcompname(): Promise<any>
		getcompname$($: {}): Promise<any>
		getparams(): Promise<any>
		getparams$($: {}): Promise<any>
		getmarkers(): Promise<any>
		getmarkers$($: {}): Promise<any>
		getmark(id): Promise<any>
		getmark$({ id }): Promise<any>
		readframes(nframes): Promise<any>
		readframes$({ nframes }): Promise<any>
		rewind(): Promise<any>
		rewind$($: {}): Promise<any>
		tell(): Promise<any>
		tell$($: {}): Promise<any>
		setpos(pos): Promise<any>
		setpos$({ pos }): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}
	function Au_write(f): Promise<IAu_write>
	function Au_write$({ f }): Promise<IAu_write>
	interface IAu_write {
		initfp(file): Promise<any>
		initfp$({ file }): Promise<any>
		setnchannels(nchannels): Promise<any>
		setnchannels$({ nchannels }): Promise<any>
		getnchannels(): Promise<any>
		getnchannels$($: {}): Promise<any>
		setsampwidth(sampwidth): Promise<any>
		setsampwidth$({ sampwidth }): Promise<any>
		getsampwidth(): Promise<any>
		getsampwidth$($: {}): Promise<any>
		setframerate(framerate): Promise<any>
		setframerate$({ framerate }): Promise<any>
		getframerate(): Promise<any>
		getframerate$($: {}): Promise<any>
		setnframes(nframes): Promise<any>
		setnframes$({ nframes }): Promise<any>
		getnframes(): Promise<any>
		getnframes$($: {}): Promise<any>
		setcomptype(type, name): Promise<any>
		setcomptype$({ type, name }): Promise<any>
		getcomptype(): Promise<any>
		getcomptype$($: {}): Promise<any>
		getcompname(): Promise<any>
		getcompname$($: {}): Promise<any>
		setparams(params): Promise<any>
		setparams$({ params }): Promise<any>
		getparams(): Promise<any>
		getparams$($: {}): Promise<any>
		tell(): Promise<any>
		tell$($: {}): Promise<any>
		writeframesraw(data): Promise<any>
		writeframesraw$({ data }): Promise<any>
		writeframes(data): Promise<any>
		writeframes$({ data }): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}
	let AUDIO_FILE_MAGIC: Promise<any>
	let AUDIO_FILE_ENCODING_MULAW_8: Promise<any>
	let AUDIO_FILE_ENCODING_LINEAR_8: Promise<any>
	let AUDIO_FILE_ENCODING_LINEAR_16: Promise<any>
	let AUDIO_FILE_ENCODING_LINEAR_24: Promise<any>
	let AUDIO_FILE_ENCODING_LINEAR_32: Promise<any>
	let AUDIO_FILE_ENCODING_FLOAT: Promise<any>
	let AUDIO_FILE_ENCODING_DOUBLE: Promise<any>
	let AUDIO_FILE_ENCODING_ADPCM_G721: Promise<any>
	let AUDIO_FILE_ENCODING_ADPCM_G722: Promise<any>
	let AUDIO_FILE_ENCODING_ADPCM_G723_3: Promise<any>
	let AUDIO_FILE_ENCODING_ADPCM_G723_5: Promise<any>
	let AUDIO_FILE_ENCODING_ALAW_8: Promise<any>
	let AUDIO_UNKNOWN_SIZE: Promise<any>
}
declare module symtable {
	var _

	/**
	 *  Return the toplevel *SymbolTable* for the source code.
	 * 
	 *     *filename* is the name of the file with the code
	 *     and *compile_type* is the *compile()* mode argument.
	 *     
	 */
	function symtable(code, filename, compile_type): Promise<any>
	function symtable$({ code, filename, compile_type }): Promise<any>
	function SymbolTableFactory(): Promise<ISymbolTableFactory>
	function SymbolTableFactory$({ }): Promise<ISymbolTableFactory>
	interface ISymbolTableFactory {
		new$({ table, filename }): Promise<any>
	}
	function SymbolTable(raw_table, filename): Promise<ISymbolTable>
	function SymbolTable$({ raw_table, filename }): Promise<ISymbolTable>
	interface ISymbolTable {

		/**
		 * Return the type of the symbol table.
		 * 
		 *         The values returned are 'class', 'module' and
		 *         'function'.
		 *         
		 */
		get_type(): Promise<any>
		get_type$($: {}): Promise<any>

		/**
		 * Return an identifier for the table.
		 *         
		 */
		get_id(): Promise<any>
		get_id$($: {}): Promise<any>

		/**
		 * Return the table's name.
		 * 
		 *         This corresponds to the name of the class, function
		 *         or 'top' if the table is for a class, function or
		 *         global respectively.
		 *         
		 */
		get_name(): Promise<any>
		get_name$($: {}): Promise<any>

		/**
		 * Return the number of the first line in the
		 *         block for the table.
		 *         
		 */
		get_lineno(): Promise<any>
		get_lineno$($: {}): Promise<any>

		/**
		 * Return *True* if the locals in the table
		 *         are optimizable.
		 *         
		 */
		is_optimized(): Promise<any>
		is_optimized$($: {}): Promise<any>

		/**
		 * Return *True* if the block is a nested class
		 *         or function.
		 */
		is_nested(): Promise<any>
		is_nested$($: {}): Promise<any>

		/**
		 * Return *True* if the block has nested namespaces.
		 *         
		 */
		has_children(): Promise<any>
		has_children$($: {}): Promise<any>

		/**
		 * Return a list of names of symbols in the table.
		 *         
		 */
		get_identifiers(): Promise<any>
		get_identifiers$($: {}): Promise<any>

		/**
		 * Lookup a *name* in the table.
		 * 
		 *         Returns a *Symbol* instance.
		 *         
		 */
		lookup(name): Promise<any>
		lookup$({ name }): Promise<any>

		/**
		 * Return a list of *Symbol* instances for
		 *         names in the table.
		 *         
		 */
		get_symbols(): Promise<any>
		get_symbols$($: {}): Promise<any>

		/**
		 * Return a list of the nested symbol tables.
		 *         
		 */
		get_children(): Promise<any>
		get_children$($: {}): Promise<any>
	}
	interface IFunction extends ISymbolTable {

		/**
		 * Return a tuple of parameters to the function.
		 *         
		 */
		get_parameters(): Promise<any>
		get_parameters$($: {}): Promise<any>

		/**
		 * Return a tuple of locals in the function.
		 *         
		 */
		get_locals(): Promise<any>
		get_locals$($: {}): Promise<any>

		/**
		 * Return a tuple of globals in the function.
		 *         
		 */
		get_globals(): Promise<any>
		get_globals$($: {}): Promise<any>

		/**
		 * Return a tuple of nonlocals in the function.
		 *         
		 */
		get_nonlocals(): Promise<any>
		get_nonlocals$($: {}): Promise<any>

		/**
		 * Return a tuple of free variables in the function.
		 *         
		 */
		get_frees(): Promise<any>
		get_frees$($: {}): Promise<any>
	}
	interface IClass extends ISymbolTable {

		/**
		 * Return a tuple of methods declared in the class.
		 *         
		 */
		get_methods(): Promise<any>
		get_methods$($: {}): Promise<any>
	}
	function Symbol(name, flags, namespaces?): Promise<ISymbol>
	function Symbol$({ name, flags, namespaces }: { name, flags, namespaces?}): Promise<ISymbol>
	interface ISymbol {

		/**
		 * Return a name of a symbol.
		 *         
		 */
		get_name(): Promise<any>
		get_name$($: {}): Promise<any>

		/**
		 * Return *True* if the symbol is used in
		 *         its block.
		 *         
		 */
		is_referenced(): Promise<any>
		is_referenced$($: {}): Promise<any>

		/**
		 * Return *True* if the symbol is a parameter.
		 *         
		 */
		is_parameter(): Promise<any>
		is_parameter$($: {}): Promise<any>

		/**
		 * Return *True* if the symbol is global.
		 *         
		 */
		is_global(): Promise<any>
		is_global$($: {}): Promise<any>

		/**
		 * Return *True* if the symbol is nonlocal.
		 */
		is_nonlocal(): Promise<any>
		is_nonlocal$($: {}): Promise<any>

		/**
		 * Return *True* if the symbol is declared global
		 *         with a global statement.
		 */
		is_declared_global(): Promise<any>
		is_declared_global$($: {}): Promise<any>

		/**
		 * Return *True* if the symbol is local.
		 *         
		 */
		is_local(): Promise<any>
		is_local$($: {}): Promise<any>

		/**
		 * Return *True* if the symbol is annotated.
		 *         
		 */
		is_annotated(): Promise<any>
		is_annotated$($: {}): Promise<any>

		/**
		 * Return *True* if a referenced symbol is
		 *         not assigned to.
		 *         
		 */
		is_free(): Promise<any>
		is_free$($: {}): Promise<any>

		/**
		 * Return *True* if the symbol is created from
		 *         an import statement.
		 *         
		 */
		is_imported(): Promise<any>
		is_imported$($: {}): Promise<any>

		/**
		 * Return *True* if a symbol is assigned to.
		 */
		is_assigned(): Promise<any>
		is_assigned$($: {}): Promise<any>

		/**
		 * Returns *True* if name binding introduces new namespace.
		 * 
		 *         If the name is used as the target of a function or class
		 *         statement, this will be true.
		 * 
		 *         Note that a single name can be bound to multiple objects.  If
		 *         is_namespace() is true, the name may also be bound to other
		 *         objects, like an int or list, that does not introduce a new
		 *         namespace.
		 *         
		 */
		is_namespace(): Promise<any>
		is_namespace$($: {}): Promise<any>

		/**
		 * Return a list of namespaces bound to this name
		 */
		get_namespaces(): Promise<any>
		get_namespaces$($: {}): Promise<any>

		/**
		 * Return the single namespace bound to this name.
		 * 
		 *         Raises ValueError if the name is bound to multiple namespaces.
		 *         
		 */
		get_namespace(): Promise<any>
		get_namespace$($: {}): Promise<any>
	}
	let src: Promise<any>
	let mod: Promise<any>
	let info: Promise<any>
}
declare module sysconfig {
	var _
	function is_python_build(check_home?: boolean): Promise<any>
	function is_python_build$({ check_home }: { check_home?}): Promise<any>
	function get_preferred_scheme(key): Promise<any>
	function get_preferred_scheme$({ key }): Promise<any>
	function get_default_scheme(): Promise<any>
	function get_default_scheme$($: {}): Promise<any>

	/**
	 * Return the path of the Makefile.
	 */
	function get_makefile_filename(): Promise<any>
	function get_makefile_filename$($: {}): Promise<any>

	/**
	 * Parse a config.h-style file.
	 * 
	 *     A dictionary containing name/value pairs is returned.  If an
	 *     optional dictionary is passed in as the second argument, it is
	 *     used instead of a new dictionary.
	 *     
	 */
	function parse_config_h(fp, vars?): Promise<any>
	function parse_config_h$({ fp, vars }: { fp, vars?}): Promise<any>

	/**
	 * Return the path of pyconfig.h.
	 */
	function get_config_h_filename(): Promise<any>
	function get_config_h_filename$($: {}): Promise<any>

	/**
	 * Return a tuple containing the schemes names.
	 */
	function get_scheme_names(): Promise<any>
	function get_scheme_names$($: {}): Promise<any>

	/**
	 * Return a tuple containing the paths names.
	 */
	function get_path_names(): Promise<any>
	function get_path_names$($: {}): Promise<any>

	/**
	 * Return a mapping containing an install scheme.
	 * 
	 *     ``scheme`` is the install scheme name. If not provided, it will
	 *     return the default scheme for the current platform.
	 *     
	 */
	function get_paths(scheme?, vars?, expand?: boolean): Promise<any>
	function get_paths$({ scheme, vars, expand }: { scheme?, vars?, expand?}): Promise<any>

	/**
	 * Return a path corresponding to the scheme.
	 * 
	 *     ``scheme`` is the install scheme name.
	 *     
	 */
	function get_path(name, scheme?, vars?, expand?: boolean): Promise<any>
	function get_path$({ name, scheme, vars, expand }: { name, scheme?, vars?, expand?}): Promise<any>

	/**
	 * With no arguments, return a dictionary of all configuration
	 *     variables relevant for the current platform.
	 * 
	 *     On Unix, this means every variable defined in Python's installed Makefile;
	 *     On Windows it's a much smaller set.
	 * 
	 *     With arguments, return a list of values that result from looking up
	 *     each argument in the configuration variable dictionary.
	 *     
	 */
	function get_config_vars(): Promise<any>
	function get_config_vars$($: {}): Promise<any>

	/**
	 * Return the value of a single variable using the dictionary returned by
	 *     'get_config_vars()'.
	 * 
	 *     Equivalent to get_config_vars().get(name)
	 *     
	 */
	function get_config_var(name): Promise<any>
	function get_config_var$({ name }): Promise<any>

	/**
	 * Return a string that identifies the current platform.
	 * 
	 *     This is used mainly to distinguish platform-specific build directories and
	 *     platform-specific built distributions.  Typically includes the OS name and
	 *     version and the architecture (as supplied by 'os.uname()'), although the
	 *     exact information included depends on the OS; on Linux, the kernel version
	 *     isn't particularly important.
	 * 
	 *     Examples of returned values:
	 *        linux-i586
	 *        linux-alpha (?)
	 *        solaris-2.6-sun4u
	 * 
	 *     Windows will return one of:
	 *        win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)
	 *        win32 (all others - specifically, sys.platform is returned)
	 * 
	 *     For other non-POSIX platforms, currently just returns 'sys.platform'.
	 * 
	 *     
	 */
	function get_platform(): Promise<any>
	function get_platform$($: {}): Promise<any>
	function get_python_version(): Promise<any>
	function get_python_version$($: {}): Promise<any>

	/**
	 * Expand Makefile-style variables -- "${foo}" or "$(foo)" -- in
	 *     'string' according to 'vars' (a dictionary mapping variable names to
	 *     values).  Variables not present in 'vars' are silently expanded to the
	 *     empty string.  The variable values in 'vars' should not contain further
	 *     variable expansions; if 'vars' is the output of 'parse_makefile()',
	 *     you're fine.  Returns a variable-expanded version of 's'.
	 *     
	 */
	function expand_makefile_vars(s, vars): Promise<any>
	function expand_makefile_vars$({ s, vars }): Promise<any>
	let scheme: Promise<any>
}
declare module tabnanny {
	var _
	function errprint(): Promise<any>
	function errprint$($: {}): Promise<any>
	function main(): Promise<any>
	function main$($: {}): Promise<any>

	/**
	 * check(file_or_dir)
	 * 
	 *     If file_or_dir is a directory and not a symbolic link, then recursively
	 *     descend the directory tree named by file_or_dir, checking all .py files
	 *     along the way. If file_or_dir is an ordinary Python source file, it is
	 *     checked for whitespace related problems. The diagnostic messages are
	 *     written to standard output using the print statement.
	 *     
	 */
	function check(file): Promise<any>
	function check$({ file }): Promise<any>
	function format_witnesses(w): Promise<any>
	function format_witnesses$({ w }): Promise<any>
	function process_tokens(tokens): Promise<any>
	function process_tokens$({ tokens }): Promise<any>

	/**
	 * 
	 *     Raised by process_tokens() if detecting an ambiguous indent.
	 *     Captured and handled in check().
	 *     
	 */
	function NannyNag(lineno, msg, line): Promise<INannyNag>
	function NannyNag$({ lineno, msg, line }): Promise<INannyNag>
	interface INannyNag {
		get_lineno(): Promise<any>
		get_lineno$($: {}): Promise<any>
		get_msg(): Promise<any>
		get_msg$($: {}): Promise<any>
		get_line(): Promise<any>
		get_line$($: {}): Promise<any>
	}
	function Whitespace(ws): Promise<IWhitespace>
	function Whitespace$({ ws }): Promise<IWhitespace>
	interface IWhitespace {
		longest_run_of_spaces(): Promise<any>
		longest_run_of_spaces$($: {}): Promise<any>
		indent_level(tabsize): Promise<any>
		indent_level$({ tabsize }): Promise<any>
		equal(other): Promise<any>
		equal$({ other }): Promise<any>
		not_equal_witness(other): Promise<any>
		not_equal_witness$({ other }): Promise<any>
		less(other): Promise<any>
		less$({ other }): Promise<any>
		not_less_witness(other): Promise<any>
		not_less_witness$({ other }): Promise<any>
	}
	let verbose: Promise<any>
	let filename_only: Promise<any>
}
declare module tarfile {
	var _

	/**
	 * Convert a string to a null-terminated bytes object.
	 *     
	 */
	function stn(s, length, encoding, errors): Promise<any>
	function stn$({ s, length, encoding, errors }): Promise<any>

	/**
	 * Convert a null-terminated bytes object to a string.
	 *     
	 */
	function nts(s, encoding, errors): Promise<any>
	function nts$({ s, encoding, errors }): Promise<any>

	/**
	 * Convert a number field to a python number.
	 *     
	 */
	function nti(s): Promise<any>
	function nti$({ s }): Promise<any>

	/**
	 * Convert a python number to a number field.
	 *     
	 */
	function itn(n, digits?, format?): Promise<any>
	function itn$({ n, digits, format }: { n, digits?, format?}): Promise<any>

	/**
	 * Calculate the checksum for a member's header by summing up all
	 *        characters except for the chksum field which is treated as if
	 *        it was filled with spaces. According to the GNU tar sources,
	 *        some tars (Sun and NeXT) calculate chksum with signed char,
	 *        which will be different if there are chars in the buffer with
	 *        the high bit set. So we calculate two checksums, unsigned and
	 *        signed.
	 *     
	 */
	function calc_chksums(buf): Promise<any>
	function calc_chksums$({ buf }): Promise<any>

	/**
	 * Copy length bytes from fileobj src to fileobj dst.
	 *        If length is None, copy the entire content.
	 *     
	 */
	function copyfileobj(src, dst, length?, exception?, bufsize?): Promise<any>
	function copyfileobj$({ src, dst, length, exception, bufsize }: { src, dst, length?, exception?, bufsize?}): Promise<any>

	/**
	 * Return True if name points to a tar archive that we
	 *        are able to handle, else return False.
	 * 
	 *        'name' should be a string, file, or file-like object.
	 *     
	 */
	function is_tarfile(name): Promise<any>
	function is_tarfile$({ name }): Promise<any>
	function main(): Promise<any>
	function main$($: {}): Promise<any>

	/**
	 * Base exception.
	 */
	interface ITarError {
	}

	/**
	 * General exception for extract errors.
	 */
	interface IExtractError extends ITarError {
	}

	/**
	 * Exception for unreadable tar archives.
	 */
	interface IReadError extends ITarError {
	}

	/**
	 * Exception for unavailable compression methods.
	 */
	interface ICompressionError extends ITarError {
	}

	/**
	 * Exception for unsupported operations on stream-like TarFiles.
	 */
	interface IStreamError extends ITarError {
	}

	/**
	 * Base exception for header errors.
	 */
	interface IHeaderError extends ITarError {
	}

	/**
	 * Exception for empty headers.
	 */
	interface IEmptyHeaderError extends IHeaderError {
	}

	/**
	 * Exception for truncated headers.
	 */
	interface ITruncatedHeaderError extends IHeaderError {
	}

	/**
	 * Exception for end of file headers.
	 */
	interface IEOFHeaderError extends IHeaderError {
	}

	/**
	 * Exception for invalid headers.
	 */
	interface IInvalidHeaderError extends IHeaderError {
	}

	/**
	 * Exception for missing and invalid extended headers.
	 */
	interface ISubsequentHeaderError extends IHeaderError {
	}

	/**
	 * Low-level file object. Supports reading and writing.
	 *        It is used instead of a regular file object for streaming
	 *        access.
	 *     
	 */
	interface I_LowLevelFile {
		close(): Promise<any>
		close$($: {}): Promise<any>
		read(size): Promise<any>
		read$({ size }): Promise<any>
		write(s): Promise<any>
		write$({ s }): Promise<any>
	}

	/**
	 * Class that serves as an adapter between TarFile and
	 *        a stream-like object.  The stream-like object only
	 *        needs to have a read() or write() method and is accessed
	 *        blockwise.  Use of gzip or bzip2 compression is possible.
	 *        A stream-like object could be for example: sys.stdin,
	 *        sys.stdout, a socket, a tape device etc.
	 * 
	 *        _Stream is intended to be used only internally.
	 *     
	 */
	interface I_Stream {

		/**
		 * Write string s to the stream.
		 *         
		 */
		write(s): Promise<any>
		write$({ s }): Promise<any>

		/**
		 * Close the _Stream object. No operation should be
		 *            done on it afterwards.
		 *         
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>

		/**
		 * Return the stream's file pointer position.
		 *         
		 */
		tell(): Promise<any>
		tell$($: {}): Promise<any>

		/**
		 * Set the stream's file pointer to pos. Negative seeking
		 *            is forbidden.
		 *         
		 */
		seek(pos?): Promise<any>
		seek$({ pos }: { pos?}): Promise<any>

		/**
		 * Return the next size number of bytes from the stream.
		 */
		read(size): Promise<any>
		read$({ size }): Promise<any>
	}

	/**
	 * Small proxy class that enables transparent compression
	 *        detection for the Stream interface (mode 'r|*').
	 *     
	 */
	interface I_StreamProxy {
		read(size): Promise<any>
		read$({ size }): Promise<any>
		getcomptype(): Promise<any>
		getcomptype$($: {}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 * A thin wrapper around an existing file object that
	 *        provides a part of its data as an individual file
	 *        object.
	 *     
	 */
	interface I_FileInFile {
		flush(): Promise<any>
		flush$($: {}): Promise<any>
		readable(): Promise<any>
		readable$($: {}): Promise<any>
		writable(): Promise<any>
		writable$($: {}): Promise<any>
		seekable(): Promise<any>
		seekable$($: {}): Promise<any>

		/**
		 * Return the current file position.
		 *         
		 */
		tell(): Promise<any>
		tell$($: {}): Promise<any>

		/**
		 * Seek to a position in the file.
		 *         
		 */
		seek(position, whence?): Promise<any>
		seek$({ position, whence }: { position, whence?}): Promise<any>

		/**
		 * Read data from the file.
		 *         
		 */
		read(size?): Promise<any>
		read$({ size }: { size?}): Promise<any>
		readinto(b): Promise<any>
		readinto$({ b }): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}
	function ExFileObject(tarfile, tarinfo): Promise<IExFileObject>
	function ExFileObject$({ tarfile, tarinfo }): Promise<IExFileObject>
	interface IExFileObject {
	}

	/**
	 * Informational class which holds the details about an
	 *        archive member given by a tar header block.
	 *        TarInfo objects are returned by TarFile.getmember(),
	 *        TarFile.getmembers() and TarFile.gettarinfo() and are
	 *        usually created internally.
	 *     
	 */

	/**
	 * Construct a TarInfo object. name is the optional name
	 *            of the member.
	 *         
	 */
	function TarInfo(name?): Promise<ITarInfo>
	function TarInfo$({ name }: { name?}): Promise<ITarInfo>
	interface ITarInfo {

		/**
		 * In pax headers, "name" is called "path".
		 */
		path(): Promise<any>
		path$($: {}): Promise<any>
		path(name): Promise<any>
		path$({ name }): Promise<any>

		/**
		 * In pax headers, "linkname" is called "linkpath".
		 */
		linkpath(): Promise<any>
		linkpath$($: {}): Promise<any>
		linkpath(linkname): Promise<any>
		linkpath$({ linkname }): Promise<any>

		/**
		 * Return the TarInfo's attributes as a dictionary.
		 *         
		 */
		get_info(): Promise<any>
		get_info$($: {}): Promise<any>

		/**
		 * Return a tar header as a string of 512 byte blocks.
		 *         
		 */
		tobuf(format?, encoding?, errors?): Promise<any>
		tobuf$({ format, encoding, errors }: { format?, encoding?, errors?}): Promise<any>

		/**
		 * Return the object as a ustar header block.
		 *         
		 */
		create_ustar_header(info, encoding, errors): Promise<any>
		create_ustar_header$({ info, encoding, errors }): Promise<any>

		/**
		 * Return the object as a GNU header block sequence.
		 *         
		 */
		create_gnu_header(info, encoding, errors): Promise<any>
		create_gnu_header$({ info, encoding, errors }): Promise<any>

		/**
		 * Return the object as a ustar header block. If it cannot be
		 *            represented this way, prepend a pax extended header sequence
		 *            with supplement information.
		 *         
		 */
		create_pax_header(info, encoding): Promise<any>
		create_pax_header$({ info, encoding }): Promise<any>

		/**
		 * Return the object as a pax global header block sequence.
		 *         
		 */
		create_pax_global_header(pax_headers): Promise<any>
		create_pax_global_header$({ pax_headers }): Promise<any>

		/**
		 * Construct a TarInfo object from a 512 byte bytes object.
		 *         
		 */
		frombuf(buf, encoding, errors): Promise<any>
		frombuf$({ buf, encoding, errors }): Promise<any>

		/**
		 * Return the next TarInfo object from TarFile object
		 *            tarfile.
		 *         
		 */
		fromtarfile(tarfile): Promise<any>
		fromtarfile$({ tarfile }): Promise<any>

		/**
		 * Return True if the Tarinfo object is a regular file.
		 */
		isreg(): Promise<any>
		isreg$($: {}): Promise<any>

		/**
		 * Return True if the Tarinfo object is a regular file.
		 */
		isfile(): Promise<any>
		isfile$($: {}): Promise<any>

		/**
		 * Return True if it is a directory.
		 */
		isdir(): Promise<any>
		isdir$($: {}): Promise<any>

		/**
		 * Return True if it is a symbolic link.
		 */
		issym(): Promise<any>
		issym$($: {}): Promise<any>

		/**
		 * Return True if it is a hard link.
		 */
		islnk(): Promise<any>
		islnk$($: {}): Promise<any>

		/**
		 * Return True if it is a character device.
		 */
		ischr(): Promise<any>
		ischr$($: {}): Promise<any>

		/**
		 * Return True if it is a block device.
		 */
		isblk(): Promise<any>
		isblk$($: {}): Promise<any>

		/**
		 * Return True if it is a FIFO.
		 */
		isfifo(): Promise<any>
		isfifo$($: {}): Promise<any>
		issparse(): Promise<any>
		issparse$($: {}): Promise<any>

		/**
		 * Return True if it is one of character device, block device or FIFO.
		 */
		isdev(): Promise<any>
		isdev$($: {}): Promise<any>
	}

	/**
	 * The TarFile Class provides an interface to tar archives.
	 *     
	 */

	/**
	 * Open an (uncompressed) tar archive `name'. `mode' is either 'r' to
	 *            read from an existing archive, 'a' to append data to an existing
	 *            file or 'w' to create a new file overwriting an existing one. `mode'
	 *            defaults to 'r'.
	 *            If `fileobj' is given, it is used for reading or writing data. If it
	 *            can be determined, `mode' is overridden by `fileobj's mode.
	 *            `fileobj' is not closed, when TarFile is closed.
	 *         
	 */
	function TarFile(name?, mode?, fileobj?, format?, tarinfo?, dereference?, ignore_zeros?, encoding?, errors?, pax_headers?, debug?, errorlevel?, copybufsize?): Promise<ITarFile>
	function TarFile$({ name, mode, fileobj, format, tarinfo, dereference, ignore_zeros, encoding, errors, pax_headers, debug, errorlevel, copybufsize }: { name?, mode?, fileobj?, format?, tarinfo?, dereference?, ignore_zeros?, encoding?, errors?, pax_headers?, debug?, errorlevel?, copybufsize?}): Promise<ITarFile>
	interface ITarFile {

		/**
		 * Open a tar archive for reading, writing or appending. Return
		 *            an appropriate TarFile class.
		 * 
		 *            mode:
		 *            'r' or 'r:*' open for reading with transparent compression
		 *            'r:'         open for reading exclusively uncompressed
		 *            'r:gz'       open for reading with gzip compression
		 *            'r:bz2'      open for reading with bzip2 compression
		 *            'r:xz'       open for reading with lzma compression
		 *            'a' or 'a:'  open for appending, creating the file if necessary
		 *            'w' or 'w:'  open for writing without compression
		 *            'w:gz'       open for writing with gzip compression
		 *            'w:bz2'      open for writing with bzip2 compression
		 *            'w:xz'       open for writing with lzma compression
		 * 
		 *            'x' or 'x:'  create a tarfile exclusively without compression, raise
		 *                         an exception if the file is already created
		 *            'x:gz'       create a gzip compressed tarfile, raise an exception
		 *                         if the file is already created
		 *            'x:bz2'      create a bzip2 compressed tarfile, raise an exception
		 *                         if the file is already created
		 *            'x:xz'       create an lzma compressed tarfile, raise an exception
		 *                         if the file is already created
		 * 
		 *            'r|*'        open a stream of tar blocks with transparent compression
		 *            'r|'         open an uncompressed stream of tar blocks for reading
		 *            'r|gz'       open a gzip compressed stream of tar blocks
		 *            'r|bz2'      open a bzip2 compressed stream of tar blocks
		 *            'r|xz'       open an lzma compressed stream of tar blocks
		 *            'w|'         open an uncompressed stream for writing
		 *            'w|gz'       open a gzip compressed stream for writing
		 *            'w|bz2'      open a bzip2 compressed stream for writing
		 *            'w|xz'       open an lzma compressed stream for writing
		 *         
		 */
		open(name?, mode?, fileobj?, bufsize?): Promise<any>
		open$({ name, mode, fileobj, bufsize }: { name?, mode?, fileobj?, bufsize?}): Promise<any>

		/**
		 * Open uncompressed tar archive name for reading or writing.
		 *         
		 */
		taropen(name, mode?, fileobj?): Promise<any>
		taropen$({ name, mode, fileobj }: { name, mode?, fileobj?}): Promise<any>

		/**
		 * Open gzip compressed tar archive name for reading or writing.
		 *            Appending is not allowed.
		 *         
		 */
		gzopen(name, mode?, fileobj?, compresslevel?): Promise<any>
		gzopen$({ name, mode, fileobj, compresslevel }: { name, mode?, fileobj?, compresslevel?}): Promise<any>

		/**
		 * Open bzip2 compressed tar archive name for reading or writing.
		 *            Appending is not allowed.
		 *         
		 */
		bz2open(name, mode?, fileobj?, compresslevel?): Promise<any>
		bz2open$({ name, mode, fileobj, compresslevel }: { name, mode?, fileobj?, compresslevel?}): Promise<any>

		/**
		 * Open lzma compressed tar archive name for reading or writing.
		 *            Appending is not allowed.
		 *         
		 */
		xzopen(name, mode?, fileobj?, preset?): Promise<any>
		xzopen$({ name, mode, fileobj, preset }: { name, mode?, fileobj?, preset?}): Promise<any>

		/**
		 * Close the TarFile. In write-mode, two finishing zero blocks are
		 *            appended to the archive.
		 *         
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>

		/**
		 * Return a TarInfo object for member `name'. If `name' can not be
		 *            found in the archive, KeyError is raised. If a member occurs more
		 *            than once in the archive, its last occurrence is assumed to be the
		 *            most up-to-date version.
		 *         
		 */
		getmember(name): Promise<any>
		getmember$({ name }): Promise<any>

		/**
		 * Return the members of the archive as a list of TarInfo objects. The
		 *            list has the same order as the members in the archive.
		 *         
		 */
		getmembers(): Promise<any>
		getmembers$($: {}): Promise<any>

		/**
		 * Return the members of the archive as a list of their names. It has
		 *            the same order as the list returned by getmembers().
		 *         
		 */
		getnames(): Promise<any>
		getnames$($: {}): Promise<any>

		/**
		 * Create a TarInfo object from the result of os.stat or equivalent
		 *            on an existing file. The file is either named by `name', or
		 *            specified as a file object `fileobj' with a file descriptor. If
		 *            given, `arcname' specifies an alternative name for the file in the
		 *            archive, otherwise, the name is taken from the 'name' attribute of
		 *            'fileobj', or the 'name' argument. The name should be a text
		 *            string.
		 *         
		 */
		gettarinfo(name?, arcname?, fileobj?): Promise<any>
		gettarinfo$({ name, arcname, fileobj }: { name?, arcname?, fileobj?}): Promise<any>

		/**
		 * Print a table of contents to sys.stdout. If `verbose' is False, only
		 *            the names of the members are printed. If it is True, an `ls -l'-like
		 *            output is produced. `members' is optional and must be a subset of the
		 *            list returned by getmembers().
		 *         
		 */
		list(verbose?: boolean): Promise<any>
		list$({ verbose }: { verbose?}): Promise<any>

		/**
		 * Add the file `name' to the archive. `name' may be any type of file
		 *            (directory, fifo, symbolic link, etc.). If given, `arcname'
		 *            specifies an alternative name for the file in the archive.
		 *            Directories are added recursively by default. This can be avoided by
		 *            setting `recursive' to False. `filter' is a function
		 *            that expects a TarInfo object argument and returns the changed
		 *            TarInfo object, if it returns None the TarInfo object will be
		 *            excluded from the archive.
		 *         
		 */
		add(name, arcname?, recursive?: boolean): Promise<any>
		add$({ name, arcname, recursive }: { name, arcname?, recursive?}): Promise<any>

		/**
		 * Add the TarInfo object `tarinfo' to the archive. If `fileobj' is
		 *            given, it should be a binary file, and tarinfo.size bytes are read
		 *            from it and added to the archive. You can create TarInfo objects
		 *            directly, or by using gettarinfo().
		 *         
		 */
		addfile(tarinfo, fileobj?): Promise<any>
		addfile$({ tarinfo, fileobj }: { tarinfo, fileobj?}): Promise<any>

		/**
		 * Extract all members from the archive to the current working
		 *            directory and set owner, modification time and permissions on
		 *            directories afterwards. `path' specifies a different directory
		 *            to extract to. `members' is optional and must be a subset of the
		 *            list returned by getmembers(). If `numeric_owner` is True, only
		 *            the numbers for user/group names are used and not the names.
		 *         
		 */
		extractall(path?, members?): Promise<any>
		extractall$({ path, members }: { path?, members?}): Promise<any>

		/**
		 * Extract a member from the archive to the current working directory,
		 *            using its full name. Its file information is extracted as accurately
		 *            as possible. `member' may be a filename or a TarInfo object. You can
		 *            specify a different directory using `path'. File attributes (owner,
		 *            mtime, mode) are set unless `set_attrs' is False. If `numeric_owner`
		 *            is True, only the numbers for user/group names are used and not
		 *            the names.
		 *         
		 */
		extract(member, path?, set_attrs?: boolean): Promise<any>
		extract$({ member, path, set_attrs }: { member, path?, set_attrs?}): Promise<any>

		/**
		 * Extract a member from the archive as a file object. `member' may be
		 *            a filename or a TarInfo object. If `member' is a regular file or
		 *            a link, an io.BufferedReader object is returned. For all other
		 *            existing members, None is returned. If `member' does not appear
		 *            in the archive, KeyError is raised.
		 *         
		 */
		extractfile(member): Promise<any>
		extractfile$({ member }): Promise<any>

		/**
		 * Make a directory called targetpath.
		 *         
		 */
		makedir(tarinfo, targetpath): Promise<any>
		makedir$({ tarinfo, targetpath }): Promise<any>

		/**
		 * Make a file called targetpath.
		 *         
		 */
		makefile(tarinfo, targetpath): Promise<any>
		makefile$({ tarinfo, targetpath }): Promise<any>

		/**
		 * Make a file from a TarInfo object with an unknown type
		 *            at targetpath.
		 *         
		 */
		makeunknown(tarinfo, targetpath): Promise<any>
		makeunknown$({ tarinfo, targetpath }): Promise<any>

		/**
		 * Make a fifo called targetpath.
		 *         
		 */
		makefifo(tarinfo, targetpath): Promise<any>
		makefifo$({ tarinfo, targetpath }): Promise<any>

		/**
		 * Make a character or block device called targetpath.
		 *         
		 */
		makedev(tarinfo, targetpath): Promise<any>
		makedev$({ tarinfo, targetpath }): Promise<any>

		/**
		 * Make a (symbolic) link called targetpath. If it cannot be created
		 *           (platform limitation), we try to make a copy of the referenced file
		 *           instead of a link.
		 *         
		 */
		makelink(tarinfo, targetpath): Promise<any>
		makelink$({ tarinfo, targetpath }): Promise<any>

		/**
		 * Set owner of targetpath according to tarinfo. If numeric_owner
		 *            is True, use .gid/.uid instead of .gname/.uname. If numeric_owner
		 *            is False, fall back to .gid/.uid when the search based on name
		 *            fails.
		 *         
		 */
		chown(tarinfo, targetpath, numeric_owner): Promise<any>
		chown$({ tarinfo, targetpath, numeric_owner }): Promise<any>

		/**
		 * Set file permissions of targetpath according to tarinfo.
		 *         
		 */
		chmod(tarinfo, targetpath): Promise<any>
		chmod$({ tarinfo, targetpath }): Promise<any>

		/**
		 * Set modification time of targetpath according to tarinfo.
		 *         
		 */
		utime(tarinfo, targetpath): Promise<any>
		utime$({ tarinfo, targetpath }): Promise<any>

		/**
		 * Return the next member of the archive as a TarInfo object, when
		 *            TarFile is opened for reading. Return None if there is no more
		 *            available.
		 *         
		 */
		next(): Promise<any>
		next$($: {}): Promise<any>
		debug
		dereference
		ignore_zeros
		errorlevel
		format
		encoding
		errors
		tarinfo
		fileobject
		OPEN_METH
	}
	let version: Promise<any>
	let symlink_exception: Promise<any>
	let NUL: Promise<any>
	let BLOCKSIZE: Promise<any>
	let RECORDSIZE: Promise<any>
	let GNU_MAGIC: Promise<any>
	let POSIX_MAGIC: Promise<any>
	let LENGTH_NAME: Promise<any>
	let LENGTH_LINK: Promise<any>
	let LENGTH_PREFIX: Promise<any>
	let REGTYPE: Promise<any>
	let AREGTYPE: Promise<any>
	let LNKTYPE: Promise<any>
	let SYMTYPE: Promise<any>
	let CHRTYPE: Promise<any>
	let BLKTYPE: Promise<any>
	let DIRTYPE: Promise<any>
	let FIFOTYPE: Promise<any>
	let CONTTYPE: Promise<any>
	let GNUTYPE_LONGNAME: Promise<any>
	let GNUTYPE_LONGLINK: Promise<any>
	let GNUTYPE_SPARSE: Promise<any>
	let XHDTYPE: Promise<any>
	let XGLTYPE: Promise<any>
	let SOLARIS_XHDTYPE: Promise<any>
	let USTAR_FORMAT: Promise<any>
	let GNU_FORMAT: Promise<any>
	let PAX_FORMAT: Promise<any>
	let DEFAULT_FORMAT: Promise<any>
	let SUPPORTED_TYPES: Promise<any>
	let REGULAR_TYPES: Promise<any>
	let GNU_TYPES: Promise<any>
	let PAX_FIELDS: Promise<any>
	let PAX_NAME_FIELDS: Promise<any>
	let PAX_NUMBER_FIELDS: Promise<any>
	let ENCODING: Promise<any>
}
declare module telnetlib {
	var _

	/**
	 * Test program for telnetlib.
	 * 
	 *     Usage: python telnetlib.py [-d] ... [host [port]]
	 * 
	 *     Default host is localhost; default port is 23.
	 * 
	 *     
	 */
	function test(): Promise<any>
	function test$($: {}): Promise<any>

	/**
	 * Telnet interface class.
	 * 
	 *     An instance of this class represents a connection to a telnet
	 *     server.  The instance is initially not connected; the open()
	 *     method must be used to establish a connection.  Alternatively, the
	 *     host name and optional port number can be passed to the
	 *     constructor, too.
	 * 
	 *     Don't try to reopen an already connected instance.
	 * 
	 *     This class has many read_*() methods.  Note that some of them
	 *     raise EOFError when the end of the connection is read, because
	 *     they can return an empty string for other reasons.  See the
	 *     individual doc strings.
	 * 
	 *     read_until(expected, [timeout])
	 *         Read until the expected string has been seen, or a timeout is
	 *         hit (default is no timeout); may block.
	 * 
	 *     read_all()
	 *         Read all data until EOF; may block.
	 * 
	 *     read_some()
	 *         Read at least one byte or EOF; may block.
	 * 
	 *     read_very_eager()
	 *         Read all data available already queued or on the socket,
	 *         without blocking.
	 * 
	 *     read_eager()
	 *         Read either data already queued or some data available on the
	 *         socket, without blocking.
	 * 
	 *     read_lazy()
	 *         Read all data in the raw queue (processing it first), without
	 *         doing any socket I/O.
	 * 
	 *     read_very_lazy()
	 *         Reads all data in the cooked queue, without doing any socket
	 *         I/O.
	 * 
	 *     read_sb_data()
	 *         Reads available data between SB ... SE sequence. Don't block.
	 * 
	 *     set_option_negotiation_callback(callback)
	 *         Each time a telnet option is read on the input flow, this callback
	 *         (if set) is called with the following parameters :
	 *         callback(telnet socket, command, option)
	 *             option will be chr(0) when there is no option.
	 *         No other action is done afterwards by telnetlib.
	 * 
	 *     
	 */

	/**
	 * Constructor.
	 * 
	 *         When called without arguments, create an unconnected instance.
	 *         With a hostname argument, it connects the instance; port number
	 *         and timeout are optional.
	 *         
	 */
	function Telnet(host?, port?, timeout?): Promise<ITelnet>
	function Telnet$({ host, port, timeout }: { host?, port?, timeout?}): Promise<ITelnet>
	interface ITelnet {

		/**
		 * Connect to a host.
		 * 
		 *         The optional second argument is the port number, which
		 *         defaults to the standard telnet port (23).
		 * 
		 *         Don't try to reopen an already connected instance.
		 *         
		 */
		open(host, port?, timeout?): Promise<any>
		open$({ host, port, timeout }: { host, port?, timeout?}): Promise<any>

		/**
		 * Print a debug message, when the debug level is > 0.
		 * 
		 *         If extra arguments are present, they are substituted in the
		 *         message using the standard string formatting operator.
		 * 
		 *         
		 */
		msg(msg): Promise<any>
		msg$({ msg }): Promise<any>

		/**
		 * Set the debug level.
		 * 
		 *         The higher it is, the more debug output you get (on sys.stdout).
		 * 
		 *         
		 */
		set_debuglevel(debuglevel): Promise<any>
		set_debuglevel$({ debuglevel }): Promise<any>

		/**
		 * Close the connection.
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>

		/**
		 * Return the socket object used internally.
		 */
		get_socket(): Promise<any>
		get_socket$($: {}): Promise<any>

		/**
		 * Return the fileno() of the socket object used internally.
		 */
		fileno(): Promise<any>
		fileno$($: {}): Promise<any>

		/**
		 * Write a string to the socket, doubling any IAC characters.
		 * 
		 *         Can block if the connection is blocked.  May raise
		 *         OSError if the connection is closed.
		 * 
		 *         
		 */
		write(buffer): Promise<any>
		write$({ buffer }): Promise<any>

		/**
		 * Read until a given string is encountered or until timeout.
		 * 
		 *         When no match is found, return whatever is available instead,
		 *         possibly the empty string.  Raise EOFError if the connection
		 *         is closed and no cooked data is available.
		 * 
		 *         
		 */
		read_until(match, timeout?): Promise<any>
		read_until$({ match, timeout }: { match, timeout?}): Promise<any>

		/**
		 * Read all data until EOF; block until connection closed.
		 */
		read_all(): Promise<any>
		read_all$($: {}): Promise<any>

		/**
		 * Read at least one byte of cooked data unless EOF is hit.
		 * 
		 *         Return b'' if EOF is hit.  Block if no data is immediately
		 *         available.
		 * 
		 *         
		 */
		read_some(): Promise<any>
		read_some$($: {}): Promise<any>

		/**
		 * Read everything that's possible without blocking in I/O (eager).
		 * 
		 *         Raise EOFError if connection closed and no cooked data
		 *         available.  Return b'' if no cooked data available otherwise.
		 *         Don't block unless in the midst of an IAC sequence.
		 * 
		 *         
		 */
		read_very_eager(): Promise<any>
		read_very_eager$($: {}): Promise<any>

		/**
		 * Read readily available data.
		 * 
		 *         Raise EOFError if connection closed and no cooked data
		 *         available.  Return b'' if no cooked data available otherwise.
		 *         Don't block unless in the midst of an IAC sequence.
		 * 
		 *         
		 */
		read_eager(): Promise<any>
		read_eager$($: {}): Promise<any>

		/**
		 * Process and return data that's already in the queues (lazy).
		 * 
		 *         Raise EOFError if connection closed and no data available.
		 *         Return b'' if no cooked data available otherwise.  Don't block
		 *         unless in the midst of an IAC sequence.
		 * 
		 *         
		 */
		read_lazy(): Promise<any>
		read_lazy$($: {}): Promise<any>

		/**
		 * Return any data available in the cooked queue (very lazy).
		 * 
		 *         Raise EOFError if connection closed and no data available.
		 *         Return b'' if no cooked data available otherwise.  Don't block.
		 * 
		 *         
		 */
		read_very_lazy(): Promise<any>
		read_very_lazy$($: {}): Promise<any>

		/**
		 * Return any data available in the SB ... SE queue.
		 * 
		 *         Return b'' if no SB ... SE available. Should only be called
		 *         after seeing a SB or SE command. When a new SB command is
		 *         found, old unread SB data will be discarded. Don't block.
		 * 
		 *         
		 */
		read_sb_data(): Promise<any>
		read_sb_data$($: {}): Promise<any>

		/**
		 * Provide a callback function called after each receipt of a telnet option.
		 */
		set_option_negotiation_callback(callback): Promise<any>
		set_option_negotiation_callback$({ callback }): Promise<any>

		/**
		 * Transfer from raw queue to cooked queue.
		 * 
		 *         Set self.eof when connection is closed.  Don't block unless in
		 *         the midst of an IAC sequence.
		 * 
		 *         
		 */
		process_rawq(): Promise<any>
		process_rawq$($: {}): Promise<any>

		/**
		 * Get next char from raw queue.
		 * 
		 *         Block if no data is immediately available.  Raise EOFError
		 *         when connection is closed.
		 * 
		 *         
		 */
		rawq_getchar(): Promise<any>
		rawq_getchar$($: {}): Promise<any>

		/**
		 * Fill raw queue from exactly one recv() system call.
		 * 
		 *         Block if no data is immediately available.  Set self.eof when
		 *         connection is closed.
		 * 
		 *         
		 */
		fill_rawq(): Promise<any>
		fill_rawq$($: {}): Promise<any>

		/**
		 * Test whether data is available on the socket.
		 */
		sock_avail(): Promise<any>
		sock_avail$($: {}): Promise<any>

		/**
		 * Interaction function, emulates a very dumb telnet client.
		 */
		interact(): Promise<any>
		interact$($: {}): Promise<any>

		/**
		 * Multithreaded version of interact().
		 */
		mt_interact(): Promise<any>
		mt_interact$($: {}): Promise<any>

		/**
		 * Helper for mt_interact() -- this executes in the other thread.
		 */
		listener(): Promise<any>
		listener$($: {}): Promise<any>

		/**
		 * Read until one from a list of a regular expressions matches.
		 * 
		 *         The first argument is a list of regular expressions, either
		 *         compiled (re.Pattern instances) or uncompiled (strings).
		 *         The optional second argument is a timeout, in seconds; default
		 *         is no timeout.
		 * 
		 *         Return a tuple of three items: the index in the list of the
		 *         first regular expression that matches; the re.Match object
		 *         returned; and the text read up till and including the match.
		 * 
		 *         If EOF is read and no text was read, raise EOFError.
		 *         Otherwise, when nothing matches, return (-1, None, text) where
		 *         text is the text received so far (may be the empty string if a
		 *         timeout happened).
		 * 
		 *         If a regular expression ends with a greedy match (e.g. '.*')
		 *         or if more than one expression can match the same input, the
		 *         results are undeterministic, and may depend on the I/O timing.
		 * 
		 *         
		 */
		expect(list, timeout?): Promise<any>
		expect$({ list, timeout }: { list, timeout?}): Promise<any>
	}
	let DEBUGLEVEL: Promise<any>
	let TELNET_PORT: Promise<any>
	let IAC: Promise<any>
	let DONT: Promise<any>
	let DO: Promise<any>
	let WONT: Promise<any>
	let WILL: Promise<any>
	let theNULL: Promise<any>
	let SE: Promise<any>
	let NOP: Promise<any>
	let DM: Promise<any>
	let BRK: Promise<any>
	let IP: Promise<any>
	let AO: Promise<any>
	let AYT: Promise<any>
	let EC: Promise<any>
	let EL: Promise<any>
	let GA: Promise<any>
	let SB: Promise<any>
	let BINARY: Promise<any>
	let ECHO: Promise<any>
	let RCP: Promise<any>
	let SGA: Promise<any>
	let NAMS: Promise<any>
	let STATUS: Promise<any>
	let TM: Promise<any>
	let RCTE: Promise<any>
	let NAOL: Promise<any>
	let NAOP: Promise<any>
	let NAOCRD: Promise<any>
	let NAOHTS: Promise<any>
	let NAOHTD: Promise<any>
	let NAOFFD: Promise<any>
	let NAOVTS: Promise<any>
	let NAOVTD: Promise<any>
	let NAOLFD: Promise<any>
	let XASCII: Promise<any>
	let LOGOUT: Promise<any>
	let BM: Promise<any>
	let DET: Promise<any>
	let SUPDUP: Promise<any>
	let SUPDUPOUTPUT: Promise<any>
	let SNDLOC: Promise<any>
	let TTYPE: Promise<any>
	let EOR: Promise<any>
	let TUID: Promise<any>
	let OUTMRK: Promise<any>
	let TTYLOC: Promise<any>
	let VT3270REGIME: Promise<any>
	let X3PAD: Promise<any>
	let NAWS: Promise<any>
	let TSPEED: Promise<any>
	let LFLOW: Promise<any>
	let LINEMODE: Promise<any>
	let XDISPLOC: Promise<any>
	let OLD_ENVIRON: Promise<any>
	let AUTHENTICATION: Promise<any>
	let ENCRYPT: Promise<any>
	let NEW_ENVIRON: Promise<any>
	let TN3270E: Promise<any>
	let XAUTH: Promise<any>
	let CHARSET: Promise<any>
	let RSP: Promise<any>
	let COM_PORT_OPTION: Promise<any>
	let SUPPRESS_LOCAL_ECHO: Promise<any>
	let TLS: Promise<any>
	let KERMIT: Promise<any>
	let SEND_URL: Promise<any>
	let FORWARD_X: Promise<any>
	let PRAGMA_LOGON: Promise<any>
	let SSPI_LOGON: Promise<any>
	let PRAGMA_HEARTBEAT: Promise<any>
	let EXOPL: Promise<any>
	let NOOPT: Promise<any>
}
declare module tempfile {
	var _

	/**
	 * The default prefix for temporary directories as string.
	 */
	function gettempprefix(): Promise<any>
	function gettempprefix$($: {}): Promise<any>

	/**
	 * The default prefix for temporary directories as bytes.
	 */
	function gettempprefixb(): Promise<any>
	function gettempprefixb$($: {}): Promise<any>

	/**
	 * Returns tempfile.tempdir as str.
	 */
	function gettempdir(): Promise<any>
	function gettempdir$($: {}): Promise<any>

	/**
	 * Returns tempfile.tempdir as bytes.
	 */
	function gettempdirb(): Promise<any>
	function gettempdirb$($: {}): Promise<any>

	/**
	 * User-callable function to create and return a unique temporary
	 *     file.  The return value is a pair (fd, name) where fd is the
	 *     file descriptor returned by os.open, and name is the filename.
	 * 
	 *     If 'suffix' is not None, the file name will end with that suffix,
	 *     otherwise there will be no suffix.
	 * 
	 *     If 'prefix' is not None, the file name will begin with that prefix,
	 *     otherwise a default prefix is used.
	 * 
	 *     If 'dir' is not None, the file will be created in that directory,
	 *     otherwise a default directory is used.
	 * 
	 *     If 'text' is specified and true, the file is opened in text
	 *     mode.  Else (the default) the file is opened in binary mode.
	 * 
	 *     If any of 'suffix', 'prefix' and 'dir' are not None, they must be the
	 *     same type.  If they are bytes, the returned name will be bytes; str
	 *     otherwise.
	 * 
	 *     The file is readable and writable only by the creating user ID.
	 *     If the operating system uses permission bits to indicate whether a
	 *     file is executable, the file is executable by no one. The file
	 *     descriptor is not inherited by children of this process.
	 * 
	 *     Caller is responsible for deleting the file when done with it.
	 *     
	 */
	function mkstemp(suffix?, prefix?, dir?, text?: boolean): Promise<any>
	function mkstemp$({ suffix, prefix, dir, text }: { suffix?, prefix?, dir?, text?}): Promise<any>

	/**
	 * User-callable function to create and return a unique temporary
	 *     directory.  The return value is the pathname of the directory.
	 * 
	 *     Arguments are as for mkstemp, except that the 'text' argument is
	 *     not accepted.
	 * 
	 *     The directory is readable, writable, and searchable only by the
	 *     creating user.
	 * 
	 *     Caller is responsible for deleting the directory when done with it.
	 *     
	 */
	function mkdtemp(suffix?, prefix?, dir?): Promise<any>
	function mkdtemp$({ suffix, prefix, dir }: { suffix?, prefix?, dir?}): Promise<any>

	/**
	 * User-callable function to return a unique temporary file name.  The
	 *     file is not created.
	 * 
	 *     Arguments are similar to mkstemp, except that the 'text' argument is
	 *     not accepted, and suffix=None, prefix=None and bytes file names are not
	 *     supported.
	 * 
	 *     THIS FUNCTION IS UNSAFE AND SHOULD NOT BE USED.  The file name may
	 *     refer to a file that did not exist at some point, but by the time
	 *     you get around to creating it, someone else may have beaten you to
	 *     the punch.
	 *     
	 */
	function mktemp(suffix?, prefix?, dir?): Promise<any>
	function mktemp$({ suffix, prefix, dir }: { suffix?, prefix?, dir?}): Promise<any>

	/**
	 * Create and return a temporary file.
	 *     Arguments:
	 *     'prefix', 'suffix', 'dir' -- as for mkstemp.
	 *     'mode' -- the mode argument to io.open (default "w+b").
	 *     'buffering' -- the buffer size argument to io.open (default -1).
	 *     'encoding' -- the encoding argument to io.open (default None)
	 *     'newline' -- the newline argument to io.open (default None)
	 *     'delete' -- whether the file is deleted on close (default True).
	 *     'errors' -- the errors argument to io.open (default None)
	 *     The file is created as mkstemp() would do it.
	 * 
	 *     Returns an object with a file-like interface; the name of the file
	 *     is accessible as its 'name' attribute.  The file will be automatically
	 *     deleted when it is closed unless the 'delete' argument is set to False.
	 * 
	 *     On POSIX, NamedTemporaryFiles cannot be automatically deleted if
	 *     the creating process is terminated abruptly with a SIGKILL signal.
	 *     Windows can delete the file even in this case.
	 *     
	 */
	function NamedTemporaryFile(mode?, buffering?, encoding?, newline?, suffix?, prefix?, dir?, del?: boolean): Promise<any>
	function NamedTemporaryFile$({ mode, buffering, encoding, newline, suffix, prefix, dir, del }: { mode?, buffering?, encoding?, newline?, suffix?, prefix?, dir?, del?}): Promise<any>

	/**
	 * Create and return a temporary file.
	 *         Arguments:
	 *         'prefix', 'suffix', 'dir' -- as for mkstemp.
	 *         'mode' -- the mode argument to io.open (default "w+b").
	 *         'buffering' -- the buffer size argument to io.open (default -1).
	 *         'encoding' -- the encoding argument to io.open (default None)
	 *         'newline' -- the newline argument to io.open (default None)
	 *         'errors' -- the errors argument to io.open (default None)
	 *         The file is created as mkstemp() would do it.
	 * 
	 *         Returns an object with a file-like interface.  The file has no
	 *         name, and will cease to exist when it is closed.
	 *         
	 */
	function TemporaryFile(mode?, buffering?, encoding?, newline?, suffix?, prefix?, dir?): Promise<any>
	function TemporaryFile$({ mode, buffering, encoding, newline, suffix, prefix, dir }: { mode?, buffering?, encoding?, newline?, suffix?, prefix?, dir?}): Promise<any>

	/**
	 * An instance of _RandomNameSequence generates an endless
	 *     sequence of unpredictable strings which can safely be incorporated
	 *     into file names.  Each string is eight characters long.  Multiple
	 *     threads can safely use the same instance at the same time.
	 * 
	 *     _RandomNameSequence is an iterator.
	 */
	interface I_RandomNameSequence {
		rng(): Promise<any>
		rng$($: {}): Promise<any>
		characters
	}

	/**
	 * A separate object allowing proper closing of a temporary file's
	 *     underlying file object, without adding a __del__ method to the
	 *     temporary file.
	 */
	interface I_TemporaryFileCloser {
		file
		close_called
	}

	/**
	 * Temporary file wrapper
	 * 
	 *     This class provides a wrapper around files opened for
	 *     temporary use.  In particular, it seeks to automatically
	 *     remove the file when it is no longer needed.
	 *     
	 */
	interface I_TemporaryFileWrapper {

		/**
		 * 
		 *         Close the temporary file, possibly deleting it.
		 *         
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 * Temporary file wrapper, specialized to switch from BytesIO
	 *     or StringIO to a real file when it exceeds a certain size or
	 *     when a fileno is needed.
	 *     
	 */
	function SpooledTemporaryFile(max_size?, mode?, buffering?, encoding?, newline?, suffix?, prefix?, dir?): Promise<ISpooledTemporaryFile>
	function SpooledTemporaryFile$({ max_size, mode, buffering, encoding, newline, suffix, prefix, dir }: { max_size?, mode?, buffering?, encoding?, newline?, suffix?, prefix?, dir?}): Promise<ISpooledTemporaryFile>
	interface ISpooledTemporaryFile {
		rollover(): Promise<any>
		rollover$($: {}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
		closed(): Promise<any>
		closed$($: {}): Promise<any>
		encoding(): Promise<any>
		encoding$($: {}): Promise<any>
		errors(): Promise<any>
		errors$($: {}): Promise<any>
		fileno(): Promise<any>
		fileno$($: {}): Promise<any>
		flush(): Promise<any>
		flush$($: {}): Promise<any>
		isatty(): Promise<any>
		isatty$($: {}): Promise<any>
		mode(): Promise<any>
		mode$($: {}): Promise<any>
		name(): Promise<any>
		name$($: {}): Promise<any>
		newlines(): Promise<any>
		newlines$($: {}): Promise<any>
		read(): Promise<any>
		read$($: {}): Promise<any>
		readline(): Promise<any>
		readline$($: {}): Promise<any>
		readlines(): Promise<any>
		readlines$($: {}): Promise<any>
		seek(): Promise<any>
		seek$($: {}): Promise<any>
		tell(): Promise<any>
		tell$($: {}): Promise<any>
		truncate(size?): Promise<any>
		truncate$({ size }: { size?}): Promise<any>
		write(s): Promise<any>
		write$({ s }): Promise<any>
		writelines(iterable): Promise<any>
		writelines$({ iterable }): Promise<any>
	}

	/**
	 * Create and return a temporary directory.  This has the same
	 *     behavior as mkdtemp but can be used as a context manager.  For
	 *     example:
	 * 
	 *         with TemporaryDirectory() as tmpdir:
	 *             ...
	 * 
	 *     Upon exiting the context, the directory and everything contained
	 *     in it are removed.
	 *     
	 */
	function TemporaryDirectory(suffix?, prefix?, dir?, ignore_cleanup_errors?: boolean): Promise<ITemporaryDirectory>
	function TemporaryDirectory$({ suffix, prefix, dir, ignore_cleanup_errors }: { suffix?, prefix?, dir?, ignore_cleanup_errors?}): Promise<ITemporaryDirectory>
	interface ITemporaryDirectory {
		cleanup(): Promise<any>
		cleanup$($: {}): Promise<any>
	}
	let TMP_MAX: Promise<any>
	let template: Promise<any>
	let tempdir: Promise<any>
}
declare module textwrap {
	var _

	/**
	 * Wrap a single paragraph of text, returning a list of wrapped lines.
	 * 
	 *     Reformat the single paragraph in 'text' so it fits in lines of no
	 *     more than 'width' columns, and return a list of wrapped lines.  By
	 *     default, tabs in 'text' are expanded with string.expandtabs(), and
	 *     all other whitespace characters (including newline) are converted to
	 *     space.  See TextWrapper class for available keyword args to customize
	 *     wrapping behaviour.
	 *     
	 */
	function wrap(text, width?): Promise<any>
	function wrap$({ text, width }: { text, width?}): Promise<any>

	/**
	 * Fill a single paragraph of text, returning a new string.
	 * 
	 *     Reformat the single paragraph in 'text' to fit in lines of no more
	 *     than 'width' columns, and return a new string containing the entire
	 *     wrapped paragraph.  As with wrap(), tabs are expanded and other
	 *     whitespace characters converted to space.  See TextWrapper class for
	 *     available keyword args to customize wrapping behaviour.
	 *     
	 */
	function fill(text, width?): Promise<any>
	function fill$({ text, width }: { text, width?}): Promise<any>

	/**
	 * Collapse and truncate the given text to fit in the given width.
	 * 
	 *     The text first has its whitespace collapsed.  If it then fits in
	 *     the *width*, it is returned as is.  Otherwise, as many words
	 *     as possible are joined and then the placeholder is appended::
	 * 
	 *         >>> textwrap.shorten("Hello  world!", width=12)
	 *         'Hello world!'
	 *         >>> textwrap.shorten("Hello  world!", width=11)
	 *         'Hello [...]'
	 *     
	 */
	function shorten(text, width): Promise<any>
	function shorten$({ text, width }): Promise<any>

	/**
	 * Remove any common leading whitespace from every line in `text`.
	 * 
	 *     This can be used to make triple-quoted strings line up with the left
	 *     edge of the display, while still presenting them in the source code
	 *     in indented form.
	 * 
	 *     Note that tabs and spaces are both treated as whitespace, but they
	 *     are not equal: the lines "  hello" and "\thello" are
	 *     considered to have no common leading whitespace.
	 * 
	 *     Entirely blank lines are normalized to a newline character.
	 *     
	 */
	function dedent(text): Promise<any>
	function dedent$({ text }): Promise<any>

	/**
	 * Adds 'prefix' to the beginning of selected lines in 'text'.
	 * 
	 *     If 'predicate' is provided, 'prefix' will only be added to the lines
	 *     where 'predicate(line)' is True. If 'predicate' is not provided,
	 *     it will default to adding 'prefix' to all non-empty lines that do not
	 *     consist solely of whitespace characters.
	 *     
	 */
	function indent(text, prefix, predicate?): Promise<any>
	function indent$({ text, prefix, predicate }: { text, prefix, predicate?}): Promise<any>

	/**
	 * 
	 *     Object for wrapping/filling text.  The public interface consists of
	 *     the wrap() and fill() methods; the other methods are just there for
	 *     subclasses to override in order to tweak the default behaviour.
	 *     If you want to completely replace the main wrapping algorithm,
	 *     you'll probably have to override _wrap_chunks().
	 * 
	 *     Several instance attributes control various aspects of wrapping:
	 *       width (default: 70)
	 *         the maximum width of wrapped lines (unless break_long_words
	 *         is false)
	 *       initial_indent (default: "")
	 *         string that will be prepended to the first line of wrapped
	 *         output.  Counts towards the line's width.
	 *       subsequent_indent (default: "")
	 *         string that will be prepended to all lines save the first
	 *         of wrapped output; also counts towards each line's width.
	 *       expand_tabs (default: true)
	 *         Expand tabs in input text to spaces before further processing.
	 *         Each tab will become 0 .. 'tabsize' spaces, depending on its position
	 *         in its line.  If false, each tab is treated as a single character.
	 *       tabsize (default: 8)
	 *         Expand tabs in input text to 0 .. 'tabsize' spaces, unless
	 *         'expand_tabs' is false.
	 *       replace_whitespace (default: true)
	 *         Replace all whitespace characters in the input text by spaces
	 *         after tab expansion.  Note that if expand_tabs is false and
	 *         replace_whitespace is true, every tab will be converted to a
	 *         single space!
	 *       fix_sentence_endings (default: false)
	 *         Ensure that sentence-ending punctuation is always followed
	 *         by two spaces.  Off by default because the algorithm is
	 *         (unavoidably) imperfect.
	 *       break_long_words (default: true)
	 *         Break words longer than 'width'.  If false, those words will not
	 *         be broken, and some lines might be longer than 'width'.
	 *       break_on_hyphens (default: true)
	 *         Allow breaking hyphenated words. If true, wrapping will occur
	 *         preferably on whitespaces and right after hyphens part of
	 *         compound words.
	 *       drop_whitespace (default: true)
	 *         Drop leading and trailing whitespace from lines.
	 *       max_lines (default: None)
	 *         Truncate wrapped lines.
	 *       placeholder (default: ' [...]')
	 *         Append to the last line of truncated text.
	 *     
	 */
	function TextWrapper(width?, initial_indent?, subsequent_indent?, expand_tabs?: boolean, replace_whitespace?: boolean, fix_sentence_endings?: boolean, break_long_words?: boolean, drop_whitespace?: boolean, break_on_hyphens?: boolean, tabsize?): Promise<ITextWrapper>
	function TextWrapper$({ width, initial_indent, subsequent_indent, expand_tabs, replace_whitespace, fix_sentence_endings, break_long_words, drop_whitespace, break_on_hyphens, tabsize }: { width?, initial_indent?, subsequent_indent?, expand_tabs?, replace_whitespace?, fix_sentence_endings?, break_long_words?, drop_whitespace?, break_on_hyphens?, tabsize?}): Promise<ITextWrapper>
	interface ITextWrapper {

		/**
		 * wrap(text : string) -> [string]
		 * 
		 *         Reformat the single paragraph in 'text' so it fits in lines of
		 *         no more than 'self.width' columns, and return a list of wrapped
		 *         lines.  Tabs in 'text' are expanded with string.expandtabs(),
		 *         and all other whitespace characters (including newline) are
		 *         converted to space.
		 *         
		 */
		wrap(text): Promise<any>
		wrap$({ text }): Promise<any>

		/**
		 * fill(text : string) -> string
		 * 
		 *         Reformat the single paragraph in 'text' to fit in lines of no
		 *         more than 'self.width' columns, and return a new string
		 *         containing the entire wrapped paragraph.
		 *         
		 */
		fill(text): Promise<any>
		fill$({ text }): Promise<any>
		unicode_whitespace_trans
		uspace
		word_punct
		letter
		whitespace
		nowhitespace
		wordsep_re
		wordsep_simple_re
		sentence_end_re
	}
}
declare module _this {
	var _
	let s: Promise<any>
	let d: Promise<any>
}
declare module threading {
	var _

	/**
	 * Set a profile function for all threads started from the threading module.
	 * 
	 *     The func will be passed to sys.setprofile() for each thread, before its
	 *     run() method is called.
	 * 
	 *     
	 */
	function setprofile(func): Promise<any>
	function setprofile$({ func }): Promise<any>

	/**
	 * Get the profiler function as set by threading.setprofile().
	 */
	function getprofile(): Promise<any>
	function getprofile$($: {}): Promise<any>

	/**
	 * Set a trace function for all threads started from the threading module.
	 * 
	 *     The func will be passed to sys.settrace() for each thread, before its run()
	 *     method is called.
	 * 
	 *     
	 */
	function settrace(func): Promise<any>
	function settrace$({ func }): Promise<any>

	/**
	 * Get the trace function as set by threading.settrace().
	 */
	function gettrace(): Promise<any>
	function gettrace$($: {}): Promise<any>

	/**
	 * Factory function that returns a new reentrant lock.
	 * 
	 *     A reentrant lock must be released by the thread that acquired it. Once a
	 *     thread has acquired a reentrant lock, the same thread may acquire it again
	 *     without blocking; the thread must release it once for each time it has
	 *     acquired it.
	 * 
	 *     
	 */
	function RLock(): Promise<any>
	function RLock$($: {}): Promise<any>

	/**
	 * Return the current Thread object, corresponding to the caller's thread of control.
	 * 
	 *     If the caller's thread of control was not created through the threading
	 *     module, a dummy thread object with limited functionality is returned.
	 * 
	 *     
	 */
	function current_thread(): Promise<any>
	function current_thread$($: {}): Promise<any>

	/**
	 * Return the current Thread object, corresponding to the caller's thread of control.
	 * 
	 *     This function is deprecated, use current_thread() instead.
	 * 
	 *     
	 */
	function currentThread(): Promise<any>
	function currentThread$($: {}): Promise<any>

	/**
	 * Return the number of Thread objects currently alive.
	 * 
	 *     The returned count is equal to the length of the list returned by
	 *     enumerate().
	 * 
	 *     
	 */
	function active_count(): Promise<any>
	function active_count$($: {}): Promise<any>

	/**
	 * Return the number of Thread objects currently alive.
	 * 
	 *     This function is deprecated, use active_count() instead.
	 * 
	 *     
	 */
	function activeCount(): Promise<any>
	function activeCount$($: {}): Promise<any>

	/**
	 * Return a list of all Thread objects currently alive.
	 * 
	 *     The list includes daemonic threads, dummy thread objects created by
	 *     current_thread(), and the main thread. It excludes terminated threads and
	 *     threads that have not yet been started.
	 * 
	 *     
	 */
	function enumerate(): Promise<any>
	function enumerate$($: {}): Promise<any>

	/**
	 * Return the main thread object.
	 * 
	 *     In normal conditions, the main thread is the thread from which the
	 *     Python interpreter was started.
	 *     
	 */
	function main_thread(): Promise<any>
	function main_thread$($: {}): Promise<any>

	/**
	 * This class implements reentrant lock objects.
	 * 
	 *     A reentrant lock must be released by the thread that acquired it. Once a
	 *     thread has acquired a reentrant lock, the same thread may acquire it
	 *     again without blocking; the thread must release it once for each time it
	 *     has acquired it.
	 * 
	 *     
	 */
	interface I_RLock {

		/**
		 * Acquire a lock, blocking or non-blocking.
		 * 
		 *         When invoked without arguments: if this thread already owns the lock,
		 *         increment the recursion level by one, and return immediately. Otherwise,
		 *         if another thread owns the lock, block until the lock is unlocked. Once
		 *         the lock is unlocked (not owned by any thread), then grab ownership, set
		 *         the recursion level to one, and return. If more than one thread is
		 *         blocked waiting until the lock is unlocked, only one at a time will be
		 *         able to grab ownership of the lock. There is no return value in this
		 *         case.
		 * 
		 *         When invoked with the blocking argument set to true, do the same thing
		 *         as when called without arguments, and return true.
		 * 
		 *         When invoked with the blocking argument set to false, do not block. If a
		 *         call without an argument would block, return false immediately;
		 *         otherwise, do the same thing as when called without arguments, and
		 *         return true.
		 * 
		 *         When invoked with the floating-point timeout argument set to a positive
		 *         value, block for at most the number of seconds specified by timeout
		 *         and as long as the lock cannot be acquired.  Return true if the lock has
		 *         been acquired, false if the timeout has elapsed.
		 * 
		 *         
		 */
		acquire(blocking?: boolean, timeout?): Promise<any>
		acquire$({ blocking, timeout }: { blocking?, timeout?}): Promise<any>

		/**
		 * Release a lock, decrementing the recursion level.
		 * 
		 *         If after the decrement it is zero, reset the lock to unlocked (not owned
		 *         by any thread), and if any other threads are blocked waiting for the
		 *         lock to become unlocked, allow exactly one of them to proceed. If after
		 *         the decrement the recursion level is still nonzero, the lock remains
		 *         locked and owned by the calling thread.
		 * 
		 *         Only call this method when the calling thread owns the lock. A
		 *         RuntimeError is raised if this method is called when the lock is
		 *         unlocked.
		 * 
		 *         There is no return value.
		 * 
		 *         
		 */
		release(): Promise<any>
		release$($: {}): Promise<any>
	}

	/**
	 * Class that implements a condition variable.
	 * 
	 *     A condition variable allows one or more threads to wait until they are
	 *     notified by another thread.
	 * 
	 *     If the lock argument is given and not None, it must be a Lock or RLock
	 *     object, and it is used as the underlying lock. Otherwise, a new RLock object
	 *     is created and used as the underlying lock.
	 * 
	 *     
	 */
	function Condition(lock?): Promise<ICondition>
	function Condition$({ lock }: { lock?}): Promise<ICondition>
	interface ICondition {

		/**
		 * Wait until notified or until a timeout occurs.
		 * 
		 *         If the calling thread has not acquired the lock when this method is
		 *         called, a RuntimeError is raised.
		 * 
		 *         This method releases the underlying lock, and then blocks until it is
		 *         awakened by a notify() or notify_all() call for the same condition
		 *         variable in another thread, or until the optional timeout occurs. Once
		 *         awakened or timed out, it re-acquires the lock and returns.
		 * 
		 *         When the timeout argument is present and not None, it should be a
		 *         floating point number specifying a timeout for the operation in seconds
		 *         (or fractions thereof).
		 * 
		 *         When the underlying lock is an RLock, it is not released using its
		 *         release() method, since this may not actually unlock the lock when it
		 *         was acquired multiple times recursively. Instead, an internal interface
		 *         of the RLock class is used, which really unlocks it even when it has
		 *         been recursively acquired several times. Another internal interface is
		 *         then used to restore the recursion level when the lock is reacquired.
		 * 
		 *         
		 */
		wait(timeout?): Promise<any>
		wait$({ timeout }: { timeout?}): Promise<any>

		/**
		 * Wait until a condition evaluates to True.
		 * 
		 *         predicate should be a callable which result will be interpreted as a
		 *         boolean value.  A timeout may be provided giving the maximum time to
		 *         wait.
		 * 
		 *         
		 */
		wait_for(predicate, timeout?): Promise<any>
		wait_for$({ predicate, timeout }: { predicate, timeout?}): Promise<any>

		/**
		 * Wake up one or more threads waiting on this condition, if any.
		 * 
		 *         If the calling thread has not acquired the lock when this method is
		 *         called, a RuntimeError is raised.
		 * 
		 *         This method wakes up at most n of the threads waiting for the condition
		 *         variable; it is a no-op if no threads are waiting.
		 * 
		 *         
		 */
		notify(n?): Promise<any>
		notify$({ n }: { n?}): Promise<any>

		/**
		 * Wake up all threads waiting on this condition.
		 * 
		 *         If the calling thread has not acquired the lock when this method
		 *         is called, a RuntimeError is raised.
		 * 
		 *         
		 */
		notify_all(): Promise<any>
		notify_all$($: {}): Promise<any>

		/**
		 * Wake up all threads waiting on this condition.
		 * 
		 *         This method is deprecated, use notify_all() instead.
		 * 
		 *         
		 */
		notifyAll(): Promise<any>
		notifyAll$($: {}): Promise<any>
	}

	/**
	 * This class implements semaphore objects.
	 * 
	 *     Semaphores manage a counter representing the number of release() calls minus
	 *     the number of acquire() calls, plus an initial value. The acquire() method
	 *     blocks if necessary until it can return without making the counter
	 *     negative. If not given, value defaults to 1.
	 * 
	 *     
	 */
	function Semaphore(value?): Promise<ISemaphore>
	function Semaphore$({ value }: { value?}): Promise<ISemaphore>
	interface ISemaphore {

		/**
		 * Acquire a semaphore, decrementing the internal counter by one.
		 * 
		 *         When invoked without arguments: if the internal counter is larger than
		 *         zero on entry, decrement it by one and return immediately. If it is zero
		 *         on entry, block, waiting until some other thread has called release() to
		 *         make it larger than zero. This is done with proper interlocking so that
		 *         if multiple acquire() calls are blocked, release() will wake exactly one
		 *         of them up. The implementation may pick one at random, so the order in
		 *         which blocked threads are awakened should not be relied on. There is no
		 *         return value in this case.
		 * 
		 *         When invoked with blocking set to true, do the same thing as when called
		 *         without arguments, and return true.
		 * 
		 *         When invoked with blocking set to false, do not block. If a call without
		 *         an argument would block, return false immediately; otherwise, do the
		 *         same thing as when called without arguments, and return true.
		 * 
		 *         When invoked with a timeout other than None, it will block for at
		 *         most timeout seconds.  If acquire does not complete successfully in
		 *         that interval, return false.  Return true otherwise.
		 * 
		 *         
		 */
		acquire(blocking?: boolean, timeout?): Promise<any>
		acquire$({ blocking, timeout }: { blocking?, timeout?}): Promise<any>

		/**
		 * Release a semaphore, incrementing the internal counter by one or more.
		 * 
		 *         When the counter is zero on entry and another thread is waiting for it
		 *         to become larger than zero again, wake up that thread.
		 * 
		 *         
		 */
		release(n?): Promise<any>
		release$({ n }: { n?}): Promise<any>
	}

	/**
	 * Implements a bounded semaphore.
	 * 
	 *     A bounded semaphore checks to make sure its current value doesn't exceed its
	 *     initial value. If it does, ValueError is raised. In most situations
	 *     semaphores are used to guard resources with limited capacity.
	 * 
	 *     If the semaphore is released too many times it's a sign of a bug. If not
	 *     given, value defaults to 1.
	 * 
	 *     Like regular semaphores, bounded semaphores manage a counter representing
	 *     the number of release() calls minus the number of acquire() calls, plus an
	 *     initial value. The acquire() method blocks if necessary until it can return
	 *     without making the counter negative. If not given, value defaults to 1.
	 * 
	 *     
	 */
	function BoundedSemaphore(value?): Promise<IBoundedSemaphore>
	function BoundedSemaphore$({ value }: { value?}): Promise<IBoundedSemaphore>
	interface IBoundedSemaphore extends ISemaphore {

		/**
		 * Release a semaphore, incrementing the internal counter by one or more.
		 * 
		 *         When the counter is zero on entry and another thread is waiting for it
		 *         to become larger than zero again, wake up that thread.
		 * 
		 *         If the number of releases exceeds the number of acquires,
		 *         raise a ValueError.
		 * 
		 *         
		 */
		release(n?): Promise<any>
		release$({ n }: { n?}): Promise<any>
	}

	/**
	 * Class implementing event objects.
	 * 
	 *     Events manage a flag that can be set to true with the set() method and reset
	 *     to false with the clear() method. The wait() method blocks until the flag is
	 *     true.  The flag is initially false.
	 * 
	 *     
	 */
	function Event(): Promise<IEvent>
	function Event$({ }): Promise<IEvent>
	interface IEvent {

		/**
		 * Return true if and only if the internal flag is true.
		 */
		is_set(): Promise<any>
		is_set$($: {}): Promise<any>

		/**
		 * Return true if and only if the internal flag is true.
		 * 
		 *         This method is deprecated, use notify_all() instead.
		 * 
		 *         
		 */
		isSet(): Promise<any>
		isSet$($: {}): Promise<any>

		/**
		 * Set the internal flag to true.
		 * 
		 *         All threads waiting for it to become true are awakened. Threads
		 *         that call wait() once the flag is true will not block at all.
		 * 
		 *         
		 */
		set(): Promise<any>
		set$($: {}): Promise<any>

		/**
		 * Reset the internal flag to false.
		 * 
		 *         Subsequently, threads calling wait() will block until set() is called to
		 *         set the internal flag to true again.
		 * 
		 *         
		 */
		clear(): Promise<any>
		clear$($: {}): Promise<any>

		/**
		 * Block until the internal flag is true.
		 * 
		 *         If the internal flag is true on entry, return immediately. Otherwise,
		 *         block until another thread calls set() to set the flag to true, or until
		 *         the optional timeout occurs.
		 * 
		 *         When the timeout argument is present and not None, it should be a
		 *         floating point number specifying a timeout for the operation in seconds
		 *         (or fractions thereof).
		 * 
		 *         This method returns the internal flag on exit, so it will always return
		 *         True except if a timeout is given and the operation times out.
		 * 
		 *         
		 */
		wait(timeout?): Promise<any>
		wait$({ timeout }: { timeout?}): Promise<any>
	}

	/**
	 * Implements a Barrier.
	 * 
	 *     Useful for synchronizing a fixed number of threads at known synchronization
	 *     points.  Threads block on 'wait()' and are simultaneously awoken once they
	 *     have all made that call.
	 * 
	 *     
	 */

	/**
	 * Create a barrier, initialised to 'parties' threads.
	 * 
	 *         'action' is a callable which, when supplied, will be called by one of
	 *         the threads after they have all entered the barrier and just prior to
	 *         releasing them all. If a 'timeout' is provided, it is used as the
	 *         default for all subsequent 'wait()' calls.
	 * 
	 *         
	 */
	function Barrier(parties, action?, timeout?): Promise<IBarrier>
	function Barrier$({ parties, action, timeout }: { parties, action?, timeout?}): Promise<IBarrier>
	interface IBarrier {

		/**
		 * Wait for the barrier.
		 * 
		 *         When the specified number of threads have started waiting, they are all
		 *         simultaneously awoken. If an 'action' was provided for the barrier, one
		 *         of the threads will have executed that callback prior to returning.
		 *         Returns an individual index number from 0 to 'parties-1'.
		 * 
		 *         
		 */
		wait(timeout?): Promise<any>
		wait$({ timeout }: { timeout?}): Promise<any>

		/**
		 * Reset the barrier to the initial state.
		 * 
		 *         Any threads currently waiting will get the BrokenBarrier exception
		 *         raised.
		 * 
		 *         
		 */
		reset(): Promise<any>
		reset$($: {}): Promise<any>

		/**
		 * Place the barrier into a 'broken' state.
		 * 
		 *         Useful in case of error.  Any currently waiting threads and threads
		 *         attempting to 'wait()' will have BrokenBarrierError raised.
		 * 
		 *         
		 */
		abort(): Promise<any>
		abort$($: {}): Promise<any>

		/**
		 * Return the number of threads required to trip the barrier.
		 */
		parties(): Promise<any>
		parties$($: {}): Promise<any>

		/**
		 * Return the number of threads currently waiting at the barrier.
		 */
		n_waiting(): Promise<any>
		n_waiting$($: {}): Promise<any>

		/**
		 * Return True if the barrier is in a broken state.
		 */
		broken(): Promise<any>
		broken$($: {}): Promise<any>
	}
	interface IBrokenBarrierError {
	}

	/**
	 * A class that represents a thread of control.
	 * 
	 *     This class can be safely subclassed in a limited fashion. There are two ways
	 *     to specify the activity: by passing a callable object to the constructor, or
	 *     by overriding the run() method in a subclass.
	 * 
	 *     
	 */

	/**
	 * This constructor should always be called with keyword arguments. Arguments are:
	 * 
	 *         *group* should be None; reserved for future extension when a ThreadGroup
	 *         class is implemented.
	 * 
	 *         *target* is the callable object to be invoked by the run()
	 *         method. Defaults to None, meaning nothing is called.
	 * 
	 *         *name* is the thread name. By default, a unique name is constructed of
	 *         the form "Thread-N" where N is a small decimal number.
	 * 
	 *         *args* is the argument tuple for the target invocation. Defaults to ().
	 * 
	 *         *kwargs* is a dictionary of keyword arguments for the target
	 *         invocation. Defaults to {}.
	 * 
	 *         If a subclass overrides the constructor, it must make sure to invoke
	 *         the base class constructor (Thread.__init__()) before doing anything
	 *         else to the thread.
	 * 
	 *         
	 */
	function Thread(group?, target?, name?, args?, kwargs?): Promise<IThread>
	function Thread$({ group, target, name, args, kwargs }: { group?, target?, name?, args?, kwargs?}): Promise<IThread>
	interface IThread {

		/**
		 * Start the thread's activity.
		 * 
		 *         It must be called at most once per thread object. It arranges for the
		 *         object's run() method to be invoked in a separate thread of control.
		 * 
		 *         This method will raise a RuntimeError if called more than once on the
		 *         same thread object.
		 * 
		 *         
		 */
		start(): Promise<any>
		start$($: {}): Promise<any>

		/**
		 * Method representing the thread's activity.
		 * 
		 *         You may override this method in a subclass. The standard run() method
		 *         invokes the callable object passed to the object's constructor as the
		 *         target argument, if any, with sequential and keyword arguments taken
		 *         from the args and kwargs arguments, respectively.
		 * 
		 *         
		 */
		run(): Promise<any>
		run$($: {}): Promise<any>

		/**
		 * Wait until the thread terminates.
		 * 
		 *         This blocks the calling thread until the thread whose join() method is
		 *         called terminates -- either normally or through an unhandled exception
		 *         or until the optional timeout occurs.
		 * 
		 *         When the timeout argument is present and not None, it should be a
		 *         floating point number specifying a timeout for the operation in seconds
		 *         (or fractions thereof). As join() always returns None, you must call
		 *         is_alive() after join() to decide whether a timeout happened -- if the
		 *         thread is still alive, the join() call timed out.
		 * 
		 *         When the timeout argument is not present or None, the operation will
		 *         block until the thread terminates.
		 * 
		 *         A thread can be join()ed many times.
		 * 
		 *         join() raises a RuntimeError if an attempt is made to join the current
		 *         thread as that would cause a deadlock. It is also an error to join() a
		 *         thread before it has been started and attempts to do so raises the same
		 *         exception.
		 * 
		 *         
		 */
		join(timeout?): Promise<any>
		join$({ timeout }: { timeout?}): Promise<any>

		/**
		 * A string used for identification purposes only.
		 * 
		 *         It has no semantics. Multiple threads may be given the same name. The
		 *         initial name is set by the constructor.
		 * 
		 *         
		 */
		name(): Promise<any>
		name$($: {}): Promise<any>
		name(name): Promise<any>
		name$({ name }): Promise<any>

		/**
		 * Thread identifier of this thread or None if it has not been started.
		 * 
		 *         This is a nonzero integer. See the get_ident() function. Thread
		 *         identifiers may be recycled when a thread exits and another thread is
		 *         created. The identifier is available even after the thread has exited.
		 * 
		 *         
		 */
		ident(): Promise<any>
		ident$($: {}): Promise<any>

		/**
		 * Return whether the thread is alive.
		 * 
		 *         This method returns True just before the run() method starts until just
		 *         after the run() method terminates. See also the module function
		 *         enumerate().
		 * 
		 *         
		 */
		is_alive(): Promise<any>
		is_alive$($: {}): Promise<any>

		/**
		 * A boolean value indicating whether this thread is a daemon thread.
		 * 
		 *         This must be set before start() is called, otherwise RuntimeError is
		 *         raised. Its initial value is inherited from the creating thread; the
		 *         main thread is not a daemon thread and therefore all threads created in
		 *         the main thread default to daemon = False.
		 * 
		 *         The entire Python program exits when only daemon threads are left.
		 * 
		 *         
		 */
		daemon(): Promise<any>
		daemon$($: {}): Promise<any>
		daemon(daemonic): Promise<any>
		daemon$({ daemonic }): Promise<any>

		/**
		 * Return whether this thread is a daemon.
		 * 
		 *         This method is deprecated, use the daemon attribute instead.
		 * 
		 *         
		 */
		isDaemon(): Promise<any>
		isDaemon$($: {}): Promise<any>

		/**
		 * Set whether this thread is a daemon.
		 * 
		 *         This method is deprecated, use the .daemon property instead.
		 * 
		 *         
		 */
		setDaemon(daemonic): Promise<any>
		setDaemon$({ daemonic }): Promise<any>

		/**
		 * Return a string used for identification purposes only.
		 * 
		 *         This method is deprecated, use the name attribute instead.
		 * 
		 *         
		 */
		getName(): Promise<any>
		getName$($: {}): Promise<any>

		/**
		 * Set the name string for this thread.
		 * 
		 *         This method is deprecated, use the name attribute instead.
		 * 
		 *         
		 */
		setName(name): Promise<any>
		setName$({ name }): Promise<any>
	}

	/**
	 * Call a function after a specified number of seconds:
	 * 
	 *             t = Timer(30.0, f, args=None, kwargs=None)
	 *             t.start()
	 *             t.cancel()     # stop the timer's action if it's still waiting
	 * 
	 *     
	 */
	function Timer(interval, func, args?, kwargs?): Promise<ITimer>
	function Timer$({ interval, func, args, kwargs }: { interval, func, args?, kwargs?}): Promise<ITimer>
	interface ITimer extends IThread {

		/**
		 * Stop the timer if it hasn't finished yet.
		 */
		cancel(): Promise<any>
		cancel$($: {}): Promise<any>
		run(): Promise<any>
		run$($: {}): Promise<any>
	}
	interface I_MainThread extends IThread {
	}
	interface I_DummyThread extends IThread {
		is_alive(): Promise<any>
		is_alive$($: {}): Promise<any>
		join(timeout?): Promise<any>
		join$({ timeout }: { timeout?}): Promise<any>
	}
	let get_ident: Promise<any>
	let get_native_id: Promise<any>
	let ThreadError: Promise<any>
	let TIMEOUT_MAX: Promise<any>
	let Lock: Promise<any>
}
declare module timeit {
	var _

	/**
	 * Helper to reindent a multi-line statement.
	 */
	function reindent(src, indent): Promise<any>
	function reindent$({ src, indent }): Promise<any>

	/**
	 * Convenience function to create Timer object and call timeit method.
	 */
	function timeit(stmt?, setup?, timer?, number?, globals?): Promise<any>
	function timeit$({ stmt, setup, timer, number, globals }: { stmt?, setup?, timer?, number?, globals?}): Promise<any>

	/**
	 * Convenience function to create Timer object and call repeat method.
	 */
	function repeat(stmt?, setup?, timer?, repeat?, number?, globals?): Promise<any>
	function repeat$({ stmt, setup, timer, repeat, number, globals }: { stmt?, setup?, timer?, repeat?, number?, globals?}): Promise<any>

	/**
	 * Main program, used when run as a script.
	 * 
	 *     The optional 'args' argument specifies the command line to be parsed,
	 *     defaulting to sys.argv[1:].
	 * 
	 *     The return value is an exit code to be passed to sys.exit(); it
	 *     may be None to indicate success.
	 * 
	 *     When an exception happens during timing, a traceback is printed to
	 *     stderr and the return value is 1.  Exceptions at other times
	 *     (including the template compilation) are not caught.
	 * 
	 *     '_wrap_timer' is an internal interface used for unit testing.  If it
	 *     is not None, it must be a callable that accepts a timer function
	 *     and returns another timer function (used for unit testing).
	 *     
	 */
	function main(args?): Promise<any>
	function main$({ args }: { args?}): Promise<any>

	/**
	 * Class for timing execution speed of small code snippets.
	 * 
	 *     The constructor takes a statement to be timed, an additional
	 *     statement used for setup, and a timer function.  Both statements
	 *     default to 'pass'; the timer function is platform-dependent (see
	 *     module doc string).  If 'globals' is specified, the code will be
	 *     executed within that namespace (as opposed to inside timeit's
	 *     namespace).
	 * 
	 *     To measure the execution time of the first statement, use the
	 *     timeit() method.  The repeat() method is a convenience to call
	 *     timeit() multiple times and return a list of results.
	 * 
	 *     The statements may contain newlines, as long as they don't contain
	 *     multi-line string literals.
	 *     
	 */

	/**
	 * Constructor.  See class doc string.
	 */
	function Timer(stmt?, setup?, timer?, globals?): Promise<ITimer>
	function Timer$({ stmt, setup, timer, globals }: { stmt?, setup?, timer?, globals?}): Promise<ITimer>
	interface ITimer {

		/**
		 * Helper to print a traceback from the timed code.
		 * 
		 *         Typical use:
		 * 
		 *             t = Timer(...)       # outside the try/except
		 *             try:
		 *                 t.timeit(...)    # or t.repeat(...)
		 *             except:
		 *                 t.print_exc()
		 * 
		 *         The advantage over the standard traceback is that source lines
		 *         in the compiled template will be displayed.
		 * 
		 *         The optional file argument directs where the traceback is
		 *         sent; it defaults to sys.stderr.
		 *         
		 */
		print_exc(file?): Promise<any>
		print_exc$({ file }: { file?}): Promise<any>

		/**
		 * Time 'number' executions of the main statement.
		 * 
		 *         To be precise, this executes the setup statement once, and
		 *         then returns the time it takes to execute the main statement
		 *         a number of times, as a float measured in seconds.  The
		 *         argument is the number of times through the loop, defaulting
		 *         to one million.  The main statement, the setup statement and
		 *         the timer function to be used are passed to the constructor.
		 *         
		 */
		timeit(number?): Promise<any>
		timeit$({ number }: { number?}): Promise<any>

		/**
		 * Call timeit() a few times.
		 * 
		 *         This is a convenience function that calls the timeit()
		 *         repeatedly, returning a list of results.  The first argument
		 *         specifies how many times to call timeit(), defaulting to 5;
		 *         the second argument specifies the timer argument, defaulting
		 *         to one million.
		 * 
		 *         Note: it's tempting to calculate mean and standard deviation
		 *         from the result vector and report these.  However, this is not
		 *         very useful.  In a typical case, the lowest value gives a
		 *         lower bound for how fast your machine can run the given code
		 *         snippet; higher values in the result vector are typically not
		 *         caused by variability in Python's speed, but by other
		 *         processes interfering with your timing accuracy.  So the min()
		 *         of the result is probably the only number you should be
		 *         interested in.  After that, you should look at the entire
		 *         vector and apply common sense rather than statistics.
		 *         
		 */
		repeat(repeat?, number?): Promise<any>
		repeat$({ repeat, number }: { repeat?, number?}): Promise<any>

		/**
		 * Return the number of loops and time taken so that total time >= 0.2.
		 * 
		 *         Calls the timeit method with increasing numbers from the sequence
		 *         1, 2, 5, 10, 20, 50, ... until the time taken is at least 0.2
		 *         second.  Returns (number, time_taken).
		 * 
		 *         If *callback* is given and is not None, it will be called after
		 *         each trial with two arguments: ``callback(number, time_taken)``.
		 *         
		 */
		autorange(callback?): Promise<any>
		autorange$({ callback }: { callback?}): Promise<any>
	}
	let dummy_src_name: Promise<any>
	let default_number: Promise<any>
	let default_repeat: Promise<any>
	let default_timer: Promise<any>
	let template: Promise<any>
}
declare module tkinter {
	var _

	/**
	 * Inhibit setting of default root window.
	 * 
	 *     Call this function to inhibit that the first instance of
	 *     Tk is used for windows without an explicit parent window.
	 *     
	 */
	function NoDefaultRoot(): Promise<any>
	function NoDefaultRoot$($: {}): Promise<any>

	/**
	 * Run the main loop of Tcl.
	 */
	function mainloop(n?): Promise<any>
	function mainloop$({ n }: { n?}): Promise<any>

	/**
	 * Convert Tcl object to True or False.
	 */
	function getboolean(s): Promise<any>
	function getboolean$({ s }): Promise<any>
	function Tcl(screenName?, baseName?, className?, useTk?: boolean): Promise<any>
	function Tcl$({ screenName, baseName, className, useTk }: { screenName?, baseName?, className?, useTk?}): Promise<any>
	function image_names(): Promise<any>
	function image_names$($: {}): Promise<any>
	function image_types(): Promise<any>
	function image_types$($: {}): Promise<any>
	interface IEventType {
		KeyPress
		Key
		KeyRelease
		ButtonPress
		Button
		ButtonRelease
		Motion
		Enter
		Leave
		FocusIn
		FocusOut
		Keymap
		Expose
		GraphicsExpose
		NoExpose
		Visibility
		Create
		Destroy
		Unmap
		Map
		MapRequest
		Reparent
		Configure
		ConfigureRequest
		Gravity
		ResizeRequest
		Circulate
		CirculateRequest
		Property
		SelectionClear
		SelectionRequest
		Selection
		Colormap
		ClientMessage
		Mapping
		VirtualEvent
		Activate
		Deactivate
		MouseWheel
	}

	/**
	 * Container for the properties of an event.
	 * 
	 *     Instances of this type are generated if one of the following events occurs:
	 * 
	 *     KeyPress, KeyRelease - for keyboard events
	 *     ButtonPress, ButtonRelease, Motion, Enter, Leave, MouseWheel - for mouse events
	 *     Visibility, Unmap, Map, Expose, FocusIn, FocusOut, Circulate,
	 *     Colormap, Gravity, Reparent, Property, Destroy, Activate,
	 *     Deactivate - for window events.
	 * 
	 *     If a callback function for one of these events is registered
	 *     using bind, bind_all, bind_class, or tag_bind, the callback is
	 *     called with an Event as first argument. It will have the
	 *     following attributes (in braces are the event types for which
	 *     the attribute is valid):
	 * 
	 *         serial - serial number of event
	 *     num - mouse button pressed (ButtonPress, ButtonRelease)
	 *     focus - whether the window has the focus (Enter, Leave)
	 *     height - height of the exposed window (Configure, Expose)
	 *     width - width of the exposed window (Configure, Expose)
	 *     keycode - keycode of the pressed key (KeyPress, KeyRelease)
	 *     state - state of the event as a number (ButtonPress, ButtonRelease,
	 *                             Enter, KeyPress, KeyRelease,
	 *                             Leave, Motion)
	 *     state - state as a string (Visibility)
	 *     time - when the event occurred
	 *     x - x-position of the mouse
	 *     y - y-position of the mouse
	 *     x_root - x-position of the mouse on the screen
	 *              (ButtonPress, ButtonRelease, KeyPress, KeyRelease, Motion)
	 *     y_root - y-position of the mouse on the screen
	 *              (ButtonPress, ButtonRelease, KeyPress, KeyRelease, Motion)
	 *     char - pressed character (KeyPress, KeyRelease)
	 *     send_event - see X/Windows documentation
	 *     keysym - keysym of the event as a string (KeyPress, KeyRelease)
	 *     keysym_num - keysym of the event as a number (KeyPress, KeyRelease)
	 *     type - type of the event as a number
	 *     widget - widget in which the event occurred
	 *     delta - delta of wheel movement (MouseWheel)
	 *     
	 */
	interface IEvent {
	}

	/**
	 * Class to define value holders for e.g. buttons.
	 * 
	 *     Subclasses StringVar, IntVar, DoubleVar, BooleanVar are specializations
	 *     that constrain the type of the value returned from get().
	 */

	/**
	 * Construct a variable
	 * 
	 *         MASTER can be given as master widget.
	 *         VALUE is an optional value (defaults to "")
	 *         NAME is an optional Tcl name (defaults to PY_VARnum).
	 * 
	 *         If NAME matches an existing variable and VALUE is omitted
	 *         then the existing value is retained.
	 *         
	 */
	function Variable(master?, value?, name?): Promise<IVariable>
	function Variable$({ master, value, name }: { master?, value?, name?}): Promise<IVariable>
	interface IVariable {

		/**
		 * Set the variable to VALUE.
		 */
		set(value): Promise<any>
		set$({ value }): Promise<any>

		/**
		 * Return value of variable.
		 */
		get(): Promise<any>
		get$($: {}): Promise<any>

		/**
		 * Define a trace callback for the variable.
		 * 
		 *         Mode is one of "read", "write", "unset", or a list or tuple of
		 *         such strings.
		 *         Callback must be a function which is called when the variable is
		 *         read, written or unset.
		 * 
		 *         Return the name of the callback.
		 *         
		 */
		trace_add(mode, callback): Promise<any>
		trace_add$({ mode, callback }): Promise<any>

		/**
		 * Delete the trace callback for a variable.
		 * 
		 *         Mode is one of "read", "write", "unset" or a list or tuple of
		 *         such strings.  Must be same as were specified in trace_add().
		 *         cbname is the name of the callback returned from trace_add().
		 *         
		 */
		trace_remove(mode, cbname): Promise<any>
		trace_remove$({ mode, cbname }): Promise<any>

		/**
		 * Return all trace callback information.
		 */
		trace_info(): Promise<any>
		trace_info$($: {}): Promise<any>

		/**
		 * Define a trace callback for the variable.
		 * 
		 *         MODE is one of "r", "w", "u" for read, write, undefine.
		 *         CALLBACK must be a function which is called when
		 *         the variable is read, written or undefined.
		 * 
		 *         Return the name of the callback.
		 * 
		 *         This deprecated method wraps a deprecated Tcl method that will
		 *         likely be removed in the future.  Use trace_add() instead.
		 *         
		 */
		trace_variable(mode, callback): Promise<any>
		trace_variable$({ mode, callback }): Promise<any>

		/**
		 * Delete the trace callback for a variable.
		 * 
		 *         MODE is one of "r", "w", "u" for read, write, undefine.
		 *         CBNAME is the name of the callback returned from trace_variable or trace.
		 * 
		 *         This deprecated method wraps a deprecated Tcl method that will
		 *         likely be removed in the future.  Use trace_remove() instead.
		 *         
		 */
		trace_vdelete(mode, cbname): Promise<any>
		trace_vdelete$({ mode, cbname }): Promise<any>

		/**
		 * Return all trace callback information.
		 * 
		 *         This deprecated method wraps a deprecated Tcl method that will
		 *         likely be removed in the future.  Use trace_info() instead.
		 *         
		 */
		trace_vinfo(): Promise<any>
		trace_vinfo$($: {}): Promise<any>
		initialize
		trace
	}

	/**
	 * Value holder for strings variables.
	 */

	/**
	 * Construct a string variable.
	 * 
	 *         MASTER can be given as master widget.
	 *         VALUE is an optional value (defaults to "")
	 *         NAME is an optional Tcl name (defaults to PY_VARnum).
	 * 
	 *         If NAME matches an existing variable and VALUE is omitted
	 *         then the existing value is retained.
	 *         
	 */
	function StringVar(master?, value?, name?): Promise<IStringVar>
	function StringVar$({ master, value, name }: { master?, value?, name?}): Promise<IStringVar>
	interface IStringVar extends IVariable {

		/**
		 * Return value of variable as string.
		 */
		get(): Promise<any>
		get$($: {}): Promise<any>
	}

	/**
	 * Value holder for integer variables.
	 */

	/**
	 * Construct an integer variable.
	 * 
	 *         MASTER can be given as master widget.
	 *         VALUE is an optional value (defaults to 0)
	 *         NAME is an optional Tcl name (defaults to PY_VARnum).
	 * 
	 *         If NAME matches an existing variable and VALUE is omitted
	 *         then the existing value is retained.
	 *         
	 */
	function IntVar(master?, value?, name?): Promise<IIntVar>
	function IntVar$({ master, value, name }: { master?, value?, name?}): Promise<IIntVar>
	interface IIntVar extends IVariable {

		/**
		 * Return the value of the variable as an integer.
		 */
		get(): Promise<any>
		get$($: {}): Promise<any>
	}

	/**
	 * Value holder for float variables.
	 */

	/**
	 * Construct a float variable.
	 * 
	 *         MASTER can be given as master widget.
	 *         VALUE is an optional value (defaults to 0.0)
	 *         NAME is an optional Tcl name (defaults to PY_VARnum).
	 * 
	 *         If NAME matches an existing variable and VALUE is omitted
	 *         then the existing value is retained.
	 *         
	 */
	function DoubleVar(master?, value?, name?): Promise<IDoubleVar>
	function DoubleVar$({ master, value, name }: { master?, value?, name?}): Promise<IDoubleVar>
	interface IDoubleVar extends IVariable {

		/**
		 * Return the value of the variable as a float.
		 */
		get(): Promise<any>
		get$($: {}): Promise<any>
	}

	/**
	 * Value holder for boolean variables.
	 */

	/**
	 * Construct a boolean variable.
	 * 
	 *         MASTER can be given as master widget.
	 *         VALUE is an optional value (defaults to False)
	 *         NAME is an optional Tcl name (defaults to PY_VARnum).
	 * 
	 *         If NAME matches an existing variable and VALUE is omitted
	 *         then the existing value is retained.
	 *         
	 */
	function BooleanVar(master?, value?, name?): Promise<IBooleanVar>
	function BooleanVar$({ master, value, name }: { master?, value?, name?}): Promise<IBooleanVar>
	interface IBooleanVar extends IVariable {

		/**
		 * Set the variable to VALUE.
		 */
		set(value): Promise<any>
		set$({ value }): Promise<any>

		/**
		 * Return the value of the variable as a bool.
		 */
		get(): Promise<any>
		get$($: {}): Promise<any>
	}

	/**
	 * Internal class.
	 * 
	 *     Base class which defines methods common for interior widgets.
	 */
	interface IMisc {

		/**
		 * Internal function.
		 * 
		 *         Delete all Tcl commands created for
		 *         this widget in the Tcl interpreter.
		 */
		destroy(): Promise<any>
		destroy$($: {}): Promise<any>

		/**
		 * Internal function.
		 * 
		 *         Delete the Tcl command provided in NAME.
		 */
		deletecommand(name): Promise<any>
		deletecommand$({ name }): Promise<any>

		/**
		 * Set Tcl internal variable, whether the look and feel
		 *         should adhere to Motif.
		 * 
		 *         A parameter of 1 means adhere to Motif (e.g. no color
		 *         change if mouse passes over slider).
		 *         Returns the set value.
		 */
		tk_strictMotif(boolean?): Promise<any>
		tk_strictMotif$({ boolean }: { boolean?}): Promise<any>

		/**
		 * Change the color scheme to light brown as used in Tk 3.6 and before.
		 */
		tk_bisque(): Promise<any>
		tk_bisque$($: {}): Promise<any>

		/**
		 * Set a new color scheme for all widget elements.
		 * 
		 *         A single color as argument will cause that all colors of Tk
		 *         widget elements are derived from this.
		 *         Alternatively several keyword parameters and its associated
		 *         colors can be given. The following keywords are valid:
		 *         activeBackground, foreground, selectColor,
		 *         activeForeground, highlightBackground, selectBackground,
		 *         background, highlightColor, selectForeground,
		 *         disabledForeground, insertBackground, troughColor.
		 */
		tk_setPalette(): Promise<any>
		tk_setPalette$($: {}): Promise<any>

		/**
		 * Wait until the variable is modified.
		 * 
		 *         A parameter of type IntVar, StringVar, DoubleVar or
		 *         BooleanVar must be given.
		 */
		wait_variable(name?): Promise<any>
		wait_variable$({ name }: { name?}): Promise<any>

		/**
		 * Wait until a WIDGET is destroyed.
		 * 
		 *         If no parameter is given self is used.
		 */
		wait_window(window?): Promise<any>
		wait_window$({ window }: { window?}): Promise<any>

		/**
		 * Wait until the visibility of a WIDGET changes
		 *         (e.g. it appears).
		 * 
		 *         If no parameter is given self is used.
		 */
		wait_visibility(window?): Promise<any>
		wait_visibility$({ window }: { window?}): Promise<any>

		/**
		 * Set Tcl variable NAME to VALUE.
		 */
		setvar(name?, value?): Promise<any>
		setvar$({ name, value }: { name?, value?}): Promise<any>

		/**
		 * Return value of Tcl variable NAME.
		 */
		getvar(name?): Promise<any>
		getvar$({ name }: { name?}): Promise<any>
		getint(s): Promise<any>
		getint$({ s }): Promise<any>
		getdouble(s): Promise<any>
		getdouble$({ s }): Promise<any>

		/**
		 * Return a boolean value for Tcl boolean values true and false given as parameter.
		 */
		getboolean(s): Promise<any>
		getboolean$({ s }): Promise<any>

		/**
		 * Direct input focus to this widget.
		 * 
		 *         If the application currently does not have the focus
		 *         this widget will get the focus if the application gets
		 *         the focus through the window manager.
		 */
		focus_set(): Promise<any>
		focus_set$($: {}): Promise<any>

		/**
		 * Direct input focus to this widget even if the
		 *         application does not have the focus. Use with
		 *         caution!
		 */
		focus_force(): Promise<any>
		focus_force$($: {}): Promise<any>

		/**
		 * Return the widget which has currently the focus in the
		 *         application.
		 * 
		 *         Use focus_displayof to allow working with several
		 *         displays. Return None if application does not have
		 *         the focus.
		 */
		focus_get(): Promise<any>
		focus_get$($: {}): Promise<any>

		/**
		 * Return the widget which has currently the focus on the
		 *         display where this widget is located.
		 * 
		 *         Return None if the application does not have the focus.
		 */
		focus_displayof(): Promise<any>
		focus_displayof$($: {}): Promise<any>

		/**
		 * Return the widget which would have the focus if top level
		 *         for this widget gets the focus from the window manager.
		 */
		focus_lastfor(): Promise<any>
		focus_lastfor$($: {}): Promise<any>

		/**
		 * The widget under mouse will get automatically focus. Can not
		 *         be disabled easily.
		 */
		tk_focusFollowsMouse(): Promise<any>
		tk_focusFollowsMouse$($: {}): Promise<any>

		/**
		 * Return the next widget in the focus order which follows
		 *         widget which has currently the focus.
		 * 
		 *         The focus order first goes to the next child, then to
		 *         the children of the child recursively and then to the
		 *         next sibling which is higher in the stacking order.  A
		 *         widget is omitted if it has the takefocus resource set
		 *         to 0.
		 */
		tk_focusNext(): Promise<any>
		tk_focusNext$($: {}): Promise<any>

		/**
		 * Return previous widget in the focus order. See tk_focusNext for details.
		 */
		tk_focusPrev(): Promise<any>
		tk_focusPrev$($: {}): Promise<any>

		/**
		 * Call function once after given time.
		 * 
		 *         MS specifies the time in milliseconds. FUNC gives the
		 *         function which shall be called. Additional parameters
		 *         are given as parameters to the function call.  Return
		 *         identifier to cancel scheduling with after_cancel.
		 */
		after(ms, func?): Promise<any>
		after$({ ms, func }: { ms, func?}): Promise<any>

		/**
		 * Call FUNC once if the Tcl main loop has no event to
		 *         process.
		 * 
		 *         Return an identifier to cancel the scheduling with
		 *         after_cancel.
		 */
		after_idle(func): Promise<any>
		after_idle$({ func }): Promise<any>

		/**
		 * Cancel scheduling of function identified with ID.
		 * 
		 *         Identifier returned by after or after_idle must be
		 *         given as first parameter.
		 *         
		 */
		after_cancel(id): Promise<any>
		after_cancel$({ id }): Promise<any>

		/**
		 * Ring a display's bell.
		 */
		bell(displayof?): Promise<any>
		bell$({ displayof }: { displayof?}): Promise<any>

		/**
		 * Retrieve data from the clipboard on window's display.
		 * 
		 *         The window keyword defaults to the root window of the Tkinter
		 *         application.
		 * 
		 *         The type keyword specifies the form in which the data is
		 *         to be returned and should be an atom name such as STRING
		 *         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
		 *         is to try UTF8_STRING and fall back to STRING.
		 * 
		 *         This command is equivalent to:
		 * 
		 *         selection_get(CLIPBOARD)
		 *         
		 */
		clipboard_get(): Promise<any>
		clipboard_get$($: {}): Promise<any>

		/**
		 * Clear the data in the Tk clipboard.
		 * 
		 *         A widget specified for the optional displayof keyword
		 *         argument specifies the target display.
		 */
		clipboard_clear(): Promise<any>
		clipboard_clear$($: {}): Promise<any>

		/**
		 * Append STRING to the Tk clipboard.
		 * 
		 *         A widget specified at the optional displayof keyword
		 *         argument specifies the target display. The clipboard
		 *         can be retrieved with selection_get.
		 */
		clipboard_append(string): Promise<any>
		clipboard_append$({ string }): Promise<any>

		/**
		 * Return widget which has currently the grab in this application
		 *         or None.
		 */
		grab_current(): Promise<any>
		grab_current$($: {}): Promise<any>

		/**
		 * Release grab for this widget if currently set.
		 */
		grab_release(): Promise<any>
		grab_release$($: {}): Promise<any>

		/**
		 * Set grab for this widget.
		 * 
		 *         A grab directs all events to this and descendant
		 *         widgets in the application.
		 */
		grab_set(): Promise<any>
		grab_set$($: {}): Promise<any>

		/**
		 * Set global grab for this widget.
		 * 
		 *         A global grab directs all events to this and
		 *         descendant widgets on the display. Use with caution -
		 *         other applications do not get events anymore.
		 */
		grab_set_global(): Promise<any>
		grab_set_global$($: {}): Promise<any>

		/**
		 * Return None, "local" or "global" if this widget has
		 *         no, a local or a global grab.
		 */
		grab_status(): Promise<any>
		grab_status$($: {}): Promise<any>

		/**
		 * Set a VALUE (second parameter) for an option
		 *         PATTERN (first parameter).
		 * 
		 *         An optional third parameter gives the numeric priority
		 *         (defaults to 80).
		 */
		option_add(pattern, value, priority?): Promise<any>
		option_add$({ pattern, value, priority }: { pattern, value, priority?}): Promise<any>

		/**
		 * Clear the option database.
		 * 
		 *         It will be reloaded if option_add is called.
		 */
		option_clear(): Promise<any>
		option_clear$($: {}): Promise<any>

		/**
		 * Return the value for an option NAME for this widget
		 *         with CLASSNAME.
		 * 
		 *         Values with higher priority override lower values.
		 */
		option_get(name, className): Promise<any>
		option_get$({ name, className }): Promise<any>

		/**
		 * Read file FILENAME into the option database.
		 * 
		 *         An optional second parameter gives the numeric
		 *         priority.
		 */
		option_readfile(fileName, priority?): Promise<any>
		option_readfile$({ fileName, priority }: { fileName, priority?}): Promise<any>

		/**
		 * Clear the current X selection.
		 */
		selection_clear(): Promise<any>
		selection_clear$($: {}): Promise<any>

		/**
		 * Return the contents of the current X selection.
		 * 
		 *         A keyword parameter selection specifies the name of
		 *         the selection and defaults to PRIMARY.  A keyword
		 *         parameter displayof specifies a widget on the display
		 *         to use. A keyword parameter type specifies the form of data to be
		 *         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
		 *         before STRING.
		 */
		selection_get(): Promise<any>
		selection_get$($: {}): Promise<any>

		/**
		 * Specify a function COMMAND to call if the X
		 *         selection owned by this widget is queried by another
		 *         application.
		 * 
		 *         This function must return the contents of the
		 *         selection. The function will be called with the
		 *         arguments OFFSET and LENGTH which allows the chunking
		 *         of very long selections. The following keyword
		 *         parameters can be provided:
		 *         selection - name of the selection (default PRIMARY),
		 *         type - type of the selection (e.g. STRING, FILE_NAME).
		 */
		selection_handle(command): Promise<any>
		selection_handle$({ command }): Promise<any>

		/**
		 * Become owner of X selection.
		 * 
		 *         A keyword parameter selection specifies the name of
		 *         the selection (default PRIMARY).
		 */
		selection_own(): Promise<any>
		selection_own$($: {}): Promise<any>

		/**
		 * Return owner of X selection.
		 * 
		 *         The following keyword parameter can
		 *         be provided:
		 *         selection - name of the selection (default PRIMARY),
		 *         type - type of the selection (e.g. STRING, FILE_NAME).
		 */
		selection_own_get(): Promise<any>
		selection_own_get$($: {}): Promise<any>

		/**
		 * Send Tcl command CMD to different interpreter INTERP to be executed.
		 */
		send(interp, cmd): Promise<any>
		send$({ interp, cmd }): Promise<any>

		/**
		 * Lower this widget in the stacking order.
		 */
		lower(belowThis?): Promise<any>
		lower$({ belowThis }: { belowThis?}): Promise<any>

		/**
		 * Raise this widget in the stacking order.
		 */
		tkraise(aboveThis?): Promise<any>
		tkraise$({ aboveThis }: { aboveThis?}): Promise<any>

		/**
		 * Return integer which represents atom NAME.
		 */
		winfo_atom(name, displayof?): Promise<any>
		winfo_atom$({ name, displayof }: { name, displayof?}): Promise<any>

		/**
		 * Return name of atom with identifier ID.
		 */
		winfo_atomname(id, displayof?): Promise<any>
		winfo_atomname$({ id, displayof }: { id, displayof?}): Promise<any>

		/**
		 * Return number of cells in the colormap for this widget.
		 */
		winfo_cells(): Promise<any>
		winfo_cells$($: {}): Promise<any>

		/**
		 * Return a list of all widgets which are children of this widget.
		 */
		winfo_children(): Promise<any>
		winfo_children$($: {}): Promise<any>

		/**
		 * Return window class name of this widget.
		 */
		winfo_class(): Promise<any>
		winfo_class$($: {}): Promise<any>

		/**
		 * Return True if at the last color request the colormap was full.
		 */
		winfo_colormapfull(): Promise<any>
		winfo_colormapfull$($: {}): Promise<any>

		/**
		 * Return the widget which is at the root coordinates ROOTX, ROOTY.
		 */
		winfo_containing(rootX, rootY, displayof?): Promise<any>
		winfo_containing$({ rootX, rootY, displayof }: { rootX, rootY, displayof?}): Promise<any>

		/**
		 * Return the number of bits per pixel.
		 */
		winfo_depth(): Promise<any>
		winfo_depth$($: {}): Promise<any>

		/**
		 * Return true if this widget exists.
		 */
		winfo_exists(): Promise<any>
		winfo_exists$($: {}): Promise<any>

		/**
		 * Return the number of pixels for the given distance NUMBER
		 *         (e.g. "3c") as float.
		 */
		winfo_fpixels(number): Promise<any>
		winfo_fpixels$({ number }): Promise<any>

		/**
		 * Return geometry string for this widget in the form "widthxheight+X+Y".
		 */
		winfo_geometry(): Promise<any>
		winfo_geometry$($: {}): Promise<any>

		/**
		 * Return height of this widget.
		 */
		winfo_height(): Promise<any>
		winfo_height$($: {}): Promise<any>

		/**
		 * Return identifier ID for this widget.
		 */
		winfo_id(): Promise<any>
		winfo_id$($: {}): Promise<any>

		/**
		 * Return the name of all Tcl interpreters for this display.
		 */
		winfo_interps(displayof?): Promise<any>
		winfo_interps$({ displayof }: { displayof?}): Promise<any>

		/**
		 * Return true if this widget is mapped.
		 */
		winfo_ismapped(): Promise<any>
		winfo_ismapped$($: {}): Promise<any>

		/**
		 * Return the window manager name for this widget.
		 */
		winfo_manager(): Promise<any>
		winfo_manager$($: {}): Promise<any>

		/**
		 * Return the name of this widget.
		 */
		winfo_name(): Promise<any>
		winfo_name$($: {}): Promise<any>

		/**
		 * Return the name of the parent of this widget.
		 */
		winfo_parent(): Promise<any>
		winfo_parent$($: {}): Promise<any>

		/**
		 * Return the pathname of the widget given by ID.
		 */
		winfo_pathname(id, displayof?): Promise<any>
		winfo_pathname$({ id, displayof }: { id, displayof?}): Promise<any>

		/**
		 * Rounded integer value of winfo_fpixels.
		 */
		winfo_pixels(number): Promise<any>
		winfo_pixels$({ number }): Promise<any>

		/**
		 * Return the x coordinate of the pointer on the root window.
		 */
		winfo_pointerx(): Promise<any>
		winfo_pointerx$($: {}): Promise<any>

		/**
		 * Return a tuple of x and y coordinates of the pointer on the root window.
		 */
		winfo_pointerxy(): Promise<any>
		winfo_pointerxy$($: {}): Promise<any>

		/**
		 * Return the y coordinate of the pointer on the root window.
		 */
		winfo_pointery(): Promise<any>
		winfo_pointery$($: {}): Promise<any>

		/**
		 * Return requested height of this widget.
		 */
		winfo_reqheight(): Promise<any>
		winfo_reqheight$($: {}): Promise<any>

		/**
		 * Return requested width of this widget.
		 */
		winfo_reqwidth(): Promise<any>
		winfo_reqwidth$($: {}): Promise<any>

		/**
		 * Return a tuple of integer RGB values in range(65536) for color in this widget.
		 */
		winfo_rgb(color): Promise<any>
		winfo_rgb$({ color }): Promise<any>

		/**
		 * Return x coordinate of upper left corner of this widget on the
		 *         root window.
		 */
		winfo_rootx(): Promise<any>
		winfo_rootx$($: {}): Promise<any>

		/**
		 * Return y coordinate of upper left corner of this widget on the
		 *         root window.
		 */
		winfo_rooty(): Promise<any>
		winfo_rooty$($: {}): Promise<any>

		/**
		 * Return the screen name of this widget.
		 */
		winfo_screen(): Promise<any>
		winfo_screen$($: {}): Promise<any>

		/**
		 * Return the number of the cells in the colormap of the screen
		 *         of this widget.
		 */
		winfo_screencells(): Promise<any>
		winfo_screencells$($: {}): Promise<any>

		/**
		 * Return the number of bits per pixel of the root window of the
		 *         screen of this widget.
		 */
		winfo_screendepth(): Promise<any>
		winfo_screendepth$($: {}): Promise<any>

		/**
		 * Return the number of pixels of the height of the screen of this widget
		 *         in pixel.
		 */
		winfo_screenheight(): Promise<any>
		winfo_screenheight$($: {}): Promise<any>

		/**
		 * Return the number of pixels of the height of the screen of
		 *         this widget in mm.
		 */
		winfo_screenmmheight(): Promise<any>
		winfo_screenmmheight$($: {}): Promise<any>

		/**
		 * Return the number of pixels of the width of the screen of
		 *         this widget in mm.
		 */
		winfo_screenmmwidth(): Promise<any>
		winfo_screenmmwidth$($: {}): Promise<any>

		/**
		 * Return one of the strings directcolor, grayscale, pseudocolor,
		 *         staticcolor, staticgray, or truecolor for the default
		 *         colormodel of this screen.
		 */
		winfo_screenvisual(): Promise<any>
		winfo_screenvisual$($: {}): Promise<any>

		/**
		 * Return the number of pixels of the width of the screen of
		 *         this widget in pixel.
		 */
		winfo_screenwidth(): Promise<any>
		winfo_screenwidth$($: {}): Promise<any>

		/**
		 * Return information of the X-Server of the screen of this widget in
		 *         the form "XmajorRminor vendor vendorVersion".
		 */
		winfo_server(): Promise<any>
		winfo_server$($: {}): Promise<any>

		/**
		 * Return the toplevel widget of this widget.
		 */
		winfo_toplevel(): Promise<any>
		winfo_toplevel$($: {}): Promise<any>

		/**
		 * Return true if the widget and all its higher ancestors are mapped.
		 */
		winfo_viewable(): Promise<any>
		winfo_viewable$($: {}): Promise<any>

		/**
		 * Return one of the strings directcolor, grayscale, pseudocolor,
		 *         staticcolor, staticgray, or truecolor for the
		 *         colormodel of this widget.
		 */
		winfo_visual(): Promise<any>
		winfo_visual$($: {}): Promise<any>

		/**
		 * Return the X identifier for the visual for this widget.
		 */
		winfo_visualid(): Promise<any>
		winfo_visualid$($: {}): Promise<any>

		/**
		 * Return a list of all visuals available for the screen
		 *         of this widget.
		 * 
		 *         Each item in the list consists of a visual name (see winfo_visual), a
		 *         depth and if includeids is true is given also the X identifier.
		 */
		winfo_visualsavailable(includeids?: boolean): Promise<any>
		winfo_visualsavailable$({ includeids }: { includeids?}): Promise<any>

		/**
		 * Return the height of the virtual root window associated with this
		 *         widget in pixels. If there is no virtual root window return the
		 *         height of the screen.
		 */
		winfo_vrootheight(): Promise<any>
		winfo_vrootheight$($: {}): Promise<any>

		/**
		 * Return the width of the virtual root window associated with this
		 *         widget in pixel. If there is no virtual root window return the
		 *         width of the screen.
		 */
		winfo_vrootwidth(): Promise<any>
		winfo_vrootwidth$($: {}): Promise<any>

		/**
		 * Return the x offset of the virtual root relative to the root
		 *         window of the screen of this widget.
		 */
		winfo_vrootx(): Promise<any>
		winfo_vrootx$($: {}): Promise<any>

		/**
		 * Return the y offset of the virtual root relative to the root
		 *         window of the screen of this widget.
		 */
		winfo_vrooty(): Promise<any>
		winfo_vrooty$($: {}): Promise<any>

		/**
		 * Return the width of this widget.
		 */
		winfo_width(): Promise<any>
		winfo_width$($: {}): Promise<any>

		/**
		 * Return the x coordinate of the upper left corner of this widget
		 *         in the parent.
		 */
		winfo_x(): Promise<any>
		winfo_x$($: {}): Promise<any>

		/**
		 * Return the y coordinate of the upper left corner of this widget
		 *         in the parent.
		 */
		winfo_y(): Promise<any>
		winfo_y$($: {}): Promise<any>

		/**
		 * Enter event loop until all pending events have been processed by Tcl.
		 */
		update(): Promise<any>
		update$($: {}): Promise<any>

		/**
		 * Enter event loop until all idle callbacks have been called. This
		 *         will update the display of windows but not process events caused by
		 *         the user.
		 */
		update_idletasks(): Promise<any>
		update_idletasks$($: {}): Promise<any>

		/**
		 * Set or get the list of bindtags for this widget.
		 * 
		 *         With no argument return the list of all bindtags associated with
		 *         this widget. With a list of strings as argument the bindtags are
		 *         set to this list. The bindtags determine in which order events are
		 *         processed (see bind).
		 */
		bindtags(tagList?): Promise<any>
		bindtags$({ tagList }: { tagList?}): Promise<any>

		/**
		 * Bind to this widget at event SEQUENCE a call to function FUNC.
		 * 
		 *         SEQUENCE is a string of concatenated event
		 *         patterns. An event pattern is of the form
		 *         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
		 *         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
		 *         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
		 *         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
		 *         Mod1, M1. TYPE is one of Activate, Enter, Map,
		 *         ButtonPress, Button, Expose, Motion, ButtonRelease
		 *         FocusIn, MouseWheel, Circulate, FocusOut, Property,
		 *         Colormap, Gravity Reparent, Configure, KeyPress, Key,
		 *         Unmap, Deactivate, KeyRelease Visibility, Destroy,
		 *         Leave and DETAIL is the button number for ButtonPress,
		 *         ButtonRelease and DETAIL is the Keysym for KeyPress and
		 *         KeyRelease. Examples are
		 *         <Control-Button-1> for pressing Control and mouse button 1 or
		 *         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
		 *         An event pattern can also be a virtual event of the form
		 *         <<AString>> where AString can be arbitrary. This
		 *         event can be generated by event_generate.
		 *         If events are concatenated they must appear shortly
		 *         after each other.
		 * 
		 *         FUNC will be called if the event sequence occurs with an
		 *         instance of Event as argument. If the return value of FUNC is
		 *         "break" no further bound function is invoked.
		 * 
		 *         An additional boolean parameter ADD specifies whether FUNC will
		 *         be called additionally to the other bound function or whether
		 *         it will replace the previous function.
		 * 
		 *         Bind will return an identifier to allow deletion of the bound function with
		 *         unbind without memory leak.
		 * 
		 *         If FUNC or SEQUENCE is omitted the bound function or list
		 *         of bound events are returned.
		 */
		bind(sequence?, func?, add?): Promise<any>
		bind$({ sequence, func, add }: { sequence?, func?, add?}): Promise<any>

		/**
		 * Unbind for this widget for event SEQUENCE  the
		 *         function identified with FUNCID.
		 */
		unbind(sequence, funcid?): Promise<any>
		unbind$({ sequence, funcid }: { sequence, funcid?}): Promise<any>

		/**
		 * Bind to all widgets at an event SEQUENCE a call to function FUNC.
		 *         An additional boolean parameter ADD specifies whether FUNC will
		 *         be called additionally to the other bound function or whether
		 *         it will replace the previous function. See bind for the return value.
		 */
		bind_all(sequence?, func?, add?): Promise<any>
		bind_all$({ sequence, func, add }: { sequence?, func?, add?}): Promise<any>

		/**
		 * Unbind for all widgets for event SEQUENCE all functions.
		 */
		unbind_all(sequence): Promise<any>
		unbind_all$({ sequence }): Promise<any>

		/**
		 * Bind to widgets with bindtag CLASSNAME at event
		 *         SEQUENCE a call of function FUNC. An additional
		 *         boolean parameter ADD specifies whether FUNC will be
		 *         called additionally to the other bound function or
		 *         whether it will replace the previous function. See bind for
		 *         the return value.
		 */
		bind_class(className, sequence?, func?, add?): Promise<any>
		bind_class$({ className, sequence, func, add }: { className, sequence?, func?, add?}): Promise<any>

		/**
		 * Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
		 *         all functions.
		 */
		unbind_class(className, sequence): Promise<any>
		unbind_class$({ className, sequence }): Promise<any>

		/**
		 * Call the mainloop of Tk.
		 */
		mainloop(n?): Promise<any>
		mainloop$({ n }: { n?}): Promise<any>

		/**
		 * Quit the Tcl interpreter. All widgets will be destroyed.
		 */
		quit(): Promise<any>
		quit$($: {}): Promise<any>

		/**
		 * Return the Tkinter instance of a widget identified by
		 *         its Tcl name NAME.
		 */
		nametowidget(name): Promise<any>
		nametowidget$({ name }): Promise<any>

		/**
		 * Configure resources of a widget.
		 * 
		 *         The values for resources are specified as keyword
		 *         arguments. To get an overview about
		 *         the allowed keyword arguments call the method keys.
		 *         
		 */
		configure(cnf?): Promise<any>
		configure$({ cnf }: { cnf?}): Promise<any>

		/**
		 * Return the resource value for a KEY given as string.
		 */
		cget(key): Promise<any>
		cget$({ key }): Promise<any>

		/**
		 * Return a list of all resource names of this widget.
		 */
		keys(): Promise<any>
		keys$($: {}): Promise<any>

		/**
		 * Set or get the status for propagation of geometry information.
		 * 
		 *         A boolean argument specifies whether the geometry information
		 *         of the slaves will determine the size of this widget. If no argument
		 *         is given the current setting will be returned.
		 *         
		 */
		pack_propagate(flag?): Promise<any>
		pack_propagate$({ flag }: { flag?}): Promise<any>

		/**
		 * Return a list of all slaves of this widget
		 *         in its packing order.
		 */
		pack_slaves(): Promise<any>
		pack_slaves$($: {}): Promise<any>

		/**
		 * Return a list of all slaves of this widget
		 *         in its packing order.
		 */
		place_slaves(): Promise<any>
		place_slaves$($: {}): Promise<any>

		/**
		 * The anchor value controls how to place the grid within the
		 *         master when no row/column has any weight.
		 * 
		 *         The default anchor is nw.
		 */
		grid_anchor(anchor?): Promise<any>
		grid_anchor$({ anchor }: { anchor?}): Promise<any>

		/**
		 * Return a tuple of integer coordinates for the bounding
		 *         box of this widget controlled by the geometry manager grid.
		 * 
		 *         If COLUMN, ROW is given the bounding box applies from
		 *         the cell with row and column 0 to the specified
		 *         cell. If COL2 and ROW2 are given the bounding box
		 *         starts at that cell.
		 * 
		 *         The returned integers specify the offset of the upper left
		 *         corner in the master widget and the width and height.
		 *         
		 */
		grid_bbox(column?, row?, col2?, row2?): Promise<any>
		grid_bbox$({ column, row, col2, row2 }: { column?, row?, col2?, row2?}): Promise<any>

		/**
		 * Configure column INDEX of a grid.
		 * 
		 *         Valid resources are minsize (minimum size of the column),
		 *         weight (how much does additional space propagate to this column)
		 *         and pad (how much space to let additionally).
		 */
		grid_columnconfigure(index, cnf?): Promise<any>
		grid_columnconfigure$({ index, cnf }: { index, cnf?}): Promise<any>

		/**
		 * Return a tuple of column and row which identify the cell
		 *         at which the pixel at position X and Y inside the master
		 *         widget is located.
		 */
		grid_location(x, y): Promise<any>
		grid_location$({ x, y }): Promise<any>

		/**
		 * Set or get the status for propagation of geometry information.
		 * 
		 *         A boolean argument specifies whether the geometry information
		 *         of the slaves will determine the size of this widget. If no argument
		 *         is given, the current setting will be returned.
		 *         
		 */
		grid_propagate(flag?): Promise<any>
		grid_propagate$({ flag }: { flag?}): Promise<any>

		/**
		 * Configure row INDEX of a grid.
		 * 
		 *         Valid resources are minsize (minimum size of the row),
		 *         weight (how much does additional space propagate to this row)
		 *         and pad (how much space to let additionally).
		 */
		grid_rowconfigure(index, cnf?): Promise<any>
		grid_rowconfigure$({ index, cnf }: { index, cnf?}): Promise<any>

		/**
		 * Return a tuple of the number of column and rows in the grid.
		 */
		grid_size(): Promise<any>
		grid_size$($: {}): Promise<any>

		/**
		 * Return a list of all slaves of this widget
		 *         in its packing order.
		 */
		grid_slaves(row?, column?): Promise<any>
		grid_slaves$({ row, column }: { row?, column?}): Promise<any>

		/**
		 * Bind a virtual event VIRTUAL (of the form <<Name>>)
		 *         to an event SEQUENCE such that the virtual event is triggered
		 *         whenever SEQUENCE occurs.
		 */
		event_add(virtual): Promise<any>
		event_add$({ virtual }): Promise<any>

		/**
		 * Unbind a virtual event VIRTUAL from SEQUENCE.
		 */
		event_delete(virtual): Promise<any>
		event_delete$({ virtual }): Promise<any>

		/**
		 * Generate an event SEQUENCE. Additional
		 *         keyword arguments specify parameter of the event
		 *         (e.g. x, y, rootx, rooty).
		 */
		event_generate(sequence): Promise<any>
		event_generate$({ sequence }): Promise<any>

		/**
		 * Return a list of all virtual events or the information
		 *         about the SEQUENCE bound to the virtual event VIRTUAL.
		 */
		event_info(virtual?): Promise<any>
		event_info$({ virtual }: { virtual?}): Promise<any>

		/**
		 * Return a list of all existing image names.
		 */
		image_names(): Promise<any>
		image_names$($: {}): Promise<any>

		/**
		 * Return a list of all available image types (e.g. photo bitmap).
		 */
		image_types(): Promise<any>
		image_types$($: {}): Promise<any>
		waitvar
		focus
		lift
		register
		config
		propagate
		slaves
		anchor
		bbox
		columnconfigure
		rowconfigure
		size
	}

	/**
	 * Internal class. Stores function to call when some user
	 *     defined Tcl function is called e.g. after an event occurred.
	 */

	/**
	 * Store FUNC, SUBST and WIDGET as members.
	 */
	function CallWrapper(func, subst, widget): Promise<ICallWrapper>
	function CallWrapper$({ func, subst, widget }): Promise<ICallWrapper>
	interface ICallWrapper {
	}

	/**
	 * Mix-in class for querying and changing the horizontal position
	 *     of a widget's window.
	 */
	interface IXView {

		/**
		 * Query and change the horizontal position of the view.
		 */
		xview(): Promise<any>
		xview$($: {}): Promise<any>

		/**
		 * Adjusts the view in the window so that FRACTION of the
		 *         total width of the canvas is off-screen to the left.
		 */
		xview_moveto(fraction): Promise<any>
		xview_moveto$({ fraction }): Promise<any>

		/**
		 * Shift the x-view according to NUMBER which is measured in "units"
		 *         or "pages" (WHAT).
		 */
		xview_scroll(number, what): Promise<any>
		xview_scroll$({ number, what }): Promise<any>
	}

	/**
	 * Mix-in class for querying and changing the vertical position
	 *     of a widget's window.
	 */
	interface IYView {

		/**
		 * Query and change the vertical position of the view.
		 */
		yview(): Promise<any>
		yview$($: {}): Promise<any>

		/**
		 * Adjusts the view in the window so that FRACTION of the
		 *         total height of the canvas is off-screen to the top.
		 */
		yview_moveto(fraction): Promise<any>
		yview_moveto$({ fraction }): Promise<any>

		/**
		 * Shift the y-view according to NUMBER which is measured in
		 *         "units" or "pages" (WHAT).
		 */
		yview_scroll(number, what): Promise<any>
		yview_scroll$({ number, what }): Promise<any>
	}

	/**
	 * Provides functions for the communication with the window manager.
	 */
	interface IWm {

		/**
		 * Instruct the window manager to set the aspect ratio (width/height)
		 *         of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
		 *         of the actual values if no argument is given.
		 */
		wm_aspect(minNumer?, minDenom?, maxNumer?, maxDenom?): Promise<any>
		wm_aspect$({ minNumer, minDenom, maxNumer, maxDenom }: { minNumer?, minDenom?, maxNumer?, maxDenom?}): Promise<any>

		/**
		 * This subcommand returns or sets platform specific attributes
		 * 
		 *         The first form returns a list of the platform specific flags and
		 *         their values. The second form returns the value for the specific
		 *         option. The third form sets one or more of the values. The values
		 *         are as follows:
		 * 
		 *         On Windows, -disabled gets or sets whether the window is in a
		 *         disabled state. -toolwindow gets or sets the style of the window
		 *         to toolwindow (as defined in the MSDN). -topmost gets or sets
		 *         whether this is a topmost window (displays above all other
		 *         windows).
		 * 
		 *         On Macintosh, XXXXX
		 * 
		 *         On Unix, there are currently no special attribute values.
		 *         
		 */
		wm_attributes(): Promise<any>
		wm_attributes$($: {}): Promise<any>

		/**
		 * Store NAME in WM_CLIENT_MACHINE property of this widget. Return
		 *         current value.
		 */
		wm_client(name?): Promise<any>
		wm_client$({ name }: { name?}): Promise<any>

		/**
		 * Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
		 *         of this widget. This list contains windows whose colormaps differ from their
		 *         parents. Return current list of widgets if WLIST is empty.
		 */
		wm_colormapwindows(): Promise<any>
		wm_colormapwindows$($: {}): Promise<any>

		/**
		 * Store VALUE in WM_COMMAND property. It is the command
		 *         which shall be used to invoke the application. Return current
		 *         command if VALUE is None.
		 */
		wm_command(value?): Promise<any>
		wm_command$({ value }: { value?}): Promise<any>

		/**
		 * Deiconify this widget. If it was never mapped it will not be mapped.
		 *         On Windows it will raise this widget and give it the focus.
		 */
		wm_deiconify(): Promise<any>
		wm_deiconify$($: {}): Promise<any>

		/**
		 * Set focus model to MODEL. "active" means that this widget will claim
		 *         the focus itself, "passive" means that the window manager shall give
		 *         the focus. Return current focus model if MODEL is None.
		 */
		wm_focusmodel(model?): Promise<any>
		wm_focusmodel$({ model }: { model?}): Promise<any>

		/**
		 * The window will be unmapped from the screen and will no longer
		 *         be managed by wm. toplevel windows will be treated like frame
		 *         windows once they are no longer managed by wm, however, the menu
		 *         option configuration will be remembered and the menus will return
		 *         once the widget is managed again.
		 */
		wm_forget(window): Promise<any>
		wm_forget$({ window }): Promise<any>

		/**
		 * Return identifier for decorative frame of this widget if present.
		 */
		wm_frame(): Promise<any>
		wm_frame$($: {}): Promise<any>

		/**
		 * Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
		 *         current value if None is given.
		 */
		wm_geometry(newGeometry?): Promise<any>
		wm_geometry$({ newGeometry }: { newGeometry?}): Promise<any>

		/**
		 * Instruct the window manager that this widget shall only be
		 *         resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
		 *         height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
		 *         number of grid units requested in Tk_GeometryRequest.
		 */
		wm_grid(baseWidth?, baseHeight?, widthInc?, heightInc?): Promise<any>
		wm_grid$({ baseWidth, baseHeight, widthInc, heightInc }: { baseWidth?, baseHeight?, widthInc?, heightInc?}): Promise<any>

		/**
		 * Set the group leader widgets for related widgets to PATHNAME. Return
		 *         the group leader of this widget if None is given.
		 */
		wm_group(pathName?): Promise<any>
		wm_group$({ pathName }: { pathName?}): Promise<any>

		/**
		 * Set bitmap for the iconified widget to BITMAP. Return
		 *         the bitmap if None is given.
		 * 
		 *         Under Windows, the DEFAULT parameter can be used to set the icon
		 *         for the widget and any descendents that don't have an icon set
		 *         explicitly.  DEFAULT can be the relative path to a .ico file
		 *         (example: root.iconbitmap(default='myicon.ico') ).  See Tk
		 *         documentation for more information.
		 */
		wm_iconbitmap(bitmap?, def?): Promise<any>
		wm_iconbitmap$({ bitmap, def }: { bitmap?, def?}): Promise<any>

		/**
		 * Display widget as icon.
		 */
		wm_iconify(): Promise<any>
		wm_iconify$($: {}): Promise<any>

		/**
		 * Set mask for the icon bitmap of this widget. Return the
		 *         mask if None is given.
		 */
		wm_iconmask(bitmap?): Promise<any>
		wm_iconmask$({ bitmap }: { bitmap?}): Promise<any>

		/**
		 * Set the name of the icon for this widget. Return the name if
		 *         None is given.
		 */
		wm_iconname(newName?): Promise<any>
		wm_iconname$({ newName }: { newName?}): Promise<any>

		/**
		 * Sets the titlebar icon for this window based on the named photo
		 *         images passed through args. If default is True, this is applied to
		 *         all future created toplevels as well.
		 * 
		 *         The data in the images is taken as a snapshot at the time of
		 *         invocation. If the images are later changed, this is not reflected
		 *         to the titlebar icons. Multiple images are accepted to allow
		 *         different images sizes to be provided. The window manager may scale
		 *         provided icons to an appropriate size.
		 * 
		 *         On Windows, the images are packed into a Windows icon structure.
		 *         This will override an icon specified to wm_iconbitmap, and vice
		 *         versa.
		 * 
		 *         On X, the images are arranged into the _NET_WM_ICON X property,
		 *         which most modern window managers support. An icon specified by
		 *         wm_iconbitmap may exist simultaneously.
		 * 
		 *         On Macintosh, this currently does nothing.
		 */
		wm_iconphoto(def?: boolean): Promise<any>
		wm_iconphoto$({ def }: { def?}): Promise<any>

		/**
		 * Set the position of the icon of this widget to X and Y. Return
		 *         a tuple of the current values of X and X if None is given.
		 */
		wm_iconposition(x?, y?): Promise<any>
		wm_iconposition$({ x, y }: { x?, y?}): Promise<any>

		/**
		 * Set widget PATHNAME to be displayed instead of icon. Return the current
		 *         value if None is given.
		 */
		wm_iconwindow(pathName?): Promise<any>
		wm_iconwindow$({ pathName }: { pathName?}): Promise<any>

		/**
		 * The widget specified will become a stand alone top-level window.
		 *         The window will be decorated with the window managers title bar,
		 *         etc.
		 */
		wm_manage(widget): Promise<any>
		wm_manage$({ widget }): Promise<any>

		/**
		 * Set max WIDTH and HEIGHT for this widget. If the window is gridded
		 *         the values are given in grid units. Return the current values if None
		 *         is given.
		 */
		wm_maxsize(width?, height?): Promise<any>
		wm_maxsize$({ width, height }: { width?, height?}): Promise<any>

		/**
		 * Set min WIDTH and HEIGHT for this widget. If the window is gridded
		 *         the values are given in grid units. Return the current values if None
		 *         is given.
		 */
		wm_minsize(width?, height?): Promise<any>
		wm_minsize$({ width, height }: { width?, height?}): Promise<any>

		/**
		 * Instruct the window manager to ignore this widget
		 *         if BOOLEAN is given with 1. Return the current value if None
		 *         is given.
		 */
		wm_overrideredirect(boolean?): Promise<any>
		wm_overrideredirect$({ boolean }: { boolean?}): Promise<any>

		/**
		 * Instruct the window manager that the position of this widget shall
		 *         be defined by the user if WHO is "user", and by its own policy if WHO is
		 *         "program".
		 */
		wm_positionfrom(who?): Promise<any>
		wm_positionfrom$({ who }: { who?}): Promise<any>

		/**
		 * Bind function FUNC to command NAME for this widget.
		 *         Return the function bound to NAME if None is given. NAME could be
		 *         e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW".
		 */
		wm_protocol(name?, func?): Promise<any>
		wm_protocol$({ name, func }: { name?, func?}): Promise<any>

		/**
		 * Instruct the window manager whether this width can be resized
		 *         in WIDTH or HEIGHT. Both values are boolean values.
		 */
		wm_resizable(width?, height?): Promise<any>
		wm_resizable$({ width, height }: { width?, height?}): Promise<any>

		/**
		 * Instruct the window manager that the size of this widget shall
		 *         be defined by the user if WHO is "user", and by its own policy if WHO is
		 *         "program".
		 */
		wm_sizefrom(who?): Promise<any>
		wm_sizefrom$({ who }: { who?}): Promise<any>

		/**
		 * Query or set the state of this widget as one of normal, icon,
		 *         iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only).
		 */
		wm_state(newstate?): Promise<any>
		wm_state$({ newstate }: { newstate?}): Promise<any>

		/**
		 * Set the title of this widget.
		 */
		wm_title(string?): Promise<any>
		wm_title$({ string }: { string?}): Promise<any>

		/**
		 * Instruct the window manager that this widget is transient
		 *         with regard to widget MASTER.
		 */
		wm_transient(master?): Promise<any>
		wm_transient$({ master }: { master?}): Promise<any>

		/**
		 * Withdraw this widget from the screen such that it is unmapped
		 *         and forgotten by the window manager. Re-draw it with wm_deiconify.
		 */
		wm_withdraw(): Promise<any>
		wm_withdraw$($: {}): Promise<any>
		aspect
		attributes
		client
		colormapwindows
		command
		deiconify
		focusmodel
		forget
		frame
		geometry
		grid
		group
		iconbitmap
		iconify
		iconmask
		iconname
		iconphoto
		iconposition
		iconwindow
		manage
		maxsize
		minsize
		overrideredirect
		positionfrom
		protocol
		resizable
		sizefrom
		state
		title
		transient
		withdraw
	}

	/**
	 * Toplevel widget of Tk which represents mostly the main window
	 *     of an application. It has an associated Tcl interpreter.
	 */

	/**
	 * Return a new Toplevel widget on screen SCREENNAME. A new Tcl interpreter will
	 *         be created. BASENAME will be used for the identification of the profile file (see
	 *         readprofile).
	 *         It is constructed from sys.argv[0] without extensions if None is given. CLASSNAME
	 *         is the name of the widget class.
	 */
	function Tk(screenName?, baseName?, className?, useTk?: boolean, sync?: boolean, use?): Promise<ITk>
	function Tk$({ screenName, baseName, className, useTk, sync, use }: { screenName?, baseName?, className?, useTk?, sync?, use?}): Promise<ITk>
	interface ITk extends IMisc, IWm {
		loadtk(): Promise<any>
		loadtk$($: {}): Promise<any>

		/**
		 * Destroy this and all descendants widgets. This will
		 *         end the application of this Tcl interpreter.
		 */
		destroy(): Promise<any>
		destroy$($: {}): Promise<any>

		/**
		 * Internal function. It reads BASENAME.tcl and CLASSNAME.tcl into
		 *         the Tcl Interpreter and calls exec on the contents of BASENAME.py and
		 *         CLASSNAME.py if such a file exists in the home directory.
		 */
		readprofile(baseName, className): Promise<any>
		readprofile$({ baseName, className }): Promise<any>

		/**
		 * Report callback exception on sys.stderr.
		 * 
		 *         Applications may want to override this internal function, and
		 *         should when sys.stderr is None.
		 */
		report_callback_exception(exc, val, tb): Promise<any>
		report_callback_exception$({ exc, val, tb }): Promise<any>
	}

	/**
	 * Geometry manager Pack.
	 * 
	 *     Base class to use the methods pack_* in every widget.
	 */
	interface IPack {

		/**
		 * Pack a widget in the parent widget. Use as options:
		 *         after=widget - pack it after you have packed widget
		 *         anchor=NSEW (or subset) - position widget according to
		 *                                   given direction
		 *         before=widget - pack it before you will pack widget
		 *         expand=bool - expand widget if parent size grows
		 *         fill=NONE or X or Y or BOTH - fill widget if widget grows
		 *         in=master - use master to contain this widget
		 *         in_=master - see 'in' option description
		 *         ipadx=amount - add internal padding in x direction
		 *         ipady=amount - add internal padding in y direction
		 *         padx=amount - add padding in x direction
		 *         pady=amount - add padding in y direction
		 *         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
		 *         
		 */
		pack_configure(cnf?): Promise<any>
		pack_configure$({ cnf }: { cnf?}): Promise<any>

		/**
		 * Unmap this widget and do not use it for the packing order.
		 */
		pack_forget(): Promise<any>
		pack_forget$($: {}): Promise<any>

		/**
		 * Return information about the packing options
		 *         for this widget.
		 */
		pack_info(): Promise<any>
		pack_info$($: {}): Promise<any>
		pack
		info
	}

	/**
	 * Geometry manager Place.
	 * 
	 *     Base class to use the methods place_* in every widget.
	 */
	interface IPlace {

		/**
		 * Place a widget in the parent widget. Use as options:
		 *         in=master - master relative to which the widget is placed
		 *         in_=master - see 'in' option description
		 *         x=amount - locate anchor of this widget at position x of master
		 *         y=amount - locate anchor of this widget at position y of master
		 *         relx=amount - locate anchor of this widget between 0.0 and 1.0
		 *                       relative to width of master (1.0 is right edge)
		 *         rely=amount - locate anchor of this widget between 0.0 and 1.0
		 *                       relative to height of master (1.0 is bottom edge)
		 *         anchor=NSEW (or subset) - position anchor according to given direction
		 *         width=amount - width of this widget in pixel
		 *         height=amount - height of this widget in pixel
		 *         relwidth=amount - width of this widget between 0.0 and 1.0
		 *                           relative to width of master (1.0 is the same width
		 *                           as the master)
		 *         relheight=amount - height of this widget between 0.0 and 1.0
		 *                            relative to height of master (1.0 is the same
		 *                            height as the master)
		 *         bordermode="inside" or "outside" - whether to take border width of
		 *                                            master widget into account
		 *         
		 */
		place_configure(cnf?): Promise<any>
		place_configure$({ cnf }: { cnf?}): Promise<any>

		/**
		 * Unmap this widget.
		 */
		place_forget(): Promise<any>
		place_forget$($: {}): Promise<any>

		/**
		 * Return information about the placing options
		 *         for this widget.
		 */
		place_info(): Promise<any>
		place_info$($: {}): Promise<any>
		place
	}

	/**
	 * Geometry manager Grid.
	 * 
	 *     Base class to use the methods grid_* in every widget.
	 */
	interface IGrid {

		/**
		 * Position a widget in the parent widget in a grid. Use as options:
		 *         column=number - use cell identified with given column (starting with 0)
		 *         columnspan=number - this widget will span several columns
		 *         in=master - use master to contain this widget
		 *         in_=master - see 'in' option description
		 *         ipadx=amount - add internal padding in x direction
		 *         ipady=amount - add internal padding in y direction
		 *         padx=amount - add padding in x direction
		 *         pady=amount - add padding in y direction
		 *         row=number - use cell identified with given row (starting with 0)
		 *         rowspan=number - this widget will span several rows
		 *         sticky=NSEW - if cell is larger on which sides will this
		 *                       widget stick to the cell boundary
		 *         
		 */
		grid_configure(cnf?): Promise<any>
		grid_configure$({ cnf }: { cnf?}): Promise<any>

		/**
		 * Unmap this widget.
		 */
		grid_forget(): Promise<any>
		grid_forget$($: {}): Promise<any>

		/**
		 * Unmap this widget but remember the grid options.
		 */
		grid_remove(): Promise<any>
		grid_remove$($: {}): Promise<any>

		/**
		 * Return information about the options
		 *         for positioning this widget in a grid.
		 */
		grid_info(): Promise<any>
		grid_info$($: {}): Promise<any>
		location
	}

	/**
	 * Internal class.
	 */

	/**
	 * Construct a widget with the parent widget MASTER, a name WIDGETNAME
	 *         and appropriate options.
	 */
	function BaseWidget(master, widgetName, cnf?, kw?, extra?): Promise<IBaseWidget>
	function BaseWidget$({ master, widgetName, cnf, kw, extra }: { master, widgetName, cnf?, kw?, extra?}): Promise<IBaseWidget>
	interface IBaseWidget extends IMisc {

		/**
		 * Destroy this and all descendants widgets.
		 */
		destroy(): Promise<any>
		destroy$($: {}): Promise<any>
	}

	/**
	 * Internal class.
	 * 
	 *     Base class for a widget which can be positioned with the geometry managers
	 *     Pack, Place or Grid.
	 */
	interface IWidget extends IBaseWidget, IPack, IPlace, IGrid {
	}

	/**
	 * Toplevel widget, e.g. for dialogs.
	 */

	/**
	 * Construct a toplevel widget with the parent MASTER.
	 * 
	 *         Valid resource names: background, bd, bg, borderwidth, class,
	 *         colormap, container, cursor, height, highlightbackground,
	 *         highlightcolor, highlightthickness, menu, relief, screen, takefocus,
	 *         use, visual, width.
	 */
	function Toplevel(master?, cnf?): Promise<IToplevel>
	function Toplevel$({ master, cnf }: { master?, cnf?}): Promise<IToplevel>
	interface IToplevel extends IBaseWidget, IWm {
	}

	/**
	 * Button widget.
	 */

	/**
	 * Construct a button widget with the parent MASTER.
	 * 
	 *         STANDARD OPTIONS
	 * 
	 *             activebackground, activeforeground, anchor,
	 *             background, bitmap, borderwidth, cursor,
	 *             disabledforeground, font, foreground
	 *             highlightbackground, highlightcolor,
	 *             highlightthickness, image, justify,
	 *             padx, pady, relief, repeatdelay,
	 *             repeatinterval, takefocus, text,
	 *             textvariable, underline, wraplength
	 * 
	 *         WIDGET-SPECIFIC OPTIONS
	 * 
	 *             command, compound, default, height,
	 *             overrelief, state, width
	 *         
	 */
	function Button(master?, cnf?): Promise<IButton>
	function Button$({ master, cnf }: { master?, cnf?}): Promise<IButton>
	interface IButton extends IWidget {

		/**
		 * Flash the button.
		 * 
		 *         This is accomplished by redisplaying
		 *         the button several times, alternating between active and
		 *         normal colors. At the end of the flash the button is left
		 *         in the same normal/active state as when the command was
		 *         invoked. This command is ignored if the button's state is
		 *         disabled.
		 *         
		 */
		flash(): Promise<any>
		flash$($: {}): Promise<any>

		/**
		 * Invoke the command associated with the button.
		 * 
		 *         The return value is the return value from the command,
		 *         or an empty string if there is no command associated with
		 *         the button. This command is ignored if the button's state
		 *         is disabled.
		 *         
		 */
		invoke(): Promise<any>
		invoke$($: {}): Promise<any>
	}

	/**
	 * Canvas widget to display graphical elements like lines or text.
	 */

	/**
	 * Construct a canvas widget with the parent MASTER.
	 * 
	 *         Valid resource names: background, bd, bg, borderwidth, closeenough,
	 *         confine, cursor, height, highlightbackground, highlightcolor,
	 *         highlightthickness, insertbackground, insertborderwidth,
	 *         insertofftime, insertontime, insertwidth, offset, relief,
	 *         scrollregion, selectbackground, selectborderwidth, selectforeground,
	 *         state, takefocus, width, xscrollcommand, xscrollincrement,
	 *         yscrollcommand, yscrollincrement.
	 */
	function Canvas(master?, cnf?): Promise<ICanvas>
	function Canvas$({ master, cnf }: { master?, cnf?}): Promise<ICanvas>
	interface ICanvas extends IWidget, IXView, IYView {

		/**
		 * Internal function.
		 */
		addtag(): Promise<any>
		addtag$($: {}): Promise<any>

		/**
		 * Add tag NEWTAG to all items above TAGORID.
		 */
		addtag_above(newtag, tagOrId): Promise<any>
		addtag_above$({ newtag, tagOrId }): Promise<any>

		/**
		 * Add tag NEWTAG to all items.
		 */
		addtag_all(newtag): Promise<any>
		addtag_all$({ newtag }): Promise<any>

		/**
		 * Add tag NEWTAG to all items below TAGORID.
		 */
		addtag_below(newtag, tagOrId): Promise<any>
		addtag_below$({ newtag, tagOrId }): Promise<any>

		/**
		 * Add tag NEWTAG to item which is closest to pixel at X, Y.
		 *         If several match take the top-most.
		 *         All items closer than HALO are considered overlapping (all are
		 *         closests). If START is specified the next below this tag is taken.
		 */
		addtag_closest(newtag, x, y, halo?, start?): Promise<any>
		addtag_closest$({ newtag, x, y, halo, start }: { newtag, x, y, halo?, start?}): Promise<any>

		/**
		 * Add tag NEWTAG to all items in the rectangle defined
		 *         by X1,Y1,X2,Y2.
		 */
		addtag_enclosed(newtag, x1, y1, x2, y2): Promise<any>
		addtag_enclosed$({ newtag, x1, y1, x2, y2 }): Promise<any>

		/**
		 * Add tag NEWTAG to all items which overlap the rectangle
		 *         defined by X1,Y1,X2,Y2.
		 */
		addtag_overlapping(newtag, x1, y1, x2, y2): Promise<any>
		addtag_overlapping$({ newtag, x1, y1, x2, y2 }): Promise<any>

		/**
		 * Add tag NEWTAG to all items with TAGORID.
		 */
		addtag_withtag(newtag, tagOrId): Promise<any>
		addtag_withtag$({ newtag, tagOrId }): Promise<any>

		/**
		 * Return a tuple of X1,Y1,X2,Y2 coordinates for a rectangle
		 *         which encloses all items with tags specified as arguments.
		 */
		bbox(): Promise<any>
		bbox$($: {}): Promise<any>

		/**
		 * Unbind for all items with TAGORID for event SEQUENCE  the
		 *         function identified with FUNCID.
		 */
		tag_unbind(tagOrId, sequence, funcid?): Promise<any>
		tag_unbind$({ tagOrId, sequence, funcid }: { tagOrId, sequence, funcid?}): Promise<any>

		/**
		 * Bind to all items with TAGORID at event SEQUENCE a call to function FUNC.
		 * 
		 *         An additional boolean parameter ADD specifies whether FUNC will be
		 *         called additionally to the other bound function or whether it will
		 *         replace the previous function. See bind for the return value.
		 */
		tag_bind(tagOrId, sequence?, func?, add?): Promise<any>
		tag_bind$({ tagOrId, sequence, func, add }: { tagOrId, sequence?, func?, add?}): Promise<any>

		/**
		 * Return the canvas x coordinate of pixel position SCREENX rounded
		 *         to nearest multiple of GRIDSPACING units.
		 */
		canvasx(screenx, gridspacing?): Promise<any>
		canvasx$({ screenx, gridspacing }: { screenx, gridspacing?}): Promise<any>

		/**
		 * Return the canvas y coordinate of pixel position SCREENY rounded
		 *         to nearest multiple of GRIDSPACING units.
		 */
		canvasy(screeny, gridspacing?): Promise<any>
		canvasy$({ screeny, gridspacing }: { screeny, gridspacing?}): Promise<any>

		/**
		 * Return a list of coordinates for the item given in ARGS.
		 */
		coords(): Promise<any>
		coords$($: {}): Promise<any>

		/**
		 * Create arc shaped region with coordinates x1,y1,x2,y2.
		 */
		create_arc(): Promise<any>
		create_arc$($: {}): Promise<any>

		/**
		 * Create bitmap with coordinates x1,y1.
		 */
		create_bitmap(): Promise<any>
		create_bitmap$($: {}): Promise<any>

		/**
		 * Create image item with coordinates x1,y1.
		 */
		create_image(): Promise<any>
		create_image$($: {}): Promise<any>

		/**
		 * Create line with coordinates x1,y1,...,xn,yn.
		 */
		create_line(): Promise<any>
		create_line$($: {}): Promise<any>

		/**
		 * Create oval with coordinates x1,y1,x2,y2.
		 */
		create_oval(): Promise<any>
		create_oval$($: {}): Promise<any>

		/**
		 * Create polygon with coordinates x1,y1,...,xn,yn.
		 */
		create_polygon(): Promise<any>
		create_polygon$($: {}): Promise<any>

		/**
		 * Create rectangle with coordinates x1,y1,x2,y2.
		 */
		create_rectangle(): Promise<any>
		create_rectangle$($: {}): Promise<any>

		/**
		 * Create text with coordinates x1,y1.
		 */
		create_text(): Promise<any>
		create_text$($: {}): Promise<any>

		/**
		 * Create window with coordinates x1,y1,x2,y2.
		 */
		create_window(): Promise<any>
		create_window$($: {}): Promise<any>

		/**
		 * Delete characters of text items identified by tag or id in ARGS (possibly
		 *         several times) from FIRST to LAST character (including).
		 */
		dchars(): Promise<any>
		dchars$($: {}): Promise<any>

		/**
		 * Delete items identified by all tag or ids contained in ARGS.
		 */
		delete(): Promise<any>
		delete$($: {}): Promise<any>

		/**
		 * Delete tag or id given as last arguments in ARGS from items
		 *         identified by first argument in ARGS.
		 */
		dtag(): Promise<any>
		dtag$($: {}): Promise<any>

		/**
		 * Internal function.
		 */
		find(): Promise<any>
		find$($: {}): Promise<any>

		/**
		 * Return items above TAGORID.
		 */
		find_above(tagOrId): Promise<any>
		find_above$({ tagOrId }): Promise<any>

		/**
		 * Return all items.
		 */
		find_all(): Promise<any>
		find_all$($: {}): Promise<any>

		/**
		 * Return all items below TAGORID.
		 */
		find_below(tagOrId): Promise<any>
		find_below$({ tagOrId }): Promise<any>

		/**
		 * Return item which is closest to pixel at X, Y.
		 *         If several match take the top-most.
		 *         All items closer than HALO are considered overlapping (all are
		 *         closest). If START is specified the next below this tag is taken.
		 */
		find_closest(x, y, halo?, start?): Promise<any>
		find_closest$({ x, y, halo, start }: { x, y, halo?, start?}): Promise<any>

		/**
		 * Return all items in rectangle defined
		 *         by X1,Y1,X2,Y2.
		 */
		find_enclosed(x1, y1, x2, y2): Promise<any>
		find_enclosed$({ x1, y1, x2, y2 }): Promise<any>

		/**
		 * Return all items which overlap the rectangle
		 *         defined by X1,Y1,X2,Y2.
		 */
		find_overlapping(x1, y1, x2, y2): Promise<any>
		find_overlapping$({ x1, y1, x2, y2 }): Promise<any>

		/**
		 * Return all items with TAGORID.
		 */
		find_withtag(tagOrId): Promise<any>
		find_withtag$({ tagOrId }): Promise<any>

		/**
		 * Set focus to the first item specified in ARGS.
		 */
		focus(): Promise<any>
		focus$($: {}): Promise<any>

		/**
		 * Return tags associated with the first item specified in ARGS.
		 */
		gettags(): Promise<any>
		gettags$($: {}): Promise<any>

		/**
		 * Set cursor at position POS in the item identified by TAGORID.
		 *         In ARGS TAGORID must be first.
		 */
		icursor(): Promise<any>
		icursor$($: {}): Promise<any>

		/**
		 * Return position of cursor as integer in item specified in ARGS.
		 */
		index(): Promise<any>
		index$($: {}): Promise<any>

		/**
		 * Insert TEXT in item TAGORID at position POS. ARGS must
		 *         be TAGORID POS TEXT.
		 */
		insert(): Promise<any>
		insert$($: {}): Promise<any>

		/**
		 * Return the resource value for an OPTION for item TAGORID.
		 */
		itemcget(tagOrId, option): Promise<any>
		itemcget$({ tagOrId, option }): Promise<any>

		/**
		 * Configure resources of an item TAGORID.
		 * 
		 *         The values for resources are specified as keyword
		 *         arguments. To get an overview about
		 *         the allowed keyword arguments call the method without arguments.
		 *         
		 */
		itemconfigure(tagOrId, cnf?): Promise<any>
		itemconfigure$({ tagOrId, cnf }: { tagOrId, cnf?}): Promise<any>

		/**
		 * Lower an item TAGORID given in ARGS
		 *         (optional below another item).
		 */
		tag_lower(): Promise<any>
		tag_lower$($: {}): Promise<any>

		/**
		 * Move an item TAGORID given in ARGS.
		 */
		move(): Promise<any>
		move$($: {}): Promise<any>

		/**
		 * Move the items given by TAGORID in the canvas coordinate
		 *         space so that the first coordinate pair of the bottommost
		 *         item with tag TAGORID is located at position (X,Y).
		 *         X and Y may be the empty string, in which case the
		 *         corresponding coordinate will be unchanged. All items matching
		 *         TAGORID remain in the same positions relative to each other.
		 */
		moveto(tagOrId, x?, y?): Promise<any>
		moveto$({ tagOrId, x, y }: { tagOrId, x?, y?}): Promise<any>

		/**
		 * Print the contents of the canvas to a postscript
		 *         file. Valid options: colormap, colormode, file, fontmap,
		 *         height, pageanchor, pageheight, pagewidth, pagex, pagey,
		 *         rotate, width, x, y.
		 */
		postscript(cnf?): Promise<any>
		postscript$({ cnf }: { cnf?}): Promise<any>

		/**
		 * Raise an item TAGORID given in ARGS
		 *         (optional above another item).
		 */
		tag_raise(): Promise<any>
		tag_raise$($: {}): Promise<any>

		/**
		 * Scale item TAGORID with XORIGIN, YORIGIN, XSCALE, YSCALE.
		 */
		scale(): Promise<any>
		scale$($: {}): Promise<any>

		/**
		 * Remember the current X, Y coordinates.
		 */
		scan_mark(x, y): Promise<any>
		scan_mark$({ x, y }): Promise<any>

		/**
		 * Adjust the view of the canvas to GAIN times the
		 *         difference between X and Y and the coordinates given in
		 *         scan_mark.
		 */
		scan_dragto(x, y, gain?): Promise<any>
		scan_dragto$({ x, y, gain }: { x, y, gain?}): Promise<any>

		/**
		 * Adjust the end of the selection near the cursor of an item TAGORID to index.
		 */
		select_adjust(tagOrId, index): Promise<any>
		select_adjust$({ tagOrId, index }): Promise<any>

		/**
		 * Clear the selection if it is in this widget.
		 */
		select_clear(): Promise<any>
		select_clear$($: {}): Promise<any>

		/**
		 * Set the fixed end of a selection in item TAGORID to INDEX.
		 */
		select_from(tagOrId, index): Promise<any>
		select_from$({ tagOrId, index }): Promise<any>

		/**
		 * Return the item which has the selection.
		 */
		select_item(): Promise<any>
		select_item$($: {}): Promise<any>

		/**
		 * Set the variable end of a selection in item TAGORID to INDEX.
		 */
		select_to(tagOrId, index): Promise<any>
		select_to$({ tagOrId, index }): Promise<any>

		/**
		 * Return the type of the item TAGORID.
		 */
		type(tagOrId): Promise<any>
		type$({ tagOrId }): Promise<any>
		itemconfig
	}

	/**
	 * Checkbutton widget which is either in on- or off-state.
	 */

	/**
	 * Construct a checkbutton widget with the parent MASTER.
	 * 
	 *         Valid resource names: activebackground, activeforeground, anchor,
	 *         background, bd, bg, bitmap, borderwidth, command, cursor,
	 *         disabledforeground, fg, font, foreground, height,
	 *         highlightbackground, highlightcolor, highlightthickness, image,
	 *         indicatoron, justify, offvalue, onvalue, padx, pady, relief,
	 *         selectcolor, selectimage, state, takefocus, text, textvariable,
	 *         underline, variable, width, wraplength.
	 */
	function Checkbutton(master?, cnf?): Promise<ICheckbutton>
	function Checkbutton$({ master, cnf }: { master?, cnf?}): Promise<ICheckbutton>
	interface ICheckbutton extends IWidget {

		/**
		 * Put the button in off-state.
		 */
		deselect(): Promise<any>
		deselect$($: {}): Promise<any>

		/**
		 * Flash the button.
		 */
		flash(): Promise<any>
		flash$($: {}): Promise<any>

		/**
		 * Toggle the button and invoke a command if given as resource.
		 */
		invoke(): Promise<any>
		invoke$($: {}): Promise<any>

		/**
		 * Put the button in on-state.
		 */
		select(): Promise<any>
		select$($: {}): Promise<any>

		/**
		 * Toggle the button.
		 */
		toggle(): Promise<any>
		toggle$($: {}): Promise<any>
	}

	/**
	 * Entry widget which allows displaying simple text.
	 */

	/**
	 * Construct an entry widget with the parent MASTER.
	 * 
	 *         Valid resource names: background, bd, bg, borderwidth, cursor,
	 *         exportselection, fg, font, foreground, highlightbackground,
	 *         highlightcolor, highlightthickness, insertbackground,
	 *         insertborderwidth, insertofftime, insertontime, insertwidth,
	 *         invalidcommand, invcmd, justify, relief, selectbackground,
	 *         selectborderwidth, selectforeground, show, state, takefocus,
	 *         textvariable, validate, validatecommand, vcmd, width,
	 *         xscrollcommand.
	 */
	function Entry(master?, cnf?): Promise<IEntry>
	function Entry$({ master, cnf }: { master?, cnf?}): Promise<IEntry>
	interface IEntry extends IWidget, IXView {

		/**
		 * Delete text from FIRST to LAST (not included).
		 */
		delete(first, last?): Promise<any>
		delete$({ first, last }: { first, last?}): Promise<any>

		/**
		 * Return the text.
		 */
		get(): Promise<any>
		get$($: {}): Promise<any>

		/**
		 * Insert cursor at INDEX.
		 */
		icursor(index): Promise<any>
		icursor$({ index }): Promise<any>

		/**
		 * Return position of cursor.
		 */
		index(index): Promise<any>
		index$({ index }): Promise<any>

		/**
		 * Insert STRING at INDEX.
		 */
		insert(index, string): Promise<any>
		insert$({ index, string }): Promise<any>

		/**
		 * Remember the current X, Y coordinates.
		 */
		scan_mark(x): Promise<any>
		scan_mark$({ x }): Promise<any>

		/**
		 * Adjust the view of the canvas to 10 times the
		 *         difference between X and Y and the coordinates given in
		 *         scan_mark.
		 */
		scan_dragto(x): Promise<any>
		scan_dragto$({ x }): Promise<any>

		/**
		 * Adjust the end of the selection near the cursor to INDEX.
		 */
		selection_adjust(index): Promise<any>
		selection_adjust$({ index }): Promise<any>

		/**
		 * Clear the selection if it is in this widget.
		 */
		selection_clear(): Promise<any>
		selection_clear$($: {}): Promise<any>

		/**
		 * Set the fixed end of a selection to INDEX.
		 */
		selection_from(index): Promise<any>
		selection_from$({ index }): Promise<any>

		/**
		 * Return True if there are characters selected in the entry, False
		 *         otherwise.
		 */
		selection_present(): Promise<any>
		selection_present$($: {}): Promise<any>

		/**
		 * Set the selection from START to END (not included).
		 */
		selection_range(start, end): Promise<any>
		selection_range$({ start, end }): Promise<any>

		/**
		 * Set the variable end of a selection to INDEX.
		 */
		selection_to(index): Promise<any>
		selection_to$({ index }): Promise<any>
		select_present
		select_range
	}

	/**
	 * Frame widget which may contain other widgets and can have a 3D border.
	 */

	/**
	 * Construct a frame widget with the parent MASTER.
	 * 
	 *         Valid resource names: background, bd, bg, borderwidth, class,
	 *         colormap, container, cursor, height, highlightbackground,
	 *         highlightcolor, highlightthickness, relief, takefocus, visual, width.
	 */
	function Frame(master?, cnf?): Promise<IFrame>
	function Frame$({ master, cnf }: { master?, cnf?}): Promise<IFrame>
	interface IFrame extends IWidget {
	}

	/**
	 * Label widget which can display text and bitmaps.
	 */

	/**
	 * Construct a label widget with the parent MASTER.
	 * 
	 *         STANDARD OPTIONS
	 * 
	 *             activebackground, activeforeground, anchor,
	 *             background, bitmap, borderwidth, cursor,
	 *             disabledforeground, font, foreground,
	 *             highlightbackground, highlightcolor,
	 *             highlightthickness, image, justify,
	 *             padx, pady, relief, takefocus, text,
	 *             textvariable, underline, wraplength
	 * 
	 *         WIDGET-SPECIFIC OPTIONS
	 * 
	 *             height, state, width
	 * 
	 *         
	 */
	function Label(master?, cnf?): Promise<ILabel>
	function Label$({ master, cnf }: { master?, cnf?}): Promise<ILabel>
	interface ILabel extends IWidget {
	}

	/**
	 * Listbox widget which can display a list of strings.
	 */

	/**
	 * Construct a listbox widget with the parent MASTER.
	 * 
	 *         Valid resource names: background, bd, bg, borderwidth, cursor,
	 *         exportselection, fg, font, foreground, height, highlightbackground,
	 *         highlightcolor, highlightthickness, relief, selectbackground,
	 *         selectborderwidth, selectforeground, selectmode, setgrid, takefocus,
	 *         width, xscrollcommand, yscrollcommand, listvariable.
	 */
	function Listbox(master?, cnf?): Promise<IListbox>
	function Listbox$({ master, cnf }: { master?, cnf?}): Promise<IListbox>
	interface IListbox extends IWidget, IXView, IYView {

		/**
		 * Activate item identified by INDEX.
		 */
		activate(index): Promise<any>
		activate$({ index }): Promise<any>

		/**
		 * Return a tuple of X1,Y1,X2,Y2 coordinates for a rectangle
		 *         which encloses the item identified by the given index.
		 */
		bbox(index): Promise<any>
		bbox$({ index }): Promise<any>

		/**
		 * Return the indices of currently selected item.
		 */
		curselection(): Promise<any>
		curselection$($: {}): Promise<any>

		/**
		 * Delete items from FIRST to LAST (included).
		 */
		delete(first, last?): Promise<any>
		delete$({ first, last }: { first, last?}): Promise<any>

		/**
		 * Get list of items from FIRST to LAST (included).
		 */
		get(first, last?): Promise<any>
		get$({ first, last }: { first, last?}): Promise<any>

		/**
		 * Return index of item identified with INDEX.
		 */
		index(index): Promise<any>
		index$({ index }): Promise<any>

		/**
		 * Insert ELEMENTS at INDEX.
		 */
		insert(index): Promise<any>
		insert$({ index }): Promise<any>

		/**
		 * Get index of item which is nearest to y coordinate Y.
		 */
		nearest(y): Promise<any>
		nearest$({ y }): Promise<any>

		/**
		 * Remember the current X, Y coordinates.
		 */
		scan_mark(x, y): Promise<any>
		scan_mark$({ x, y }): Promise<any>

		/**
		 * Adjust the view of the listbox to 10 times the
		 *         difference between X and Y and the coordinates given in
		 *         scan_mark.
		 */
		scan_dragto(x, y): Promise<any>
		scan_dragto$({ x, y }): Promise<any>

		/**
		 * Scroll such that INDEX is visible.
		 */
		see(index): Promise<any>
		see$({ index }): Promise<any>

		/**
		 * Set the fixed end oft the selection to INDEX.
		 */
		selection_anchor(index): Promise<any>
		selection_anchor$({ index }): Promise<any>

		/**
		 * Clear the selection from FIRST to LAST (included).
		 */
		selection_clear(first, last?): Promise<any>
		selection_clear$({ first, last }: { first, last?}): Promise<any>

		/**
		 * Return True if INDEX is part of the selection.
		 */
		selection_includes(index): Promise<any>
		selection_includes$({ index }): Promise<any>

		/**
		 * Set the selection from FIRST to LAST (included) without
		 *         changing the currently selected elements.
		 */
		selection_set(first, last?): Promise<any>
		selection_set$({ first, last }: { first, last?}): Promise<any>

		/**
		 * Return the number of elements in the listbox.
		 */
		size(): Promise<any>
		size$($: {}): Promise<any>

		/**
		 * Return the resource value for an ITEM and an OPTION.
		 */
		itemcget(index, option): Promise<any>
		itemcget$({ index, option }): Promise<any>

		/**
		 * Configure resources of an ITEM.
		 * 
		 *         The values for resources are specified as keyword arguments.
		 *         To get an overview about the allowed keyword arguments
		 *         call the method without arguments.
		 *         Valid resource names: background, bg, foreground, fg,
		 *         selectbackground, selectforeground.
		 */
		itemconfigure(index, cnf?): Promise<any>
		itemconfigure$({ index, cnf }: { index, cnf?}): Promise<any>
		select_anchor
		select_includes
		select_set
	}

	/**
	 * Menu widget which allows displaying menu bars, pull-down menus and pop-up menus.
	 */

	/**
	 * Construct menu widget with the parent MASTER.
	 * 
	 *         Valid resource names: activebackground, activeborderwidth,
	 *         activeforeground, background, bd, bg, borderwidth, cursor,
	 *         disabledforeground, fg, font, foreground, postcommand, relief,
	 *         selectcolor, takefocus, tearoff, tearoffcommand, title, type.
	 */
	function Menu(master?, cnf?): Promise<IMenu>
	function Menu$({ master, cnf }: { master?, cnf?}): Promise<IMenu>
	interface IMenu extends IWidget {

		/**
		 * Post the menu at position X,Y with entry ENTRY.
		 */
		tk_popup(x, y, entry?): Promise<any>
		tk_popup$({ x, y, entry }: { x, y, entry?}): Promise<any>

		/**
		 * Activate entry at INDEX.
		 */
		activate(index): Promise<any>
		activate$({ index }): Promise<any>

		/**
		 * Internal function.
		 */
		add(itemType, cnf?): Promise<any>
		add$({ itemType, cnf }: { itemType, cnf?}): Promise<any>

		/**
		 * Add hierarchical menu item.
		 */
		add_cascade(cnf?): Promise<any>
		add_cascade$({ cnf }: { cnf?}): Promise<any>

		/**
		 * Add checkbutton menu item.
		 */
		add_checkbutton(cnf?): Promise<any>
		add_checkbutton$({ cnf }: { cnf?}): Promise<any>

		/**
		 * Add command menu item.
		 */
		add_command(cnf?): Promise<any>
		add_command$({ cnf }: { cnf?}): Promise<any>

		/**
		 * Addd radio menu item.
		 */
		add_radiobutton(cnf?): Promise<any>
		add_radiobutton$({ cnf }: { cnf?}): Promise<any>

		/**
		 * Add separator.
		 */
		add_separator(cnf?): Promise<any>
		add_separator$({ cnf }: { cnf?}): Promise<any>

		/**
		 * Internal function.
		 */
		insert(index, itemType, cnf?): Promise<any>
		insert$({ index, itemType, cnf }: { index, itemType, cnf?}): Promise<any>

		/**
		 * Add hierarchical menu item at INDEX.
		 */
		insert_cascade(index, cnf?): Promise<any>
		insert_cascade$({ index, cnf }: { index, cnf?}): Promise<any>

		/**
		 * Add checkbutton menu item at INDEX.
		 */
		insert_checkbutton(index, cnf?): Promise<any>
		insert_checkbutton$({ index, cnf }: { index, cnf?}): Promise<any>

		/**
		 * Add command menu item at INDEX.
		 */
		insert_command(index, cnf?): Promise<any>
		insert_command$({ index, cnf }: { index, cnf?}): Promise<any>

		/**
		 * Addd radio menu item at INDEX.
		 */
		insert_radiobutton(index, cnf?): Promise<any>
		insert_radiobutton$({ index, cnf }: { index, cnf?}): Promise<any>

		/**
		 * Add separator at INDEX.
		 */
		insert_separator(index, cnf?): Promise<any>
		insert_separator$({ index, cnf }: { index, cnf?}): Promise<any>

		/**
		 * Delete menu items between INDEX1 and INDEX2 (included).
		 */
		delete(index1, index2?): Promise<any>
		delete$({ index1, index2 }: { index1, index2?}): Promise<any>

		/**
		 * Return the resource value of a menu item for OPTION at INDEX.
		 */
		entrycget(index, option): Promise<any>
		entrycget$({ index, option }): Promise<any>

		/**
		 * Configure a menu item at INDEX.
		 */
		entryconfigure(index, cnf?): Promise<any>
		entryconfigure$({ index, cnf }: { index, cnf?}): Promise<any>

		/**
		 * Return the index of a menu item identified by INDEX.
		 */
		index(index): Promise<any>
		index$({ index }): Promise<any>

		/**
		 * Invoke a menu item identified by INDEX and execute
		 *         the associated command.
		 */
		invoke(index): Promise<any>
		invoke$({ index }): Promise<any>

		/**
		 * Display a menu at position X,Y.
		 */
		post(x, y): Promise<any>
		post$({ x, y }): Promise<any>

		/**
		 * Return the type of the menu item at INDEX.
		 */
		type(index): Promise<any>
		type$({ index }): Promise<any>

		/**
		 * Unmap a menu.
		 */
		unpost(): Promise<any>
		unpost$($: {}): Promise<any>

		/**
		 * Return the x-position of the leftmost pixel of the menu item
		 *         at INDEX.
		 */
		xposition(index): Promise<any>
		xposition$({ index }): Promise<any>

		/**
		 * Return the y-position of the topmost pixel of the menu item at INDEX.
		 */
		yposition(index): Promise<any>
		yposition$({ index }): Promise<any>
		entryconfig
	}

	/**
	 * Menubutton widget, obsolete since Tk8.0.
	 */
	function Menubutton(master?, cnf?): Promise<IMenubutton>
	function Menubutton$({ master, cnf }: { master?, cnf?}): Promise<IMenubutton>
	interface IMenubutton extends IWidget {
	}

	/**
	 * Message widget to display multiline text. Obsolete since Label does it too.
	 */
	function Message(master?, cnf?): Promise<IMessage>
	function Message$({ master, cnf }: { master?, cnf?}): Promise<IMessage>
	interface IMessage extends IWidget {
	}

	/**
	 * Radiobutton widget which shows only one of several buttons in on-state.
	 */

	/**
	 * Construct a radiobutton widget with the parent MASTER.
	 * 
	 *         Valid resource names: activebackground, activeforeground, anchor,
	 *         background, bd, bg, bitmap, borderwidth, command, cursor,
	 *         disabledforeground, fg, font, foreground, height,
	 *         highlightbackground, highlightcolor, highlightthickness, image,
	 *         indicatoron, justify, padx, pady, relief, selectcolor, selectimage,
	 *         state, takefocus, text, textvariable, underline, value, variable,
	 *         width, wraplength.
	 */
	function Radiobutton(master?, cnf?): Promise<IRadiobutton>
	function Radiobutton$({ master, cnf }: { master?, cnf?}): Promise<IRadiobutton>
	interface IRadiobutton extends IWidget {

		/**
		 * Put the button in off-state.
		 */
		deselect(): Promise<any>
		deselect$($: {}): Promise<any>

		/**
		 * Flash the button.
		 */
		flash(): Promise<any>
		flash$($: {}): Promise<any>

		/**
		 * Toggle the button and invoke a command if given as resource.
		 */
		invoke(): Promise<any>
		invoke$($: {}): Promise<any>

		/**
		 * Put the button in on-state.
		 */
		select(): Promise<any>
		select$($: {}): Promise<any>
	}

	/**
	 * Scale widget which can display a numerical scale.
	 */

	/**
	 * Construct a scale widget with the parent MASTER.
	 * 
	 *         Valid resource names: activebackground, background, bigincrement, bd,
	 *         bg, borderwidth, command, cursor, digits, fg, font, foreground, from,
	 *         highlightbackground, highlightcolor, highlightthickness, label,
	 *         length, orient, relief, repeatdelay, repeatinterval, resolution,
	 *         showvalue, sliderlength, sliderrelief, state, takefocus,
	 *         tickinterval, to, troughcolor, variable, width.
	 */
	function Scale(master?, cnf?): Promise<IScale>
	function Scale$({ master, cnf }: { master?, cnf?}): Promise<IScale>
	interface IScale extends IWidget {

		/**
		 * Get the current value as integer or float.
		 */
		get(): Promise<any>
		get$($: {}): Promise<any>

		/**
		 * Set the value to VALUE.
		 */
		set(value): Promise<any>
		set$({ value }): Promise<any>

		/**
		 * Return a tuple (X,Y) of the point along the centerline of the
		 *         trough that corresponds to VALUE or the current value if None is
		 *         given.
		 */
		coords(value?): Promise<any>
		coords$({ value }: { value?}): Promise<any>

		/**
		 * Return where the point X,Y lies. Valid return values are "slider",
		 *         "though1" and "though2".
		 */
		identify(x, y): Promise<any>
		identify$({ x, y }): Promise<any>
	}

	/**
	 * Scrollbar widget which displays a slider at a certain position.
	 */

	/**
	 * Construct a scrollbar widget with the parent MASTER.
	 * 
	 *         Valid resource names: activebackground, activerelief,
	 *         background, bd, bg, borderwidth, command, cursor,
	 *         elementborderwidth, highlightbackground,
	 *         highlightcolor, highlightthickness, jump, orient,
	 *         relief, repeatdelay, repeatinterval, takefocus,
	 *         troughcolor, width.
	 */
	function Scrollbar(master?, cnf?): Promise<IScrollbar>
	function Scrollbar$({ master, cnf }: { master?, cnf?}): Promise<IScrollbar>
	interface IScrollbar extends IWidget {

		/**
		 * Marks the element indicated by index as active.
		 *         The only index values understood by this method are "arrow1",
		 *         "slider", or "arrow2".  If any other value is specified then no
		 *         element of the scrollbar will be active.  If index is not specified,
		 *         the method returns the name of the element that is currently active,
		 *         or None if no element is active.
		 */
		activate(index?): Promise<any>
		activate$({ index }: { index?}): Promise<any>

		/**
		 * Return the fractional change of the scrollbar setting if it
		 *         would be moved by DELTAX or DELTAY pixels.
		 */
		delta(deltax, deltay): Promise<any>
		delta$({ deltax, deltay }): Promise<any>

		/**
		 * Return the fractional value which corresponds to a slider
		 *         position of X,Y.
		 */
		fraction(x, y): Promise<any>
		fraction$({ x, y }): Promise<any>

		/**
		 * Return the element under position X,Y as one of
		 *         "arrow1","slider","arrow2" or "".
		 */
		identify(x, y): Promise<any>
		identify$({ x, y }): Promise<any>

		/**
		 * Return the current fractional values (upper and lower end)
		 *         of the slider position.
		 */
		get(): Promise<any>
		get$($: {}): Promise<any>

		/**
		 * Set the fractional values of the slider position (upper and
		 *         lower ends as value between 0 and 1).
		 */
		set(first, last): Promise<any>
		set$({ first, last }): Promise<any>
	}

	/**
	 * Text widget which can display text in various forms.
	 */

	/**
	 * Construct a text widget with the parent MASTER.
	 * 
	 *         STANDARD OPTIONS
	 * 
	 *             background, borderwidth, cursor,
	 *             exportselection, font, foreground,
	 *             highlightbackground, highlightcolor,
	 *             highlightthickness, insertbackground,
	 *             insertborderwidth, insertofftime,
	 *             insertontime, insertwidth, padx, pady,
	 *             relief, selectbackground,
	 *             selectborderwidth, selectforeground,
	 *             setgrid, takefocus,
	 *             xscrollcommand, yscrollcommand,
	 * 
	 *         WIDGET-SPECIFIC OPTIONS
	 * 
	 *             autoseparators, height, maxundo,
	 *             spacing1, spacing2, spacing3,
	 *             state, tabs, undo, width, wrap,
	 * 
	 *         
	 */
	function Text(master?, cnf?): Promise<IText>
	function Text$({ master, cnf }: { master?, cnf?}): Promise<IText>
	interface IText extends IWidget, IXView, IYView {

		/**
		 * Return a tuple of (x,y,width,height) which gives the bounding
		 *         box of the visible part of the character at the given index.
		 */
		bbox(index): Promise<any>
		bbox$({ index }): Promise<any>

		/**
		 * Return whether between index INDEX1 and index INDEX2 the
		 *         relation OP is satisfied. OP is one of <, <=, ==, >=, >, or !=.
		 */
		compare(index1, op, index2): Promise<any>
		compare$({ index1, op, index2 }): Promise<any>

		/**
		 * Counts the number of relevant things between the two indices.
		 *         If index1 is after index2, the result will be a negative number
		 *         (and this holds for each of the possible options).
		 * 
		 *         The actual items which are counted depends on the options given by
		 *         args. The result is a list of integers, one for the result of each
		 *         counting option given. Valid counting options are "chars",
		 *         "displaychars", "displayindices", "displaylines", "indices",
		 *         "lines", "xpixels" and "ypixels". There is an additional possible
		 *         option "update", which if given then all subsequent options ensure
		 *         that any possible out of date information is recalculated.
		 */
		count(index1, index2): Promise<any>
		count$({ index1, index2 }): Promise<any>

		/**
		 * Turn on the internal consistency checks of the B-Tree inside the text
		 *         widget according to BOOLEAN.
		 */
		debug(boolean?): Promise<any>
		debug$({ boolean }: { boolean?}): Promise<any>

		/**
		 * Delete the characters between INDEX1 and INDEX2 (not included).
		 */
		delete(index1, index2?): Promise<any>
		delete$({ index1, index2 }: { index1, index2?}): Promise<any>

		/**
		 * Return tuple (x,y,width,height,baseline) giving the bounding box
		 *         and baseline position of the visible part of the line containing
		 *         the character at INDEX.
		 */
		dlineinfo(index): Promise<any>
		dlineinfo$({ index }): Promise<any>

		/**
		 * Return the contents of the widget between index1 and index2.
		 * 
		 *         The type of contents returned in filtered based on the keyword
		 *         parameters; if 'all', 'image', 'mark', 'tag', 'text', or 'window' are
		 *         given and true, then the corresponding items are returned. The result
		 *         is a list of triples of the form (key, value, index). If none of the
		 *         keywords are true then 'all' is used by default.
		 * 
		 *         If the 'command' argument is given, it is called once for each element
		 *         of the list of triples, with the values of each triple serving as the
		 *         arguments to the function. In this case the list is not returned.
		 */
		dump(index1, index2?, command?): Promise<any>
		dump$({ index1, index2, command }: { index1, index2?, command?}): Promise<any>

		/**
		 * Internal method
		 * 
		 *         This method controls the undo mechanism and
		 *         the modified flag. The exact behavior of the
		 *         command depends on the option argument that
		 *         follows the edit argument. The following forms
		 *         of the command are currently supported:
		 * 
		 *         edit_modified, edit_redo, edit_reset, edit_separator
		 *         and edit_undo
		 * 
		 *         
		 */
		edit(): Promise<any>
		edit$($: {}): Promise<any>

		/**
		 * Get or Set the modified flag
		 * 
		 *         If arg is not specified, returns the modified
		 *         flag of the widget. The insert, delete, edit undo and
		 *         edit redo commands or the user can set or clear the
		 *         modified flag. If boolean is specified, sets the
		 *         modified flag of the widget to arg.
		 *         
		 */
		edit_modified(arg?): Promise<any>
		edit_modified$({ arg }: { arg?}): Promise<any>

		/**
		 * Redo the last undone edit
		 * 
		 *         When the undo option is true, reapplies the last
		 *         undone edits provided no other edits were done since
		 *         then. Generates an error when the redo stack is empty.
		 *         Does nothing when the undo option is false.
		 *         
		 */
		edit_redo(): Promise<any>
		edit_redo$($: {}): Promise<any>

		/**
		 * Clears the undo and redo stacks
		 *         
		 */
		edit_reset(): Promise<any>
		edit_reset$($: {}): Promise<any>

		/**
		 * Inserts a separator (boundary) on the undo stack.
		 * 
		 *         Does nothing when the undo option is false
		 *         
		 */
		edit_separator(): Promise<any>
		edit_separator$($: {}): Promise<any>

		/**
		 * Undoes the last edit action
		 * 
		 *         If the undo option is true. An edit action is defined
		 *         as all the insert and delete commands that are recorded
		 *         on the undo stack in between two separators. Generates
		 *         an error when the undo stack is empty. Does nothing
		 *         when the undo option is false
		 *         
		 */
		edit_undo(): Promise<any>
		edit_undo$($: {}): Promise<any>

		/**
		 * Return the text from INDEX1 to INDEX2 (not included).
		 */
		get(index1, index2?): Promise<any>
		get$({ index1, index2 }: { index1, index2?}): Promise<any>

		/**
		 * Return the value of OPTION of an embedded image at INDEX.
		 */
		image_cget(index, option): Promise<any>
		image_cget$({ index, option }): Promise<any>

		/**
		 * Configure an embedded image at INDEX.
		 */
		image_configure(index, cnf?): Promise<any>
		image_configure$({ index, cnf }: { index, cnf?}): Promise<any>

		/**
		 * Create an embedded image at INDEX.
		 */
		image_create(index, cnf?): Promise<any>
		image_create$({ index, cnf }: { index, cnf?}): Promise<any>

		/**
		 * Return all names of embedded images in this widget.
		 */
		image_names(): Promise<any>
		image_names$($: {}): Promise<any>

		/**
		 * Return the index in the form line.char for INDEX.
		 */
		index(index): Promise<any>
		index$({ index }): Promise<any>

		/**
		 * Insert CHARS before the characters at INDEX. An additional
		 *         tag can be given in ARGS. Additional CHARS and tags can follow in ARGS.
		 */
		insert(index, chars): Promise<any>
		insert$({ index, chars }): Promise<any>

		/**
		 * Change the gravity of a mark MARKNAME to DIRECTION (LEFT or RIGHT).
		 *         Return the current value if None is given for DIRECTION.
		 */
		mark_gravity(markName, direction?): Promise<any>
		mark_gravity$({ markName, direction }: { markName, direction?}): Promise<any>

		/**
		 * Return all mark names.
		 */
		mark_names(): Promise<any>
		mark_names$($: {}): Promise<any>

		/**
		 * Set mark MARKNAME before the character at INDEX.
		 */
		mark_set(markName, index): Promise<any>
		mark_set$({ markName, index }): Promise<any>

		/**
		 * Delete all marks in MARKNAMES.
		 */
		mark_unset(): Promise<any>
		mark_unset$($: {}): Promise<any>

		/**
		 * Return the name of the next mark after INDEX.
		 */
		mark_next(index): Promise<any>
		mark_next$({ index }): Promise<any>

		/**
		 * Return the name of the previous mark before INDEX.
		 */
		mark_previous(index): Promise<any>
		mark_previous$({ index }): Promise<any>

		/**
		 * Creates a peer text widget with the given newPathName, and any
		 *         optional standard configuration options. By default the peer will
		 *         have the same start and end line as the parent widget, but
		 *         these can be overridden with the standard configuration options.
		 */
		peer_create(newPathName, cnf?): Promise<any>
		peer_create$({ newPathName, cnf }: { newPathName, cnf?}): Promise<any>

		/**
		 * Returns a list of peers of this widget (this does not include
		 *         the widget itself).
		 */
		peer_names(): Promise<any>
		peer_names$($: {}): Promise<any>

		/**
		 * Replaces the range of characters between index1 and index2 with
		 *         the given characters and tags specified by args.
		 * 
		 *         See the method insert for some more information about args, and the
		 *         method delete for information about the indices.
		 */
		replace(index1, index2, chars): Promise<any>
		replace$({ index1, index2, chars }): Promise<any>

		/**
		 * Remember the current X, Y coordinates.
		 */
		scan_mark(x, y): Promise<any>
		scan_mark$({ x, y }): Promise<any>

		/**
		 * Adjust the view of the text to 10 times the
		 *         difference between X and Y and the coordinates given in
		 *         scan_mark.
		 */
		scan_dragto(x, y): Promise<any>
		scan_dragto$({ x, y }): Promise<any>

		/**
		 * Search PATTERN beginning from INDEX until STOPINDEX.
		 *         Return the index of the first character of a match or an
		 *         empty string.
		 */
		search(pattern, index, stopindex?, forwards?, backwards?, exact?, regexp?, nocase?, count?, elide?): Promise<any>
		search$({ pattern, index, stopindex, forwards, backwards, exact, regexp, nocase, count, elide }: { pattern, index, stopindex?, forwards?, backwards?, exact?, regexp?, nocase?, count?, elide?}): Promise<any>

		/**
		 * Scroll such that the character at INDEX is visible.
		 */
		see(index): Promise<any>
		see$({ index }): Promise<any>

		/**
		 * Add tag TAGNAME to all characters between INDEX1 and index2 in ARGS.
		 *         Additional pairs of indices may follow in ARGS.
		 */
		tag_add(tagName, index1): Promise<any>
		tag_add$({ tagName, index1 }): Promise<any>

		/**
		 * Unbind for all characters with TAGNAME for event SEQUENCE  the
		 *         function identified with FUNCID.
		 */
		tag_unbind(tagName, sequence, funcid?): Promise<any>
		tag_unbind$({ tagName, sequence, funcid }: { tagName, sequence, funcid?}): Promise<any>

		/**
		 * Bind to all characters with TAGNAME at event SEQUENCE a call to function FUNC.
		 * 
		 *         An additional boolean parameter ADD specifies whether FUNC will be
		 *         called additionally to the other bound function or whether it will
		 *         replace the previous function. See bind for the return value.
		 */
		tag_bind(tagName, sequence, func, add?): Promise<any>
		tag_bind$({ tagName, sequence, func, add }: { tagName, sequence, func, add?}): Promise<any>

		/**
		 * Return the value of OPTION for tag TAGNAME.
		 */
		tag_cget(tagName, option): Promise<any>
		tag_cget$({ tagName, option }): Promise<any>

		/**
		 * Configure a tag TAGNAME.
		 */
		tag_configure(tagName, cnf?): Promise<any>
		tag_configure$({ tagName, cnf }: { tagName, cnf?}): Promise<any>

		/**
		 * Delete all tags in TAGNAMES.
		 */
		tag_delete(): Promise<any>
		tag_delete$($: {}): Promise<any>

		/**
		 * Change the priority of tag TAGNAME such that it is lower
		 *         than the priority of BELOWTHIS.
		 */
		tag_lower(tagName, belowThis?): Promise<any>
		tag_lower$({ tagName, belowThis }: { tagName, belowThis?}): Promise<any>

		/**
		 * Return a list of all tag names.
		 */
		tag_names(index?): Promise<any>
		tag_names$({ index }: { index?}): Promise<any>

		/**
		 * Return a list of start and end index for the first sequence of
		 *         characters between INDEX1 and INDEX2 which all have tag TAGNAME.
		 *         The text is searched forward from INDEX1.
		 */
		tag_nextrange(tagName, index1, index2?): Promise<any>
		tag_nextrange$({ tagName, index1, index2 }: { tagName, index1, index2?}): Promise<any>

		/**
		 * Return a list of start and end index for the first sequence of
		 *         characters between INDEX1 and INDEX2 which all have tag TAGNAME.
		 *         The text is searched backwards from INDEX1.
		 */
		tag_prevrange(tagName, index1, index2?): Promise<any>
		tag_prevrange$({ tagName, index1, index2 }: { tagName, index1, index2?}): Promise<any>

		/**
		 * Change the priority of tag TAGNAME such that it is higher
		 *         than the priority of ABOVETHIS.
		 */
		tag_raise(tagName, aboveThis?): Promise<any>
		tag_raise$({ tagName, aboveThis }: { tagName, aboveThis?}): Promise<any>

		/**
		 * Return a list of ranges of text which have tag TAGNAME.
		 */
		tag_ranges(tagName): Promise<any>
		tag_ranges$({ tagName }): Promise<any>

		/**
		 * Remove tag TAGNAME from all characters between INDEX1 and INDEX2.
		 */
		tag_remove(tagName, index1, index2?): Promise<any>
		tag_remove$({ tagName, index1, index2 }: { tagName, index1, index2?}): Promise<any>

		/**
		 * Return the value of OPTION of an embedded window at INDEX.
		 */
		window_cget(index, option): Promise<any>
		window_cget$({ index, option }): Promise<any>

		/**
		 * Configure an embedded window at INDEX.
		 */
		window_configure(index, cnf?): Promise<any>
		window_configure$({ index, cnf }: { index, cnf?}): Promise<any>

		/**
		 * Create a window at INDEX.
		 */
		window_create(index, cnf?): Promise<any>
		window_create$({ index, cnf }: { index, cnf?}): Promise<any>

		/**
		 * Return all names of embedded windows in this widget.
		 */
		window_names(): Promise<any>
		window_names$($: {}): Promise<any>

		/**
		 * Obsolete function, use see.
		 */
		yview_pickplace(): Promise<any>
		yview_pickplace$($: {}): Promise<any>
		tag_config
		window_config
	}

	/**
	 * Internal class. It wraps the command in the widget OptionMenu.
	 */
	interface I_setit {
	}

	/**
	 * OptionMenu which allows the user to select a value from a menu.
	 */

	/**
	 * Construct an optionmenu widget with the parent MASTER, with
	 *         the resource textvariable set to VARIABLE, the initially selected
	 *         value VALUE, the other menu values VALUES and an additional
	 *         keyword argument command.
	 */
	function OptionMenu(master, variable, value): Promise<IOptionMenu>
	function OptionMenu$({ master, variable, value }): Promise<IOptionMenu>
	interface IOptionMenu extends IMenubutton {

		/**
		 * Destroy this widget and the associated menu.
		 */
		destroy(): Promise<any>
		destroy$($: {}): Promise<any>
	}

	/**
	 * Base class for images.
	 */
	function Image(imgtype, name?, cnf?, master?): Promise<IImage>
	function Image$({ imgtype, name, cnf, master }: { imgtype, name?, cnf?, master?}): Promise<IImage>
	interface IImage {

		/**
		 * Configure the image.
		 */
		configure(): Promise<any>
		configure$($: {}): Promise<any>

		/**
		 * Return the height of the image.
		 */
		height(): Promise<any>
		height$($: {}): Promise<any>

		/**
		 * Return the type of the image, e.g. "photo" or "bitmap".
		 */
		type(): Promise<any>
		type$($: {}): Promise<any>

		/**
		 * Return the width of the image.
		 */
		width(): Promise<any>
		width$($: {}): Promise<any>
	}

	/**
	 * Widget which can display images in PGM, PPM, GIF, PNG format.
	 */

	/**
	 * Create an image with NAME.
	 * 
	 *         Valid resource names: data, format, file, gamma, height, palette,
	 *         width.
	 */
	function PhotoImage(name?, cnf?, master?): Promise<IPhotoImage>
	function PhotoImage$({ name, cnf, master }: { name?, cnf?, master?}): Promise<IPhotoImage>
	interface IPhotoImage extends IImage {

		/**
		 * Display a transparent image.
		 */
		blank(): Promise<any>
		blank$($: {}): Promise<any>

		/**
		 * Return the value of OPTION.
		 */
		cget(option): Promise<any>
		cget$({ option }): Promise<any>

		/**
		 * Return a new PhotoImage with the same image as this widget.
		 */
		copy(): Promise<any>
		copy$($: {}): Promise<any>

		/**
		 * Return a new PhotoImage with the same image as this widget
		 *         but zoom it with a factor of x in the X direction and y in the Y
		 *         direction.  If y is not given, the default value is the same as x.
		 *         
		 */
		zoom(x, y?): Promise<any>
		zoom$({ x, y }: { x, y?}): Promise<any>

		/**
		 * Return a new PhotoImage based on the same image as this widget
		 *         but use only every Xth or Yth pixel.  If y is not given, the
		 *         default value is the same as x.
		 *         
		 */
		subsample(x, y?): Promise<any>
		subsample$({ x, y }: { x, y?}): Promise<any>

		/**
		 * Return the color (red, green, blue) of the pixel at X,Y.
		 */
		get(x, y): Promise<any>
		get$({ x, y }): Promise<any>

		/**
		 * Put row formatted colors to image starting from
		 *         position TO, e.g. image.put("{red green} {blue yellow}", to=(4,6))
		 */
		put(data, to?): Promise<any>
		put$({ data, to }: { data, to?}): Promise<any>

		/**
		 * Write image to file FILENAME in FORMAT starting from
		 *         position FROM_COORDS.
		 */
		write(filename, format?, from_coords?): Promise<any>
		write$({ filename, format, from_coords }: { filename, format?, from_coords?}): Promise<any>

		/**
		 * Return True if the pixel at x,y is transparent.
		 */
		transparency_get(x, y): Promise<any>
		transparency_get$({ x, y }): Promise<any>

		/**
		 * Set the transparency of the pixel at x,y.
		 */
		transparency_set(x, y, boolean): Promise<any>
		transparency_set$({ x, y, boolean }): Promise<any>
	}

	/**
	 * Widget which can display images in XBM format.
	 */

	/**
	 * Create a bitmap with NAME.
	 * 
	 *         Valid resource names: background, data, file, foreground, maskdata, maskfile.
	 */
	function BitmapImage(name?, cnf?, master?): Promise<IBitmapImage>
	function BitmapImage$({ name, cnf, master }: { name?, cnf?, master?}): Promise<IBitmapImage>
	interface IBitmapImage extends IImage {
	}

	/**
	 * spinbox widget.
	 */

	/**
	 * Construct a spinbox widget with the parent MASTER.
	 * 
	 *         STANDARD OPTIONS
	 * 
	 *             activebackground, background, borderwidth,
	 *             cursor, exportselection, font, foreground,
	 *             highlightbackground, highlightcolor,
	 *             highlightthickness, insertbackground,
	 *             insertborderwidth, insertofftime,
	 *             insertontime, insertwidth, justify, relief,
	 *             repeatdelay, repeatinterval,
	 *             selectbackground, selectborderwidth
	 *             selectforeground, takefocus, textvariable
	 *             xscrollcommand.
	 * 
	 *         WIDGET-SPECIFIC OPTIONS
	 * 
	 *             buttonbackground, buttoncursor,
	 *             buttondownrelief, buttonuprelief,
	 *             command, disabledbackground,
	 *             disabledforeground, format, from,
	 *             invalidcommand, increment,
	 *             readonlybackground, state, to,
	 *             validate, validatecommand values,
	 *             width, wrap,
	 *         
	 */
	function Spinbox(master?, cnf?): Promise<ISpinbox>
	function Spinbox$({ master, cnf }: { master?, cnf?}): Promise<ISpinbox>
	interface ISpinbox extends IWidget, IXView {

		/**
		 * Return a tuple of X1,Y1,X2,Y2 coordinates for a
		 *         rectangle which encloses the character given by index.
		 * 
		 *         The first two elements of the list give the x and y
		 *         coordinates of the upper-left corner of the screen
		 *         area covered by the character (in pixels relative
		 *         to the widget) and the last two elements give the
		 *         width and height of the character, in pixels. The
		 *         bounding box may refer to a region outside the
		 *         visible area of the window.
		 *         
		 */
		bbox(index): Promise<any>
		bbox$({ index }): Promise<any>

		/**
		 * Delete one or more elements of the spinbox.
		 * 
		 *         First is the index of the first character to delete,
		 *         and last is the index of the character just after
		 *         the last one to delete. If last isn't specified it
		 *         defaults to first+1, i.e. a single character is
		 *         deleted.  This command returns an empty string.
		 *         
		 */
		delete(first, last?): Promise<any>
		delete$({ first, last }: { first, last?}): Promise<any>

		/**
		 * Returns the spinbox's string
		 */
		get(): Promise<any>
		get$($: {}): Promise<any>

		/**
		 * Alter the position of the insertion cursor.
		 * 
		 *         The insertion cursor will be displayed just before
		 *         the character given by index. Returns an empty string
		 *         
		 */
		icursor(index): Promise<any>
		icursor$({ index }): Promise<any>

		/**
		 * Returns the name of the widget at position x, y
		 * 
		 *         Return value is one of: none, buttondown, buttonup, entry
		 *         
		 */
		identify(x, y): Promise<any>
		identify$({ x, y }): Promise<any>

		/**
		 * Returns the numerical index corresponding to index
		 *         
		 */
		index(index): Promise<any>
		index$({ index }): Promise<any>

		/**
		 * Insert string s at index
		 * 
		 *          Returns an empty string.
		 *         
		 */
		insert(index, s): Promise<any>
		insert$({ index, s }): Promise<any>

		/**
		 * Causes the specified element to be invoked
		 * 
		 *         The element could be buttondown or buttonup
		 *         triggering the action associated with it.
		 *         
		 */
		invoke(element): Promise<any>
		invoke$({ element }): Promise<any>

		/**
		 * Internal function.
		 */
		scan(): Promise<any>
		scan$($: {}): Promise<any>

		/**
		 * Records x and the current view in the spinbox window;
		 * 
		 *         used in conjunction with later scan dragto commands.
		 *         Typically this command is associated with a mouse button
		 *         press in the widget. It returns an empty string.
		 *         
		 */
		scan_mark(x): Promise<any>
		scan_mark$({ x }): Promise<any>

		/**
		 * Compute the difference between the given x argument
		 *         and the x argument to the last scan mark command
		 * 
		 *         It then adjusts the view left or right by 10 times the
		 *         difference in x-coordinates. This command is typically
		 *         associated with mouse motion events in the widget, to
		 *         produce the effect of dragging the spinbox at high speed
		 *         through the window. The return value is an empty string.
		 *         
		 */
		scan_dragto(x): Promise<any>
		scan_dragto$({ x }): Promise<any>

		/**
		 * Internal function.
		 */
		selection(): Promise<any>
		selection$($: {}): Promise<any>

		/**
		 * Locate the end of the selection nearest to the character
		 *         given by index,
		 * 
		 *         Then adjust that end of the selection to be at index
		 *         (i.e including but not going beyond index). The other
		 *         end of the selection is made the anchor point for future
		 *         select to commands. If the selection isn't currently in
		 *         the spinbox, then a new selection is created to include
		 *         the characters between index and the most recent selection
		 *         anchor point, inclusive.
		 *         
		 */
		selection_adjust(index): Promise<any>
		selection_adjust$({ index }): Promise<any>

		/**
		 * Clear the selection
		 * 
		 *         If the selection isn't in this widget then the
		 *         command has no effect.
		 *         
		 */
		selection_clear(): Promise<any>
		selection_clear$($: {}): Promise<any>

		/**
		 * Sets or gets the currently selected element.
		 * 
		 *         If a spinbutton element is specified, it will be
		 *         displayed depressed.
		 *         
		 */
		selection_element(element?): Promise<any>
		selection_element$({ element }: { element?}): Promise<any>

		/**
		 * Set the fixed end of a selection to INDEX.
		 */
		selection_from(index): Promise<any>
		selection_from$({ index }): Promise<any>

		/**
		 * Return True if there are characters selected in the spinbox, False
		 *         otherwise.
		 */
		selection_present(): Promise<any>
		selection_present$($: {}): Promise<any>

		/**
		 * Set the selection from START to END (not included).
		 */
		selection_range(start, end): Promise<any>
		selection_range$({ start, end }): Promise<any>

		/**
		 * Set the variable end of a selection to INDEX.
		 */
		selection_to(index): Promise<any>
		selection_to$({ index }): Promise<any>
	}

	/**
	 * labelframe widget.
	 */

	/**
	 * Construct a labelframe widget with the parent MASTER.
	 * 
	 *         STANDARD OPTIONS
	 * 
	 *             borderwidth, cursor, font, foreground,
	 *             highlightbackground, highlightcolor,
	 *             highlightthickness, padx, pady, relief,
	 *             takefocus, text
	 * 
	 *         WIDGET-SPECIFIC OPTIONS
	 * 
	 *             background, class, colormap, container,
	 *             height, labelanchor, labelwidget,
	 *             visual, width
	 *         
	 */
	function LabelFrame(master?, cnf?): Promise<ILabelFrame>
	function LabelFrame$({ master, cnf }: { master?, cnf?}): Promise<ILabelFrame>
	interface ILabelFrame extends IWidget {
	}

	/**
	 * panedwindow widget.
	 */

	/**
	 * Construct a panedwindow widget with the parent MASTER.
	 * 
	 *         STANDARD OPTIONS
	 * 
	 *             background, borderwidth, cursor, height,
	 *             orient, relief, width
	 * 
	 *         WIDGET-SPECIFIC OPTIONS
	 * 
	 *             handlepad, handlesize, opaqueresize,
	 *             sashcursor, sashpad, sashrelief,
	 *             sashwidth, showhandle,
	 *         
	 */
	function PanedWindow(master?, cnf?): Promise<IPanedWindow>
	function PanedWindow$({ master, cnf }: { master?, cnf?}): Promise<IPanedWindow>
	interface IPanedWindow extends IWidget {

		/**
		 * Add a child widget to the panedwindow in a new pane.
		 * 
		 *         The child argument is the name of the child widget
		 *         followed by pairs of arguments that specify how to
		 *         manage the windows. The possible options and values
		 *         are the ones accepted by the paneconfigure method.
		 *         
		 */
		add(child): Promise<any>
		add$({ child }): Promise<any>

		/**
		 * Remove the pane containing child from the panedwindow
		 * 
		 *         All geometry management options for child will be forgotten.
		 *         
		 */
		remove(child): Promise<any>
		remove$({ child }): Promise<any>

		/**
		 * Identify the panedwindow component at point x, y
		 * 
		 *         If the point is over a sash or a sash handle, the result
		 *         is a two element list containing the index of the sash or
		 *         handle, and a word indicating whether it is over a sash
		 *         or a handle, such as {0 sash} or {2 handle}. If the point
		 *         is over any other part of the panedwindow, the result is
		 *         an empty list.
		 *         
		 */
		identify(x, y): Promise<any>
		identify$({ x, y }): Promise<any>

		/**
		 * Internal function.
		 */
		proxy(): Promise<any>
		proxy$($: {}): Promise<any>

		/**
		 * Return the x and y pair of the most recent proxy location
		 *         
		 */
		proxy_coord(): Promise<any>
		proxy_coord$($: {}): Promise<any>

		/**
		 * Remove the proxy from the display.
		 *         
		 */
		proxy_forget(): Promise<any>
		proxy_forget$($: {}): Promise<any>

		/**
		 * Place the proxy at the given x and y coordinates.
		 *         
		 */
		proxy_place(x, y): Promise<any>
		proxy_place$({ x, y }): Promise<any>

		/**
		 * Internal function.
		 */
		sash(): Promise<any>
		sash$($: {}): Promise<any>

		/**
		 * Return the current x and y pair for the sash given by index.
		 * 
		 *         Index must be an integer between 0 and 1 less than the
		 *         number of panes in the panedwindow. The coordinates given are
		 *         those of the top left corner of the region containing the sash.
		 *         pathName sash dragto index x y This command computes the
		 *         difference between the given coordinates and the coordinates
		 *         given to the last sash coord command for the given sash. It then
		 *         moves that sash the computed difference. The return value is the
		 *         empty string.
		 *         
		 */
		sash_coord(index): Promise<any>
		sash_coord$({ index }): Promise<any>

		/**
		 * Records x and y for the sash given by index;
		 * 
		 *         Used in conjunction with later dragto commands to move the sash.
		 *         
		 */
		sash_mark(index): Promise<any>
		sash_mark$({ index }): Promise<any>

		/**
		 * Place the sash given by index at the given coordinates
		 *         
		 */
		sash_place(index, x, y): Promise<any>
		sash_place$({ index, x, y }): Promise<any>

		/**
		 * Query a management option for window.
		 * 
		 *         Option may be any value allowed by the paneconfigure subcommand
		 *         
		 */
		panecget(child, option): Promise<any>
		panecget$({ child, option }): Promise<any>

		/**
		 * Query or modify the management options for window.
		 * 
		 *         If no option is specified, returns a list describing all
		 *         of the available options for pathName.  If option is
		 *         specified with no value, then the command returns a list
		 *         describing the one named option (this list will be identical
		 *         to the corresponding sublist of the value returned if no
		 *         option is specified). If one or more option-value pairs are
		 *         specified, then the command modifies the given widget
		 *         option(s) to have the given value(s); in this case the
		 *         command returns an empty string. The following options
		 *         are supported:
		 * 
		 *         after window
		 *             Insert the window after the window specified. window
		 *             should be the name of a window already managed by pathName.
		 *         before window
		 *             Insert the window before the window specified. window
		 *             should be the name of a window already managed by pathName.
		 *         height size
		 *             Specify a height for the window. The height will be the
		 *             outer dimension of the window including its border, if
		 *             any. If size is an empty string, or if -height is not
		 *             specified, then the height requested internally by the
		 *             window will be used initially; the height may later be
		 *             adjusted by the movement of sashes in the panedwindow.
		 *             Size may be any value accepted by Tk_GetPixels.
		 *         minsize n
		 *             Specifies that the size of the window cannot be made
		 *             less than n. This constraint only affects the size of
		 *             the widget in the paned dimension -- the x dimension
		 *             for horizontal panedwindows, the y dimension for
		 *             vertical panedwindows. May be any value accepted by
		 *             Tk_GetPixels.
		 *         padx n
		 *             Specifies a non-negative value indicating how much
		 *             extra space to leave on each side of the window in
		 *             the X-direction. The value may have any of the forms
		 *             accepted by Tk_GetPixels.
		 *         pady n
		 *             Specifies a non-negative value indicating how much
		 *             extra space to leave on each side of the window in
		 *             the Y-direction. The value may have any of the forms
		 *             accepted by Tk_GetPixels.
		 *         sticky style
		 *             If a window's pane is larger than the requested
		 *             dimensions of the window, this option may be used
		 *             to position (or stretch) the window within its pane.
		 *             Style is a string that contains zero or more of the
		 *             characters n, s, e or w. The string can optionally
		 *             contains spaces or commas, but they are ignored. Each
		 *             letter refers to a side (north, south, east, or west)
		 *             that the window will "stick" to. If both n and s
		 *             (or e and w) are specified, the window will be
		 *             stretched to fill the entire height (or width) of
		 *             its cavity.
		 *         width size
		 *             Specify a width for the window. The width will be
		 *             the outer dimension of the window including its
		 *             border, if any. If size is an empty string, or
		 *             if -width is not specified, then the width requested
		 *             internally by the window will be used initially; the
		 *             width may later be adjusted by the movement of sashes
		 *             in the panedwindow. Size may be any value accepted by
		 *             Tk_GetPixels.
		 * 
		 *         
		 */
		paneconfigure(tagOrId, cnf?): Promise<any>
		paneconfigure$({ tagOrId, cnf }: { tagOrId, cnf?}): Promise<any>

		/**
		 * Returns an ordered list of the child panes.
		 */
		panes(): Promise<any>
		panes$($: {}): Promise<any>
		paneconfig
	}
	let TclError: Promise<any>
	let wantobjects: Promise<any>
	let TkVersion: Promise<any>
	let TclVersion: Promise<any>
	let READABLE: Promise<any>
	let WRITABLE: Promise<any>
	let EXCEPTION: Promise<any>
	module __main__ {
		var _
	}
	module colorchooser {
		var _

		/**
		 * Display dialog window for selection of a color.
		 * 
		 *     Convenience wrapper for the Chooser class.  Displays the color
		 *     chooser dialog with color as the initial value.
		 *     
		 */
		function askcolor(color?): Promise<any>
		function askcolor$({ color }: { color?}): Promise<any>

		/**
		 * Create a dialog for the tk_chooseColor command.
		 * 
		 *     Args:
		 *         master: The master widget for this dialog.  If not provided,
		 *             defaults to options['parent'] (if defined).
		 *         options: Dictionary of options for the tk_chooseColor call.
		 *             initialcolor: Specifies the selected color when the
		 *                 dialog is first displayed.  This can be a tk color
		 *                 string or a 3-tuple of ints in the range (0, 255)
		 *                 for an RGB triplet.
		 *             parent: The parent window of the color dialog.  The
		 *                 color dialog is displayed on top of this.
		 *             title: A string for the title of the dialog box.
		 *     
		 */
		interface IChooser {
			command
		}
	}
	module commondialog {
		var _
		function Dialog(master?): Promise<IDialog>
		function Dialog$({ master }: { master?}): Promise<IDialog>
		interface IDialog {
			show(): Promise<any>
			show$($: {}): Promise<any>
			command
		}
	}
	module constants {
		var _
		let NO: Promise<any>
		let FALSE: Promise<any>
		let OFF: Promise<any>
		let YES: Promise<any>
		let TRUE: Promise<any>
		let ON: Promise<any>
		let N: Promise<any>
		let S: Promise<any>
		let W: Promise<any>
		let E: Promise<any>
		let NW: Promise<any>
		let SW: Promise<any>
		let NE: Promise<any>
		let SE: Promise<any>
		let NS: Promise<any>
		let EW: Promise<any>
		let NSEW: Promise<any>
		let CENTER: Promise<any>
		let NONE: Promise<any>
		let X: Promise<any>
		let Y: Promise<any>
		let BOTH: Promise<any>
		let LEFT: Promise<any>
		let TOP: Promise<any>
		let RIGHT: Promise<any>
		let BOTTOM: Promise<any>
		let RAISED: Promise<any>
		let SUNKEN: Promise<any>
		let FLAT: Promise<any>
		let RIDGE: Promise<any>
		let GROOVE: Promise<any>
		let SOLID: Promise<any>
		let HORIZONTAL: Promise<any>
		let VERTICAL: Promise<any>
		let NUMERIC: Promise<any>
		let CHAR: Promise<any>
		let WORD: Promise<any>
		let BASELINE: Promise<any>
		let INSIDE: Promise<any>
		let OUTSIDE: Promise<any>
		let SEL: Promise<any>
		let SEL_FIRST: Promise<any>
		let SEL_LAST: Promise<any>
		let END: Promise<any>
		let INSERT: Promise<any>
		let CURRENT: Promise<any>
		let ANCHOR: Promise<any>
		let ALL: Promise<any>
		let NORMAL: Promise<any>
		let DISABLED: Promise<any>
		let ACTIVE: Promise<any>
		let HIDDEN: Promise<any>
		let CASCADE: Promise<any>
		let CHECKBUTTON: Promise<any>
		let COMMAND: Promise<any>
		let RADIOBUTTON: Promise<any>
		let SEPARATOR: Promise<any>
		let SINGLE: Promise<any>
		let BROWSE: Promise<any>
		let MULTIPLE: Promise<any>
		let EXTENDED: Promise<any>
		let DOTBOX: Promise<any>
		let UNDERLINE: Promise<any>
		let PIESLICE: Promise<any>
		let CHORD: Promise<any>
		let ARC: Promise<any>
		let FIRST: Promise<any>
		let LAST: Promise<any>
		let BUTT: Promise<any>
		let PROJECTING: Promise<any>
		let ROUND: Promise<any>
		let BEVEL: Promise<any>
		let MITER: Promise<any>
		let MOVETO: Promise<any>
		let SCROLL: Promise<any>
		let UNITS: Promise<any>
		let PAGES: Promise<any>
	}
	module dialog {
		var _
		function Dialog(master?, cnf?): Promise<IDialog>
		function Dialog$({ master, cnf }: { master?, cnf?}): Promise<IDialog>
		interface IDialog {
			destroy(): Promise<any>
			destroy$($: {}): Promise<any>
		}
		let DIALOG_ICON: Promise<any>
		let t: Promise<any>
		let q: Promise<any>
	}
	module dnd {
		var _
		function dnd_start(source, event): Promise<any>
		function dnd_start$({ source, event }): Promise<any>
		function test(): Promise<any>
		function test$($: {}): Promise<any>
		function DndHandler(source, event): Promise<IDndHandler>
		function DndHandler$({ source, event }): Promise<IDndHandler>
		interface IDndHandler {
			on_motion(event): Promise<any>
			on_motion$({ event }): Promise<any>
			on_release(event): Promise<any>
			on_release$({ event }): Promise<any>
			cancel(event?): Promise<any>
			cancel$({ event }: { event?}): Promise<any>
			finish(event, commit?): Promise<any>
			finish$({ event, commit }: { event, commit?}): Promise<any>
			root
		}
		function Icon(name): Promise<IIcon>
		function Icon$({ name }): Promise<IIcon>
		interface IIcon {
			attach(canvas, x?, y?): Promise<any>
			attach$({ canvas, x, y }: { canvas, x?, y?}): Promise<any>
			detach(): Promise<any>
			detach$($: {}): Promise<any>
			press(event): Promise<any>
			press$({ event }): Promise<any>
			move(event): Promise<any>
			move$({ event }): Promise<any>
			putback(): Promise<any>
			putback$($: {}): Promise<any>
			where(canvas, event): Promise<any>
			where$({ canvas, event }): Promise<any>
			dnd_end(target, event): Promise<any>
			dnd_end$({ target, event }): Promise<any>
		}
		function Tester(root): Promise<ITester>
		function Tester$({ root }): Promise<ITester>
		interface ITester {
			dnd_accept(source, event): Promise<any>
			dnd_accept$({ source, event }): Promise<any>
			dnd_enter(source, event): Promise<any>
			dnd_enter$({ source, event }): Promise<any>
			dnd_motion(source, event): Promise<any>
			dnd_motion$({ source, event }): Promise<any>
			dnd_leave(source, event): Promise<any>
			dnd_leave$({ source, event }): Promise<any>
			dnd_commit(source, event): Promise<any>
			dnd_commit$({ source, event }): Promise<any>
		}
	}
	module filedialog {
		var _

		/**
		 * Ask for a filename to open
		 */
		function askopenfilename(): Promise<any>
		function askopenfilename$($: {}): Promise<any>

		/**
		 * Ask for a filename to save as
		 */
		function asksaveasfilename(): Promise<any>
		function asksaveasfilename$($: {}): Promise<any>

		/**
		 * Ask for multiple filenames to open
		 * 
		 *     Returns a list of filenames or empty list if
		 *     cancel button selected
		 *     
		 */
		function askopenfilenames(): Promise<any>
		function askopenfilenames$($: {}): Promise<any>

		/**
		 * Ask for a filename to open, and returned the opened file
		 */
		function askopenfile(mode?): Promise<any>
		function askopenfile$({ mode }: { mode?}): Promise<any>

		/**
		 * Ask for multiple filenames and return the open file
		 *     objects
		 * 
		 *     returns a list of open file objects or an empty list if
		 *     cancel selected
		 *     
		 */
		function askopenfiles(mode?): Promise<any>
		function askopenfiles$({ mode }: { mode?}): Promise<any>

		/**
		 * Ask for a filename to save as, and returned the opened file
		 */
		function asksaveasfile(mode?): Promise<any>
		function asksaveasfile$({ mode }: { mode?}): Promise<any>

		/**
		 * Ask for a directory, and return the file name
		 */
		function askdirectory(): Promise<any>
		function askdirectory$($: {}): Promise<any>

		/**
		 * Simple test program.
		 */
		function test(): Promise<any>
		function test$($: {}): Promise<any>

		/**
		 * Standard file selection dialog -- no checks on selected file.
		 * 
		 *     Usage:
		 * 
		 *         d = FileDialog(master)
		 *         fname = d.go(dir_or_file, pattern, default, key)
		 *         if fname is None: ...canceled...
		 *         else: ...open file...
		 * 
		 *     All arguments to go() are optional.
		 * 
		 *     The 'key' argument specifies a key in the global dictionary
		 *     'dialogstates', which keeps track of the values for the directory
		 *     and pattern arguments, overriding the values passed in (it does
		 *     not keep track of the default argument!).  If no key is specified,
		 *     the dialog keeps no memory of previous state.  Note that memory is
		 *     kept even when the dialog is canceled.  (All this emulates the
		 *     behavior of the Macintosh file selection dialogs.)
		 * 
		 *     
		 */
		function FileDialog(master, title?): Promise<IFileDialog>
		function FileDialog$({ master, title }: { master, title?}): Promise<IFileDialog>
		interface IFileDialog {
			go(dir_or_file?, pattern?, def?, key?): Promise<any>
			go$({ dir_or_file, pattern, def, key }: { dir_or_file?, pattern?, def?, key?}): Promise<any>
			quit(how?): Promise<any>
			quit$({ how }: { how?}): Promise<any>
			dirs_double_event(event): Promise<any>
			dirs_double_event$({ event }): Promise<any>
			dirs_select_event(event): Promise<any>
			dirs_select_event$({ event }): Promise<any>
			files_double_event(event): Promise<any>
			files_double_event$({ event }): Promise<any>
			files_select_event(event): Promise<any>
			files_select_event$({ event }): Promise<any>
			ok_event(event): Promise<any>
			ok_event$({ event }): Promise<any>
			ok_command(): Promise<any>
			ok_command$($: {}): Promise<any>
			filter_command(event?): Promise<any>
			filter_command$({ event }: { event?}): Promise<any>
			get_filter(): Promise<any>
			get_filter$($: {}): Promise<any>
			get_selection(): Promise<any>
			get_selection$($: {}): Promise<any>
			cancel_command(event?): Promise<any>
			cancel_command$({ event }: { event?}): Promise<any>
			set_filter(dir, pat): Promise<any>
			set_filter$({ dir, pat }): Promise<any>
			set_selection(file): Promise<any>
			set_selection$({ file }): Promise<any>
			title
		}

		/**
		 * File selection dialog which checks that the file exists.
		 */
		interface ILoadFileDialog extends IFileDialog {
			ok_command(): Promise<any>
			ok_command$($: {}): Promise<any>
		}

		/**
		 * File selection dialog which checks that the file may be created.
		 */
		interface ISaveFileDialog extends IFileDialog {
			ok_command(): Promise<any>
			ok_command$($: {}): Promise<any>
		}
		interface I_Dialog {
		}

		/**
		 * Ask for a filename to open
		 */
		interface IOpen extends I_Dialog {
			command
		}

		/**
		 * Ask for a filename to save as
		 */
		interface ISaveAs extends I_Dialog {
		}

		/**
		 * Ask for a directory
		 */
		interface IDirectory {
		}
		let dialogstates: Promise<any>
	}
	module font {
		var _

		/**
		 * Given the name of a tk named font, returns a Font representation.
		 *     
		 */
		function nametofont(name, root?): Promise<any>
		function nametofont$({ name, root }: { name, root?}): Promise<any>

		/**
		 * Get font families (as a tuple)
		 */
		function families(root?, displayof?): Promise<any>
		function families$({ root, displayof }: { root?, displayof?}): Promise<any>

		/**
		 * Get names of defined fonts (as a tuple)
		 */
		function names(root?): Promise<any>
		function names$({ root }: { root?}): Promise<any>

		/**
		 * Represents a named font.
		 * 
		 *     Constructor options are:
		 * 
		 *     font -- font specifier (name, system font, or (family, size, style)-tuple)
		 *     name -- name to use for this font configuration (defaults to a unique name)
		 *     exists -- does a named font by this name already exist?
		 *        Creates a new named font if False, points to the existing font if True.
		 *        Raises _tkinter.TclError if the assertion is false.
		 * 
		 *        the following are ignored if font is specified:
		 * 
		 *     family -- font 'family', e.g. Courier, Times, Helvetica
		 *     size -- font size in points
		 *     weight -- font thickness: NORMAL, BOLD
		 *     slant -- font slant: ROMAN, ITALIC
		 *     underline -- font underlining: false (0), true (1)
		 *     overstrike -- font strikeout: false (0), true (1)
		 * 
		 *     
		 */
		function Font(root?, font?, name?, exists?: boolean): Promise<IFont>
		function Font$({ root, font, name, exists }: { root?, font?, name?, exists?}): Promise<IFont>
		interface IFont {

			/**
			 * Return a distinct copy of the current font
			 */
			copy(): Promise<any>
			copy$($: {}): Promise<any>

			/**
			 * Return actual font attributes
			 */
			actual(option?, displayof?): Promise<any>
			actual$({ option, displayof }: { option?, displayof?}): Promise<any>

			/**
			 * Get font attribute
			 */
			cget(option): Promise<any>
			cget$({ option }): Promise<any>

			/**
			 * Modify font attributes
			 */
			config(): Promise<any>
			config$($: {}): Promise<any>

			/**
			 * Return text width
			 */
			measure(text, displayof?): Promise<any>
			measure$({ text, displayof }: { text, displayof?}): Promise<any>

			/**
			 * Return font metrics.
			 * 
			 *         For best performance, create a dummy widget
			 *         using this font before calling this method.
			 */
			metrics(): Promise<any>
			metrics$($: {}): Promise<any>
			counter
			configure
		}
		let NORMAL: Promise<any>
		let ROMAN: Promise<any>
		let BOLD: Promise<any>
		let ITALIC: Promise<any>
		let root: Promise<any>
		let f: Promise<any>
		let w: Promise<any>
		let fb: Promise<any>
	}
	module messagebox {
		var _

		/**
		 * Show an info message
		 */
		function showinfo(title?, message?): Promise<any>
		function showinfo$({ title, message }: { title?, message?}): Promise<any>

		/**
		 * Show a warning message
		 */
		function showwarning(title?, message?): Promise<any>
		function showwarning$({ title, message }: { title?, message?}): Promise<any>

		/**
		 * Show an error message
		 */
		function showerror(title?, message?): Promise<any>
		function showerror$({ title, message }: { title?, message?}): Promise<any>

		/**
		 * Ask a question
		 */
		function askquestion(title?, message?): Promise<any>
		function askquestion$({ title, message }: { title?, message?}): Promise<any>

		/**
		 * Ask if operation should proceed; return true if the answer is ok
		 */
		function askokcancel(title?, message?): Promise<any>
		function askokcancel$({ title, message }: { title?, message?}): Promise<any>

		/**
		 * Ask a question; return true if the answer is yes
		 */
		function askyesno(title?, message?): Promise<any>
		function askyesno$({ title, message }: { title?, message?}): Promise<any>

		/**
		 * Ask a question; return true if the answer is yes, None if cancelled.
		 */
		function askyesnocancel(title?, message?): Promise<any>
		function askyesnocancel$({ title, message }: { title?, message?}): Promise<any>

		/**
		 * Ask if operation should be retried; return true if the answer is yes
		 */
		function askretrycancel(title?, message?): Promise<any>
		function askretrycancel$({ title, message }: { title?, message?}): Promise<any>

		/**
		 * A message box
		 */
		interface IMessage {
			command
		}
		let ERROR: Promise<any>
		let INFO: Promise<any>
		let QUESTION: Promise<any>
		let WARNING: Promise<any>
		let ABORTRETRYIGNORE: Promise<any>
		let OK: Promise<any>
		let OKCANCEL: Promise<any>
		let RETRYCANCEL: Promise<any>
		let YESNO: Promise<any>
		let YESNOCANCEL: Promise<any>
		let ABORT: Promise<any>
		let RETRY: Promise<any>
		let IGNORE: Promise<any>
		let CANCEL: Promise<any>
		let YES: Promise<any>
		let NO: Promise<any>
	}
	module scrolledtext {
		var _
		function example(): Promise<any>
		function example$($: {}): Promise<any>
		function ScrolledText(master?): Promise<IScrolledText>
		function ScrolledText$({ master }: { master?}): Promise<IScrolledText>
		interface IScrolledText {
		}
	}
	module simpledialog {
		var _

		/**
		 * get an integer from the user
		 * 
		 *     Arguments:
		 * 
		 *         title -- the dialog title
		 *         prompt -- the label text
		 *         **kw -- see SimpleDialog class
		 * 
		 *     Return value is an integer
		 *     
		 */
		function askinteger(title, prompt): Promise<any>
		function askinteger$({ title, prompt }): Promise<any>

		/**
		 * get a float from the user
		 * 
		 *     Arguments:
		 * 
		 *         title -- the dialog title
		 *         prompt -- the label text
		 *         **kw -- see SimpleDialog class
		 * 
		 *     Return value is a float
		 *     
		 */
		function askfloat(title, prompt): Promise<any>
		function askfloat$({ title, prompt }): Promise<any>

		/**
		 * get a string from the user
		 * 
		 *     Arguments:
		 * 
		 *         title -- the dialog title
		 *         prompt -- the label text
		 *         **kw -- see SimpleDialog class
		 * 
		 *     Return value is a string
		 *     
		 */
		function askstring(title, prompt): Promise<any>
		function askstring$({ title, prompt }): Promise<any>
		function test(): Promise<any>
		function test$($: {}): Promise<any>
		function SimpleDialog(master, text?, buttons?, def?, cancel?, title?, class_?): Promise<ISimpleDialog>
		function SimpleDialog$({ master, text, buttons, def, cancel, title, class_ }: { master, text?, buttons?, def?, cancel?, title?, class_?}): Promise<ISimpleDialog>
		interface ISimpleDialog {
			go(): Promise<any>
			go$($: {}): Promise<any>
			return_event(event): Promise<any>
			return_event$({ event }): Promise<any>
			wm_delete_window(): Promise<any>
			wm_delete_window$($: {}): Promise<any>
			done(num): Promise<any>
			done$({ num }): Promise<any>
		}

		/**
		 * Class to open dialogs.
		 * 
		 *     This class is intended as a base class for custom dialogs
		 *     
		 */

		/**
		 * Initialize a dialog.
		 * 
		 *         Arguments:
		 * 
		 *             parent -- a parent window (the application window)
		 * 
		 *             title -- the dialog title
		 *         
		 */
		function Dialog(parent, title?): Promise<IDialog>
		function Dialog$({ parent, title }: { parent, title?}): Promise<IDialog>
		interface IDialog {

			/**
			 * Destroy the window
			 */
			destroy(): Promise<any>
			destroy$($: {}): Promise<any>

			/**
			 * create dialog body.
			 * 
			 *         return widget that should have initial focus.
			 *         This method should be overridden, and is called
			 *         by the __init__ method.
			 *         
			 */
			body(master): Promise<any>
			body$({ master }): Promise<any>

			/**
			 * add standard button box.
			 * 
			 *         override if you do not want the standard buttons
			 *         
			 */
			buttonbox(): Promise<any>
			buttonbox$($: {}): Promise<any>
			ok(event?): Promise<any>
			ok$({ event }: { event?}): Promise<any>
			cancel(event?): Promise<any>
			cancel$({ event }: { event?}): Promise<any>

			/**
			 * validate the data
			 * 
			 *         This method is called automatically to validate the data before the
			 *         dialog is destroyed. By default, it always validates OK.
			 *         
			 */
			validate(): Promise<any>
			validate$($: {}): Promise<any>

			/**
			 * process the data
			 * 
			 *         This method is called automatically to process the data, *after*
			 *         the dialog is destroyed. By default, it does nothing.
			 *         
			 */
			apply(): Promise<any>
			apply$($: {}): Promise<any>
		}
		interface I_QueryDialog extends IDialog {
			destroy(): Promise<any>
			destroy$($: {}): Promise<any>
			body(master): Promise<any>
			body$({ master }): Promise<any>
			validate(): Promise<any>
			validate$($: {}): Promise<any>
		}
		interface I_QueryInteger extends I_QueryDialog {
			getresult(): Promise<any>
			getresult$($: {}): Promise<any>
			errormessage
		}
		interface I_QueryFloat extends I_QueryDialog {
			getresult(): Promise<any>
			getresult$($: {}): Promise<any>
		}
		interface I_QueryString extends I_QueryDialog {
			body(master): Promise<any>
			body$({ master }): Promise<any>
			getresult(): Promise<any>
			getresult$($: {}): Promise<any>
		}
	}
	module tix {
		var _

		/**
		 * Returns the qualified path name for the widget. Normally used to set
		 *     default options for subwidgets. See tixwidgets.py
		 */
		function OptionName(widget): Promise<any>
		function OptionName$({ widget }): Promise<any>
		function FileTypeList(dict): Promise<any>
		function FileTypeList$({ dict }): Promise<any>

		/**
		 * The tix commands provide access to miscellaneous  elements
		 *     of  Tix's  internal state and the Tix application context.
		 *     Most of the information manipulated by these  commands pertains
		 *     to  the  application  as a whole, or to a screen or
		 *     display, rather than to a particular window.
		 * 
		 *     This is a mixin class, assumed to be mixed to Tkinter.Tk
		 *     that supports the self.tk.call method.
		 *     
		 */
		interface ItixCommand {

			/**
			 * Tix maintains a list of directories under which
			 *         the  tix_getimage  and tix_getbitmap commands will
			 *         search for image files. The standard bitmap  directory
			 *         is $TIX_LIBRARY/bitmaps. The addbitmapdir command
			 *         adds directory into this list. By  using  this
			 *         command, the  image  files  of an applications can
			 *         also be located using the tix_getimage or tix_getbitmap
			 *         command.
			 *         
			 */
			tix_addbitmapdir(directory): Promise<any>
			tix_addbitmapdir$({ directory }): Promise<any>

			/**
			 * Returns  the  current  value  of the configuration
			 *         option given by option. Option may be  any  of  the
			 *         options described in the CONFIGURATION OPTIONS section.
			 *         
			 */
			tix_cget(option): Promise<any>
			tix_cget$({ option }): Promise<any>

			/**
			 * Query or modify the configuration options of the Tix application
			 *         context. If no option is specified, returns a dictionary all of the
			 *         available options.  If option is specified with no value, then the
			 *         command returns a list describing the one named option (this list
			 *         will be identical to the corresponding sublist of the value
			 *         returned if no option is specified).  If one or more option-value
			 *         pairs are specified, then the command modifies the given option(s)
			 *         to have the given value(s); in this case the command returns an
			 *         empty string. Option may be any of the configuration options.
			 *         
			 */
			tix_configure(cnf?): Promise<any>
			tix_configure$({ cnf }: { cnf?}): Promise<any>

			/**
			 * Returns the file selection dialog that may be shared among
			 *         different calls from this application.  This command will create a
			 *         file selection dialog widget when it is called the first time. This
			 *         dialog will be returned by all subsequent calls to tix_filedialog.
			 *         An optional dlgclass parameter can be passed to specified what type
			 *         of file selection dialog widget is desired. Possible options are
			 *         tix FileSelectDialog or tixExFileSelectDialog.
			 *         
			 */
			tix_filedialog(dlgclass?): Promise<any>
			tix_filedialog$({ dlgclass }: { dlgclass?}): Promise<any>

			/**
			 * Locates a bitmap file of the name name.xpm or name in one of the
			 *         bitmap directories (see the tix_addbitmapdir command above).  By
			 *         using tix_getbitmap, you can avoid hard coding the pathnames of the
			 *         bitmap files in your application. When successful, it returns the
			 *         complete pathname of the bitmap file, prefixed with the character
			 *         '@'.  The returned value can be used to configure the -bitmap
			 *         option of the TK and Tix widgets.
			 *         
			 */
			tix_getbitmap(name): Promise<any>
			tix_getbitmap$({ name }): Promise<any>

			/**
			 * Locates an image file of the name name.xpm, name.xbm or name.ppm
			 *         in one of the bitmap directories (see the addbitmapdir command
			 *         above). If more than one file with the same name (but different
			 *         extensions) exist, then the image type is chosen according to the
			 *         depth of the X display: xbm images are chosen on monochrome
			 *         displays and color images are chosen on color displays. By using
			 *         tix_ getimage, you can avoid hard coding the pathnames of the
			 *         image files in your application. When successful, this command
			 *         returns the name of the newly created image, which can be used to
			 *         configure the -image option of the Tk and Tix widgets.
			 *         
			 */
			tix_getimage(name): Promise<any>
			tix_getimage$({ name }): Promise<any>

			/**
			 * Gets  the options  maintained  by  the  Tix
			 *         scheme mechanism. Available options include:
			 * 
			 *             active_bg       active_fg      bg
			 *             bold_font       dark1_bg       dark1_fg
			 *             dark2_bg        dark2_fg       disabled_fg
			 *             fg              fixed_font     font
			 *             inactive_bg     inactive_fg    input1_bg
			 *             input2_bg       italic_font    light1_bg
			 *             light1_fg       light2_bg      light2_fg
			 *             menu_font       output1_bg     output2_bg
			 *             select_bg       select_fg      selector
			 *             
			 */
			tix_option_get(name): Promise<any>
			tix_option_get$({ name }): Promise<any>

			/**
			 * Resets the scheme and fontset of the Tix application to
			 *         newScheme and newFontSet, respectively.  This affects only those
			 *         widgets created after this call. Therefore, it is best to call the
			 *         resetoptions command before the creation of any widgets in a Tix
			 *         application.
			 * 
			 *         The optional parameter newScmPrio can be given to reset the
			 *         priority level of the Tk options set by the Tix schemes.
			 * 
			 *         Because of the way Tk handles the X option database, after Tix has
			 *         been has imported and inited, it is not possible to reset the color
			 *         schemes and font sets using the tix config command.  Instead, the
			 *         tix_resetoptions command must be used.
			 *         
			 */
			tix_resetoptions(newScheme, newFontSet, newScmPrio?): Promise<any>
			tix_resetoptions$({ newScheme, newFontSet, newScmPrio }: { newScheme, newFontSet, newScmPrio?}): Promise<any>
		}

		/**
		 * Toplevel widget of Tix which represents mostly the main window
		 *     of an application. It has an associated Tcl interpreter.
		 */
		function Tk(screenName?, baseName?, className?): Promise<ITk>
		function Tk$({ screenName, baseName, className }: { screenName?, baseName?, className?}): Promise<ITk>
		interface ITk extends ItixCommand {
			destroy(): Promise<any>
			destroy$($: {}): Promise<any>
		}

		/**
		 * The Tix Form geometry manager
		 * 
		 *     Widgets can be arranged by specifying attachments to other widgets.
		 *     See Tix documentation for complete details
		 */
		interface IForm {
			config(cnf?): Promise<any>
			config$({ cnf }: { cnf?}): Promise<any>
			check(): Promise<any>
			check$($: {}): Promise<any>
			forget(): Promise<any>
			forget$($: {}): Promise<any>
			grid(xsize?, ysize?): Promise<any>
			grid$({ xsize, ysize }: { xsize?, ysize?}): Promise<any>
			info(option?): Promise<any>
			info$({ option }: { option?}): Promise<any>
			slaves(): Promise<any>
			slaves$($: {}): Promise<any>
			form
		}

		/**
		 * A TixWidget class is used to package all (or most) Tix widgets.
		 * 
		 *     Widget initialization is extended in two ways:
		 *        1) It is possible to give a list of options which must be part of
		 *        the creation command (so called Tix 'static' options). These cannot be
		 *        given as a 'config' command later.
		 *        2) It is possible to give the name of an existing TK widget. These are
		 *        child widgets created automatically by a Tix mega-widget. The Tk call
		 *        to create these widgets is therefore bypassed in TixWidget.__init__
		 * 
		 *     Both options are for use by subclasses only.
		 *     
		 */
		function TixWidget(master?, widgetName?, static_options?, cnf?, kw?): Promise<ITixWidget>
		function TixWidget$({ master, widgetName, static_options, cnf, kw }: { master?, widgetName?, static_options?, cnf?, kw?}): Promise<ITixWidget>
		interface ITixWidget {

			/**
			 * Set a variable without calling its action routine
			 */
			set_silent(value): Promise<any>
			set_silent$({ value }): Promise<any>

			/**
			 * Return the named subwidget (which must have been created by
			 *         the sub-class).
			 */
			subwidget(name): Promise<any>
			subwidget$({ name }): Promise<any>

			/**
			 * Return all subwidgets.
			 */
			subwidgets_all(): Promise<any>
			subwidgets_all$($: {}): Promise<any>

			/**
			 * Set configuration options for all subwidgets (and self).
			 */
			config_all(option, value): Promise<any>
			config_all$({ option, value }): Promise<any>
			image_create(imgtype, cnf?, master?): Promise<any>
			image_create$({ imgtype, cnf, master }: { imgtype, cnf?, master?}): Promise<any>
			image_delete(imgname): Promise<any>
			image_delete$({ imgname }): Promise<any>
		}

		/**
		 * Subwidget class.
		 * 
		 *     This is used to mirror child widgets automatically created
		 *     by Tix/Tk as part of a mega-widget in Python (which is not informed
		 *     of this)
		 */
		function TixSubWidget(master, name, destroy_physically?, check_intermediate?): Promise<ITixSubWidget>
		function TixSubWidget$({ master, name, destroy_physically, check_intermediate }: { master, name, destroy_physically?, check_intermediate?}): Promise<ITixSubWidget>
		interface ITixSubWidget extends ITixWidget {
			destroy(): Promise<any>
			destroy$($: {}): Promise<any>
		}

		/**
		 * DisplayStyle - handle configuration options shared by
		 *     (multiple) Display Items
		 */
		function DisplayStyle(itemtype, cnf?): Promise<IDisplayStyle>
		function DisplayStyle$({ itemtype, cnf }: { itemtype, cnf?}): Promise<IDisplayStyle>
		interface IDisplayStyle {
			delete(): Promise<any>
			delete$($: {}): Promise<any>
			config(cnf?): Promise<any>
			config$({ cnf }: { cnf?}): Promise<any>
		}

		/**
		 * Balloon help widget.
		 * 
		 *     Subwidget       Class
		 *     ---------       -----
		 *     label           Label
		 *     message         Message
		 */
		function Balloon(master?, cnf?): Promise<IBalloon>
		function Balloon$({ master, cnf }: { master?, cnf?}): Promise<IBalloon>
		interface IBalloon extends ITixWidget {

			/**
			 * Bind balloon widget to another.
			 *         One balloon widget may be bound to several widgets at the same time
			 */
			bind_widget(widget, cnf?): Promise<any>
			bind_widget$({ widget, cnf }: { widget, cnf?}): Promise<any>
			unbind_widget(widget): Promise<any>
			unbind_widget$({ widget }): Promise<any>
		}

		/**
		 * ButtonBox - A container for pushbuttons.
		 *     Subwidgets are the buttons added with the add method.
		 *     
		 */
		function ButtonBox(master?, cnf?): Promise<IButtonBox>
		function ButtonBox$({ master, cnf }: { master?, cnf?}): Promise<IButtonBox>
		interface IButtonBox extends ITixWidget {

			/**
			 * Add a button with given name to box.
			 */
			add(name, cnf?): Promise<any>
			add$({ name, cnf }: { name, cnf?}): Promise<any>
			invoke(name): Promise<any>
			invoke$({ name }): Promise<any>
		}

		/**
		 * ComboBox - an Entry field with a dropdown menu. The user can select a
		 *     choice by either typing in the entry subwidget or selecting from the
		 *     listbox subwidget.
		 * 
		 *     Subwidget       Class
		 *     ---------       -----
		 *     entry       Entry
		 *     arrow       Button
		 *     slistbox    ScrolledListBox
		 *     tick        Button
		 *     cross       Button : present if created with the fancy option
		 */
		function ComboBox(master?, cnf?): Promise<IComboBox>
		function ComboBox$({ master, cnf }: { master?, cnf?}): Promise<IComboBox>
		interface IComboBox extends ITixWidget {
			add_history(str): Promise<any>
			add_history$({ str }): Promise<any>
			append_history(str): Promise<any>
			append_history$({ str }): Promise<any>
			insert(index, str): Promise<any>
			insert$({ index, str }): Promise<any>
			pick(index): Promise<any>
			pick$({ index }): Promise<any>
		}

		/**
		 * Control - An entry field with value change arrows.  The user can
		 *     adjust the value by pressing the two arrow buttons or by entering
		 *     the value directly into the entry. The new value will be checked
		 *     against the user-defined upper and lower limits.
		 * 
		 *     Subwidget       Class
		 *     ---------       -----
		 *     incr       Button
		 *     decr       Button
		 *     entry       Entry
		 *     label       Label
		 */
		function Control(master?, cnf?): Promise<IControl>
		function Control$({ master, cnf }: { master?, cnf?}): Promise<IControl>
		interface IControl extends ITixWidget {
			decrement(): Promise<any>
			decrement$($: {}): Promise<any>
			increment(): Promise<any>
			increment$($: {}): Promise<any>
			invoke(): Promise<any>
			invoke$($: {}): Promise<any>
			update(): Promise<any>
			update$($: {}): Promise<any>
		}

		/**
		 * DirList - displays a list view of a directory, its previous
		 *     directories and its sub-directories. The user can choose one of
		 *     the directories displayed in the list or change to another directory.
		 * 
		 *     Subwidget       Class
		 *     ---------       -----
		 *     hlist       HList
		 *     hsb              Scrollbar
		 *     vsb              Scrollbar
		 */
		function DirList(master, cnf?): Promise<IDirList>
		function DirList$({ master, cnf }: { master, cnf?}): Promise<IDirList>
		interface IDirList extends ITixWidget {
			chdir(dir): Promise<any>
			chdir$({ dir }): Promise<any>
		}

		/**
		 * DirTree - Directory Listing in a hierarchical view.
		 *     Displays a tree view of a directory, its previous directories and its
		 *     sub-directories. The user can choose one of the directories displayed
		 *     in the list or change to another directory.
		 * 
		 *     Subwidget       Class
		 *     ---------       -----
		 *     hlist           HList
		 *     hsb             Scrollbar
		 *     vsb             Scrollbar
		 */
		function DirTree(master, cnf?): Promise<IDirTree>
		function DirTree$({ master, cnf }: { master, cnf?}): Promise<IDirTree>
		interface IDirTree extends ITixWidget {
			chdir(dir): Promise<any>
			chdir$({ dir }): Promise<any>
		}

		/**
		 * DirSelectBox - Motif style file select box.
		 *     It is generally used for
		 *     the user to choose a file. FileSelectBox stores the files mostly
		 *     recently selected into a ComboBox widget so that they can be quickly
		 *     selected again.
		 * 
		 *     Subwidget       Class
		 *     ---------       -----
		 *     selection       ComboBox
		 *     filter          ComboBox
		 *     dirlist         ScrolledListBox
		 *     filelist        ScrolledListBox
		 */
		function DirSelectBox(master, cnf?): Promise<IDirSelectBox>
		function DirSelectBox$({ master, cnf }: { master, cnf?}): Promise<IDirSelectBox>
		interface IDirSelectBox extends ITixWidget {
		}

		/**
		 * ExFileSelectBox - MS Windows style file select box.
		 *     It provides a convenient method for the user to select files.
		 * 
		 *     Subwidget       Class
		 *     ---------       -----
		 *     cancel       Button
		 *     ok              Button
		 *     hidden       Checkbutton
		 *     types       ComboBox
		 *     dir              ComboBox
		 *     file       ComboBox
		 *     dirlist       ScrolledListBox
		 *     filelist       ScrolledListBox
		 */
		function ExFileSelectBox(master, cnf?): Promise<IExFileSelectBox>
		function ExFileSelectBox$({ master, cnf }: { master, cnf?}): Promise<IExFileSelectBox>
		interface IExFileSelectBox extends ITixWidget {
			filter(): Promise<any>
			filter$($: {}): Promise<any>
			invoke(): Promise<any>
			invoke$($: {}): Promise<any>
		}

		/**
		 * The DirSelectDialog widget presents the directories in the file
		 *     system in a dialog window. The user can use this dialog window to
		 *     navigate through the file system to select the desired directory.
		 * 
		 *     Subwidgets       Class
		 *     ----------       -----
		 *     dirbox       DirSelectDialog
		 */
		function DirSelectDialog(master, cnf?): Promise<IDirSelectDialog>
		function DirSelectDialog$({ master, cnf }: { master, cnf?}): Promise<IDirSelectDialog>
		interface IDirSelectDialog extends ITixWidget {
			popup(): Promise<any>
			popup$($: {}): Promise<any>
			popdown(): Promise<any>
			popdown$($: {}): Promise<any>
		}

		/**
		 * ExFileSelectDialog - MS Windows style file select dialog.
		 *     It provides a convenient method for the user to select files.
		 * 
		 *     Subwidgets       Class
		 *     ----------       -----
		 *     fsbox       ExFileSelectBox
		 */
		function ExFileSelectDialog(master, cnf?): Promise<IExFileSelectDialog>
		function ExFileSelectDialog$({ master, cnf }: { master, cnf?}): Promise<IExFileSelectDialog>
		interface IExFileSelectDialog extends ITixWidget {
			popup(): Promise<any>
			popup$($: {}): Promise<any>
			popdown(): Promise<any>
			popdown$($: {}): Promise<any>
		}

		/**
		 * ExFileSelectBox - Motif style file select box.
		 *     It is generally used for
		 *     the user to choose a file. FileSelectBox stores the files mostly
		 *     recently selected into a ComboBox widget so that they can be quickly
		 *     selected again.
		 * 
		 *     Subwidget       Class
		 *     ---------       -----
		 *     selection       ComboBox
		 *     filter          ComboBox
		 *     dirlist         ScrolledListBox
		 *     filelist        ScrolledListBox
		 */
		function FileSelectBox(master, cnf?): Promise<IFileSelectBox>
		function FileSelectBox$({ master, cnf }: { master, cnf?}): Promise<IFileSelectBox>
		interface IFileSelectBox extends ITixWidget {
			apply_filter(): Promise<any>
			apply_filter$($: {}): Promise<any>
			invoke(): Promise<any>
			invoke$($: {}): Promise<any>
		}

		/**
		 * FileSelectDialog - Motif style file select dialog.
		 * 
		 *     Subwidgets       Class
		 *     ----------       -----
		 *     btns       StdButtonBox
		 *     fsbox       FileSelectBox
		 */
		function FileSelectDialog(master, cnf?): Promise<IFileSelectDialog>
		function FileSelectDialog$({ master, cnf }: { master, cnf?}): Promise<IFileSelectDialog>
		interface IFileSelectDialog extends ITixWidget {
			popup(): Promise<any>
			popup$($: {}): Promise<any>
			popdown(): Promise<any>
			popdown$($: {}): Promise<any>
		}

		/**
		 * FileEntry - Entry field with button that invokes a FileSelectDialog.
		 *     The user can type in the filename manually. Alternatively, the user can
		 *     press the button widget that sits next to the entry, which will bring
		 *     up a file selection dialog.
		 * 
		 *     Subwidgets       Class
		 *     ----------       -----
		 *     button       Button
		 *     entry       Entry
		 */
		function FileEntry(master, cnf?): Promise<IFileEntry>
		function FileEntry$({ master, cnf }: { master, cnf?}): Promise<IFileEntry>
		interface IFileEntry extends ITixWidget {
			invoke(): Promise<any>
			invoke$($: {}): Promise<any>
			file_dialog(): Promise<any>
			file_dialog$($: {}): Promise<any>
		}

		/**
		 * HList - Hierarchy display  widget can be used to display any data
		 *     that have a hierarchical structure, for example, file system directory
		 *     trees. The list entries are indented and connected by branch lines
		 *     according to their places in the hierarchy.
		 * 
		 *     Subwidgets - None
		 */
		function HList(master?, cnf?): Promise<IHList>
		function HList$({ master, cnf }: { master?, cnf?}): Promise<IHList>
		interface IHList extends ITixWidget {
			add(entry, cnf?): Promise<any>
			add$({ entry, cnf }: { entry, cnf?}): Promise<any>
			add_child(parent?, cnf?): Promise<any>
			add_child$({ parent, cnf }: { parent?, cnf?}): Promise<any>
			anchor_set(entry): Promise<any>
			anchor_set$({ entry }): Promise<any>
			anchor_clear(): Promise<any>
			anchor_clear$($: {}): Promise<any>
			column_width(col?, width?, chars?): Promise<any>
			column_width$({ col, width, chars }: { col?, width?, chars?}): Promise<any>
			delete_all(): Promise<any>
			delete_all$($: {}): Promise<any>
			delete_entry(entry): Promise<any>
			delete_entry$({ entry }): Promise<any>
			delete_offsprings(entry): Promise<any>
			delete_offsprings$({ entry }): Promise<any>
			delete_siblings(entry): Promise<any>
			delete_siblings$({ entry }): Promise<any>
			dragsite_set(index): Promise<any>
			dragsite_set$({ index }): Promise<any>
			dragsite_clear(): Promise<any>
			dragsite_clear$($: {}): Promise<any>
			dropsite_set(index): Promise<any>
			dropsite_set$({ index }): Promise<any>
			dropsite_clear(): Promise<any>
			dropsite_clear$($: {}): Promise<any>
			header_create(col, cnf?): Promise<any>
			header_create$({ col, cnf }: { col, cnf?}): Promise<any>
			header_configure(col, cnf?): Promise<any>
			header_configure$({ col, cnf }: { col, cnf?}): Promise<any>
			header_cget(col, opt): Promise<any>
			header_cget$({ col, opt }): Promise<any>
			header_exists(col): Promise<any>
			header_exists$({ col }): Promise<any>
			header_delete(col): Promise<any>
			header_delete$({ col }): Promise<any>
			header_size(col): Promise<any>
			header_size$({ col }): Promise<any>
			hide_entry(entry): Promise<any>
			hide_entry$({ entry }): Promise<any>
			indicator_create(entry, cnf?): Promise<any>
			indicator_create$({ entry, cnf }: { entry, cnf?}): Promise<any>
			indicator_configure(entry, cnf?): Promise<any>
			indicator_configure$({ entry, cnf }: { entry, cnf?}): Promise<any>
			indicator_cget(entry, opt): Promise<any>
			indicator_cget$({ entry, opt }): Promise<any>
			indicator_exists(entry): Promise<any>
			indicator_exists$({ entry }): Promise<any>
			indicator_delete(entry): Promise<any>
			indicator_delete$({ entry }): Promise<any>
			indicator_size(entry): Promise<any>
			indicator_size$({ entry }): Promise<any>
			info_anchor(): Promise<any>
			info_anchor$($: {}): Promise<any>
			info_bbox(entry): Promise<any>
			info_bbox$({ entry }): Promise<any>
			info_children(entry?): Promise<any>
			info_children$({ entry }: { entry?}): Promise<any>
			info_data(entry): Promise<any>
			info_data$({ entry }): Promise<any>
			info_dragsite(): Promise<any>
			info_dragsite$($: {}): Promise<any>
			info_dropsite(): Promise<any>
			info_dropsite$($: {}): Promise<any>
			info_exists(entry): Promise<any>
			info_exists$({ entry }): Promise<any>
			info_hidden(entry): Promise<any>
			info_hidden$({ entry }): Promise<any>
			info_next(entry): Promise<any>
			info_next$({ entry }): Promise<any>
			info_parent(entry): Promise<any>
			info_parent$({ entry }): Promise<any>
			info_prev(entry): Promise<any>
			info_prev$({ entry }): Promise<any>
			info_selection(): Promise<any>
			info_selection$($: {}): Promise<any>
			item_cget(entry, col, opt): Promise<any>
			item_cget$({ entry, col, opt }): Promise<any>
			item_configure(entry, col, cnf?): Promise<any>
			item_configure$({ entry, col, cnf }: { entry, col, cnf?}): Promise<any>
			item_create(entry, col, cnf?): Promise<any>
			item_create$({ entry, col, cnf }: { entry, col, cnf?}): Promise<any>
			item_exists(entry, col): Promise<any>
			item_exists$({ entry, col }): Promise<any>
			item_delete(entry, col): Promise<any>
			item_delete$({ entry, col }): Promise<any>
			entrycget(entry, opt): Promise<any>
			entrycget$({ entry, opt }): Promise<any>
			entryconfigure(entry, cnf?): Promise<any>
			entryconfigure$({ entry, cnf }: { entry, cnf?}): Promise<any>
			nearest(y): Promise<any>
			nearest$({ y }): Promise<any>
			see(entry): Promise<any>
			see$({ entry }): Promise<any>
			selection_clear(cnf?): Promise<any>
			selection_clear$({ cnf }: { cnf?}): Promise<any>
			selection_includes(entry): Promise<any>
			selection_includes$({ entry }): Promise<any>
			selection_set(first, last?): Promise<any>
			selection_set$({ first, last }: { first, last?}): Promise<any>
			show_entry(entry): Promise<any>
			show_entry$({ entry }): Promise<any>
			header_exist
		}

		/**
		 * InputOnly - Invisible widget. Unix only.
		 * 
		 *     Subwidgets - None
		 */
		function InputOnly(master?, cnf?): Promise<IInputOnly>
		function InputOnly$({ master, cnf }: { master?, cnf?}): Promise<IInputOnly>
		interface IInputOnly extends ITixWidget {
		}

		/**
		 * LabelEntry - Entry field with label. Packages an entry widget
		 *     and a label into one mega widget. It can be used to simplify the creation
		 *     of ``entry-form'' type of interface.
		 * 
		 *     Subwidgets       Class
		 *     ----------       -----
		 *     label       Label
		 *     entry       Entry
		 */
		function LabelEntry(master?, cnf?): Promise<ILabelEntry>
		function LabelEntry$({ master, cnf }: { master?, cnf?}): Promise<ILabelEntry>
		interface ILabelEntry extends ITixWidget {
		}

		/**
		 * LabelFrame - Labelled Frame container. Packages a frame widget
		 *     and a label into one mega widget. To create widgets inside a
		 *     LabelFrame widget, one creates the new widgets relative to the
		 *     frame subwidget and manage them inside the frame subwidget.
		 * 
		 *     Subwidgets       Class
		 *     ----------       -----
		 *     label       Label
		 *     frame       Frame
		 */
		function LabelFrame(master?, cnf?): Promise<ILabelFrame>
		function LabelFrame$({ master, cnf }: { master?, cnf?}): Promise<ILabelFrame>
		interface ILabelFrame extends ITixWidget {
		}

		/**
		 * A ListNoteBook widget is very similar to the TixNoteBook widget:
		 *     it can be used to display many windows in a limited space using a
		 *     notebook metaphor. The notebook is divided into a stack of pages
		 *     (windows). At one time only one of these pages can be shown.
		 *     The user can navigate through these pages by
		 *     choosing the name of the desired page in the hlist subwidget.
		 */
		function ListNoteBook(master, cnf?): Promise<IListNoteBook>
		function ListNoteBook$({ master, cnf }: { master, cnf?}): Promise<IListNoteBook>
		interface IListNoteBook extends ITixWidget {
			add(name, cnf?): Promise<any>
			add$({ name, cnf }: { name, cnf?}): Promise<any>
			page(name): Promise<any>
			page$({ name }): Promise<any>
			pages(): Promise<any>
			pages$($: {}): Promise<any>
			raise_page(name): Promise<any>
			raise_page$({ name }): Promise<any>
		}

		/**
		 * The Meter widget can be used to show the progress of a background
		 *     job which may take a long time to execute.
		 *     
		 */
		function Meter(master?, cnf?): Promise<IMeter>
		function Meter$({ master, cnf }: { master?, cnf?}): Promise<IMeter>
		interface IMeter extends ITixWidget {
		}

		/**
		 * NoteBook - Multi-page container widget (tabbed notebook metaphor).
		 * 
		 *     Subwidgets       Class
		 *     ----------       -----
		 *     nbframe       NoteBookFrame
		 *     <pages>       page widgets added dynamically with the add method
		 */
		function NoteBook(master?, cnf?): Promise<INoteBook>
		function NoteBook$({ master, cnf }: { master?, cnf?}): Promise<INoteBook>
		interface INoteBook extends ITixWidget {
			add(name, cnf?): Promise<any>
			add$({ name, cnf }: { name, cnf?}): Promise<any>
			delete(name): Promise<any>
			delete$({ name }): Promise<any>
			page(name): Promise<any>
			page$({ name }): Promise<any>
			pages(): Promise<any>
			pages$($: {}): Promise<any>
			raise_page(name): Promise<any>
			raise_page$({ name }): Promise<any>
			raised(): Promise<any>
			raised$($: {}): Promise<any>
		}
		interface INoteBookFrame extends ITixWidget {
		}

		/**
		 * OptionMenu - creates a menu button of options.
		 * 
		 *     Subwidget       Class
		 *     ---------       -----
		 *     menubutton      Menubutton
		 *     menu            Menu
		 */
		function OptionMenu(master, cnf?): Promise<IOptionMenu>
		function OptionMenu$({ master, cnf }: { master, cnf?}): Promise<IOptionMenu>
		interface IOptionMenu extends ITixWidget {
			add_command(name, cnf?): Promise<any>
			add_command$({ name, cnf }: { name, cnf?}): Promise<any>
			add_separator(name, cnf?): Promise<any>
			add_separator$({ name, cnf }: { name, cnf?}): Promise<any>
			delete(name): Promise<any>
			delete$({ name }): Promise<any>
			disable(name): Promise<any>
			disable$({ name }): Promise<any>
			enable(name): Promise<any>
			enable$({ name }): Promise<any>
		}

		/**
		 * PanedWindow - Multi-pane container widget
		 *     allows the user to interactively manipulate the sizes of several
		 *     panes. The panes can be arranged either vertically or horizontally.The
		 *     user changes the sizes of the panes by dragging the resize handle
		 *     between two panes.
		 * 
		 *     Subwidgets       Class
		 *     ----------       -----
		 *     <panes>       g/p widgets added dynamically with the add method.
		 */
		function PanedWindow(master, cnf?): Promise<IPanedWindow>
		function PanedWindow$({ master, cnf }: { master, cnf?}): Promise<IPanedWindow>
		interface IPanedWindow extends ITixWidget {
			add(name, cnf?): Promise<any>
			add$({ name, cnf }: { name, cnf?}): Promise<any>
			delete(name): Promise<any>
			delete$({ name }): Promise<any>
			forget(name): Promise<any>
			forget$({ name }): Promise<any>
			panecget(entry, opt): Promise<any>
			panecget$({ entry, opt }): Promise<any>
			paneconfigure(entry, cnf?): Promise<any>
			paneconfigure$({ entry, cnf }: { entry, cnf?}): Promise<any>
			panes(): Promise<any>
			panes$($: {}): Promise<any>
		}

		/**
		 * PopupMenu widget can be used as a replacement of the tk_popup command.
		 *     The advantage of the Tix PopupMenu widget is it requires less application
		 *     code to manipulate.
		 * 
		 * 
		 *     Subwidgets       Class
		 *     ----------       -----
		 *     menubutton       Menubutton
		 *     menu       Menu
		 */
		function PopupMenu(master, cnf?): Promise<IPopupMenu>
		function PopupMenu$({ master, cnf }: { master, cnf?}): Promise<IPopupMenu>
		interface IPopupMenu extends ITixWidget {
			bind_widget(widget): Promise<any>
			bind_widget$({ widget }): Promise<any>
			unbind_widget(widget): Promise<any>
			unbind_widget$({ widget }): Promise<any>
			post_widget(widget, x, y): Promise<any>
			post_widget$({ widget, x, y }): Promise<any>
		}

		/**
		 * Internal widget to draw resize handles on Scrolled widgets.
		 */
		function ResizeHandle(master, cnf?): Promise<IResizeHandle>
		function ResizeHandle$({ master, cnf }: { master, cnf?}): Promise<IResizeHandle>
		interface IResizeHandle extends ITixWidget {
			attach_widget(widget): Promise<any>
			attach_widget$({ widget }): Promise<any>
			detach_widget(widget): Promise<any>
			detach_widget$({ widget }): Promise<any>
			hide(widget): Promise<any>
			hide$({ widget }): Promise<any>
			show(widget): Promise<any>
			show$({ widget }): Promise<any>
		}

		/**
		 * ScrolledHList - HList with automatic scrollbars.
		 */
		function ScrolledHList(master, cnf?): Promise<IScrolledHList>
		function ScrolledHList$({ master, cnf }: { master, cnf?}): Promise<IScrolledHList>
		interface IScrolledHList extends ITixWidget {
		}

		/**
		 * ScrolledListBox - Listbox with automatic scrollbars.
		 */
		function ScrolledListBox(master, cnf?): Promise<IScrolledListBox>
		function ScrolledListBox$({ master, cnf }: { master, cnf?}): Promise<IScrolledListBox>
		interface IScrolledListBox extends ITixWidget {
		}

		/**
		 * ScrolledText - Text with automatic scrollbars.
		 */
		function ScrolledText(master, cnf?): Promise<IScrolledText>
		function ScrolledText$({ master, cnf }: { master, cnf?}): Promise<IScrolledText>
		interface IScrolledText extends ITixWidget {
		}

		/**
		 * ScrolledTList - TList with automatic scrollbars.
		 */
		function ScrolledTList(master, cnf?): Promise<IScrolledTList>
		function ScrolledTList$({ master, cnf }: { master, cnf?}): Promise<IScrolledTList>
		interface IScrolledTList extends ITixWidget {
		}

		/**
		 * ScrolledWindow - Window with automatic scrollbars.
		 */
		function ScrolledWindow(master, cnf?): Promise<IScrolledWindow>
		function ScrolledWindow$({ master, cnf }: { master, cnf?}): Promise<IScrolledWindow>
		interface IScrolledWindow extends ITixWidget {
		}

		/**
		 * Select - Container of button subwidgets. It can be used to provide
		 *     radio-box or check-box style of selection options for the user.
		 * 
		 *     Subwidgets are buttons added dynamically using the add method.
		 */
		function Select(master, cnf?): Promise<ISelect>
		function Select$({ master, cnf }: { master, cnf?}): Promise<ISelect>
		interface ISelect extends ITixWidget {
			add(name, cnf?): Promise<any>
			add$({ name, cnf }: { name, cnf?}): Promise<any>
			invoke(name): Promise<any>
			invoke$({ name }): Promise<any>
		}

		/**
		 * Toplevel window.
		 * 
		 *     Subwidgets - None
		 */
		function Shell(master?, cnf?): Promise<IShell>
		function Shell$({ master, cnf }: { master?, cnf?}): Promise<IShell>
		interface IShell extends ITixWidget {
		}

		/**
		 * Toplevel window, with popup popdown and center methods.
		 *     It tells the window manager that it is a dialog window and should be
		 *     treated specially. The exact treatment depends on the treatment of
		 *     the window manager.
		 * 
		 *     Subwidgets - None
		 */
		function DialogShell(master?, cnf?): Promise<IDialogShell>
		function DialogShell$({ master, cnf }: { master?, cnf?}): Promise<IDialogShell>
		interface IDialogShell extends ITixWidget {
			popdown(): Promise<any>
			popdown$($: {}): Promise<any>
			popup(): Promise<any>
			popup$($: {}): Promise<any>
			center(): Promise<any>
			center$($: {}): Promise<any>
		}

		/**
		 * StdButtonBox - Standard Button Box (OK, Apply, Cancel and Help) 
		 */
		function StdButtonBox(master?, cnf?): Promise<IStdButtonBox>
		function StdButtonBox$({ master, cnf }: { master?, cnf?}): Promise<IStdButtonBox>
		interface IStdButtonBox extends ITixWidget {
			invoke(name): Promise<any>
			invoke$({ name }): Promise<any>
		}

		/**
		 * TList - Hierarchy display widget which can be
		 *     used to display data in a tabular format. The list entries of a TList
		 *     widget are similar to the entries in the Tk listbox widget. The main
		 *     differences are (1) the TList widget can display the list entries in a
		 *     two dimensional format and (2) you can use graphical images as well as
		 *     multiple colors and fonts for the list entries.
		 * 
		 *     Subwidgets - None
		 */
		function TList(master?, cnf?): Promise<ITList>
		function TList$({ master, cnf }: { master?, cnf?}): Promise<ITList>
		interface ITList extends ITixWidget {
			active_set(index): Promise<any>
			active_set$({ index }): Promise<any>
			active_clear(): Promise<any>
			active_clear$($: {}): Promise<any>
			anchor_set(index): Promise<any>
			anchor_set$({ index }): Promise<any>
			anchor_clear(): Promise<any>
			anchor_clear$($: {}): Promise<any>
			delete(from_, to?): Promise<any>
			delete$({ from_, to }: { from_, to?}): Promise<any>
			dragsite_set(index): Promise<any>
			dragsite_set$({ index }): Promise<any>
			dragsite_clear(): Promise<any>
			dragsite_clear$($: {}): Promise<any>
			dropsite_set(index): Promise<any>
			dropsite_set$({ index }): Promise<any>
			dropsite_clear(): Promise<any>
			dropsite_clear$($: {}): Promise<any>
			insert(index, cnf?): Promise<any>
			insert$({ index, cnf }: { index, cnf?}): Promise<any>
			info_active(): Promise<any>
			info_active$($: {}): Promise<any>
			info_anchor(): Promise<any>
			info_anchor$($: {}): Promise<any>
			info_down(index): Promise<any>
			info_down$({ index }): Promise<any>
			info_left(index): Promise<any>
			info_left$({ index }): Promise<any>
			info_right(index): Promise<any>
			info_right$({ index }): Promise<any>
			info_selection(): Promise<any>
			info_selection$($: {}): Promise<any>
			info_size(): Promise<any>
			info_size$($: {}): Promise<any>
			info_up(index): Promise<any>
			info_up$({ index }): Promise<any>
			nearest(x, y): Promise<any>
			nearest$({ x, y }): Promise<any>
			see(index): Promise<any>
			see$({ index }): Promise<any>
			selection_clear(cnf?): Promise<any>
			selection_clear$({ cnf }: { cnf?}): Promise<any>
			selection_includes(index): Promise<any>
			selection_includes$({ index }): Promise<any>
			selection_set(first, last?): Promise<any>
			selection_set$({ first, last }: { first, last?}): Promise<any>
		}

		/**
		 * Tree - The tixTree widget can be used to display hierarchical
		 *     data in a tree form. The user can adjust
		 *     the view of the tree by opening or closing parts of the tree.
		 */
		function Tree(master?, cnf?): Promise<ITree>
		function Tree$({ master, cnf }: { master?, cnf?}): Promise<ITree>
		interface ITree extends ITixWidget {

			/**
			 * This command calls the setmode method for all the entries in this
			 *      Tree widget: if an entry has no child entries, its mode is set to
			 *      none. Otherwise, if the entry has any hidden child entries, its mode is
			 *      set to open; otherwise its mode is set to close.
			 */
			autosetmode(): Promise<any>
			autosetmode$($: {}): Promise<any>

			/**
			 * Close the entry given by entryPath if its mode is close.
			 */
			close(entrypath): Promise<any>
			close$({ entrypath }): Promise<any>

			/**
			 * Returns the current mode of the entry given by entryPath.
			 */
			getmode(entrypath): Promise<any>
			getmode$({ entrypath }): Promise<any>

			/**
			 * Open the entry given by entryPath if its mode is open.
			 */
			open(entrypath): Promise<any>
			open$({ entrypath }): Promise<any>

			/**
			 * This command is used to indicate whether the entry given by
			 *      entryPath has children entries and whether the children are visible. mode
			 *      must be one of open, close or none. If mode is set to open, a (+)
			 *      indicator is drawn next the entry. If mode is set to close, a (-)
			 *      indicator is drawn next the entry. If mode is set to none, no
			 *      indicators will be drawn for this entry. The default mode is none. The
			 *      open mode indicates the entry has hidden children and this entry can be
			 *      opened by the user. The close mode indicates that all the children of the
			 *      entry are now visible and the entry can be closed by the user.
			 */
			setmode(entrypath, mode?): Promise<any>
			setmode$({ entrypath, mode }: { entrypath, mode?}): Promise<any>
		}

		/**
		 * The CheckList widget
		 *     displays a list of items to be selected by the user. CheckList acts
		 *     similarly to the Tk checkbutton or radiobutton widgets, except it is
		 *     capable of handling many more items than checkbuttons or radiobuttons.
		 *     
		 */
		function CheckList(master?, cnf?): Promise<ICheckList>
		function CheckList$({ master, cnf }: { master?, cnf?}): Promise<ICheckList>
		interface ICheckList extends ITixWidget {

			/**
			 * This command calls the setmode method for all the entries in this
			 *      Tree widget: if an entry has no child entries, its mode is set to
			 *      none. Otherwise, if the entry has any hidden child entries, its mode is
			 *      set to open; otherwise its mode is set to close.
			 */
			autosetmode(): Promise<any>
			autosetmode$($: {}): Promise<any>

			/**
			 * Close the entry given by entryPath if its mode is close.
			 */
			close(entrypath): Promise<any>
			close$({ entrypath }): Promise<any>

			/**
			 * Returns the current mode of the entry given by entryPath.
			 */
			getmode(entrypath): Promise<any>
			getmode$({ entrypath }): Promise<any>

			/**
			 * Open the entry given by entryPath if its mode is open.
			 */
			open(entrypath): Promise<any>
			open$({ entrypath }): Promise<any>

			/**
			 * Returns a list of items whose status matches status. If status is
			 *      not specified, the list of items in the "on" status will be returned.
			 *      Mode can be on, off, default
			 */
			getselection(mode?): Promise<any>
			getselection$({ mode }: { mode?}): Promise<any>

			/**
			 * Returns the current status of entryPath.
			 */
			getstatus(entrypath): Promise<any>
			getstatus$({ entrypath }): Promise<any>

			/**
			 * Sets the status of entryPath to be status. A bitmap will be
			 *      displayed next to the entry its status is on, off or default.
			 */
			setstatus(entrypath, mode?): Promise<any>
			setstatus$({ entrypath, mode }: { entrypath, mode?}): Promise<any>
		}
		interface I_dummyButton extends ITixSubWidget {
		}
		interface I_dummyCheckbutton extends ITixSubWidget {
		}
		interface I_dummyEntry extends ITixSubWidget {
		}
		interface I_dummyFrame extends ITixSubWidget {
		}
		interface I_dummyLabel extends ITixSubWidget {
		}
		interface I_dummyListbox extends ITixSubWidget {
		}
		interface I_dummyMenu extends ITixSubWidget {
		}
		interface I_dummyMenubutton extends ITixSubWidget {
		}
		interface I_dummyScrollbar extends ITixSubWidget {
		}
		interface I_dummyText extends ITixSubWidget {
		}
		interface I_dummyScrolledListBox extends IScrolledListBox, ITixSubWidget {
		}
		interface I_dummyHList extends IHList, ITixSubWidget {
		}
		interface I_dummyScrolledHList extends IScrolledHList, ITixSubWidget {
		}
		interface I_dummyTList extends ITList, ITixSubWidget {
		}
		interface I_dummyComboBox extends IComboBox, ITixSubWidget {
		}
		interface I_dummyDirList extends IDirList, ITixSubWidget {
		}
		interface I_dummyDirSelectBox extends IDirSelectBox, ITixSubWidget {
		}
		interface I_dummyExFileSelectBox extends IExFileSelectBox, ITixSubWidget {
		}
		interface I_dummyFileSelectBox extends IFileSelectBox, ITixSubWidget {
		}
		interface I_dummyFileComboBox extends IComboBox, ITixSubWidget {
		}
		interface I_dummyStdButtonBox extends IStdButtonBox, ITixSubWidget {
		}
		interface I_dummyNoteBookFrame extends INoteBookFrame, ITixSubWidget {
		}
		interface I_dummyPanedWindow extends IPanedWindow, ITixSubWidget {
		}

		/**
		 * This file implements the Canvas Object View widget. This is a base
		 *     class of IconView. It implements automatic placement/adjustment of the
		 *     scrollbars according to the canvas objects inside the canvas subwidget.
		 *     The scrollbars are adjusted so that the canvas is just large enough
		 *     to see all the objects.
		 *     
		 */
		interface ICObjView extends ITixWidget {
		}

		/**
		 * The Tix Grid command creates a new window  and makes it into a
		 *     tixGrid widget. Additional options, may be specified on the command
		 *     line or in the option database to configure aspects such as its cursor
		 *     and relief.
		 * 
		 *     A Grid widget displays its contents in a two dimensional grid of cells.
		 *     Each cell may contain one Tix display item, which may be in text,
		 *     graphics or other formats. See the DisplayStyle class for more information
		 *     about Tix display items. Individual cells, or groups of cells, can be
		 *     formatted with a wide range of attributes, such as its color, relief and
		 *     border.
		 * 
		 *     Subwidgets - None
		 */
		function Grid(master?, cnf?): Promise<IGrid>
		function Grid$({ master, cnf }: { master?, cnf?}): Promise<IGrid>
		interface IGrid extends ITixWidget {

			/**
			 * Removes the selection anchor.
			 */
			anchor_clear(): Promise<any>
			anchor_clear$($: {}): Promise<any>

			/**
			 * Get the (x,y) coordinate of the current anchor cell
			 */
			anchor_get(): Promise<any>
			anchor_get$($: {}): Promise<any>

			/**
			 * Set the selection anchor to the cell at (x, y).
			 */
			anchor_set(x, y): Promise<any>
			anchor_set$({ x, y }): Promise<any>

			/**
			 * Delete rows between from_ and to inclusive.
			 *         If to is not provided,  delete only row at from_
			 */
			delete_row(from_, to?): Promise<any>
			delete_row$({ from_, to }: { from_, to?}): Promise<any>

			/**
			 * Delete columns between from_ and to inclusive.
			 *         If to is not provided,  delete only column at from_
			 */
			delete_column(from_, to?): Promise<any>
			delete_column$({ from_, to }: { from_, to?}): Promise<any>

			/**
			 * If any cell is being edited, de-highlight the cell  and  applies
			 *         the changes.
			 */
			edit_apply(): Promise<any>
			edit_apply$($: {}): Promise<any>

			/**
			 * Highlights  the  cell  at  (x, y) for editing, if the -editnotify
			 *         command returns True for this cell.
			 */
			edit_set(x, y): Promise<any>
			edit_set$({ x, y }): Promise<any>

			/**
			 * Get the option value for cell at (x,y)
			 */
			entrycget(x, y, option): Promise<any>
			entrycget$({ x, y, option }): Promise<any>
			entryconfigure(x, y, cnf?): Promise<any>
			entryconfigure$({ x, y, cnf }: { x, y, cnf?}): Promise<any>

			/**
			 * Return True if display item exists at (x,y)
			 */
			info_exists(x, y): Promise<any>
			info_exists$({ x, y }): Promise<any>
			info_bbox(x, y): Promise<any>
			info_bbox$({ x, y }): Promise<any>

			/**
			 * Moves the range of columns from position FROM through TO by
			 *         the distance indicated by OFFSET. For example, move_column(2, 4, 1)
			 *         moves the columns 2,3,4 to columns 3,4,5.
			 */
			move_column(from_, to, offset): Promise<any>
			move_column$({ from_, to, offset }): Promise<any>

			/**
			 * Moves the range of rows from position FROM through TO by
			 *         the distance indicated by OFFSET.
			 *         For example, move_row(2, 4, 1) moves the rows 2,3,4 to rows 3,4,5.
			 */
			move_row(from_, to, offset): Promise<any>
			move_row$({ from_, to, offset }): Promise<any>

			/**
			 * Return coordinate of cell nearest pixel coordinate (x,y)
			 */
			nearest(x, y): Promise<any>
			nearest$({ x, y }): Promise<any>
			set(x, y, itemtype?): Promise<any>
			set$({ x, y, itemtype }: { x, y, itemtype?}): Promise<any>

			/**
			 * Queries or sets the size of the column given by
			 *         INDEX.  INDEX may be any non-negative
			 *         integer that gives the position of a given column.
			 *         INDEX can also be the string "default"; in this case, this command
			 *         queries or sets the default size of all columns.
			 *         When no option-value pair is given, this command returns a tuple
			 *         containing the current size setting of the given column.  When
			 *         option-value pairs are given, the corresponding options of the
			 *         size setting of the given column are changed. Options may be one
			 *         of the following:
			 *               pad0 pixels
			 *                      Specifies the paddings to the left of a column.
			 *               pad1 pixels
			 *                      Specifies the paddings to the right of a column.
			 *               size val
			 *                      Specifies the width of a column.  Val may be:
			 *                      "auto" -- the width of the column is set to the
			 *                      width of the widest cell in the column;
			 *                      a valid Tk screen distance unit;
			 *                      or a real number following by the word chars
			 *                      (e.g. 3.4chars) that sets the width of the column to the
			 *                      given number of characters.
			 */
			size_column(index): Promise<any>
			size_column$({ index }): Promise<any>

			/**
			 * Queries or sets the size of the row given by
			 *         INDEX. INDEX may be any non-negative
			 *         integer that gives the position of a given row .
			 *         INDEX can also be the string "default"; in this case, this command
			 *         queries or sets the default size of all rows.
			 *         When no option-value pair is given, this command returns a list con-
			 *         taining the current size setting of the given row . When option-value
			 *         pairs are given, the corresponding options of the size setting of the
			 *         given row are changed. Options may be one of the following:
			 *               pad0 pixels
			 *                      Specifies the paddings to the top of a row.
			 *               pad1 pixels
			 *                      Specifies the paddings to the bottom of a row.
			 *               size val
			 *                      Specifies the height of a row.  Val may be:
			 *                      "auto" -- the height of the row is set to the
			 *                      height of the highest cell in the row;
			 *                      a valid Tk screen distance unit;
			 *                      or a real number following by the word chars
			 *                      (e.g. 3.4chars) that sets the height of the row to the
			 *                      given number of characters.
			 */
			size_row(index): Promise<any>
			size_row$({ index }): Promise<any>

			/**
			 * Clears the cell at (x, y) by removing its display item.
			 */
			unset(x, y): Promise<any>
			unset$({ x, y }): Promise<any>
		}

		/**
		 * Scrolled Grid widgets
		 */
		function ScrolledGrid(master?, cnf?): Promise<IScrolledGrid>
		function ScrolledGrid$({ master, cnf }: { master?, cnf?}): Promise<IScrolledGrid>
		interface IScrolledGrid extends IGrid {
		}
		let WINDOW: Promise<any>
		let TEXT: Promise<any>
		let STATUS: Promise<any>
		let IMMEDIATE: Promise<any>
		let IMAGE: Promise<any>
		let IMAGETEXT: Promise<any>
		let BALLOON: Promise<any>
		let AUTO: Promise<any>
		let ACROSSTOP: Promise<any>
		let ASCII: Promise<any>
		let CELL: Promise<any>
		let COLUMN: Promise<any>
		let DECREASING: Promise<any>
		let INCREASING: Promise<any>
		let INTEGER: Promise<any>
		let MAIN: Promise<any>
		let MAX: Promise<any>
		let REAL: Promise<any>
		let ROW: Promise<any>
		let S_REGION: Promise<any>
		let X_REGION: Promise<any>
		let Y_REGION: Promise<any>
		let TCL_DONT_WAIT: Promise<any>
		let TCL_WINDOW_EVENTS: Promise<any>
		let TCL_FILE_EVENTS: Promise<any>
		let TCL_TIMER_EVENTS: Promise<any>
		let TCL_IDLE_EVENTS: Promise<any>
		let TCL_ALL_EVENTS: Promise<any>
	}
	module ttk {
		var _

		/**
		 * Returns adict with its values converted from Tcl objects to Python
		 *     objects.
		 */
		function tclobjs_to_py(adict): Promise<any>
		function tclobjs_to_py$({ adict }): Promise<any>

		/**
		 * If master is not None, itself is returned. If master is None,
		 *     the default master is returned if there is one, otherwise a new
		 *     master is created and returned.
		 * 
		 *     If it is not allowed to use the default root and master is None,
		 *     RuntimeError is raised.
		 */
		function setup_master(master?): Promise<any>
		function setup_master$({ master }: { master?}): Promise<any>

		/**
		 * Manipulate style database.
		 */
		function Style(master?): Promise<IStyle>
		function Style$({ master }: { master?}): Promise<IStyle>
		interface IStyle {

			/**
			 * Query or sets the default value of the specified option(s) in
			 *         style.
			 * 
			 *         Each key in kw is an option and each value is either a string or
			 *         a sequence identifying the value for that option.
			 */
			configure(style, query_opt?): Promise<any>
			configure$({ style, query_opt }: { style, query_opt?}): Promise<any>

			/**
			 * Query or sets dynamic values of the specified option(s) in
			 *         style.
			 * 
			 *         Each key in kw is an option and each value should be a list or a
			 *         tuple (usually) containing statespecs grouped in tuples, or list,
			 *         or something else of your preference. A statespec is compound of
			 *         one or more states and then a value.
			 */
			map(style, query_opt?): Promise<any>
			map$({ style, query_opt }: { style, query_opt?}): Promise<any>

			/**
			 * Returns the value specified for option in style.
			 * 
			 *         If state is specified it is expected to be a sequence of one
			 *         or more states. If the default argument is set, it is used as
			 *         a fallback value in case no specification for option is found.
			 */
			lookup(style, option, state?, def?): Promise<any>
			lookup$({ style, option, state, def }: { style, option, state?, def?}): Promise<any>

			/**
			 * Define the widget layout for given style. If layoutspec is
			 *         omitted, return the layout specification for given style.
			 * 
			 *         layoutspec is expected to be a list or an object different than
			 *         None that evaluates to False if you want to "turn off" that style.
			 *         If it is a list (or tuple, or something else), each item should be
			 *         a tuple where the first item is the layout name and the second item
			 *         should have the format described below:
			 * 
			 *         LAYOUTS
			 * 
			 *             A layout can contain the value None, if takes no options, or
			 *             a dict of options specifying how to arrange the element.
			 *             The layout mechanism uses a simplified version of the pack
			 *             geometry manager: given an initial cavity, each element is
			 *             allocated a parcel. Valid options/values are:
			 * 
			 *                 side: whichside
			 *                     Specifies which side of the cavity to place the
			 *                     element; one of top, right, bottom or left. If
			 *                     omitted, the element occupies the entire cavity.
			 * 
			 *                 sticky: nswe
			 *                     Specifies where the element is placed inside its
			 *                     allocated parcel.
			 * 
			 *                 children: [sublayout... ]
			 *                     Specifies a list of elements to place inside the
			 *                     element. Each element is a tuple (or other sequence)
			 *                     where the first item is the layout name, and the other
			 *                     is a LAYOUT.
			 */
			layout(style, layoutspec?): Promise<any>
			layout$({ style, layoutspec }: { style, layoutspec?}): Promise<any>

			/**
			 * Create a new element in the current theme of given etype.
			 */
			element_create(elementname, etype): Promise<any>
			element_create$({ elementname, etype }): Promise<any>

			/**
			 * Returns the list of elements defined in the current theme.
			 */
			element_names(): Promise<any>
			element_names$($: {}): Promise<any>

			/**
			 * Return the list of elementname's options.
			 */
			element_options(elementname): Promise<any>
			element_options$({ elementname }): Promise<any>

			/**
			 * Creates a new theme.
			 * 
			 *         It is an error if themename already exists. If parent is
			 *         specified, the new theme will inherit styles, elements and
			 *         layouts from the specified parent theme. If settings are present,
			 *         they are expected to have the same syntax used for theme_settings.
			 */
			theme_create(themename, parent?, settings?): Promise<any>
			theme_create$({ themename, parent, settings }: { themename, parent?, settings?}): Promise<any>

			/**
			 * Temporarily sets the current theme to themename, apply specified
			 *         settings and then restore the previous theme.
			 * 
			 *         Each key in settings is a style and each value may contain the
			 *         keys 'configure', 'map', 'layout' and 'element create' and they
			 *         are expected to have the same format as specified by the methods
			 *         configure, map, layout and element_create respectively.
			 */
			theme_settings(themename, settings): Promise<any>
			theme_settings$({ themename, settings }): Promise<any>

			/**
			 * Returns a list of all known themes.
			 */
			theme_names(): Promise<any>
			theme_names$($: {}): Promise<any>

			/**
			 * If themename is None, returns the theme in use, otherwise, set
			 *         the current theme to themename, refreshes all widgets and emits
			 *         a <<ThemeChanged>> event.
			 */
			theme_use(themename?): Promise<any>
			theme_use$({ themename }: { themename?}): Promise<any>
		}

		/**
		 * Base class for Tk themed widgets.
		 */

		/**
		 * Constructs a Ttk Widget with the parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, cursor, takefocus, style
		 * 
		 *         SCROLLABLE WIDGET OPTIONS
		 * 
		 *             xscrollcommand, yscrollcommand
		 * 
		 *         LABEL WIDGET OPTIONS
		 * 
		 *             text, textvariable, underline, image, compound, width
		 * 
		 *         WIDGET STATES
		 * 
		 *             active, disabled, focus, pressed, selected, background,
		 *             readonly, alternate, invalid
		 *         
		 */
		function Widget(master, widgetname, kw?): Promise<IWidget>
		function Widget$({ master, widgetname, kw }: { master, widgetname, kw?}): Promise<IWidget>
		interface IWidget {

			/**
			 * Returns the name of the element at position x, y, or the empty
			 *         string if the point does not lie within any element.
			 * 
			 *         x and y are pixel coordinates relative to the widget.
			 */
			identify(x, y): Promise<any>
			identify$({ x, y }): Promise<any>

			/**
			 * Test the widget's state.
			 * 
			 *         If callback is not specified, returns True if the widget state
			 *         matches statespec and False otherwise. If callback is specified,
			 *         then it will be invoked with *args, **kw if the widget state
			 *         matches statespec. statespec is expected to be a sequence.
			 */
			instate(statespec, callback?): Promise<any>
			instate$({ statespec, callback }: { statespec, callback?}): Promise<any>

			/**
			 * Modify or inquire widget state.
			 * 
			 *         Widget state is returned if statespec is None, otherwise it is
			 *         set according to the statespec flags and then a new state spec
			 *         is returned indicating which flags were changed. statespec is
			 *         expected to be a sequence.
			 */
			state(statespec?): Promise<any>
			state$({ statespec }: { statespec?}): Promise<any>
		}

		/**
		 * Ttk Button widget, displays a textual label and/or image, and
		 *     evaluates a command when pressed.
		 */

		/**
		 * Construct a Ttk Button widget with the parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, compound, cursor, image, state, style, takefocus,
		 *             text, textvariable, underline, width
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             command, default, width
		 *         
		 */
		function Button(master?): Promise<IButton>
		function Button$({ master }: { master?}): Promise<IButton>
		interface IButton extends IWidget {

			/**
			 * Invokes the command associated with the button.
			 */
			invoke(): Promise<any>
			invoke$($: {}): Promise<any>
		}

		/**
		 * Ttk Checkbutton widget which is either in on- or off-state.
		 */

		/**
		 * Construct a Ttk Checkbutton widget with the parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, compound, cursor, image, state, style, takefocus,
		 *             text, textvariable, underline, width
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             command, offvalue, onvalue, variable
		 *         
		 */
		function Checkbutton(master?): Promise<ICheckbutton>
		function Checkbutton$({ master }: { master?}): Promise<ICheckbutton>
		interface ICheckbutton extends IWidget {

			/**
			 * Toggles between the selected and deselected states and
			 *         invokes the associated command. If the widget is currently
			 *         selected, sets the option variable to the offvalue option
			 *         and deselects the widget; otherwise, sets the option variable
			 *         to the option onvalue.
			 * 
			 *         Returns the result of the associated command.
			 */
			invoke(): Promise<any>
			invoke$($: {}): Promise<any>
		}

		/**
		 * Ttk Entry widget displays a one-line text string and allows that
		 *     string to be edited by the user.
		 */

		/**
		 * Constructs a Ttk Entry widget with the parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, cursor, style, takefocus, xscrollcommand
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             exportselection, invalidcommand, justify, show, state,
		 *             textvariable, validate, validatecommand, width
		 * 
		 *         VALIDATION MODES
		 * 
		 *             none, key, focus, focusin, focusout, all
		 *         
		 */
		function Entry(master?, widget?): Promise<IEntry>
		function Entry$({ master, widget }: { master?, widget?}): Promise<IEntry>
		interface IEntry extends IWidget {

			/**
			 * Return a tuple of (x, y, width, height) which describes the
			 *         bounding box of the character given by index.
			 */
			bbox(index): Promise<any>
			bbox$({ index }): Promise<any>

			/**
			 * Returns the name of the element at position x, y, or the
			 *         empty string if the coordinates are outside the window.
			 */
			identify(x, y): Promise<any>
			identify$({ x, y }): Promise<any>

			/**
			 * Force revalidation, independent of the conditions specified
			 *         by the validate option. Returns False if validation fails, True
			 *         if it succeeds. Sets or clears the invalid state accordingly.
			 */
			validate(): Promise<any>
			validate$($: {}): Promise<any>
		}

		/**
		 * Ttk Combobox widget combines a text field with a pop-down list of
		 *     values.
		 */

		/**
		 * Construct a Ttk Combobox widget with the parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, cursor, style, takefocus
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             exportselection, justify, height, postcommand, state,
		 *             textvariable, values, width
		 *         
		 */
		function Combobox(master?): Promise<ICombobox>
		function Combobox$({ master }: { master?}): Promise<ICombobox>
		interface ICombobox extends IEntry {

			/**
			 * If newindex is supplied, sets the combobox value to the
			 *         element at position newindex in the list of values. Otherwise,
			 *         returns the index of the current value in the list of values
			 *         or -1 if the current value does not appear in the list.
			 */
			current(newindex?): Promise<any>
			current$({ newindex }: { newindex?}): Promise<any>

			/**
			 * Sets the value of the combobox to value.
			 */
			set(value): Promise<any>
			set$({ value }): Promise<any>
		}

		/**
		 * Ttk Frame widget is a container, used to group other widgets
		 *     together.
		 */

		/**
		 * Construct a Ttk Frame with parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, cursor, style, takefocus
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             borderwidth, relief, padding, width, height
		 *         
		 */
		function Frame(master?): Promise<IFrame>
		function Frame$({ master }: { master?}): Promise<IFrame>
		interface IFrame extends IWidget {
		}

		/**
		 * Ttk Label widget displays a textual label and/or image.
		 */

		/**
		 * Construct a Ttk Label with parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, compound, cursor, image, style, takefocus, text,
		 *             textvariable, underline, width
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             anchor, background, font, foreground, justify, padding,
		 *             relief, text, wraplength
		 *         
		 */
		function Label(master?): Promise<ILabel>
		function Label$({ master }: { master?}): Promise<ILabel>
		interface ILabel extends IWidget {
		}

		/**
		 * Ttk Labelframe widget is a container used to group other widgets
		 *     together. It has an optional label, which may be a plain text string
		 *     or another widget.
		 */

		/**
		 * Construct a Ttk Labelframe with parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, cursor, style, takefocus
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 *             labelanchor, text, underline, padding, labelwidget, width,
		 *             height
		 *         
		 */
		function Labelframe(master?): Promise<ILabelframe>
		function Labelframe$({ master }: { master?}): Promise<ILabelframe>
		interface ILabelframe extends IWidget {
		}

		/**
		 * Ttk Menubutton widget displays a textual label and/or image, and
		 *     displays a menu when pressed.
		 */

		/**
		 * Construct a Ttk Menubutton with parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, compound, cursor, image, state, style, takefocus,
		 *             text, textvariable, underline, width
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             direction, menu
		 *         
		 */
		function Menubutton(master?): Promise<IMenubutton>
		function Menubutton$({ master }: { master?}): Promise<IMenubutton>
		interface IMenubutton extends IWidget {
		}

		/**
		 * Ttk Notebook widget manages a collection of windows and displays
		 *     a single one at a time. Each child window is associated with a tab,
		 *     which the user may select to change the currently-displayed window.
		 */

		/**
		 * Construct a Ttk Notebook with parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, cursor, style, takefocus
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             height, padding, width
		 * 
		 *         TAB OPTIONS
		 * 
		 *             state, sticky, padding, text, image, compound, underline
		 * 
		 *         TAB IDENTIFIERS (tab_id)
		 * 
		 *             The tab_id argument found in several methods may take any of
		 *             the following forms:
		 * 
		 *                 * An integer between zero and the number of tabs
		 *                 * The name of a child window
		 *                 * A positional specification of the form "@x,y", which
		 *                   defines the tab
		 *                 * The string "current", which identifies the
		 *                   currently-selected tab
		 *                 * The string "end", which returns the number of tabs (only
		 *                   valid for method index)
		 *         
		 */
		function Notebook(master?): Promise<INotebook>
		function Notebook$({ master }: { master?}): Promise<INotebook>
		interface INotebook extends IWidget {

			/**
			 * Adds a new tab to the notebook.
			 * 
			 *         If window is currently managed by the notebook but hidden, it is
			 *         restored to its previous position.
			 */
			add(child): Promise<any>
			add$({ child }): Promise<any>

			/**
			 * Removes the tab specified by tab_id, unmaps and unmanages the
			 *         associated window.
			 */
			forget(tab_id): Promise<any>
			forget$({ tab_id }): Promise<any>

			/**
			 * Hides the tab specified by tab_id.
			 * 
			 *         The tab will not be displayed, but the associated window remains
			 *         managed by the notebook and its configuration remembered. Hidden
			 *         tabs may be restored with the add command.
			 */
			hide(tab_id): Promise<any>
			hide$({ tab_id }): Promise<any>

			/**
			 * Returns the name of the tab element at position x, y, or the
			 *         empty string if none.
			 */
			identify(x, y): Promise<any>
			identify$({ x, y }): Promise<any>

			/**
			 * Returns the numeric index of the tab specified by tab_id, or
			 *         the total number of tabs if tab_id is the string "end".
			 */
			index(tab_id): Promise<any>
			index$({ tab_id }): Promise<any>

			/**
			 * Inserts a pane at the specified position.
			 * 
			 *         pos is either the string end, an integer index, or the name of
			 *         a managed child. If child is already managed by the notebook,
			 *         moves it to the specified position.
			 */
			insert(pos, child): Promise<any>
			insert$({ pos, child }): Promise<any>

			/**
			 * Selects the specified tab.
			 * 
			 *         The associated child window will be displayed, and the
			 *         previously-selected window (if different) is unmapped. If tab_id
			 *         is omitted, returns the widget name of the currently selected
			 *         pane.
			 */
			select(tab_id?): Promise<any>
			select$({ tab_id }: { tab_id?}): Promise<any>

			/**
			 * Query or modify the options of the specific tab_id.
			 * 
			 *         If kw is not given, returns a dict of the tab option values. If option
			 *         is specified, returns the value of that option. Otherwise, sets the
			 *         options to the corresponding values.
			 */
			tab(tab_id, option?): Promise<any>
			tab$({ tab_id, option }: { tab_id, option?}): Promise<any>

			/**
			 * Returns a list of windows managed by the notebook.
			 */
			tabs(): Promise<any>
			tabs$($: {}): Promise<any>

			/**
			 * Enable keyboard traversal for a toplevel window containing
			 *         this notebook.
			 * 
			 *         This will extend the bindings for the toplevel window containing
			 *         this notebook as follows:
			 * 
			 *             Control-Tab: selects the tab following the currently selected
			 *                          one
			 * 
			 *             Shift-Control-Tab: selects the tab preceding the currently
			 *                                selected one
			 * 
			 *             Alt-K: where K is the mnemonic (underlined) character of any
			 *                    tab, will select that tab.
			 * 
			 *         Multiple notebooks in a single toplevel may be enabled for
			 *         traversal, including nested notebooks. However, notebook traversal
			 *         only works properly if all panes are direct children of the
			 *         notebook.
			 */
			enable_traversal(): Promise<any>
			enable_traversal$($: {}): Promise<any>
		}

		/**
		 * Ttk Panedwindow widget displays a number of subwindows, stacked
		 *     either vertically or horizontally.
		 */

		/**
		 * Construct a Ttk Panedwindow with parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, cursor, style, takefocus
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             orient, width, height
		 * 
		 *         PANE OPTIONS
		 * 
		 *             weight
		 *         
		 */
		function Panedwindow(master?): Promise<IPanedwindow>
		function Panedwindow$({ master }: { master?}): Promise<IPanedwindow>
		interface IPanedwindow extends IWidget {

			/**
			 * Inserts a pane at the specified positions.
			 * 
			 *         pos is either the string end, and integer index, or the name
			 *         of a child. If child is already managed by the paned window,
			 *         moves it to the specified position.
			 */
			insert(pos, child): Promise<any>
			insert$({ pos, child }): Promise<any>

			/**
			 * Query or modify the options of the specified pane.
			 * 
			 *         pane is either an integer index or the name of a managed subwindow.
			 *         If kw is not given, returns a dict of the pane option values. If
			 *         option is specified then the value for that option is returned.
			 *         Otherwise, sets the options to the corresponding values.
			 */
			pane(pane, option?): Promise<any>
			pane$({ pane, option }: { pane, option?}): Promise<any>

			/**
			 * If newpos is specified, sets the position of sash number index.
			 * 
			 *         May adjust the positions of adjacent sashes to ensure that
			 *         positions are monotonically increasing. Sash positions are further
			 *         constrained to be between 0 and the total size of the widget.
			 * 
			 *         Returns the new position of sash number index.
			 */
			sashpos(index, newpos?): Promise<any>
			sashpos$({ index, newpos }: { index, newpos?}): Promise<any>
		}

		/**
		 * Ttk Progressbar widget shows the status of a long-running
		 *     operation. They can operate in two modes: determinate mode shows the
		 *     amount completed relative to the total amount of work to be done, and
		 *     indeterminate mode provides an animated display to let the user know
		 *     that something is happening.
		 */

		/**
		 * Construct a Ttk Progressbar with parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, cursor, style, takefocus
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             orient, length, mode, maximum, value, variable, phase
		 *         
		 */
		function Progressbar(master?): Promise<IProgressbar>
		function Progressbar$({ master }: { master?}): Promise<IProgressbar>
		interface IProgressbar extends IWidget {

			/**
			 * Begin autoincrement mode: schedules a recurring timer event
			 *         that calls method step every interval milliseconds.
			 * 
			 *         interval defaults to 50 milliseconds (20 steps/second) if omitted.
			 */
			start(interval?): Promise<any>
			start$({ interval }: { interval?}): Promise<any>

			/**
			 * Increments the value option by amount.
			 * 
			 *         amount defaults to 1.0 if omitted.
			 */
			step(amount?): Promise<any>
			step$({ amount }: { amount?}): Promise<any>

			/**
			 * Stop autoincrement mode: cancels any recurring timer event
			 *         initiated by start.
			 */
			stop(): Promise<any>
			stop$($: {}): Promise<any>
		}

		/**
		 * Ttk Radiobutton widgets are used in groups to show or change a
		 *     set of mutually-exclusive options.
		 */

		/**
		 * Construct a Ttk Radiobutton with parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, compound, cursor, image, state, style, takefocus,
		 *             text, textvariable, underline, width
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             command, value, variable
		 *         
		 */
		function Radiobutton(master?): Promise<IRadiobutton>
		function Radiobutton$({ master }: { master?}): Promise<IRadiobutton>
		interface IRadiobutton extends IWidget {

			/**
			 * Sets the option variable to the option value, selects the
			 *         widget, and invokes the associated command.
			 * 
			 *         Returns the result of the command, or an empty string if
			 *         no command is specified.
			 */
			invoke(): Promise<any>
			invoke$($: {}): Promise<any>
		}

		/**
		 * Ttk Scale widget is typically used to control the numeric value of
		 *     a linked variable that varies uniformly over some range.
		 */

		/**
		 * Construct a Ttk Scale with parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, cursor, style, takefocus
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             command, from, length, orient, to, value, variable
		 *         
		 */
		function Scale(master?): Promise<IScale>
		function Scale$({ master }: { master?}): Promise<IScale>
		interface IScale extends IWidget {

			/**
			 * Modify or query scale options.
			 * 
			 *         Setting a value for any of the "from", "from_" or "to" options
			 *         generates a <<RangeChanged>> event.
			 */
			configure(cnf?): Promise<any>
			configure$({ cnf }: { cnf?}): Promise<any>

			/**
			 * Get the current value of the value option, or the value
			 *         corresponding to the coordinates x, y if they are specified.
			 * 
			 *         x and y are pixel coordinates relative to the scale widget
			 *         origin.
			 */
			get(x?, y?): Promise<any>
			get$({ x, y }: { x?, y?}): Promise<any>
		}

		/**
		 * Ttk Scrollbar controls the viewport of a scrollable widget.
		 */

		/**
		 * Construct a Ttk Scrollbar with parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, cursor, style, takefocus
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             command, orient
		 *         
		 */
		function Scrollbar(master?): Promise<IScrollbar>
		function Scrollbar$({ master }: { master?}): Promise<IScrollbar>
		interface IScrollbar extends IWidget {
		}

		/**
		 * Ttk Separator widget displays a horizontal or vertical separator
		 *     bar.
		 */

		/**
		 * Construct a Ttk Separator with parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, cursor, style, takefocus
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             orient
		 *         
		 */
		function Separator(master?): Promise<ISeparator>
		function Separator$({ master }: { master?}): Promise<ISeparator>
		interface ISeparator extends IWidget {
		}

		/**
		 * Ttk Sizegrip allows the user to resize the containing toplevel
		 *     window by pressing and dragging the grip.
		 */

		/**
		 * Construct a Ttk Sizegrip with parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, cursor, state, style, takefocus
		 *         
		 */
		function Sizegrip(master?): Promise<ISizegrip>
		function Sizegrip$({ master }: { master?}): Promise<ISizegrip>
		interface ISizegrip extends IWidget {
		}

		/**
		 * Ttk Spinbox is an Entry with increment and decrement arrows
		 * 
		 *     It is commonly used for number entry or to select from a list of
		 *     string values.
		 *     
		 */

		/**
		 * Construct a Ttk Spinbox widget with the parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, cursor, style, takefocus, validate,
		 *             validatecommand, xscrollcommand, invalidcommand
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             to, from_, increment, values, wrap, format, command
		 *         
		 */
		function Spinbox(master?): Promise<ISpinbox>
		function Spinbox$({ master }: { master?}): Promise<ISpinbox>
		interface ISpinbox extends IEntry {

			/**
			 * Sets the value of the Spinbox to value.
			 */
			set(value): Promise<any>
			set$({ value }): Promise<any>
		}

		/**
		 * Ttk Treeview widget displays a hierarchical collection of items.
		 * 
		 *     Each item has a textual label, an optional image, and an optional list
		 *     of data values. The data values are displayed in successive columns
		 *     after the tree label.
		 */

		/**
		 * Construct a Ttk Treeview with parent master.
		 * 
		 *         STANDARD OPTIONS
		 * 
		 *             class, cursor, style, takefocus, xscrollcommand,
		 *             yscrollcommand
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             columns, displaycolumns, height, padding, selectmode, show
		 * 
		 *         ITEM OPTIONS
		 * 
		 *             text, image, values, open, tags
		 * 
		 *         TAG OPTIONS
		 * 
		 *             foreground, background, font, image
		 *         
		 */
		function Treeview(master?): Promise<ITreeview>
		function Treeview$({ master }: { master?}): Promise<ITreeview>
		interface ITreeview extends IWidget {

			/**
			 * Returns the bounding box (relative to the treeview widget's
			 *         window) of the specified item in the form x y width height.
			 * 
			 *         If column is specified, returns the bounding box of that cell.
			 *         If the item is not visible (i.e., if it is a descendant of a
			 *         closed item or is scrolled offscreen), returns an empty string.
			 */
			bbox(item, column?): Promise<any>
			bbox$({ item, column }: { item, column?}): Promise<any>

			/**
			 * Returns a tuple of children belonging to item.
			 * 
			 *         If item is not specified, returns root children.
			 */
			get_children(item?): Promise<any>
			get_children$({ item }: { item?}): Promise<any>

			/**
			 * Replaces item's child with newchildren.
			 * 
			 *         Children present in item that are not present in newchildren
			 *         are detached from tree. No items in newchildren may be an
			 *         ancestor of item.
			 */
			set_children(item): Promise<any>
			set_children$({ item }): Promise<any>

			/**
			 * Query or modify the options for the specified column.
			 * 
			 *         If kw is not given, returns a dict of the column option values. If
			 *         option is specified then the value for that option is returned.
			 *         Otherwise, sets the options to the corresponding values.
			 */
			column(column, option?): Promise<any>
			column$({ column, option }: { column, option?}): Promise<any>

			/**
			 * Delete all specified items and all their descendants. The root
			 *         item may not be deleted.
			 */
			delete(): Promise<any>
			delete$($: {}): Promise<any>

			/**
			 * Unlinks all of the specified items from the tree.
			 * 
			 *         The items and all of their descendants are still present, and may
			 *         be reinserted at another point in the tree, but will not be
			 *         displayed. The root item may not be detached.
			 */
			detach(): Promise<any>
			detach$($: {}): Promise<any>

			/**
			 * Returns True if the specified item is present in the tree,
			 *         False otherwise.
			 */
			exists(item): Promise<any>
			exists$({ item }): Promise<any>

			/**
			 * If item is specified, sets the focus item to item. Otherwise,
			 *         returns the current focus item, or '' if there is none.
			 */
			focus(item?): Promise<any>
			focus$({ item }: { item?}): Promise<any>

			/**
			 * Query or modify the heading options for the specified column.
			 * 
			 *         If kw is not given, returns a dict of the heading option values. If
			 *         option is specified then the value for that option is returned.
			 *         Otherwise, sets the options to the corresponding values.
			 * 
			 *         Valid options/values are:
			 *             text: text
			 *                 The text to display in the column heading
			 *             image: image_name
			 *                 Specifies an image to display to the right of the column
			 *                 heading
			 *             anchor: anchor
			 *                 Specifies how the heading text should be aligned. One of
			 *                 the standard Tk anchor values
			 *             command: callback
			 *                 A callback to be invoked when the heading label is
			 *                 pressed.
			 * 
			 *         To configure the tree column heading, call this with column = "#0" 
			 */
			heading(column, option?): Promise<any>
			heading$({ column, option }: { column, option?}): Promise<any>

			/**
			 * Returns a description of the specified component under the
			 *         point given by x and y, or the empty string if no such component
			 *         is present at that position.
			 */
			identify(component, x, y): Promise<any>
			identify$({ component, x, y }): Promise<any>

			/**
			 * Returns the item ID of the item at position y.
			 */
			identify_row(y): Promise<any>
			identify_row$({ y }): Promise<any>

			/**
			 * Returns the data column identifier of the cell at position x.
			 * 
			 *         The tree column has ID #0.
			 */
			identify_column(x): Promise<any>
			identify_column$({ x }): Promise<any>

			/**
			 * Returns one of:
			 * 
			 *         heading: Tree heading area.
			 *         separator: Space between two columns headings;
			 *         tree: The tree area.
			 *         cell: A data cell.
			 * 
			 *         * Availability: Tk 8.6
			 */
			identify_region(x, y): Promise<any>
			identify_region$({ x, y }): Promise<any>

			/**
			 * Returns the element at position x, y.
			 * 
			 *         * Availability: Tk 8.6
			 */
			identify_element(x, y): Promise<any>
			identify_element$({ x, y }): Promise<any>

			/**
			 * Returns the integer index of item within its parent's list
			 *         of children.
			 */
			index(item): Promise<any>
			index$({ item }): Promise<any>

			/**
			 * Creates a new item and return the item identifier of the newly
			 *         created item.
			 * 
			 *         parent is the item ID of the parent item, or the empty string
			 *         to create a new top-level item. index is an integer, or the value
			 *         end, specifying where in the list of parent's children to insert
			 *         the new item. If index is less than or equal to zero, the new node
			 *         is inserted at the beginning, if index is greater than or equal to
			 *         the current number of children, it is inserted at the end. If iid
			 *         is specified, it is used as the item identifier, iid must not
			 *         already exist in the tree. Otherwise, a new unique identifier
			 *         is generated.
			 */
			insert(parent, index, iid?): Promise<any>
			insert$({ parent, index, iid }: { parent, index, iid?}): Promise<any>

			/**
			 * Query or modify the options for the specified item.
			 * 
			 *         If no options are given, a dict with options/values for the item
			 *         is returned. If option is specified then the value for that option
			 *         is returned. Otherwise, sets the options to the corresponding
			 *         values as given by kw.
			 */
			item(item, option?): Promise<any>
			item$({ item, option }: { item, option?}): Promise<any>

			/**
			 * Moves item to position index in parent's list of children.
			 * 
			 *         It is illegal to move an item under one of its descendants. If
			 *         index is less than or equal to zero, item is moved to the
			 *         beginning, if greater than or equal to the number of children,
			 *         it is moved to the end. If item was detached it is reattached.
			 */
			move(item, parent, index): Promise<any>
			move$({ item, parent, index }): Promise<any>

			/**
			 * Returns the identifier of item's next sibling, or '' if item
			 *         is the last child of its parent.
			 */
			next(item): Promise<any>
			next$({ item }): Promise<any>

			/**
			 * Returns the ID of the parent of item, or '' if item is at the
			 *         top level of the hierarchy.
			 */
			parent(item): Promise<any>
			parent$({ item }): Promise<any>

			/**
			 * Returns the identifier of item's previous sibling, or '' if
			 *         item is the first child of its parent.
			 */
			prev(item): Promise<any>
			prev$({ item }): Promise<any>

			/**
			 * Ensure that item is visible.
			 * 
			 *         Sets all of item's ancestors open option to True, and scrolls
			 *         the widget if necessary so that item is within the visible
			 *         portion of the tree.
			 */
			see(item): Promise<any>
			see$({ item }): Promise<any>

			/**
			 * Returns the tuple of selected items.
			 */
			selection(): Promise<any>
			selection$($: {}): Promise<any>

			/**
			 * The specified items becomes the new selection.
			 */
			selection_set(): Promise<any>
			selection_set$($: {}): Promise<any>

			/**
			 * Add all of the specified items to the selection.
			 */
			selection_add(): Promise<any>
			selection_add$($: {}): Promise<any>

			/**
			 * Remove all of the specified items from the selection.
			 */
			selection_remove(): Promise<any>
			selection_remove$($: {}): Promise<any>

			/**
			 * Toggle the selection state of each specified item.
			 */
			selection_toggle(): Promise<any>
			selection_toggle$($: {}): Promise<any>

			/**
			 * Query or set the value of given item.
			 * 
			 *         With one argument, return a dictionary of column/value pairs
			 *         for the specified item. With two arguments, return the current
			 *         value of the specified column. With three arguments, set the
			 *         value of given column in given item to the specified value.
			 */
			set(item, column?, value?): Promise<any>
			set$({ item, column, value }: { item, column?, value?}): Promise<any>

			/**
			 * Bind a callback for the given event sequence to the tag tagname.
			 *         When an event is delivered to an item, the callbacks for each
			 *         of the item's tags option are called.
			 */
			tag_bind(tagname, sequence?, callback?): Promise<any>
			tag_bind$({ tagname, sequence, callback }: { tagname, sequence?, callback?}): Promise<any>

			/**
			 * Query or modify the options for the specified tagname.
			 * 
			 *         If kw is not given, returns a dict of the option settings for tagname.
			 *         If option is specified, returns the value for that option for the
			 *         specified tagname. Otherwise, sets the options to the corresponding
			 *         values for the given tagname.
			 */
			tag_configure(tagname, option?): Promise<any>
			tag_configure$({ tagname, option }: { tagname, option?}): Promise<any>

			/**
			 * If item is specified, returns 1 or 0 depending on whether the
			 *         specified item has the given tagname. Otherwise, returns a list of
			 *         all items which have the specified tag.
			 * 
			 *         * Availability: Tk 8.6
			 */
			tag_has(tagname, item?): Promise<any>
			tag_has$({ tagname, item }: { tagname, item?}): Promise<any>
			reattach
		}

		/**
		 * A Ttk Scale widget with a Ttk Label widget indicating its
		 *     current value.
		 * 
		 *     The Ttk Scale can be accessed through instance.scale, and Ttk Label
		 *     can be accessed through instance.label
		 */

		/**
		 * Construct a horizontal LabeledScale with parent master, a
		 *         variable to be associated with the Ttk Scale widget and its range.
		 *         If variable is not specified, a tkinter.IntVar is created.
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             compound: 'top' or 'bottom'
		 *                 Specifies how to display the label relative to the scale.
		 *                 Defaults to 'top'.
		 *         
		 */
		function LabeledScale(master?, variable?, from_?, to?): Promise<ILabeledScale>
		function LabeledScale$({ master, variable, from_, to }: { master?, variable?, from_?, to?}): Promise<ILabeledScale>
		interface ILabeledScale extends IFrame {

			/**
			 * Destroy this widget and possibly its associated variable.
			 */
			destroy(): Promise<any>
			destroy$($: {}): Promise<any>

			/**
			 * Return current scale value.
			 */
			value(): Promise<any>
			value$($: {}): Promise<any>

			/**
			 * Set new scale value.
			 */
			value(val): Promise<any>
			value$({ val }): Promise<any>
		}

		/**
		 * Themed OptionMenu, based after tkinter's OptionMenu, which allows
		 *     the user to select a value from a menu.
		 */

		/**
		 * Construct a themed OptionMenu widget with master as the parent,
		 *         the resource textvariable set to variable, the initially selected
		 *         value specified by the default parameter, the menu values given by
		 *         *values and additional keywords.
		 * 
		 *         WIDGET-SPECIFIC OPTIONS
		 * 
		 *             style: stylename
		 *                 Menubutton style.
		 *             direction: 'above', 'below', 'left', 'right', or 'flush'
		 *                 Menubutton direction.
		 *             command: callback
		 *                 A callback that will be invoked after selecting an item.
		 *         
		 */
		function OptionMenu(master, variable, def?): Promise<IOptionMenu>
		function OptionMenu$({ master, variable, def }: { master, variable, def?}): Promise<IOptionMenu>
		interface IOptionMenu extends IMenubutton {

			/**
			 * Build a new menu of radiobuttons with *values and optionally
			 *         a default value.
			 */
			set_menu(def?): Promise<any>
			set_menu$({ def }: { def?}): Promise<any>

			/**
			 * Destroy this widget and its associated variable.
			 */
			destroy(): Promise<any>
			destroy$($: {}): Promise<any>
		}
		let LabelFrame: Promise<any>
		let PanedWindow: Promise<any>
	}
}
declare module token {
	var _
	function ISTERMINAL(x): Promise<any>
	function ISTERMINAL$({ x }): Promise<any>
	function ISNONTERMINAL(x): Promise<any>
	function ISNONTERMINAL$({ x }): Promise<any>
	function ISEOF(x): Promise<any>
	function ISEOF$({ x }): Promise<any>
	let ENDMARKER: Promise<any>
	let NAME: Promise<any>
	let NUMBER: Promise<any>
	let STRING: Promise<any>
	let NEWLINE: Promise<any>
	let INDENT: Promise<any>
	let DEDENT: Promise<any>
	let LPAR: Promise<any>
	let RPAR: Promise<any>
	let LSQB: Promise<any>
	let RSQB: Promise<any>
	let COLON: Promise<any>
	let COMMA: Promise<any>
	let SEMI: Promise<any>
	let PLUS: Promise<any>
	let MINUS: Promise<any>
	let STAR: Promise<any>
	let SLASH: Promise<any>
	let VBAR: Promise<any>
	let AMPER: Promise<any>
	let LESS: Promise<any>
	let GREATER: Promise<any>
	let EQUAL: Promise<any>
	let DOT: Promise<any>
	let PERCENT: Promise<any>
	let LBRACE: Promise<any>
	let RBRACE: Promise<any>
	let EQEQUAL: Promise<any>
	let NOTEQUAL: Promise<any>
	let LESSEQUAL: Promise<any>
	let GREATEREQUAL: Promise<any>
	let TILDE: Promise<any>
	let CIRCUMFLEX: Promise<any>
	let LEFTSHIFT: Promise<any>
	let RIGHTSHIFT: Promise<any>
	let DOUBLESTAR: Promise<any>
	let PLUSEQUAL: Promise<any>
	let MINEQUAL: Promise<any>
	let STAREQUAL: Promise<any>
	let SLASHEQUAL: Promise<any>
	let PERCENTEQUAL: Promise<any>
	let AMPEREQUAL: Promise<any>
	let VBAREQUAL: Promise<any>
	let CIRCUMFLEXEQUAL: Promise<any>
	let LEFTSHIFTEQUAL: Promise<any>
	let RIGHTSHIFTEQUAL: Promise<any>
	let DOUBLESTAREQUAL: Promise<any>
	let DOUBLESLASH: Promise<any>
	let DOUBLESLASHEQUAL: Promise<any>
	let AT: Promise<any>
	let ATEQUAL: Promise<any>
	let RARROW: Promise<any>
	let ELLIPSIS: Promise<any>
	let COLONEQUAL: Promise<any>
	let OP: Promise<any>
	let AWAIT: Promise<any>
	let ASYNC: Promise<any>
	let TYPE_IGNORE: Promise<any>
	let TYPE_COMMENT: Promise<any>
	let SOFT_KEYWORD: Promise<any>
	let ERRORTOKEN: Promise<any>
	let COMMENT: Promise<any>
	let NL: Promise<any>
	let ENCODING: Promise<any>
	let N_TOKENS: Promise<any>
	let NT_OFFSET: Promise<any>
	let tok_name: Promise<any>
	let EXACT_TOKEN_TYPES: Promise<any>
}
declare module tokenize {
	var _
	function group(): Promise<any>
	function group$($: {}): Promise<any>
	function any(): Promise<any>
	function any$($: {}): Promise<any>
	function maybe(): Promise<any>
	function maybe$($: {}): Promise<any>

	/**
	 * Transform tokens back into Python source code.
	 *     It returns a bytes object, encoded using the ENCODING
	 *     token, which is the first token sequence output by tokenize.
	 * 
	 *     Each element returned by the iterable must be a token sequence
	 *     with at least two elements, a token number and token value.  If
	 *     only two tokens are passed, the resulting output is poor.
	 * 
	 *     Round-trip invariant for full input:
	 *         Untokenized source will match input source exactly
	 * 
	 *     Round-trip invariant for limited input:
	 *         # Output bytes will tokenize back to the input
	 *         t1 = [tok[:2] for tok in tokenize(f.readline)]
	 *         newcode = untokenize(t1)
	 *         readline = BytesIO(newcode).readline
	 *         t2 = [tok[:2] for tok in tokenize(readline)]
	 *         assert t1 == t2
	 *     
	 */
	function untokenize(iterable): Promise<any>
	function untokenize$({ iterable }): Promise<any>

	/**
	 * 
	 *     The detect_encoding() function is used to detect the encoding that should
	 *     be used to decode a Python source file.  It requires one argument, readline,
	 *     in the same way as the tokenize() generator.
	 * 
	 *     It will call readline a maximum of twice, and return the encoding used
	 *     (as a string) and a list of any lines (left as bytes) it has read in.
	 * 
	 *     It detects the encoding from the presence of a utf-8 bom or an encoding
	 *     cookie as specified in pep-0263.  If both a bom and a cookie are present,
	 *     but disagree, a SyntaxError will be raised.  If the encoding cookie is an
	 *     invalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,
	 *     'utf-8-sig' is returned.
	 * 
	 *     If no encoding is specified, then the default of 'utf-8' will be returned.
	 *     
	 */
	function detect_encoding(readline): Promise<any>
	function detect_encoding$({ readline }): Promise<any>

	/**
	 * Open a file in read only mode using the encoding detected by
	 *     detect_encoding().
	 *     
	 */
	function open(filename): Promise<any>
	function open$({ filename }): Promise<any>

	/**
	 * 
	 *     The tokenize() generator requires one argument, readline, which
	 *     must be a callable object which provides the same interface as the
	 *     readline() method of built-in file objects.  Each call to the function
	 *     should return one line of input as bytes.  Alternatively, readline
	 *     can be a callable function terminating with StopIteration:
	 *         readline = open(myfile, 'rb').__next__  # Example of alternate readline
	 * 
	 *     The generator produces 5-tuples with these members: the token type; the
	 *     token string; a 2-tuple (srow, scol) of ints specifying the row and
	 *     column where the token begins in the source; a 2-tuple (erow, ecol) of
	 *     ints specifying the row and column where the token ends in the source;
	 *     and the line on which the token was found.  The line passed is the
	 *     physical line.
	 * 
	 *     The first token sequence will always be an ENCODING token
	 *     which tells you which encoding was used to decode the bytes stream.
	 *     
	 */
	function tokenize(readline): Promise<any>
	function tokenize$({ readline }): Promise<any>

	/**
	 * Tokenize a source reading Python code as unicode strings.
	 * 
	 *     This has the same API as tokenize(), except that it expects the *readline*
	 *     callable to return str objects instead of bytes.
	 *     
	 */
	function generate_tokens(readline): Promise<any>
	function generate_tokens$({ readline }): Promise<any>
	function main(): Promise<any>
	function main$($: {}): Promise<any>
	interface ITokenInfo {
		exact_type(): Promise<any>
		exact_type$($: {}): Promise<any>
	}
	interface ITokenError {
	}
	interface IStopTokenizing {
	}
	function Untokenizer(): Promise<IUntokenizer>
	function Untokenizer$({ }): Promise<IUntokenizer>
	interface IUntokenizer {
		add_whitespace(start): Promise<any>
		add_whitespace$({ start }): Promise<any>
		untokenize(iterable): Promise<any>
		untokenize$({ iterable }): Promise<any>
		compat(token, iterable): Promise<any>
		compat$({ token, iterable }): Promise<any>
	}
	let cookie_re: Promise<any>
	let blank_re: Promise<any>
	let Whitespace: Promise<any>
	let Comment: Promise<any>
	let Ignore: Promise<any>
	let Name: Promise<any>
	let Hexnumber: Promise<any>
	let Binnumber: Promise<any>
	let Octnumber: Promise<any>
	let Decnumber: Promise<any>
	let Intnumber: Promise<any>
	let Exponent: Promise<any>
	let Pointfloat: Promise<any>
	let Expfloat: Promise<any>
	let Floatnumber: Promise<any>
	let Imagnumber: Promise<any>
	let Number: Promise<any>
	let StringPrefix: Promise<any>
	let Single: Promise<any>
	let Double: Promise<any>
	let Single3: Promise<any>
	let Double3: Promise<any>
	let Triple: Promise<any>
	let String: Promise<any>
	let Special: Promise<any>
	let Funny: Promise<any>
	let PlainToken: Promise<any>
	let Token: Promise<any>
	let ContStr: Promise<any>
	let PseudoExtras: Promise<any>
	let PseudoToken: Promise<any>
	let endpats: Promise<any>
	let single_quoted: Promise<any>
	let triple_quoted: Promise<any>
	let tabsize: Promise<any>
}
declare module trace {
	var _
	function main(): Promise<any>
	function main$($: {}): Promise<any>
	interface I_Ignore {
		names(filename, modulename): Promise<any>
		names$({ filename, modulename }): Promise<any>
	}
	function CoverageResults(counts?, calledfuncs?, infile?, callers?, outfile?): Promise<ICoverageResults>
	function CoverageResults$({ counts, calledfuncs, infile, callers, outfile }: { counts?, calledfuncs?, infile?, callers?, outfile?}): Promise<ICoverageResults>
	interface ICoverageResults {

		/**
		 * Return True if the filename does not refer to a file
		 *         we want to have reported.
		 *         
		 */
		is_ignored_filename(filename): Promise<any>
		is_ignored_filename$({ filename }): Promise<any>

		/**
		 * Merge in the data from another CoverageResults
		 */
		update(other): Promise<any>
		update$({ other }): Promise<any>

		/**
		 * 
		 *         Write the coverage results.
		 * 
		 *         :param show_missing: Show lines that had no hits.
		 *         :param summary: Include coverage summary per module.
		 *         :param coverdir: If None, the results of each module are placed in its
		 *                          directory, otherwise it is included in the directory
		 *                          specified.
		 *         
		 */
		write_results(show_missing?: boolean, summary?: boolean, coverdir?): Promise<any>
		write_results$({ show_missing, summary, coverdir }: { show_missing?, summary?, coverdir?}): Promise<any>

		/**
		 * Return a coverage results file in path.
		 */
		write_results_file(path, lines, lnotab, lines_hit, encoding?): Promise<any>
		write_results_file$({ path, lines, lnotab, lines_hit, encoding }: { path, lines, lnotab, lines_hit, encoding?}): Promise<any>
	}

	/**
	 * 
	 *         @param count true iff it should count number of times each
	 *                      line is executed
	 *         @param trace true iff it should print out each line that is
	 *                      being counted
	 *         @param countfuncs true iff it should just output a list of
	 *                      (filename, modulename, funcname,) for functions
	 *                      that were called at least once;  This overrides
	 *                      `count' and `trace'
	 *         @param ignoremods a list of the names of modules to ignore
	 *         @param ignoredirs a list of the names of directories to ignore
	 *                      all of the (recursive) contents of
	 *         @param infile file from which to read stored counts to be
	 *                      added into the results
	 *         @param outfile file in which to write the results
	 *         @param timing true iff timing information be displayed
	 *         
	 */
	function Trace(count?, trace?, countfuncs?, countcallers?, ignoremods?, ignoredirs?, infile?, outfile?, timing?: boolean): Promise<ITrace>
	function Trace$({ count, trace, countfuncs, countcallers, ignoremods, ignoredirs, infile, outfile, timing }: { count?, trace?, countfuncs?, countcallers?, ignoremods?, ignoredirs?, infile?, outfile?, timing?}): Promise<ITrace>
	interface ITrace {
		run(cmd): Promise<any>
		run$({ cmd }): Promise<any>
		runctx(cmd, globals?, locals?): Promise<any>
		runctx$({ cmd, globals, locals }: { cmd, globals?, locals?}): Promise<any>
		runfunc(func): Promise<any>
		runfunc$({ func }): Promise<any>
		file_module_function_of(frame): Promise<any>
		file_module_function_of$({ frame }): Promise<any>

		/**
		 * Handler for call events.
		 * 
		 *         Adds information about who called who to the self._callers dict.
		 *         
		 */
		globaltrace_trackcallers(frame, why, arg): Promise<any>
		globaltrace_trackcallers$({ frame, why, arg }): Promise<any>

		/**
		 * Handler for call events.
		 * 
		 *         Adds (filename, modulename, funcname) to the self._calledfuncs dict.
		 *         
		 */
		globaltrace_countfuncs(frame, why, arg): Promise<any>
		globaltrace_countfuncs$({ frame, why, arg }): Promise<any>

		/**
		 * Handler for call events.
		 * 
		 *         If the code block being entered is to be ignored, returns `None',
		 *         else returns self.localtrace.
		 *         
		 */
		globaltrace_lt(frame, why, arg): Promise<any>
		globaltrace_lt$({ frame, why, arg }): Promise<any>
		localtrace_trace_and_count(frame, why, arg): Promise<any>
		localtrace_trace_and_count$({ frame, why, arg }): Promise<any>
		localtrace_trace(frame, why, arg): Promise<any>
		localtrace_trace$({ frame, why, arg }): Promise<any>
		localtrace_count(frame, why, arg): Promise<any>
		localtrace_count$({ frame, why, arg }): Promise<any>
		results(): Promise<any>
		results$($: {}): Promise<any>
	}
	let PRAGMA_NOCOVER: Promise<any>
}
declare module traceback {
	var _

	/**
	 * Print the list of tuples as returned by extract_tb() or
	 *     extract_stack() as a formatted stack trace to the given file.
	 */
	function print_list(extracted_list, file?): Promise<any>
	function print_list$({ extracted_list, file }: { extracted_list, file?}): Promise<any>

	/**
	 * Format a list of tuples or FrameSummary objects for printing.
	 * 
	 *     Given a list of tuples or FrameSummary objects as returned by
	 *     extract_tb() or extract_stack(), return a list of strings ready
	 *     for printing.
	 * 
	 *     Each string in the resulting list corresponds to the item with the
	 *     same index in the argument list.  Each string ends in a newline;
	 *     the strings may contain internal newlines as well, for those items
	 *     whose source text line is not None.
	 *     
	 */
	function format_list(extracted_list): Promise<any>
	function format_list$({ extracted_list }): Promise<any>

	/**
	 * Print up to 'limit' stack trace entries from the traceback 'tb'.
	 * 
	 *     If 'limit' is omitted or None, all entries are printed.  If 'file'
	 *     is omitted or None, the output goes to sys.stderr; otherwise
	 *     'file' should be an open file or file-like object with a write()
	 *     method.
	 *     
	 */
	function print_tb(tb, limit?, file?): Promise<any>
	function print_tb$({ tb, limit, file }: { tb, limit?, file?}): Promise<any>

	/**
	 * A shorthand for 'format_list(extract_tb(tb, limit))'.
	 */
	function format_tb(tb, limit?): Promise<any>
	function format_tb$({ tb, limit }: { tb, limit?}): Promise<any>

	/**
	 * 
	 *     Return a StackSummary object representing a list of
	 *     pre-processed entries from traceback.
	 * 
	 *     This is useful for alternate formatting of stack traces.  If
	 *     'limit' is omitted or None, all entries are extracted.  A
	 *     pre-processed stack trace entry is a FrameSummary object
	 *     containing attributes filename, lineno, name, and line
	 *     representing the information that is usually printed for a stack
	 *     trace.  The line is a string with leading and trailing
	 *     whitespace stripped; if the source is not available it is None.
	 *     
	 */
	function extract_tb(tb, limit?): Promise<any>
	function extract_tb$({ tb, limit }: { tb, limit?}): Promise<any>

	/**
	 * Print exception up to 'limit' stack trace entries from 'tb' to 'file'.
	 * 
	 *     This differs from print_tb() in the following ways: (1) if
	 *     traceback is not None, it prints a header "Traceback (most recent
	 *     call last):"; (2) it prints the exception type and value after the
	 *     stack trace; (3) if type is SyntaxError and value has the
	 *     appropriate format, it prints the line where the syntax error
	 *     occurred with a caret on the next line indicating the approximate
	 *     position of the error.
	 *     
	 */
	function print_exception(exc, value?, tb?, limit?, file?, chain?: boolean): Promise<any>
	function print_exception$({ exc, value, tb, limit, file, chain }: { exc, value?, tb?, limit?, file?, chain?}): Promise<any>

	/**
	 * Format a stack trace and the exception information.
	 * 
	 *     The arguments have the same meaning as the corresponding arguments
	 *     to print_exception().  The return value is a list of strings, each
	 *     ending in a newline and some containing internal newlines.  When
	 *     these lines are concatenated and printed, exactly the same text is
	 *     printed as does print_exception().
	 *     
	 */
	function format_exception(exc, value?, tb?, limit?, chain?: boolean): Promise<any>
	function format_exception$({ exc, value, tb, limit, chain }: { exc, value?, tb?, limit?, chain?}): Promise<any>

	/**
	 * Format the exception part of a traceback.
	 * 
	 *     The return value is a list of strings, each ending in a newline.
	 * 
	 *     Normally, the list contains a single string; however, for
	 *     SyntaxError exceptions, it contains several lines that (when
	 *     printed) display detailed information about where the syntax
	 *     error occurred.
	 * 
	 *     The message indicating which exception occurred is always the last
	 *     string in the list.
	 * 
	 *     
	 */
	function format_exception_only(exc, value?): Promise<any>
	function format_exception_only$({ exc, value }: { exc, value?}): Promise<any>

	/**
	 * Shorthand for 'print_exception(*sys.exc_info(), limit, file)'.
	 */
	function print_exc(limit?, file?, chain?: boolean): Promise<any>
	function print_exc$({ limit, file, chain }: { limit?, file?, chain?}): Promise<any>

	/**
	 * Like print_exc() but return a string.
	 */
	function format_exc(limit?, chain?: boolean): Promise<any>
	function format_exc$({ limit, chain }: { limit?, chain?}): Promise<any>

	/**
	 * This is a shorthand for 'print_exception(sys.last_type,
	 *     sys.last_value, sys.last_traceback, limit, file)'.
	 */
	function print_last(limit?, file?, chain?: boolean): Promise<any>
	function print_last$({ limit, file, chain }: { limit?, file?, chain?}): Promise<any>

	/**
	 * Print a stack trace from its invocation point.
	 * 
	 *     The optional 'f' argument can be used to specify an alternate
	 *     stack frame at which to start. The optional 'limit' and 'file'
	 *     arguments have the same meaning as for print_exception().
	 *     
	 */
	function print_stack(f?, limit?, file?): Promise<any>
	function print_stack$({ f, limit, file }: { f?, limit?, file?}): Promise<any>

	/**
	 * Shorthand for 'format_list(extract_stack(f, limit))'.
	 */
	function format_stack(f?, limit?): Promise<any>
	function format_stack$({ f, limit }: { f?, limit?}): Promise<any>

	/**
	 * Extract the raw traceback from the current stack frame.
	 * 
	 *     The return value has the same format as for extract_tb().  The
	 *     optional 'f' and 'limit' arguments have the same meaning as for
	 *     print_stack().  Each item in the list is a quadruple (filename,
	 *     line number, function name, text), and the entries are in order
	 *     from oldest to newest stack frame.
	 *     
	 */
	function extract_stack(f?, limit?): Promise<any>
	function extract_stack$({ f, limit }: { f?, limit?}): Promise<any>

	/**
	 * Clear all references to local variables in the frames of a traceback.
	 */
	function clear_frames(tb): Promise<any>
	function clear_frames$({ tb }): Promise<any>

	/**
	 * Walk a stack yielding the frame and line number for each frame.
	 * 
	 *     This will follow f.f_back from the given frame. If no frame is given, the
	 *     current stack is used. Usually used with StackSummary.extract.
	 *     
	 */
	function walk_stack(f): Promise<any>
	function walk_stack$({ f }): Promise<any>

	/**
	 * Walk a traceback yielding the frame and line number for each frame.
	 * 
	 *     This will follow tb.tb_next (and thus is in the opposite order to
	 *     walk_stack). Usually used with StackSummary.extract.
	 *     
	 */
	function walk_tb(tb): Promise<any>
	function walk_tb$({ tb }): Promise<any>
	interface I_Sentinel {
	}

	/**
	 * A single frame from a traceback.
	 * 
	 *     - :attr:`filename` The filename for the frame.
	 *     - :attr:`lineno` The line within filename for the frame that was
	 *       active when the frame was captured.
	 *     - :attr:`name` The name of the function or method that was executing
	 *       when the frame was captured.
	 *     - :attr:`line` The text from the linecache module for the
	 *       of code that was running when the frame was captured.
	 *     - :attr:`locals` Either None if locals were not supplied, or a dict
	 *       mapping the name to the repr() of the variable.
	 *     
	 */

	/**
	 * Construct a FrameSummary.
	 * 
	 *         :param lookup_line: If True, `linecache` is consulted for the source
	 *             code line. Otherwise, the line will be looked up when first needed.
	 *         :param locals: If supplied the frame locals, which will be captured as
	 *             object representations.
	 *         :param line: If provided, use this instead of looking up the line in
	 *             the linecache.
	 *         
	 */
	function FrameSummary(filename, lineno, name): Promise<IFrameSummary>
	function FrameSummary$({ filename, lineno, name }): Promise<IFrameSummary>
	interface IFrameSummary {
		line(): Promise<any>
		line$($: {}): Promise<any>
	}

	/**
	 * A stack of frames.
	 */
	interface IStackSummary {

		/**
		 * Create a StackSummary from a traceback or stack object.
		 * 
		 *         :param frame_gen: A generator that yields (frame, lineno) tuples to
		 *             include in the stack.
		 *         :param limit: None to include all frames or the number of frames to
		 *             include.
		 *         :param lookup_lines: If True, lookup lines for each frame immediately,
		 *             otherwise lookup is deferred until the frame is rendered.
		 *         :param capture_locals: If True, the local variables from each frame will
		 *             be captured as object representations into the FrameSummary.
		 *         
		 */
		extract(frame_gen): Promise<any>
		extract$({ frame_gen }): Promise<any>

		/**
		 * 
		 *         Create a StackSummary object from a supplied list of
		 *         FrameSummary objects or old-style list of tuples.
		 *         
		 */
		from_list(a_list): Promise<any>
		from_list$({ a_list }): Promise<any>

		/**
		 * Format the stack ready for printing.
		 * 
		 *         Returns a list of strings ready for printing.  Each string in the
		 *         resulting list corresponds to a single frame from the stack.
		 *         Each string ends in a newline; the strings may contain internal
		 *         newlines as well, for those items with source text lines.
		 * 
		 *         For long sequences of the same frame and line, the first few
		 *         repetitions are shown, followed by a summary line stating the exact
		 *         number of further repetitions.
		 *         
		 */
		format(): Promise<any>
		format$($: {}): Promise<any>
	}

	/**
	 * An exception ready for rendering.
	 * 
	 *     The traceback module captures enough attributes from the original exception
	 *     to this intermediary form to ensure that no references are held, while
	 *     still being able to fully print or format it.
	 * 
	 *     Use `from_exception` to create TracebackException instances from exception
	 *     objects, or the constructor to create TracebackException instances from
	 *     individual components.
	 * 
	 *     - :attr:`__cause__` A TracebackException of the original *__cause__*.
	 *     - :attr:`__context__` A TracebackException of the original *__context__*.
	 *     - :attr:`__suppress_context__` The *__suppress_context__* value from the
	 *       original exception.
	 *     - :attr:`stack` A `StackSummary` representing the traceback.
	 *     - :attr:`exc_type` The class of the original traceback.
	 *     - :attr:`filename` For syntax errors - the filename where the error
	 *       occurred.
	 *     - :attr:`lineno` For syntax errors - the linenumber where the error
	 *       occurred.
	 *     - :attr:`text` For syntax errors - the text where the error
	 *       occurred.
	 *     - :attr:`offset` For syntax errors - the offset into the text where the
	 *       error occurred.
	 *     - :attr:`msg` For syntax errors - the compiler error message.
	 *     
	 */
	function TracebackException(exc_type, exc_value, exc_traceback): Promise<ITracebackException>
	function TracebackException$({ exc_type, exc_value, exc_traceback }): Promise<ITracebackException>
	interface ITracebackException {

		/**
		 * Create a TracebackException from an exception.
		 */
		from_exception(exc): Promise<any>
		from_exception$({ exc }): Promise<any>

		/**
		 * Format the exception part of the traceback.
		 * 
		 *         The return value is a generator of strings, each ending in a newline.
		 * 
		 *         Normally, the generator emits a single string; however, for
		 *         SyntaxError exceptions, it emits several lines that (when
		 *         printed) display detailed information about where the syntax
		 *         error occurred.
		 * 
		 *         The message indicating which exception occurred is always the last
		 *         string in the output.
		 *         
		 */
		format_exception_only(): Promise<any>
		format_exception_only$($: {}): Promise<any>

		/**
		 * Format the exception.
		 * 
		 *         If chain is not *True*, *__cause__* and *__context__* will not be formatted.
		 * 
		 *         The return value is a generator of strings, each ending in a newline and
		 *         some containing internal newlines. `print_exception` is a wrapper around
		 *         this method which just prints the lines to a file.
		 * 
		 *         The message indicating which exception occurred is always the last
		 *         string in the output.
		 *         
		 */
		format(): Promise<any>
		format$($: {}): Promise<any>

		/**
		 * Print the result of self.format(chain=chain) to 'file'.
		 */
		print(): Promise<any>
		print$($: {}): Promise<any>
	}
}
declare module tracemalloc {
	var _

	/**
	 * 
	 *     Get the traceback where the Python object *obj* was allocated.
	 *     Return a Traceback instance.
	 * 
	 *     Return None if the tracemalloc module is not tracing memory allocations or
	 *     did not trace the allocation of the object.
	 *     
	 */
	function get_object_traceback(obj): Promise<any>
	function get_object_traceback$({ obj }): Promise<any>

	/**
	 * 
	 *     Take a snapshot of traces of memory blocks allocated by Python.
	 *     
	 */
	function take_snapshot(): Promise<any>
	function take_snapshot$($: {}): Promise<any>

	/**
	 * 
	 *     Statistic difference on memory allocations between two Snapshot instance.
	 *     
	 */
	function Statistic(traceback, size, count): Promise<IStatistic>
	function Statistic$({ traceback, size, count }): Promise<IStatistic>
	interface IStatistic {
	}

	/**
	 * 
	 *     Statistic difference on memory allocations between an old and a new
	 *     Snapshot instance.
	 *     
	 */
	function StatisticDiff(traceback, size, size_diff, count, count_diff): Promise<IStatisticDiff>
	function StatisticDiff$({ traceback, size, size_diff, count, count_diff }): Promise<IStatisticDiff>
	interface IStatisticDiff {
	}

	/**
	 * 
	 *     Frame of a traceback.
	 *     
	 */
	function Frame(frame): Promise<IFrame>
	function Frame$({ frame }): Promise<IFrame>
	interface IFrame {
		filename(): Promise<any>
		filename$($: {}): Promise<any>
		lineno(): Promise<any>
		lineno$($: {}): Promise<any>
	}

	/**
	 * 
	 *     Sequence of Frame instances sorted from the oldest frame
	 *     to the most recent frame.
	 *     
	 */
	function Traceback(frames, total_nframe?): Promise<ITraceback>
	function Traceback$({ frames, total_nframe }: { frames, total_nframe?}): Promise<ITraceback>
	interface ITraceback {
		total_nframe(): Promise<any>
		total_nframe$($: {}): Promise<any>
		format(limit?, most_recent_first?: boolean): Promise<any>
		format$({ limit, most_recent_first }: { limit?, most_recent_first?}): Promise<any>
	}

	/**
	 * 
	 *     Trace of a memory block.
	 *     
	 */
	function Trace(trace): Promise<ITrace>
	function Trace$({ trace }): Promise<ITrace>
	interface ITrace {
		domain(): Promise<any>
		domain$($: {}): Promise<any>
		size(): Promise<any>
		size$($: {}): Promise<any>
		traceback(): Promise<any>
		traceback$($: {}): Promise<any>
	}
	interface I_Traces {
	}
	function BaseFilter(inclusive): Promise<IBaseFilter>
	function BaseFilter$({ inclusive }): Promise<IBaseFilter>
	interface IBaseFilter {
	}
	function Filter(inclusive, filename_pattern, lineno?, all_frames?: boolean, domain?): Promise<IFilter>
	function Filter$({ inclusive, filename_pattern, lineno, all_frames, domain }: { inclusive, filename_pattern, lineno?, all_frames?, domain?}): Promise<IFilter>
	interface IFilter extends IBaseFilter {
		filename_pattern(): Promise<any>
		filename_pattern$($: {}): Promise<any>
	}
	function DomainFilter(inclusive, domain): Promise<IDomainFilter>
	function DomainFilter$({ inclusive, domain }): Promise<IDomainFilter>
	interface IDomainFilter extends IBaseFilter {
		domain(): Promise<any>
		domain$($: {}): Promise<any>
	}

	/**
	 * 
	 *     Snapshot of traces of memory blocks allocated by Python.
	 *     
	 */
	function Snapshot(traces, traceback_limit): Promise<ISnapshot>
	function Snapshot$({ traces, traceback_limit }): Promise<ISnapshot>
	interface ISnapshot {

		/**
		 * 
		 *         Write the snapshot into a file.
		 *         
		 */
		dump(filename): Promise<any>
		dump$({ filename }): Promise<any>

		/**
		 * 
		 *         Load a snapshot from a file.
		 *         
		 */
		load(): Promise<any>
		load$($: {}): Promise<any>

		/**
		 * 
		 *         Create a new Snapshot instance with a filtered traces sequence, filters
		 *         is a list of Filter or DomainFilter instances.  If filters is an empty
		 *         list, return a new Snapshot instance with a copy of the traces.
		 *         
		 */
		filter_traces(filters): Promise<any>
		filter_traces$({ filters }): Promise<any>

		/**
		 * 
		 *         Group statistics by key_type. Return a sorted list of Statistic
		 *         instances.
		 *         
		 */
		statistics(key_type, cumulative?: boolean): Promise<any>
		statistics$({ key_type, cumulative }: { key_type, cumulative?}): Promise<any>

		/**
		 * 
		 *         Compute the differences with an old snapshot old_snapshot. Get
		 *         statistics as a sorted list of StatisticDiff instances, grouped by
		 *         group_by.
		 *         
		 */
		compare_to(old_snapshot, key_type, cumulative?: boolean): Promise<any>
		compare_to$({ old_snapshot, key_type, cumulative }: { old_snapshot, key_type, cumulative?}): Promise<any>
	}
}
declare module tty {
	var _

	/**
	 * Put terminal into a raw mode.
	 */
	function setraw(fd, when?): Promise<any>
	function setraw$({ fd, when }: { fd, when?}): Promise<any>

	/**
	 * Put terminal into a cbreak mode.
	 */
	function setcbreak(fd, when?): Promise<any>
	function setcbreak$({ fd, when }: { fd, when?}): Promise<any>
	let IFLAG: Promise<any>
	let OFLAG: Promise<any>
	let CFLAG: Promise<any>
	let LFLAG: Promise<any>
	let ISPEED: Promise<any>
	let OSPEED: Promise<any>
	let CC: Promise<any>
}
declare module turtle {
	var _

	/**
	 * Convert content of config-file into dictionary.
	 */
	function config_dict(filename): Promise<any>
	function config_dict$({ filename }): Promise<any>

	/**
	 * Read config-files, change configuration-dict accordingly.
	 * 
	 *     If there is a turtle.cfg file in the current working directory,
	 *     read it from there. If this contains an importconfig-value,
	 *     say 'myway', construct filename turtle_mayway.cfg else use
	 *     turtle.cfg and read it from the import-directory, where
	 *     turtle.py is located.
	 *     Update configuration dictionary first according to config-file,
	 *     in the import directory, then according to config-file in the
	 *     current working directory.
	 *     If no config-file is found, the default configuration is used.
	 *     
	 */
	function readconfig(cfgdict): Promise<any>
	function readconfig$({ cfgdict }): Promise<any>

	/**
	 * Return the singleton screen object.
	 *     If none exists at the moment, create a new one and return it,
	 *     else return the existing one.
	 */
	function Screen(): Promise<any>
	function Screen$($: {}): Promise<any>

	/**
	 * Create and write docstring-dictionary to file.
	 * 
	 *     Optional argument:
	 *     filename -- a string, used as filename
	 *                 default value is turtle_docstringdict
	 * 
	 *     Has to be called explicitly, (not used by the turtle-graphics classes)
	 *     The docstring dictionary will be written to the Python script <filename>.py
	 *     It is intended to serve as a template for translation of the docstrings
	 *     into different languages.
	 *     
	 */
	function write_docstringdict(filename?): Promise<any>
	function write_docstringdict$({ filename }: { filename?}): Promise<any>

	/**
	 * Read in docstrings from lang-specific docstring dictionary.
	 * 
	 *     Transfer docstrings, translated to lang, from a dictionary-file
	 *     to the methods of classes Screen and Turtle and - in revised form -
	 *     to the corresponding functions.
	 *     
	 */
	function read_docstrings(lang): Promise<any>
	function read_docstrings$({ lang }): Promise<any>

	/**
	 * Get strings describing the arguments for the given object
	 * 
	 *     Returns a pair of strings representing function parameter lists
	 *     including parenthesis.  The first string is suitable for use in
	 *     function definition and the second is suitable for use in function
	 *     call.  The "self" parameter is not included.
	 *     
	 */
	function getmethparlist(ob): Promise<any>
	function getmethparlist$({ ob }): Promise<any>
	function switchpen(): Promise<any>
	function switchpen$($: {}): Promise<any>

	/**
	 * Demo of old turtle.py - module
	 */
	function demo1(): Promise<any>
	function demo1$($: {}): Promise<any>

	/**
	 * Demo of some new features.
	 */
	function demo2(): Promise<any>
	function demo2$($: {}): Promise<any>

	/**
	 * A 2 dimensional vector class, used as a helper class
	 *     for implementing turtle graphics.
	 *     May be useful for turtle graphics programs also.
	 *     Derived from tuple, so a vector is a tuple!
	 * 
	 *     Provides (for a, b vectors, k number):
	 *        a+b vector addition
	 *        a-b vector subtraction
	 *        a*b inner product
	 *        k*a and a*k multiplication with scalar
	 *        |a| absolute value of a
	 *        a.rotate(angle) rotation
	 *     
	 */
	interface IVec2D {

		/**
		 * rotate self counterclockwise by angle
		 *         
		 */
		rotate(angle): Promise<any>
		rotate$({ angle }): Promise<any>
	}

	/**
	 * Modeled after the scrolled canvas class from Grayons's Tkinter book.
	 * 
	 *     Used as the default canvas, which pops up automatically when
	 *     using turtle graphics functions or the Turtle class.
	 *     
	 */
	function ScrolledCanvas(master, width?, height?, canvwidth?, canvheight?): Promise<IScrolledCanvas>
	function ScrolledCanvas$({ master, width, height, canvwidth, canvheight }: { master, width?, height?, canvwidth?, canvheight?}): Promise<IScrolledCanvas>
	interface IScrolledCanvas {

		/**
		 * Adjust canvas and scrollbars according to given canvas size.
		 */
		reset(canvwidth?, canvheight?, bg?): Promise<any>
		reset$({ canvwidth, canvheight, bg }: { canvwidth?, canvheight?, bg?}): Promise<any>

		/**
		 *  Adjust scrollbars according to window- and canvas-size.
		 *         
		 */
		adjustScrolls(): Promise<any>
		adjustScrolls$($: {}): Promise<any>

		/**
		 * self-explanatory
		 */
		onResize(event): Promise<any>
		onResize$({ event }): Promise<any>

		/**
		 *  'forward' method, which canvas itself has inherited...
		 *         
		 */
		bbox(): Promise<any>
		bbox$($: {}): Promise<any>

		/**
		 *  'forward' method, which canvas itself has inherited...
		 *         
		 */
		cget(): Promise<any>
		cget$($: {}): Promise<any>

		/**
		 *  'forward' method, which canvas itself has inherited...
		 *         
		 */
		config(): Promise<any>
		config$($: {}): Promise<any>

		/**
		 *  'forward' method, which canvas itself has inherited...
		 *         
		 */
		bind(): Promise<any>
		bind$($: {}): Promise<any>

		/**
		 *  'forward' method, which canvas itself has inherited...
		 *         
		 */
		unbind(): Promise<any>
		unbind$($: {}): Promise<any>

		/**
		 *  'forward' method, which canvas itself has inherited...
		 *         
		 */
		focus_force(): Promise<any>
		focus_force$($: {}): Promise<any>
	}

	/**
	 * Root class for Screen based on Tkinter.
	 */
	interface I_Root {
		setupcanvas(width, height, cwidth, cheight): Promise<any>
		setupcanvas$({ width, height, cwidth, cheight }): Promise<any>
		set_geometry(width, height, startx, starty): Promise<any>
		set_geometry$({ width, height, startx, starty }): Promise<any>
		ondestroy(destroy): Promise<any>
		ondestroy$({ destroy }): Promise<any>
		win_width(): Promise<any>
		win_width$($: {}): Promise<any>
		win_height(): Promise<any>
		win_height$($: {}): Promise<any>
	}

	/**
	 * Provide the basic graphics functionality.
	 *        Interface between Tkinter and turtle.py.
	 * 
	 *        To port turtle.py to some different graphics toolkit
	 *        a corresponding TurtleScreenBase class has to be implemented.
	 *     
	 */
	function TurtleScreenBase(cv): Promise<ITurtleScreenBase>
	function TurtleScreenBase$({ cv }): Promise<ITurtleScreenBase>
	interface ITurtleScreenBase {

		/**
		 * Starts event loop - calling Tkinter's mainloop function.
		 * 
		 *         No argument.
		 * 
		 *         Must be last statement in a turtle graphics program.
		 *         Must NOT be used if a script is run from within IDLE in -n mode
		 *         (No subprocess) - for interactive use of turtle graphics.
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.mainloop()
		 * 
		 *         
		 */
		mainloop(): Promise<any>
		mainloop$($: {}): Promise<any>

		/**
		 * Pop up a dialog window for input of a string.
		 * 
		 *         Arguments: title is the title of the dialog window,
		 *         prompt is a text mostly describing what information to input.
		 * 
		 *         Return the string input
		 *         If the dialog is canceled, return None.
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.textinput("NIM", "Name of first player:")
		 * 
		 *         
		 */
		textinput(title, prompt): Promise<any>
		textinput$({ title, prompt }): Promise<any>

		/**
		 * Pop up a dialog window for input of a number.
		 * 
		 *         Arguments: title is the title of the dialog window,
		 *         prompt is a text mostly describing what numerical information to input.
		 *         default: default value
		 *         minval: minimum value for input
		 *         maxval: maximum value for input
		 * 
		 *         The number input must be in the range minval .. maxval if these are
		 *         given. If not, a hint is issued and the dialog remains open for
		 *         correction. Return the number input.
		 *         If the dialog is canceled,  return None.
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.numinput("Poker", "Your stakes:", 1000, minval=10, maxval=10000)
		 * 
		 *         
		 */
		numinput(title, prompt, def?, minval?, maxval?): Promise<any>
		numinput$({ title, prompt, def, minval, maxval }: { title, prompt, def?, minval?, maxval?}): Promise<any>
	}

	/**
	 * Will be raised in TurtleScreen.update, if _RUNNING becomes False.
	 * 
	 *     This stops execution of a turtle graphics script.
	 *     Main purpose: use in the Demo-Viewer turtle.Demo.py.
	 *     
	 */
	interface ITerminator {
	}

	/**
	 * Some TurtleGraphics Error
	 *     
	 */
	interface ITurtleGraphicsError {
	}

	/**
	 * Data structure modeling shapes.
	 * 
	 *     attribute _type is one of "polygon", "image", "compound"
	 *     attribute _data is - depending on _type a poygon-tuple,
	 *     an image or a list constructed using the addcomponent method.
	 *     
	 */
	function Shape(type_, data?): Promise<IShape>
	function Shape$({ type_, data }: { type_, data?}): Promise<IShape>
	interface IShape {

		/**
		 * Add component to a shape of type compound.
		 * 
		 *         Arguments: poly is a polygon, i. e. a tuple of number pairs.
		 *         fill is the fillcolor of the component,
		 *         outline is the outline color of the component.
		 * 
		 *         call (for a Shapeobject namend s):
		 *         --   s.addcomponent(((0,0), (10,10), (-10,10)), "red", "blue")
		 * 
		 *         Example:
		 *         >>> poly = ((0,0),(10,-5),(0,10),(-10,-5))
		 *         >>> s = Shape("compound")
		 *         >>> s.addcomponent(poly, "red", "blue")
		 *         >>> # .. add more components and then use register_shape()
		 *         
		 */
		addcomponent(poly, fill, outline?): Promise<any>
		addcomponent$({ poly, fill, outline }: { poly, fill, outline?}): Promise<any>
	}

	/**
	 * Ring buffer used as undobuffer for RawTurtle objects.
	 */
	function Tbuffer(bufsize?): Promise<ITbuffer>
	function Tbuffer$({ bufsize }: { bufsize?}): Promise<ITbuffer>
	interface ITbuffer {
		reset(bufsize?): Promise<any>
		reset$({ bufsize }: { bufsize?}): Promise<any>
		push(item): Promise<any>
		push$({ item }): Promise<any>
		pop(): Promise<any>
		pop$($: {}): Promise<any>
		nr_of_items(): Promise<any>
		nr_of_items$($: {}): Promise<any>
	}

	/**
	 * Provides screen oriented methods like setbg etc.
	 * 
	 *     Only relies upon the methods of TurtleScreenBase and NOT
	 *     upon components of the underlying graphics toolkit -
	 *     which is Tkinter in this case.
	 *     
	 */
	function TurtleScreen(cv, mode?, colormode?, delay?): Promise<ITurtleScreen>
	function TurtleScreen$({ cv, mode, colormode, delay }: { cv, mode?, colormode?, delay?}): Promise<ITurtleScreen>
	interface ITurtleScreen extends ITurtleScreenBase {

		/**
		 * Delete all drawings and all turtles from the TurtleScreen.
		 * 
		 *         No argument.
		 * 
		 *         Reset empty TurtleScreen to its initial state: white background,
		 *         no backgroundimage, no eventbindings and tracing on.
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.clear()
		 * 
		 *         Note: this method is not available as function.
		 *         
		 */
		clear(): Promise<any>
		clear$($: {}): Promise<any>

		/**
		 * Set turtle-mode ('standard', 'logo' or 'world') and perform reset.
		 * 
		 *         Optional argument:
		 *         mode -- one of the strings 'standard', 'logo' or 'world'
		 * 
		 *         Mode 'standard' is compatible with turtle.py.
		 *         Mode 'logo' is compatible with most Logo-Turtle-Graphics.
		 *         Mode 'world' uses userdefined 'worldcoordinates'. *Attention*: in
		 *         this mode angles appear distorted if x/y unit-ratio doesn't equal 1.
		 *         If mode is not given, return the current mode.
		 * 
		 *              Mode      Initial turtle heading     positive angles
		 *          ------------|-------------------------|-------------------
		 *           'standard'    to the right (east)       counterclockwise
		 *             'logo'        upward    (north)         clockwise
		 * 
		 *         Examples:
		 *         >>> mode('logo')   # resets turtle heading to north
		 *         >>> mode()
		 *         'logo'
		 *         
		 */
		mode(mode?): Promise<any>
		mode$({ mode }: { mode?}): Promise<any>

		/**
		 * Set up a user defined coordinate-system.
		 * 
		 *         Arguments:
		 *         llx -- a number, x-coordinate of lower left corner of canvas
		 *         lly -- a number, y-coordinate of lower left corner of canvas
		 *         urx -- a number, x-coordinate of upper right corner of canvas
		 *         ury -- a number, y-coordinate of upper right corner of canvas
		 * 
		 *         Set up user coodinat-system and switch to mode 'world' if necessary.
		 *         This performs a screen.reset. If mode 'world' is already active,
		 *         all drawings are redrawn according to the new coordinates.
		 * 
		 *         But ATTENTION: in user-defined coordinatesystems angles may appear
		 *         distorted. (see Screen.mode())
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.setworldcoordinates(-10,-0.5,50,1.5)
		 *         >>> for _ in range(36):
		 *         ...     left(10)
		 *         ...     forward(0.5)
		 *         
		 */
		setworldcoordinates(llx, lly, urx, ury): Promise<any>
		setworldcoordinates$({ llx, lly, urx, ury }): Promise<any>

		/**
		 * Adds a turtle shape to TurtleScreen's shapelist.
		 * 
		 *         Arguments:
		 *         (1) name is the name of a gif-file and shape is None.
		 *             Installs the corresponding image shape.
		 *             !! Image-shapes DO NOT rotate when turning the turtle,
		 *             !! so they do not display the heading of the turtle!
		 *         (2) name is an arbitrary string and shape is a tuple
		 *             of pairs of coordinates. Installs the corresponding
		 *             polygon shape
		 *         (3) name is an arbitrary string and shape is a
		 *             (compound) Shape object. Installs the corresponding
		 *             compound shape.
		 *         To use a shape, you have to issue the command shape(shapename).
		 * 
		 *         call: register_shape("turtle.gif")
		 *         --or: register_shape("tri", ((0,0), (10,10), (-10,10)))
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.register_shape("triangle", ((5,-3),(0,5),(-5,-3)))
		 * 
		 *         
		 */
		register_shape(name, shape?): Promise<any>
		register_shape$({ name, shape }: { name, shape?}): Promise<any>

		/**
		 * Return the colormode or set it to 1.0 or 255.
		 * 
		 *         Optional argument:
		 *         cmode -- one of the values 1.0 or 255
		 * 
		 *         r, g, b values of colortriples have to be in range 0..cmode.
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.colormode()
		 *         1.0
		 *         >>> screen.colormode(255)
		 *         >>> pencolor(240,160,80)
		 *         
		 */
		colormode(cmode?): Promise<any>
		colormode$({ cmode }: { cmode?}): Promise<any>

		/**
		 * Reset all Turtles on the Screen to their initial state.
		 * 
		 *         No argument.
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.reset()
		 *         
		 */
		reset(): Promise<any>
		reset$($: {}): Promise<any>

		/**
		 * Return the list of turtles on the screen.
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.turtles()
		 *         [<turtle.Turtle object at 0x00E11FB0>]
		 *         
		 */
		turtles(): Promise<any>
		turtles$($: {}): Promise<any>

		/**
		 * Set or return backgroundcolor of the TurtleScreen.
		 * 
		 *         Arguments (if given): a color string or three numbers
		 *         in the range 0..colormode or a 3-tuple of such numbers.
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.bgcolor("orange")
		 *         >>> screen.bgcolor()
		 *         'orange'
		 *         >>> screen.bgcolor(0.5,0,0.5)
		 *         >>> screen.bgcolor()
		 *         '#800080'
		 *         
		 */
		bgcolor(): Promise<any>
		bgcolor$($: {}): Promise<any>

		/**
		 * Turns turtle animation on/off and set delay for update drawings.
		 * 
		 *         Optional arguments:
		 *         n -- nonnegative  integer
		 *         delay -- nonnegative  integer
		 * 
		 *         If n is given, only each n-th regular screen update is really performed.
		 *         (Can be used to accelerate the drawing of complex graphics.)
		 *         Second arguments sets delay value (see RawTurtle.delay())
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.tracer(8, 25)
		 *         >>> dist = 2
		 *         >>> for i in range(200):
		 *         ...     fd(dist)
		 *         ...     rt(90)
		 *         ...     dist += 2
		 *         
		 */
		tracer(n?, delay?): Promise<any>
		tracer$({ n, delay }: { n?, delay?}): Promise<any>

		/**
		 *  Return or set the drawing delay in milliseconds.
		 * 
		 *         Optional argument:
		 *         delay -- positive integer
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.delay(15)
		 *         >>> screen.delay()
		 *         15
		 *         
		 */
		delay(delay?): Promise<any>
		delay$({ delay }: { delay?}): Promise<any>

		/**
		 * Perform a TurtleScreen update.
		 *         
		 */
		update(): Promise<any>
		update$($: {}): Promise<any>

		/**
		 *  Return the width of the turtle window.
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.window_width()
		 *         640
		 *         
		 */
		window_width(): Promise<any>
		window_width$($: {}): Promise<any>

		/**
		 *  Return the height of the turtle window.
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.window_height()
		 *         480
		 *         
		 */
		window_height(): Promise<any>
		window_height$($: {}): Promise<any>

		/**
		 * Return the Canvas of this TurtleScreen.
		 * 
		 *         No argument.
		 * 
		 *         Example (for a Screen instance named screen):
		 *         >>> cv = screen.getcanvas()
		 *         >>> cv
		 *         <turtle.ScrolledCanvas instance at 0x010742D8>
		 *         
		 */
		getcanvas(): Promise<any>
		getcanvas$($: {}): Promise<any>

		/**
		 * Return a list of names of all currently available turtle shapes.
		 * 
		 *         No argument.
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.getshapes()
		 *         ['arrow', 'blank', 'circle', ... , 'turtle']
		 *         
		 */
		getshapes(): Promise<any>
		getshapes$($: {}): Promise<any>

		/**
		 * Bind fun to mouse-click event on canvas.
		 * 
		 *         Arguments:
		 *         fun -- a function with two arguments, the coordinates of the
		 *                clicked point on the canvas.
		 *         btn -- the number of the mouse-button, defaults to 1
		 * 
		 *         Example (for a TurtleScreen instance named screen)
		 * 
		 *         >>> screen.onclick(goto)
		 *         >>> # Subsequently clicking into the TurtleScreen will
		 *         >>> # make the turtle move to the clicked point.
		 *         >>> screen.onclick(None)
		 *         
		 */
		onclick(fun, btn?, add?): Promise<any>
		onclick$({ fun, btn, add }: { fun, btn?, add?}): Promise<any>

		/**
		 * Bind fun to key-release event of key.
		 * 
		 *         Arguments:
		 *         fun -- a function with no arguments
		 *         key -- a string: key (e.g. "a") or key-symbol (e.g. "space")
		 * 
		 *         In order to be able to register key-events, TurtleScreen
		 *         must have focus. (See method listen.)
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 * 
		 *         >>> def f():
		 *         ...     fd(50)
		 *         ...     lt(60)
		 *         ...
		 *         >>> screen.onkey(f, "Up")
		 *         >>> screen.listen()
		 * 
		 *         Subsequently the turtle can be moved by repeatedly pressing
		 *         the up-arrow key, consequently drawing a hexagon
		 * 
		 *         
		 */
		onkey(fun, key): Promise<any>
		onkey$({ fun, key }): Promise<any>

		/**
		 * Bind fun to key-press event of key if key is given,
		 *         or to any key-press-event if no key is given.
		 * 
		 *         Arguments:
		 *         fun -- a function with no arguments
		 *         key -- a string: key (e.g. "a") or key-symbol (e.g. "space")
		 * 
		 *         In order to be able to register key-events, TurtleScreen
		 *         must have focus. (See method listen.)
		 * 
		 *         Example (for a TurtleScreen instance named screen
		 *         and a Turtle instance named turtle):
		 * 
		 *         >>> def f():
		 *         ...     fd(50)
		 *         ...     lt(60)
		 *         ...
		 *         >>> screen.onkeypress(f, "Up")
		 *         >>> screen.listen()
		 * 
		 *         Subsequently the turtle can be moved by repeatedly pressing
		 *         the up-arrow key, or by keeping pressed the up-arrow key.
		 *         consequently drawing a hexagon.
		 *         
		 */
		onkeypress(fun, key?): Promise<any>
		onkeypress$({ fun, key }: { fun, key?}): Promise<any>

		/**
		 * Set focus on TurtleScreen (in order to collect key-events)
		 * 
		 *         No arguments.
		 *         Dummy arguments are provided in order
		 *         to be able to pass listen to the onclick method.
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.listen()
		 *         
		 */
		listen(xdummy?, ydummy?): Promise<any>
		listen$({ xdummy, ydummy }: { xdummy?, ydummy?}): Promise<any>

		/**
		 * Install a timer, which calls fun after t milliseconds.
		 * 
		 *         Arguments:
		 *         fun -- a function with no arguments.
		 *         t -- a number >= 0
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 * 
		 *         >>> running = True
		 *         >>> def f():
		 *         ...     if running:
		 *         ...             fd(50)
		 *         ...             lt(60)
		 *         ...             screen.ontimer(f, 250)
		 *         ...
		 *         >>> f()   # makes the turtle marching around
		 *         >>> running = False
		 *         
		 */
		ontimer(fun, t?): Promise<any>
		ontimer$({ fun, t }: { fun, t?}): Promise<any>

		/**
		 * Set background image or return name of current backgroundimage.
		 * 
		 *         Optional argument:
		 *         picname -- a string, name of a gif-file or "nopic".
		 * 
		 *         If picname is a filename, set the corresponding image as background.
		 *         If picname is "nopic", delete backgroundimage, if present.
		 *         If picname is None, return the filename of the current backgroundimage.
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.bgpic()
		 *         'nopic'
		 *         >>> screen.bgpic("landscape.gif")
		 *         >>> screen.bgpic()
		 *         'landscape.gif'
		 *         
		 */
		bgpic(picname?): Promise<any>
		bgpic$({ picname }: { picname?}): Promise<any>

		/**
		 * Resize the canvas the turtles are drawing on.
		 * 
		 *         Optional arguments:
		 *         canvwidth -- positive integer, new width of canvas in pixels
		 *         canvheight --  positive integer, new height of canvas in pixels
		 *         bg -- colorstring or color-tuple, new backgroundcolor
		 *         If no arguments are given, return current (canvaswidth, canvasheight)
		 * 
		 *         Do not alter the drawing window. To observe hidden parts of
		 *         the canvas use the scrollbars. (Can make visible those parts
		 *         of a drawing, which were outside the canvas before!)
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.screensize(2000,1500)
		 *         >>> # e.g. to search for an erroneously escaped turtle ;-)
		 *         
		 */
		screensize(canvwidth?, canvheight?, bg?): Promise<any>
		screensize$({ canvwidth, canvheight, bg }: { canvwidth?, canvheight?, bg?}): Promise<any>
		onscreenclick
		resetscreen
		clearscreen
		addshape
		onkeyrelease
	}

	/**
	 * Navigation part of the RawTurtle.
	 *     Implements methods for turtle movement.
	 *     
	 */
	function TNavigator(mode?): Promise<ITNavigator>
	function TNavigator$({ mode }: { mode?}): Promise<ITNavigator>
	interface ITNavigator {

		/**
		 * reset turtle to its initial values
		 * 
		 *         Will be overwritten by parent class
		 *         
		 */
		reset(): Promise<any>
		reset$($: {}): Promise<any>

		/**
		 *  Set angle measurement units to degrees.
		 * 
		 *         Optional argument:
		 *         fullcircle -  a number
		 * 
		 *         Set angle measurement units, i. e. set number
		 *         of 'degrees' for a full circle. Default value is
		 *         360 degrees.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.left(90)
		 *         >>> turtle.heading()
		 *         90
		 * 
		 *         Change angle measurement unit to grad (also known as gon,
		 *         grade, or gradian and equals 1/100-th of the right angle.)
		 *         >>> turtle.degrees(400.0)
		 *         >>> turtle.heading()
		 *         100
		 * 
		 *         
		 */
		degrees(fullcircle?): Promise<any>
		degrees$({ fullcircle }: { fullcircle?}): Promise<any>

		/**
		 *  Set the angle measurement units to radians.
		 * 
		 *         No arguments.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.heading()
		 *         90
		 *         >>> turtle.radians()
		 *         >>> turtle.heading()
		 *         1.5707963267948966
		 *         
		 */
		radians(): Promise<any>
		radians$($: {}): Promise<any>

		/**
		 * Move the turtle forward by the specified distance.
		 * 
		 *         Aliases: forward | fd
		 * 
		 *         Argument:
		 *         distance -- a number (integer or float)
		 * 
		 *         Move the turtle forward by the specified distance, in the direction
		 *         the turtle is headed.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.position()
		 *         (0.00, 0.00)
		 *         >>> turtle.forward(25)
		 *         >>> turtle.position()
		 *         (25.00,0.00)
		 *         >>> turtle.forward(-75)
		 *         >>> turtle.position()
		 *         (-50.00,0.00)
		 *         
		 */
		forward(distance): Promise<any>
		forward$({ distance }): Promise<any>

		/**
		 * Move the turtle backward by distance.
		 * 
		 *         Aliases: back | backward | bk
		 * 
		 *         Argument:
		 *         distance -- a number
		 * 
		 *         Move the turtle backward by distance, opposite to the direction the
		 *         turtle is headed. Do not change the turtle's heading.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.position()
		 *         (0.00, 0.00)
		 *         >>> turtle.backward(30)
		 *         >>> turtle.position()
		 *         (-30.00, 0.00)
		 *         
		 */
		back(distance): Promise<any>
		back$({ distance }): Promise<any>

		/**
		 * Turn turtle right by angle units.
		 * 
		 *         Aliases: right | rt
		 * 
		 *         Argument:
		 *         angle -- a number (integer or float)
		 * 
		 *         Turn turtle right by angle units. (Units are by default degrees,
		 *         but can be set via the degrees() and radians() functions.)
		 *         Angle orientation depends on mode. (See this.)
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.heading()
		 *         22.0
		 *         >>> turtle.right(45)
		 *         >>> turtle.heading()
		 *         337.0
		 *         
		 */
		right(angle): Promise<any>
		right$({ angle }): Promise<any>

		/**
		 * Turn turtle left by angle units.
		 * 
		 *         Aliases: left | lt
		 * 
		 *         Argument:
		 *         angle -- a number (integer or float)
		 * 
		 *         Turn turtle left by angle units. (Units are by default degrees,
		 *         but can be set via the degrees() and radians() functions.)
		 *         Angle orientation depends on mode. (See this.)
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.heading()
		 *         22.0
		 *         >>> turtle.left(45)
		 *         >>> turtle.heading()
		 *         67.0
		 *         
		 */
		left(angle): Promise<any>
		left$({ angle }): Promise<any>

		/**
		 * Return the turtle's current location (x,y), as a Vec2D-vector.
		 * 
		 *         Aliases: pos | position
		 * 
		 *         No arguments.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.pos()
		 *         (0.00, 240.00)
		 *         
		 */
		pos(): Promise<any>
		pos$($: {}): Promise<any>

		/**
		 *  Return the turtle's x coordinate.
		 * 
		 *         No arguments.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> reset()
		 *         >>> turtle.left(60)
		 *         >>> turtle.forward(100)
		 *         >>> print turtle.xcor()
		 *         50.0
		 *         
		 */
		xcor(): Promise<any>
		xcor$($: {}): Promise<any>

		/**
		 *  Return the turtle's y coordinate
		 *         ---
		 *         No arguments.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> reset()
		 *         >>> turtle.left(60)
		 *         >>> turtle.forward(100)
		 *         >>> print turtle.ycor()
		 *         86.6025403784
		 *         
		 */
		ycor(): Promise<any>
		ycor$($: {}): Promise<any>

		/**
		 * Move turtle to an absolute position.
		 * 
		 *         Aliases: setpos | setposition | goto:
		 * 
		 *         Arguments:
		 *         x -- a number      or     a pair/vector of numbers
		 *         y -- a number             None
		 * 
		 *         call: goto(x, y)         # two coordinates
		 *         --or: goto((x, y))       # a pair (tuple) of coordinates
		 *         --or: goto(vec)          # e.g. as returned by pos()
		 * 
		 *         Move turtle to an absolute position. If the pen is down,
		 *         a line will be drawn. The turtle's orientation does not change.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> tp = turtle.pos()
		 *         >>> tp
		 *         (0.00, 0.00)
		 *         >>> turtle.setpos(60,30)
		 *         >>> turtle.pos()
		 *         (60.00,30.00)
		 *         >>> turtle.setpos((20,80))
		 *         >>> turtle.pos()
		 *         (20.00,80.00)
		 *         >>> turtle.setpos(tp)
		 *         >>> turtle.pos()
		 *         (0.00,0.00)
		 *         
		 */
		goto(x, y?): Promise<any>
		goto$({ x, y }: { x, y?}): Promise<any>

		/**
		 * Move turtle to the origin - coordinates (0,0).
		 * 
		 *         No arguments.
		 * 
		 *         Move turtle to the origin - coordinates (0,0) and set its
		 *         heading to its start-orientation (which depends on mode).
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.home()
		 *         
		 */
		home(): Promise<any>
		home$($: {}): Promise<any>

		/**
		 * Set the turtle's first coordinate to x
		 * 
		 *         Argument:
		 *         x -- a number (integer or float)
		 * 
		 *         Set the turtle's first coordinate to x, leave second coordinate
		 *         unchanged.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.position()
		 *         (0.00, 240.00)
		 *         >>> turtle.setx(10)
		 *         >>> turtle.position()
		 *         (10.00, 240.00)
		 *         
		 */
		setx(x): Promise<any>
		setx$({ x }): Promise<any>

		/**
		 * Set the turtle's second coordinate to y
		 * 
		 *         Argument:
		 *         y -- a number (integer or float)
		 * 
		 *         Set the turtle's first coordinate to x, second coordinate remains
		 *         unchanged.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.position()
		 *         (0.00, 40.00)
		 *         >>> turtle.sety(-10)
		 *         >>> turtle.position()
		 *         (0.00, -10.00)
		 *         
		 */
		sety(y): Promise<any>
		sety$({ y }): Promise<any>

		/**
		 * Return the distance from the turtle to (x,y) in turtle step units.
		 * 
		 *         Arguments:
		 *         x -- a number   or  a pair/vector of numbers   or   a turtle instance
		 *         y -- a number       None                            None
		 * 
		 *         call: distance(x, y)         # two coordinates
		 *         --or: distance((x, y))       # a pair (tuple) of coordinates
		 *         --or: distance(vec)          # e.g. as returned by pos()
		 *         --or: distance(mypen)        # where mypen is another turtle
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.pos()
		 *         (0.00, 0.00)
		 *         >>> turtle.distance(30,40)
		 *         50.0
		 *         >>> pen = Turtle()
		 *         >>> pen.forward(77)
		 *         >>> turtle.distance(pen)
		 *         77.0
		 *         
		 */
		distance(x, y?): Promise<any>
		distance$({ x, y }: { x, y?}): Promise<any>

		/**
		 * Return the angle of the line from the turtle's position to (x, y).
		 * 
		 *         Arguments:
		 *         x -- a number   or  a pair/vector of numbers   or   a turtle instance
		 *         y -- a number       None                            None
		 * 
		 *         call: distance(x, y)         # two coordinates
		 *         --or: distance((x, y))       # a pair (tuple) of coordinates
		 *         --or: distance(vec)          # e.g. as returned by pos()
		 *         --or: distance(mypen)        # where mypen is another turtle
		 * 
		 *         Return the angle, between the line from turtle-position to position
		 *         specified by x, y and the turtle's start orientation. (Depends on
		 *         modes - "standard" or "logo")
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.pos()
		 *         (10.00, 10.00)
		 *         >>> turtle.towards(0,0)
		 *         225.0
		 *         
		 */
		towards(x, y?): Promise<any>
		towards$({ x, y }: { x, y?}): Promise<any>

		/**
		 *  Return the turtle's current heading.
		 * 
		 *         No arguments.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.left(67)
		 *         >>> turtle.heading()
		 *         67.0
		 *         
		 */
		heading(): Promise<any>
		heading$($: {}): Promise<any>

		/**
		 * Set the orientation of the turtle to to_angle.
		 * 
		 *         Aliases:  setheading | seth
		 * 
		 *         Argument:
		 *         to_angle -- a number (integer or float)
		 * 
		 *         Set the orientation of the turtle to to_angle.
		 *         Here are some common directions in degrees:
		 * 
		 *          standard - mode:          logo-mode:
		 *         -------------------|--------------------
		 *            0 - east                0 - north
		 *           90 - north              90 - east
		 *          180 - west              180 - south
		 *          270 - south             270 - west
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.setheading(90)
		 *         >>> turtle.heading()
		 *         90
		 *         
		 */
		setheading(to_angle): Promise<any>
		setheading$({ to_angle }): Promise<any>

		/**
		 *  Draw a circle with given radius.
		 * 
		 *         Arguments:
		 *         radius -- a number
		 *         extent (optional) -- a number
		 *         steps (optional) -- an integer
		 * 
		 *         Draw a circle with given radius. The center is radius units left
		 *         of the turtle; extent - an angle - determines which part of the
		 *         circle is drawn. If extent is not given, draw the entire circle.
		 *         If extent is not a full circle, one endpoint of the arc is the
		 *         current pen position. Draw the arc in counterclockwise direction
		 *         if radius is positive, otherwise in clockwise direction. Finally
		 *         the direction of the turtle is changed by the amount of extent.
		 * 
		 *         As the circle is approximated by an inscribed regular polygon,
		 *         steps determines the number of steps to use. If not given,
		 *         it will be calculated automatically. Maybe used to draw regular
		 *         polygons.
		 * 
		 *         call: circle(radius)                  # full circle
		 *         --or: circle(radius, extent)          # arc
		 *         --or: circle(radius, extent, steps)
		 *         --or: circle(radius, steps=6)         # 6-sided polygon
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.circle(50)
		 *         >>> turtle.circle(120, 180)  # semicircle
		 *         
		 */
		circle(radius, extent?, steps?): Promise<any>
		circle$({ radius, extent, steps }: { radius, extent?, steps?}): Promise<any>

		/**
		 * dummy method - to be overwritten by child class
		 */
		speed(s?): Promise<any>
		speed$({ s }: { s?}): Promise<any>
		START_ORIENTATION
		DEFAULT_MODE
		DEFAULT_ANGLEOFFSET
		DEFAULT_ANGLEORIENT
		fd
		bk
		backward
		rt
		lt
		position
		setpos
		setposition
		seth
	}

	/**
	 * Drawing part of the RawTurtle.
	 *     Implements drawing properties.
	 *     
	 */
	function TPen(resizemode?): Promise<ITPen>
	function TPen$({ resizemode }: { resizemode?}): Promise<ITPen>
	interface ITPen {

		/**
		 * Set resizemode to one of the values: "auto", "user", "noresize".
		 * 
		 *         (Optional) Argument:
		 *         rmode -- one of the strings "auto", "user", "noresize"
		 * 
		 *         Different resizemodes have the following effects:
		 *           - "auto" adapts the appearance of the turtle
		 *                    corresponding to the value of pensize.
		 *           - "user" adapts the appearance of the turtle according to the
		 *                    values of stretchfactor and outlinewidth (outline),
		 *                    which are set by shapesize()
		 *           - "noresize" no adaption of the turtle's appearance takes place.
		 *         If no argument is given, return current resizemode.
		 *         resizemode("user") is called by a call of shapesize with arguments.
		 * 
		 * 
		 *         Examples (for a Turtle instance named turtle):
		 *         >>> turtle.resizemode("noresize")
		 *         >>> turtle.resizemode()
		 *         'noresize'
		 *         
		 */
		resizemode(rmode?): Promise<any>
		resizemode$({ rmode }: { rmode?}): Promise<any>

		/**
		 * Set or return the line thickness.
		 * 
		 *         Aliases:  pensize | width
		 * 
		 *         Argument:
		 *         width -- positive number
		 * 
		 *         Set the line thickness to width or return it. If resizemode is set
		 *         to "auto" and turtleshape is a polygon, that polygon is drawn with
		 *         the same line thickness. If no argument is given, current pensize
		 *         is returned.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.pensize()
		 *         1
		 *         >>> turtle.pensize(10)   # from here on lines of width 10 are drawn
		 *         
		 */
		pensize(width?): Promise<any>
		pensize$({ width }: { width?}): Promise<any>

		/**
		 * Pull the pen up -- no drawing when moving.
		 * 
		 *         Aliases: penup | pu | up
		 * 
		 *         No argument
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.penup()
		 *         
		 */
		penup(): Promise<any>
		penup$($: {}): Promise<any>

		/**
		 * Pull the pen down -- drawing when moving.
		 * 
		 *         Aliases: pendown | pd | down
		 * 
		 *         No argument.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.pendown()
		 *         
		 */
		pendown(): Promise<any>
		pendown$($: {}): Promise<any>

		/**
		 * Return True if pen is down, False if it's up.
		 * 
		 *         No argument.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.penup()
		 *         >>> turtle.isdown()
		 *         False
		 *         >>> turtle.pendown()
		 *         >>> turtle.isdown()
		 *         True
		 *         
		 */
		isdown(): Promise<any>
		isdown$($: {}): Promise<any>

		/**
		 *  Return or set the turtle's speed.
		 * 
		 *         Optional argument:
		 *         speed -- an integer in the range 0..10 or a speedstring (see below)
		 * 
		 *         Set the turtle's speed to an integer value in the range 0 .. 10.
		 *         If no argument is given: return current speed.
		 * 
		 *         If input is a number greater than 10 or smaller than 0.5,
		 *         speed is set to 0.
		 *         Speedstrings  are mapped to speedvalues in the following way:
		 *             'fastest' :  0
		 *             'fast'    :  10
		 *             'normal'  :  6
		 *             'slow'    :  3
		 *             'slowest' :  1
		 *         speeds from 1 to 10 enforce increasingly faster animation of
		 *         line drawing and turtle turning.
		 * 
		 *         Attention:
		 *         speed = 0 : *no* animation takes place. forward/back makes turtle jump
		 *         and likewise left/right make the turtle turn instantly.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.speed(3)
		 *         
		 */
		speed(speed?): Promise<any>
		speed$({ speed }: { speed?}): Promise<any>

		/**
		 * Return or set the pencolor and fillcolor.
		 * 
		 *         Arguments:
		 *         Several input formats are allowed.
		 *         They use 0, 1, 2, or 3 arguments as follows:
		 * 
		 *         color()
		 *             Return the current pencolor and the current fillcolor
		 *             as a pair of color specification strings as are returned
		 *             by pencolor and fillcolor.
		 *         color(colorstring), color((r,g,b)), color(r,g,b)
		 *             inputs as in pencolor, set both, fillcolor and pencolor,
		 *             to the given value.
		 *         color(colorstring1, colorstring2),
		 *         color((r1,g1,b1), (r2,g2,b2))
		 *             equivalent to pencolor(colorstring1) and fillcolor(colorstring2)
		 *             and analogously, if the other input format is used.
		 * 
		 *         If turtleshape is a polygon, outline and interior of that polygon
		 *         is drawn with the newly set colors.
		 *         For more info see: pencolor, fillcolor
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.color('red', 'green')
		 *         >>> turtle.color()
		 *         ('red', 'green')
		 *         >>> colormode(255)
		 *         >>> color((40, 80, 120), (160, 200, 240))
		 *         >>> color()
		 *         ('#285078', '#a0c8f0')
		 *         
		 */
		color(): Promise<any>
		color$($: {}): Promise<any>

		/**
		 *  Return or set the pencolor.
		 * 
		 *         Arguments:
		 *         Four input formats are allowed:
		 *           - pencolor()
		 *             Return the current pencolor as color specification string,
		 *             possibly in hex-number format (see example).
		 *             May be used as input to another color/pencolor/fillcolor call.
		 *           - pencolor(colorstring)
		 *             s is a Tk color specification string, such as "red" or "yellow"
		 *           - pencolor((r, g, b))
		 *             *a tuple* of r, g, and b, which represent, an RGB color,
		 *             and each of r, g, and b are in the range 0..colormode,
		 *             where colormode is either 1.0 or 255
		 *           - pencolor(r, g, b)
		 *             r, g, and b represent an RGB color, and each of r, g, and b
		 *             are in the range 0..colormode
		 * 
		 *         If turtleshape is a polygon, the outline of that polygon is drawn
		 *         with the newly set pencolor.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.pencolor('brown')
		 *         >>> tup = (0.2, 0.8, 0.55)
		 *         >>> turtle.pencolor(tup)
		 *         >>> turtle.pencolor()
		 *         '#33cc8c'
		 *         
		 */
		pencolor(): Promise<any>
		pencolor$($: {}): Promise<any>

		/**
		 *  Return or set the fillcolor.
		 * 
		 *         Arguments:
		 *         Four input formats are allowed:
		 *           - fillcolor()
		 *             Return the current fillcolor as color specification string,
		 *             possibly in hex-number format (see example).
		 *             May be used as input to another color/pencolor/fillcolor call.
		 *           - fillcolor(colorstring)
		 *             s is a Tk color specification string, such as "red" or "yellow"
		 *           - fillcolor((r, g, b))
		 *             *a tuple* of r, g, and b, which represent, an RGB color,
		 *             and each of r, g, and b are in the range 0..colormode,
		 *             where colormode is either 1.0 or 255
		 *           - fillcolor(r, g, b)
		 *             r, g, and b represent an RGB color, and each of r, g, and b
		 *             are in the range 0..colormode
		 * 
		 *         If turtleshape is a polygon, the interior of that polygon is drawn
		 *         with the newly set fillcolor.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.fillcolor('violet')
		 *         >>> col = turtle.pencolor()
		 *         >>> turtle.fillcolor(col)
		 *         >>> turtle.fillcolor(0, .5, 0)
		 *         
		 */
		fillcolor(): Promise<any>
		fillcolor$($: {}): Promise<any>

		/**
		 * Makes the turtle visible.
		 * 
		 *         Aliases: showturtle | st
		 * 
		 *         No argument.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.hideturtle()
		 *         >>> turtle.showturtle()
		 *         
		 */
		showturtle(): Promise<any>
		showturtle$($: {}): Promise<any>

		/**
		 * Makes the turtle invisible.
		 * 
		 *         Aliases: hideturtle | ht
		 * 
		 *         No argument.
		 * 
		 *         It's a good idea to do this while you're in the
		 *         middle of a complicated drawing, because hiding
		 *         the turtle speeds up the drawing observably.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.hideturtle()
		 *         
		 */
		hideturtle(): Promise<any>
		hideturtle$($: {}): Promise<any>

		/**
		 * Return True if the Turtle is shown, False if it's hidden.
		 * 
		 *         No argument.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.hideturtle()
		 *         >>> print turtle.isvisible():
		 *         False
		 *         
		 */
		isvisible(): Promise<any>
		isvisible$($: {}): Promise<any>

		/**
		 * Return or set the pen's attributes.
		 * 
		 *         Arguments:
		 *             pen -- a dictionary with some or all of the below listed keys.
		 *             **pendict -- one or more keyword-arguments with the below
		 *                          listed keys as keywords.
		 * 
		 *         Return or set the pen's attributes in a 'pen-dictionary'
		 *         with the following key/value pairs:
		 *            "shown"      :   True/False
		 *            "pendown"    :   True/False
		 *            "pencolor"   :   color-string or color-tuple
		 *            "fillcolor"  :   color-string or color-tuple
		 *            "pensize"    :   positive number
		 *            "speed"      :   number in range 0..10
		 *            "resizemode" :   "auto" or "user" or "noresize"
		 *            "stretchfactor": (positive number, positive number)
		 *            "shearfactor":   number
		 *            "outline"    :   positive number
		 *            "tilt"       :   number
		 * 
		 *         This dictionary can be used as argument for a subsequent
		 *         pen()-call to restore the former pen-state. Moreover one
		 *         or more of these attributes can be provided as keyword-arguments.
		 *         This can be used to set several pen attributes in one statement.
		 * 
		 * 
		 *         Examples (for a Turtle instance named turtle):
		 *         >>> turtle.pen(fillcolor="black", pencolor="red", pensize=10)
		 *         >>> turtle.pen()
		 *         {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
		 *         'pencolor': 'red', 'pendown': True, 'fillcolor': 'black',
		 *         'stretchfactor': (1,1), 'speed': 3, 'shearfactor': 0.0}
		 *         >>> penstate=turtle.pen()
		 *         >>> turtle.color("yellow","")
		 *         >>> turtle.penup()
		 *         >>> turtle.pen()
		 *         {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
		 *         'pencolor': 'yellow', 'pendown': False, 'fillcolor': '',
		 *         'stretchfactor': (1,1), 'speed': 3, 'shearfactor': 0.0}
		 *         >>> p.pen(penstate, fillcolor="green")
		 *         >>> p.pen()
		 *         {'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,
		 *         'pencolor': 'red', 'pendown': True, 'fillcolor': 'green',
		 *         'stretchfactor': (1,1), 'speed': 3, 'shearfactor': 0.0}
		 *         
		 */
		pen(pen?): Promise<any>
		pen$({ pen }: { pen?}): Promise<any>
		width
		up
		pu
		pd
		down
		st
		ht
	}

	/**
	 * Helper class: Datatype to store Turtle attributes
	 *     
	 */
	interface I_TurtleImage {
	}

	/**
	 * Animation part of the RawTurtle.
	 *     Puts RawTurtle upon a TurtleScreen and provides tools for
	 *     its animation.
	 *     
	 */
	function RawTurtle(canvas?, shape?, undobuffersize?, visible?): Promise<IRawTurtle>
	function RawTurtle$({ canvas, shape, undobuffersize, visible }: { canvas?, shape?, undobuffersize?, visible?}): Promise<IRawTurtle>
	interface IRawTurtle extends ITPen, ITNavigator {

		/**
		 * Delete the turtle's drawings and restore its default values.
		 * 
		 *         No argument.
		 * 
		 *         Delete the turtle's drawings from the screen, re-center the turtle
		 *         and set variables to the default values.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.position()
		 *         (0.00,-22.00)
		 *         >>> turtle.heading()
		 *         100.0
		 *         >>> turtle.reset()
		 *         >>> turtle.position()
		 *         (0.00,0.00)
		 *         >>> turtle.heading()
		 *         0.0
		 *         
		 */
		reset(): Promise<any>
		reset$($: {}): Promise<any>

		/**
		 * Set or disable undobuffer.
		 * 
		 *         Argument:
		 *         size -- an integer or None
		 * 
		 *         If size is an integer an empty undobuffer of given size is installed.
		 *         Size gives the maximum number of turtle-actions that can be undone
		 *         by the undo() function.
		 *         If size is None, no undobuffer is present.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.setundobuffer(42)
		 *         
		 */
		setundobuffer(size): Promise<any>
		setundobuffer$({ size }): Promise<any>

		/**
		 * Return count of entries in the undobuffer.
		 * 
		 *         No argument.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> while undobufferentries():
		 *         ...     undo()
		 *         
		 */
		undobufferentries(): Promise<any>
		undobufferentries$($: {}): Promise<any>

		/**
		 * Delete the turtle's drawings from the screen. Do not move turtle.
		 * 
		 *         No arguments.
		 * 
		 *         Delete the turtle's drawings from the screen. Do not move turtle.
		 *         State and position of the turtle as well as drawings of other
		 *         turtles are not affected.
		 * 
		 *         Examples (for a Turtle instance named turtle):
		 *         >>> turtle.clear()
		 *         
		 */
		clear(): Promise<any>
		clear$($: {}): Promise<any>

		/**
		 * Create and return a clone of the turtle.
		 * 
		 *         No argument.
		 * 
		 *         Create and return a clone of the turtle with same position, heading
		 *         and turtle properties.
		 * 
		 *         Example (for a Turtle instance named mick):
		 *         mick = Turtle()
		 *         joe = mick.clone()
		 *         
		 */
		clone(): Promise<any>
		clone$($: {}): Promise<any>

		/**
		 * Set turtle shape to shape with given name / return current shapename.
		 * 
		 *         Optional argument:
		 *         name -- a string, which is a valid shapename
		 * 
		 *         Set turtle shape to shape with given name or, if name is not given,
		 *         return name of current shape.
		 *         Shape with name must exist in the TurtleScreen's shape dictionary.
		 *         Initially there are the following polygon shapes:
		 *         'arrow', 'turtle', 'circle', 'square', 'triangle', 'classic'.
		 *         To learn about how to deal with shapes see Screen-method register_shape.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.shape()
		 *         'arrow'
		 *         >>> turtle.shape("turtle")
		 *         >>> turtle.shape()
		 *         'turtle'
		 *         
		 */
		shape(name?): Promise<any>
		shape$({ name }: { name?}): Promise<any>

		/**
		 * Set/return turtle's stretchfactors/outline. Set resizemode to "user".
		 * 
		 *         Optional arguments:
		 *            stretch_wid : positive number
		 *            stretch_len : positive number
		 *            outline  : positive number
		 * 
		 *         Return or set the pen's attributes x/y-stretchfactors and/or outline.
		 *         Set resizemode to "user".
		 *         If and only if resizemode is set to "user", the turtle will be displayed
		 *         stretched according to its stretchfactors:
		 *         stretch_wid is stretchfactor perpendicular to orientation
		 *         stretch_len is stretchfactor in direction of turtles orientation.
		 *         outline determines the width of the shapes's outline.
		 * 
		 *         Examples (for a Turtle instance named turtle):
		 *         >>> turtle.resizemode("user")
		 *         >>> turtle.shapesize(5, 5, 12)
		 *         >>> turtle.shapesize(outline=8)
		 *         
		 */
		shapesize(stretch_wid?, stretch_len?, outline?): Promise<any>
		shapesize$({ stretch_wid, stretch_len, outline }: { stretch_wid?, stretch_len?, outline?}): Promise<any>

		/**
		 * Set or return the current shearfactor.
		 * 
		 *         Optional argument: shear -- number, tangent of the shear angle
		 * 
		 *         Shear the turtleshape according to the given shearfactor shear,
		 *         which is the tangent of the shear angle. DO NOT change the
		 *         turtle's heading (direction of movement).
		 *         If shear is not given: return the current shearfactor, i. e. the
		 *         tangent of the shear angle, by which lines parallel to the
		 *         heading of the turtle are sheared.
		 * 
		 *         Examples (for a Turtle instance named turtle):
		 *         >>> turtle.shape("circle")
		 *         >>> turtle.shapesize(5,2)
		 *         >>> turtle.shearfactor(0.5)
		 *         >>> turtle.shearfactor()
		 *         >>> 0.5
		 *         
		 */
		shearfactor(shear?): Promise<any>
		shearfactor$({ shear }: { shear?}): Promise<any>

		/**
		 * Rotate the turtleshape to point in the specified direction
		 * 
		 *         Argument: angle -- number
		 * 
		 *         Rotate the turtleshape to point in the direction specified by angle,
		 *         regardless of its current tilt-angle. DO NOT change the turtle's
		 *         heading (direction of movement).
		 * 
		 * 
		 *         Examples (for a Turtle instance named turtle):
		 *         >>> turtle.shape("circle")
		 *         >>> turtle.shapesize(5,2)
		 *         >>> turtle.settiltangle(45)
		 *         >>> stamp()
		 *         >>> turtle.fd(50)
		 *         >>> turtle.settiltangle(-45)
		 *         >>> stamp()
		 *         >>> turtle.fd(50)
		 *         
		 */
		settiltangle(angle): Promise<any>
		settiltangle$({ angle }): Promise<any>

		/**
		 * Set or return the current tilt-angle.
		 * 
		 *         Optional argument: angle -- number
		 * 
		 *         Rotate the turtleshape to point in the direction specified by angle,
		 *         regardless of its current tilt-angle. DO NOT change the turtle's
		 *         heading (direction of movement).
		 *         If angle is not given: return the current tilt-angle, i. e. the angle
		 *         between the orientation of the turtleshape and the heading of the
		 *         turtle (its direction of movement).
		 * 
		 *         Deprecated since Python 3.1
		 * 
		 *         Examples (for a Turtle instance named turtle):
		 *         >>> turtle.shape("circle")
		 *         >>> turtle.shapesize(5,2)
		 *         >>> turtle.tilt(45)
		 *         >>> turtle.tiltangle()
		 *         
		 */
		tiltangle(angle?): Promise<any>
		tiltangle$({ angle }: { angle?}): Promise<any>

		/**
		 * Rotate the turtleshape by angle.
		 * 
		 *         Argument:
		 *         angle - a number
		 * 
		 *         Rotate the turtleshape by angle from its current tilt-angle,
		 *         but do NOT change the turtle's heading (direction of movement).
		 * 
		 *         Examples (for a Turtle instance named turtle):
		 *         >>> turtle.shape("circle")
		 *         >>> turtle.shapesize(5,2)
		 *         >>> turtle.tilt(30)
		 *         >>> turtle.fd(50)
		 *         >>> turtle.tilt(30)
		 *         >>> turtle.fd(50)
		 *         
		 */
		tilt(angle): Promise<any>
		tilt$({ angle }): Promise<any>

		/**
		 * Set or return the current transformation matrix of the turtle shape.
		 * 
		 *         Optional arguments: t11, t12, t21, t22 -- numbers.
		 * 
		 *         If none of the matrix elements are given, return the transformation
		 *         matrix.
		 *         Otherwise set the given elements and transform the turtleshape
		 *         according to the matrix consisting of first row t11, t12 and
		 *         second row t21, 22.
		 *         Modify stretchfactor, shearfactor and tiltangle according to the
		 *         given matrix.
		 * 
		 *         Examples (for a Turtle instance named turtle):
		 *         >>> turtle.shape("square")
		 *         >>> turtle.shapesize(4,2)
		 *         >>> turtle.shearfactor(-0.5)
		 *         >>> turtle.shapetransform()
		 *         (4.0, -1.0, -0.0, 2.0)
		 *         
		 */
		shapetransform(t11?, t12?, t21?, t22?): Promise<any>
		shapetransform$({ t11, t12, t21, t22 }: { t11?, t12?, t21?, t22?}): Promise<any>

		/**
		 * Return the current shape polygon as tuple of coordinate pairs.
		 * 
		 *         No argument.
		 * 
		 *         Examples (for a Turtle instance named turtle):
		 *         >>> turtle.shape("square")
		 *         >>> turtle.shapetransform(4, -1, 0, 2)
		 *         >>> turtle.get_shapepoly()
		 *         ((50, -20), (30, 20), (-50, 20), (-30, -20))
		 * 
		 *         
		 */
		get_shapepoly(): Promise<any>
		get_shapepoly$($: {}): Promise<any>

		/**
		 * Stamp a copy of the turtleshape onto the canvas and return its id.
		 * 
		 *         No argument.
		 * 
		 *         Stamp a copy of the turtle shape onto the canvas at the current
		 *         turtle position. Return a stamp_id for that stamp, which can be
		 *         used to delete it by calling clearstamp(stamp_id).
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.color("blue")
		 *         >>> turtle.stamp()
		 *         13
		 *         >>> turtle.fd(50)
		 *         
		 */
		stamp(): Promise<any>
		stamp$($: {}): Promise<any>

		/**
		 * Delete stamp with given stampid
		 * 
		 *         Argument:
		 *         stampid - an integer, must be return value of previous stamp() call.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.color("blue")
		 *         >>> astamp = turtle.stamp()
		 *         >>> turtle.fd(50)
		 *         >>> turtle.clearstamp(astamp)
		 *         
		 */
		clearstamp(stampid): Promise<any>
		clearstamp$({ stampid }): Promise<any>

		/**
		 * Delete all or first/last n of turtle's stamps.
		 * 
		 *         Optional argument:
		 *         n -- an integer
		 * 
		 *         If n is None, delete all of pen's stamps,
		 *         else if n > 0 delete first n stamps
		 *         else if n < 0 delete last n stamps.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> for i in range(8):
		 *         ...     turtle.stamp(); turtle.fd(30)
		 *         ...
		 *         >>> turtle.clearstamps(2)
		 *         >>> turtle.clearstamps(-2)
		 *         >>> turtle.clearstamps()
		 *         
		 */
		clearstamps(n?): Promise<any>
		clearstamps$({ n }: { n?}): Promise<any>

		/**
		 * Return fillstate (True if filling, False else).
		 * 
		 *         No argument.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.begin_fill()
		 *         >>> if turtle.filling():
		 *         ...     turtle.pensize(5)
		 *         ... else:
		 *         ...     turtle.pensize(3)
		 *         
		 */
		filling(): Promise<any>
		filling$($: {}): Promise<any>

		/**
		 * Called just before drawing a shape to be filled.
		 * 
		 *         No argument.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.color("black", "red")
		 *         >>> turtle.begin_fill()
		 *         >>> turtle.circle(60)
		 *         >>> turtle.end_fill()
		 *         
		 */
		begin_fill(): Promise<any>
		begin_fill$($: {}): Promise<any>

		/**
		 * Fill the shape drawn after the call begin_fill().
		 * 
		 *         No argument.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.color("black", "red")
		 *         >>> turtle.begin_fill()
		 *         >>> turtle.circle(60)
		 *         >>> turtle.end_fill()
		 *         
		 */
		end_fill(): Promise<any>
		end_fill$($: {}): Promise<any>

		/**
		 * Draw a dot with diameter size, using color.
		 * 
		 *         Optional arguments:
		 *         size -- an integer >= 1 (if given)
		 *         color -- a colorstring or a numeric color tuple
		 * 
		 *         Draw a circular dot with diameter size, using color.
		 *         If size is not given, the maximum of pensize+4 and 2*pensize is used.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.dot()
		 *         >>> turtle.fd(50); turtle.dot(20, "blue"); turtle.fd(50)
		 *         
		 */
		dot(size?): Promise<any>
		dot$({ size }: { size?}): Promise<any>

		/**
		 * Write text at the current turtle position.
		 * 
		 *         Arguments:
		 *         arg -- info, which is to be written to the TurtleScreen
		 *         move (optional) -- True/False
		 *         align (optional) -- one of the strings "left", "center" or right"
		 *         font (optional) -- a triple (fontname, fontsize, fonttype)
		 * 
		 *         Write text - the string representation of arg - at the current
		 *         turtle position according to align ("left", "center" or right")
		 *         and with the given font.
		 *         If move is True, the pen is moved to the bottom-right corner
		 *         of the text. By default, move is False.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.write('Home = ', True, align="center")
		 *         >>> turtle.write((0,0), True)
		 *         
		 */
		write(arg, move?: boolean, align?, font?): Promise<any>
		write$({ arg, move, align, font }: { arg, move?, align?, font?}): Promise<any>

		/**
		 * Start recording the vertices of a polygon.
		 * 
		 *         No argument.
		 * 
		 *         Start recording the vertices of a polygon. Current turtle position
		 *         is first point of polygon.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.begin_poly()
		 *         
		 */
		begin_poly(): Promise<any>
		begin_poly$($: {}): Promise<any>

		/**
		 * Stop recording the vertices of a polygon.
		 * 
		 *         No argument.
		 * 
		 *         Stop recording the vertices of a polygon. Current turtle position is
		 *         last point of polygon. This will be connected with the first point.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.end_poly()
		 *         
		 */
		end_poly(): Promise<any>
		end_poly$($: {}): Promise<any>

		/**
		 * Return the lastly recorded polygon.
		 * 
		 *         No argument.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> p = turtle.get_poly()
		 *         >>> turtle.register_shape("myFavouriteShape", p)
		 *         
		 */
		get_poly(): Promise<any>
		get_poly$($: {}): Promise<any>

		/**
		 * Return the TurtleScreen object, the turtle is drawing  on.
		 * 
		 *         No argument.
		 * 
		 *         Return the TurtleScreen object, the turtle is drawing  on.
		 *         So TurtleScreen-methods can be called for that object.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> ts = turtle.getscreen()
		 *         >>> ts
		 *         <turtle.TurtleScreen object at 0x0106B770>
		 *         >>> ts.bgcolor("pink")
		 *         
		 */
		getscreen(): Promise<any>
		getscreen$($: {}): Promise<any>

		/**
		 * Return the Turtleobject itself.
		 * 
		 *         No argument.
		 * 
		 *         Only reasonable use: as a function to return the 'anonymous turtle':
		 * 
		 *         Example:
		 *         >>> pet = getturtle()
		 *         >>> pet.fd(50)
		 *         >>> pet
		 *         <turtle.Turtle object at 0x0187D810>
		 *         >>> turtles()
		 *         [<turtle.Turtle object at 0x0187D810>]
		 *         
		 */
		getturtle(): Promise<any>
		getturtle$($: {}): Promise<any>

		/**
		 * Bind fun to mouse-click event on this turtle on canvas.
		 * 
		 *         Arguments:
		 *         fun --  a function with two arguments, to which will be assigned
		 *                 the coordinates of the clicked point on the canvas.
		 *         btn --  number of the mouse-button defaults to 1 (left mouse button).
		 *         add --  True or False. If True, new binding will be added, otherwise
		 *                 it will replace a former binding.
		 * 
		 *         Example for the anonymous turtle, i. e. the procedural way:
		 * 
		 *         >>> def turn(x, y):
		 *         ...     left(360)
		 *         ...
		 *         >>> onclick(turn)  # Now clicking into the turtle will turn it.
		 *         >>> onclick(None)  # event-binding will be removed
		 *         
		 */
		onclick(fun, btn?, add?): Promise<any>
		onclick$({ fun, btn, add }: { fun, btn?, add?}): Promise<any>

		/**
		 * Bind fun to mouse-button-release event on this turtle on canvas.
		 * 
		 *         Arguments:
		 *         fun -- a function with two arguments, to which will be assigned
		 *                 the coordinates of the clicked point on the canvas.
		 *         btn --  number of the mouse-button defaults to 1 (left mouse button).
		 * 
		 *         Example (for a MyTurtle instance named joe):
		 *         >>> class MyTurtle(Turtle):
		 *         ...     def glow(self,x,y):
		 *         ...             self.fillcolor("red")
		 *         ...     def unglow(self,x,y):
		 *         ...             self.fillcolor("")
		 *         ...
		 *         >>> joe = MyTurtle()
		 *         >>> joe.onclick(joe.glow)
		 *         >>> joe.onrelease(joe.unglow)
		 * 
		 *         Clicking on joe turns fillcolor red, unclicking turns it to
		 *         transparent.
		 *         
		 */
		onrelease(fun, btn?, add?): Promise<any>
		onrelease$({ fun, btn, add }: { fun, btn?, add?}): Promise<any>

		/**
		 * Bind fun to mouse-move event on this turtle on canvas.
		 * 
		 *         Arguments:
		 *         fun -- a function with two arguments, to which will be assigned
		 *                the coordinates of the clicked point on the canvas.
		 *         btn -- number of the mouse-button defaults to 1 (left mouse button).
		 * 
		 *         Every sequence of mouse-move-events on a turtle is preceded by a
		 *         mouse-click event on that turtle.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> turtle.ondrag(turtle.goto)
		 * 
		 *         Subsequently clicking and dragging a Turtle will move it
		 *         across the screen thereby producing handdrawings (if pen is
		 *         down).
		 *         
		 */
		ondrag(fun, btn?, add?): Promise<any>
		ondrag$({ fun, btn, add }: { fun, btn?, add?}): Promise<any>

		/**
		 * undo (repeatedly) the last turtle action.
		 * 
		 *         No argument.
		 * 
		 *         undo (repeatedly) the last turtle action.
		 *         Number of available undo actions is determined by the size of
		 *         the undobuffer.
		 * 
		 *         Example (for a Turtle instance named turtle):
		 *         >>> for i in range(4):
		 *         ...     turtle.fd(50); turtle.lt(80)
		 *         ...
		 *         >>> for i in range(8):
		 *         ...     turtle.undo()
		 *         ...
		 *         
		 */
		undo(): Promise<any>
		undo$($: {}): Promise<any>
		screens
		getpen
		turtlesize
	}
	interface I_Screen extends ITurtleScreen {

		/**
		 *  Set the size and position of the main window.
		 * 
		 *         Arguments:
		 *         width: as integer a size in pixels, as float a fraction of the screen.
		 *           Default is 50% of screen.
		 *         height: as integer the height in pixels, as float a fraction of the
		 *           screen. Default is 75% of screen.
		 *         startx: if positive, starting position in pixels from the left
		 *           edge of the screen, if negative from the right edge
		 *           Default, startx=None is to center window horizontally.
		 *         starty: if positive, starting position in pixels from the top
		 *           edge of the screen, if negative from the bottom edge
		 *           Default, starty=None is to center window vertically.
		 * 
		 *         Examples (for a Screen instance named screen):
		 *         >>> screen.setup (width=200, height=200, startx=0, starty=0)
		 * 
		 *         sets window to 200x200 pixels, in upper left of screen
		 * 
		 *         >>> screen.setup(width=.75, height=0.5, startx=None, starty=None)
		 * 
		 *         sets window to 75% of screen by 50% of screen and centers
		 *         
		 */
		setup(width?, height?, startx?, starty?): Promise<any>
		setup$({ width, height, startx, starty }: { width?, height?, startx?, starty?}): Promise<any>

		/**
		 * Set title of turtle-window
		 * 
		 *         Argument:
		 *         titlestring -- a string, to appear in the titlebar of the
		 *                        turtle graphics window.
		 * 
		 *         This is a method of Screen-class. Not available for TurtleScreen-
		 *         objects.
		 * 
		 *         Example (for a Screen instance named screen):
		 *         >>> screen.title("Welcome to the turtle-zoo!")
		 *         
		 */
		title(titlestring): Promise<any>
		title$({ titlestring }): Promise<any>

		/**
		 * Shut the turtlegraphics window.
		 * 
		 *         Example (for a TurtleScreen instance named screen):
		 *         >>> screen.bye()
		 *         
		 */
		bye(): Promise<any>
		bye$($: {}): Promise<any>

		/**
		 * Go into mainloop until the mouse is clicked.
		 * 
		 *         No arguments.
		 * 
		 *         Bind bye() method to mouseclick on TurtleScreen.
		 *         If "using_IDLE" - value in configuration dictionary is False
		 *         (default value), enter mainloop.
		 *         If IDLE with -n switch (no subprocess) is used, this value should be
		 *         set to True in turtle.cfg. In this case IDLE's mainloop
		 *         is active also for the client script.
		 * 
		 *         This is a method of the Screen-class and not available for
		 *         TurtleScreen instances.
		 * 
		 *         Example (for a Screen instance named screen):
		 *         >>> screen.exitonclick()
		 * 
		 *         
		 */
		exitonclick(): Promise<any>
		exitonclick$($: {}): Promise<any>
	}

	/**
	 * RawTurtle auto-creating (scrolled) canvas.
	 * 
	 *     When a Turtle object is created or a function derived from some
	 *     Turtle method is called a TurtleScreen object is automatically created.
	 *     
	 */
	function Turtle(shape?, undobuffersize?, visible?): Promise<ITurtle>
	function Turtle$({ shape, undobuffersize, visible }: { shape?, undobuffersize?, visible?}): Promise<ITurtle>
	interface ITurtle extends IRawTurtle {
	}
	let Canvas: Promise<any>
	let RawPen: Promise<any>
	let Pen: Promise<any>
	let done: Promise<any>
}
declare module turtledemo {
	var _
	module __main__ {
		var _
		function getExampleEntries(): Promise<any>
		function getExampleEntries$($: {}): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		function DemoWindow(filename?): Promise<IDemoWindow>
		function DemoWindow$({ filename }: { filename?}): Promise<IDemoWindow>
		interface IDemoWindow {
			onResize(event): Promise<any>
			onResize$({ event }): Promise<any>
			makeTextFrame(root): Promise<any>
			makeTextFrame$({ root }): Promise<any>
			makeGraphFrame(root): Promise<any>
			makeGraphFrame$({ root }): Promise<any>
			set_txtsize(size): Promise<any>
			set_txtsize$({ size }): Promise<any>
			decrease_size(dummy?): Promise<any>
			decrease_size$({ dummy }: { dummy?}): Promise<any>
			increase_size(dummy?): Promise<any>
			increase_size$({ dummy }: { dummy?}): Promise<any>
			update_mousewheel(event): Promise<any>
			update_mousewheel$({ event }): Promise<any>
			configGUI(start, stop, clear, txt?, color?): Promise<any>
			configGUI$({ start, stop, clear, txt, color }: { start, stop, clear, txt?, color?}): Promise<any>
			makeLoadDemoMenu(master): Promise<any>
			makeLoadDemoMenu$({ master }): Promise<any>
			makeFontMenu(master): Promise<any>
			makeFontMenu$({ master }): Promise<any>
			makeHelpMenu(master): Promise<any>
			makeHelpMenu$({ master }): Promise<any>
			refreshCanvas(): Promise<any>
			refreshCanvas$($: {}): Promise<any>
			loadfile(filename): Promise<any>
			loadfile$({ filename }): Promise<any>
			startDemo(): Promise<any>
			startDemo$($: {}): Promise<any>
			clearCanvas(): Promise<any>
			clearCanvas$($: {}): Promise<any>
			stopIt(): Promise<any>
			stopIt$($: {}): Promise<any>
		}
		let demo_dir: Promise<any>
		let darwin: Promise<any>
		let STARTUP: Promise<any>
		let READY: Promise<any>
		let RUNNING: Promise<any>
		let DONE: Promise<any>
		let EVENTDRIVEN: Promise<any>
		let menufont: Promise<any>
		let btnfont: Promise<any>
		let txtfont: Promise<any>
		let MINIMUM_FONT_SIZE: Promise<any>
		let MAXIMUM_FONT_SIZE: Promise<any>
		let font_sizes: Promise<any>
		let help_entries: Promise<any>
	}
	module bytedesign {
		var _
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		interface IDesigner {
			design(homePos, scale): Promise<any>
			design$({ homePos, scale }): Promise<any>
			wheel(initpos, scale): Promise<any>
			wheel$({ initpos, scale }): Promise<any>
			tripiece(initpos, scale): Promise<any>
			tripiece$({ initpos, scale }): Promise<any>
			pentpiece(initpos, scale): Promise<any>
			pentpiece$({ initpos, scale }): Promise<any>
			pentl(side, ang, scale): Promise<any>
			pentl$({ side, ang, scale }): Promise<any>
			pentr(side, ang, scale): Promise<any>
			pentr$({ side, ang, scale }): Promise<any>
			tripolyr(side, scale): Promise<any>
			tripolyr$({ side, scale }): Promise<any>
			tripolyl(side, scale): Promise<any>
			tripolyl$({ side, scale }): Promise<any>
			centerpiece(s, a, scale): Promise<any>
			centerpiece$({ s, a, scale }): Promise<any>
		}
		let msg: Promise<any>
	}
	module chaos {
		var _
		function f(x): Promise<any>
		function f$({ x }): Promise<any>
		function g(x): Promise<any>
		function g$({ x }): Promise<any>
		function h(x): Promise<any>
		function h$({ x }): Promise<any>
		function jumpto(x, y): Promise<any>
		function jumpto$({ x, y }): Promise<any>
		function line(x1, y1, x2, y2): Promise<any>
		function line$({ x1, y1, x2, y2 }): Promise<any>
		function coosys(): Promise<any>
		function coosys$($: {}): Promise<any>
		function plot(fun, start, color): Promise<any>
		function plot$({ fun, start, color }): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		let N: Promise<any>
	}
	module clock {
		var _
		function jump(distanz, winkel?): Promise<any>
		function jump$({ distanz, winkel }: { distanz, winkel?}): Promise<any>
		function hand(laenge, spitze): Promise<any>
		function hand$({ laenge, spitze }): Promise<any>
		function make_hand_shape(name, laenge, spitze): Promise<any>
		function make_hand_shape$({ name, laenge, spitze }): Promise<any>
		function clockface(radius): Promise<any>
		function clockface$({ radius }): Promise<any>
		function setup(): Promise<any>
		function setup$($: {}): Promise<any>
		function wochentag(t): Promise<any>
		function wochentag$({ t }): Promise<any>
		function datum(z): Promise<any>
		function datum$({ z }): Promise<any>
		function tick(): Promise<any>
		function tick$($: {}): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		let msg: Promise<any>
	}
	module colormixer {
		var _
		function setbgcolor(): Promise<any>
		function setbgcolor$($: {}): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		function ColorTurtle(x, y): Promise<IColorTurtle>
		function ColorTurtle$({ x, y }): Promise<IColorTurtle>
		interface IColorTurtle {
			shift(x, y): Promise<any>
			shift$({ x, y }): Promise<any>
		}
		let msg: Promise<any>
	}
	module forest {
		var _
		function symRandom(n): Promise<any>
		function symRandom$({ n }): Promise<any>
		function randomize(branchlist, angledist, sizedist): Promise<any>
		function randomize$({ branchlist, angledist, sizedist }): Promise<any>
		function randomfd(t, distance, parts, angledist): Promise<any>
		function randomfd$({ t, distance, parts, angledist }): Promise<any>
		function tree(tlist, size, level, widthfactor, branchlists, angledist?, sizedist?): Promise<any>
		function tree$({ tlist, size, level, widthfactor, branchlists, angledist, sizedist }: { tlist, size, level, widthfactor, branchlists, angledist?, sizedist?}): Promise<any>
		function start(t, x, y): Promise<any>
		function start$({ t, x, y }): Promise<any>
		function doit1(level, pen): Promise<any>
		function doit1$({ level, pen }): Promise<any>
		function doit2(level, pen): Promise<any>
		function doit2$({ level, pen }): Promise<any>
		function doit3(level, pen): Promise<any>
		function doit3$({ level, pen }): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
	}
	module fractalcurves {
		var _
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		interface ICurvesTurtle {
			hilbert(size, level, parity): Promise<any>
			hilbert$({ size, level, parity }): Promise<any>
			fractalgon(n, rad, lev, dir): Promise<any>
			fractalgon$({ n, rad, lev, dir }): Promise<any>
			fractal(dist, depth, dir): Promise<any>
			fractal$({ dist, depth, dir }): Promise<any>
		}
		let msg: Promise<any>
	}
	module lindenmayer {
		var _
		function replace(seq, replacementRules, n): Promise<any>
		function replace$({ seq, replacementRules, n }): Promise<any>
		function draw(commands, rules): Promise<any>
		function draw$({ commands, rules }): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		let msg: Promise<any>
	}
	module minimal_hanoi {
		var _
		function hanoi(n, from_, with_, to_): Promise<any>
		function hanoi$({ n, from_, with_, to_ }): Promise<any>
		function play(): Promise<any>
		function play$($: {}): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		function Disc(n): Promise<IDisc>
		function Disc$({ n }): Promise<IDisc>
		interface IDisc {
		}

		/**
		 * Hanoi tower, a subclass of built-in type list
		 */

		/**
		 * create an empty tower. x is x-position of peg
		 */
		function Tower(x): Promise<ITower>
		function Tower$({ x }): Promise<ITower>
		interface ITower {
			push(d): Promise<any>
			push$({ d }): Promise<any>
			pop(): Promise<any>
			pop$($: {}): Promise<any>
		}
		let msg: Promise<any>
	}
	module nim {
		var _
		function randomrow(): Promise<any>
		function randomrow$($: {}): Promise<any>
		function computerzug(state): Promise<any>
		function computerzug$({ state }): Promise<any>
		function randommove(state): Promise<any>
		function randommove$({ state }): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		function NimModel(game): Promise<INimModel>
		function NimModel$({ game }): Promise<INimModel>
		interface INimModel {
			setup(): Promise<any>
			setup$($: {}): Promise<any>
			move(row, col): Promise<any>
			move$({ row, col }): Promise<any>
			game_over(): Promise<any>
			game_over$($: {}): Promise<any>
			notify_move(row, col): Promise<any>
			notify_move$({ row, col }): Promise<any>
		}
		function Stick(row, col, game): Promise<IStick>
		function Stick$({ row, col, game }): Promise<IStick>
		interface IStick {
			coords(row, col): Promise<any>
			coords$({ row, col }): Promise<any>
			makemove(x, y): Promise<any>
			makemove$({ x, y }): Promise<any>
		}
		function NimView(game): Promise<INimView>
		function NimView$({ game }): Promise<INimView>
		interface INimView {
			display(msg1, msg2?): Promise<any>
			display$({ msg1, msg2 }: { msg1, msg2?}): Promise<any>
			setup(): Promise<any>
			setup$($: {}): Promise<any>
			notify_move(row, col, maxspalte, player): Promise<any>
			notify_move$({ row, col, maxspalte, player }): Promise<any>
			notify_over(): Promise<any>
			notify_over$($: {}): Promise<any>
			clear(): Promise<any>
			clear$($: {}): Promise<any>
		}
		function NimController(game): Promise<INimController>
		function NimController$({ game }): Promise<INimController>
		interface INimController {
			notify_move(row, col): Promise<any>
			notify_move$({ row, col }): Promise<any>
		}
		function Nim(screen): Promise<INim>
		function Nim$({ screen }): Promise<INim>
		interface INim {
			CREATED
			RUNNING
			OVER
		}
		let SCREENWIDTH: Promise<any>
		let SCREENHEIGHT: Promise<any>
		let MINSTICKS: Promise<any>
		let MAXSTICKS: Promise<any>
		let HUNIT: Promise<any>
		let WUNIT: Promise<any>
		let SCOLOR: Promise<any>
		let HCOLOR: Promise<any>
		let COLOR: Promise<any>
	}
	module paint {
		var _
		function switchupdown(x?, y?): Promise<any>
		function switchupdown$({ x, y }: { x?, y?}): Promise<any>
		function changecolor(x?, y?): Promise<any>
		function changecolor$({ x, y }: { x?, y?}): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		let msg: Promise<any>
	}
	module peace {
		var _
		function main(): Promise<any>
		function main$($: {}): Promise<any>
	}
	module penrose {
		var _
		function kite(l): Promise<any>
		function kite$({ l }): Promise<any>
		function dart(l): Promise<any>
		function dart$({ l }): Promise<any>
		function inflatekite(l, n): Promise<any>
		function inflatekite$({ l, n }): Promise<any>
		function inflatedart(l, n): Promise<any>
		function inflatedart$({ l, n }): Promise<any>
		function draw(l, n, th?): Promise<any>
		function draw$({ l, n, th }: { l, n, th?}): Promise<any>
		function sun(l, n): Promise<any>
		function sun$({ l, n }): Promise<any>
		function star(l, n): Promise<any>
		function star$({ l, n }): Promise<any>
		function makeshapes(): Promise<any>
		function makeshapes$($: {}): Promise<any>
		function start(): Promise<any>
		function start$($: {}): Promise<any>
		function test(l?, n?, fun?, startpos?, th?): Promise<any>
		function test$({ l, n, fun, startpos, th }: { l?, n?, fun?, startpos?, th?}): Promise<any>
		function demo(fun?): Promise<any>
		function demo$({ fun }: { fun?}): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		let f: Promise<any>
		let d: Promise<any>
		let msg: Promise<any>
	}
	module planet_and_moon {
		var _
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		function GravSys(): Promise<IGravSys>
		function GravSys$({ }): Promise<IGravSys>
		interface IGravSys {
			init(): Promise<any>
			init$($: {}): Promise<any>
			start(): Promise<any>
			start$($: {}): Promise<any>
		}
		function Star(m, x, v, gravSys, shape): Promise<IStar>
		function Star$({ m, x, v, gravSys, shape }): Promise<IStar>
		interface IStar {
			init(): Promise<any>
			init$($: {}): Promise<any>
			acc(): Promise<any>
			acc$($: {}): Promise<any>
			step(): Promise<any>
			step$($: {}): Promise<any>
		}
		let G: Promise<any>
	}
	module rosette {
		var _
		function mn_eck(p, ne, sz): Promise<any>
		function mn_eck$({ p, ne, sz }): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		let msg: Promise<any>
	}
	module round_dance {
		var _
		function stop(): Promise<any>
		function stop$($: {}): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
	}
	module sorting_animate {
		var _
		function isort(shelf): Promise<any>
		function isort$({ shelf }): Promise<any>
		function ssort(shelf): Promise<any>
		function ssort$({ shelf }): Promise<any>
		function partition(shelf, left, right, pivot_index): Promise<any>
		function partition$({ shelf, left, right, pivot_index }): Promise<any>
		function qsort(shelf, left, right): Promise<any>
		function qsort$({ shelf, left, right }): Promise<any>
		function randomize(): Promise<any>
		function randomize$($: {}): Promise<any>
		function show_text(text, line?): Promise<any>
		function show_text$({ text, line }: { text, line?}): Promise<any>
		function start_ssort(): Promise<any>
		function start_ssort$($: {}): Promise<any>
		function start_isort(): Promise<any>
		function start_isort$($: {}): Promise<any>
		function start_qsort(): Promise<any>
		function start_qsort$($: {}): Promise<any>
		function init_shelf(): Promise<any>
		function init_shelf$($: {}): Promise<any>
		function disable_keys(): Promise<any>
		function disable_keys$($: {}): Promise<any>
		function enable_keys(): Promise<any>
		function enable_keys$($: {}): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		function Block(size): Promise<IBlock>
		function Block$({ size }): Promise<IBlock>
		interface IBlock {
			glow(): Promise<any>
			glow$($: {}): Promise<any>
			unglow(): Promise<any>
			unglow$($: {}): Promise<any>
		}

		/**
		 * create a shelf. y is y-position of first block
		 */
		function Shelf(y): Promise<IShelf>
		function Shelf$({ y }): Promise<IShelf>
		interface IShelf {
			push(d): Promise<any>
			push$({ d }): Promise<any>
			pop(key): Promise<any>
			pop$({ key }): Promise<any>
			insert(key, b): Promise<any>
			insert$({ key, b }): Promise<any>
		}
		let instructions1: Promise<any>
		let instructions2: Promise<any>
		let msg: Promise<any>
	}
	module tree {
		var _

		/**
		 *  plist is list of pens
		 *     l is length of branch
		 *     a is half of the angle between 2 branches
		 *     f is factor by which branch is shortened
		 *     from level to level.
		 */
		function tree(plist, l, a, f): Promise<any>
		function tree$({ plist, l, a, f }): Promise<any>
		function maketree(): Promise<any>
		function maketree$($: {}): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
		let msg: Promise<any>
	}
	module two_canvases {
		var _
		function main(): Promise<any>
		function main$($: {}): Promise<any>
	}
	module yinyang {
		var _
		function yin(radius, color1, color2): Promise<any>
		function yin$({ radius, color1, color2 }): Promise<any>
		function main(): Promise<any>
		function main$($: {}): Promise<any>
	}
}
declare module types {
	var _

	/**
	 * Create a class object dynamically using the appropriate metaclass.
	 */
	function new_class(name, bases?, kwds?, exec_body?): Promise<any>
	function new_class$({ name, bases, kwds, exec_body }: { name, bases?, kwds?, exec_body?}): Promise<any>

	/**
	 * Resolve MRO entries dynamically as specified by PEP 560.
	 */
	function resolve_bases(bases): Promise<any>
	function resolve_bases$({ bases }): Promise<any>

	/**
	 * Call the __prepare__ method of the appropriate metaclass.
	 * 
	 *     Returns (metaclass, namespace, kwds) as a 3-tuple
	 * 
	 *     *metaclass* is the appropriate metaclass
	 *     *namespace* is the prepared class namespace
	 *     *kwds* is an updated copy of the passed in kwds argument with any
	 *     'metaclass' entry removed. If no kwds argument is passed in, this will
	 *     be an empty dict.
	 *     
	 */
	function prepare_class(name, bases?, kwds?): Promise<any>
	function prepare_class$({ name, bases, kwds }: { name, bases?, kwds?}): Promise<any>

	/**
	 * Convert regular generator function to a coroutine.
	 */
	function coroutine(func): Promise<any>
	function coroutine$({ func }): Promise<any>
	interface I_C {
	}

	/**
	 * Route attribute access on a class to __getattr__.
	 * 
	 *     This is a descriptor, used to define attributes that act differently when
	 *     accessed through an instance and through a class.  Instance access remains
	 *     normal, but access to an attribute through a class will be routed to the
	 *     class's __getattr__ method; this is done by raising AttributeError.
	 * 
	 *     This allows one to have properties active on an instance, and have virtual
	 *     attributes on the class with the same name.  (Enum used this between Python
	 *     versions 3.4 - 3.9 .)
	 * 
	 *     Subclass from this to use a different method of accessing virtual attributes
	 *     and still be treated properly by the inspect module. (Enum uses this since
	 *     Python 3.10 .)
	 * 
	 *     
	 */
	function DynamicClassAttribute(fget?, fset?, fdel?, doc?): Promise<IDynamicClassAttribute>
	function DynamicClassAttribute$({ fget, fset, fdel, doc }: { fget?, fset?, fdel?, doc?}): Promise<IDynamicClassAttribute>
	interface IDynamicClassAttribute {
		getter(fget): Promise<any>
		getter$({ fget }): Promise<any>
		setter(fset): Promise<any>
		setter$({ fset }): Promise<any>
		deleter(fdel): Promise<any>
		deleter$({ fdel }): Promise<any>
	}
	interface I_GeneratorWrapper {
		send(val): Promise<any>
		send$({ val }): Promise<any>
		throw(tp): Promise<any>
		throw$({ tp }): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
		gi_code(): Promise<any>
		gi_code$($: {}): Promise<any>
		gi_frame(): Promise<any>
		gi_frame$($: {}): Promise<any>
		gi_running(): Promise<any>
		gi_running$($: {}): Promise<any>
		gi_yieldfrom(): Promise<any>
		gi_yieldfrom$($: {}): Promise<any>
		cr_code
		cr_frame
		cr_running
		cr_await
	}
	let FunctionType: Promise<any>
	let LambdaType: Promise<any>
	let CodeType: Promise<any>
	let MappingProxyType: Promise<any>
	let SimpleNamespace: Promise<any>
	let CellType: Promise<any>
	let GeneratorType: Promise<any>
	let CoroutineType: Promise<any>
	let AsyncGeneratorType: Promise<any>
	let MethodType: Promise<any>
	let BuiltinFunctionType: Promise<any>
	let BuiltinMethodType: Promise<any>
	let WrapperDescriptorType: Promise<any>
	let MethodWrapperType: Promise<any>
	let MethodDescriptorType: Promise<any>
	let ClassMethodDescriptorType: Promise<any>
	let ModuleType: Promise<any>
	let GetSetDescriptorType: Promise<any>
	let MemberDescriptorType: Promise<any>
	let GenericAlias: Promise<any>
	let Union: Promise<any>
	let EllipsisType: Promise<any>
	let NoneType: Promise<any>
	let NotImplementedType: Promise<any>
}
declare module typing {
	var _

	/**
	 * Special type indicating an unconstrained type.
	 * 
	 *     - Any is compatible with every type.
	 *     - Any assumed to have all methods.
	 *     - All values assumed to be instances of Any.
	 * 
	 *     Note that all the above statements are true from the point of view of
	 *     static type checkers. At runtime, Any should not be used with instance
	 *     or class checks.
	 *     
	 */
	function Any(parameters): Promise<any>
	function Any$({ parameters }): Promise<any>

	/**
	 * Special type indicating functions that never return.
	 *     Example::
	 * 
	 *       from typing import NoReturn
	 * 
	 *       def stop() -> NoReturn:
	 *           raise Exception('no way')
	 * 
	 *     This type is invalid in other positions, e.g., ``List[NoReturn]``
	 *     will fail in static type checkers.
	 *     
	 */
	function NoReturn(parameters): Promise<any>
	function NoReturn$({ parameters }): Promise<any>

	/**
	 * Special type construct to mark class variables.
	 * 
	 *     An annotation wrapped in ClassVar indicates that a given
	 *     attribute is intended to be used as a class variable and
	 *     should not be set on instances of that class. Usage::
	 * 
	 *       class Starship:
	 *           stats: ClassVar[Dict[str, int]] = {} # class variable
	 *           damage: int = 10                     # instance variable
	 * 
	 *     ClassVar accepts only types and cannot be further subscribed.
	 * 
	 *     Note that ClassVar is not a class itself, and should not
	 *     be used with isinstance() or issubclass().
	 *     
	 */
	function ClassVar(parameters): Promise<any>
	function ClassVar$({ parameters }): Promise<any>

	/**
	 * Special typing construct to indicate final names to type checkers.
	 * 
	 *     A final name cannot be re-assigned or overridden in a subclass.
	 *     For example:
	 * 
	 *       MAX_SIZE: Final = 9000
	 *       MAX_SIZE += 1  # Error reported by type checker
	 * 
	 *       class Connection:
	 *           TIMEOUT: Final[int] = 10
	 * 
	 *       class FastConnector(Connection):
	 *           TIMEOUT = 1  # Error reported by type checker
	 * 
	 *     There is no runtime checking of these properties.
	 *     
	 */
	function Final(parameters): Promise<any>
	function Final$({ parameters }): Promise<any>

	/**
	 * Union type; Union[X, Y] means either X or Y.
	 * 
	 *     To define a union, use e.g. Union[int, str].  Details:
	 *     - The arguments must be types and there must be at least one.
	 *     - None as an argument is a special case and is replaced by
	 *       type(None).
	 *     - Unions of unions are flattened, e.g.::
	 * 
	 *         Union[Union[int, str], float] == Union[int, str, float]
	 * 
	 *     - Unions of a single argument vanish, e.g.::
	 * 
	 *         Union[int] == int  # The constructor actually returns int
	 * 
	 *     - Redundant arguments are skipped, e.g.::
	 * 
	 *         Union[int, str, int] == Union[int, str]
	 * 
	 *     - When comparing unions, the argument order is ignored, e.g.::
	 * 
	 *         Union[int, str] == Union[str, int]
	 * 
	 *     - You cannot subclass or instantiate a union.
	 *     - You can use Optional[X] as a shorthand for Union[X, None].
	 *     
	 */
	function Union(parameters): Promise<any>
	function Union$({ parameters }): Promise<any>

	/**
	 * Optional type.
	 * 
	 *     Optional[X] is equivalent to Union[X, None].
	 *     
	 */
	function Optional(parameters): Promise<any>
	function Optional$({ parameters }): Promise<any>

	/**
	 * Special typing form to define literal types (a.k.a. value types).
	 * 
	 *     This form can be used to indicate to type checkers that the corresponding
	 *     variable or function parameter has a value equivalent to the provided
	 *     literal (or one of several literals):
	 * 
	 *       def validate_simple(data: Any) -> Literal[True]:  # always returns True
	 *           ...
	 * 
	 *       MODE = Literal['r', 'rb', 'w', 'wb']
	 *       def open_helper(file: str, mode: MODE) -> str:
	 *           ...
	 * 
	 *       open_helper('/some/path', 'r')  # Passes type check
	 *       open_helper('/other/path', 'typo')  # Error in type checker
	 * 
	 *     Literal[...] cannot be subclassed. At runtime, an arbitrary value
	 *     is allowed as type argument to Literal[...], but type checkers may
	 *     impose restrictions.
	 *     
	 */
	function Literal(parameters): Promise<any>
	function Literal$({ parameters }): Promise<any>

	/**
	 * Special marker indicating that an assignment should
	 *     be recognized as a proper type alias definition by type
	 *     checkers.
	 * 
	 *     For example::
	 * 
	 *         Predicate: TypeAlias = Callable[..., bool]
	 * 
	 *     It's invalid when used anywhere except as in the example above.
	 *     
	 */
	function TypeAlias(parameters): Promise<any>
	function TypeAlias$({ parameters }): Promise<any>

	/**
	 * Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a
	 *     higher order function which adds, removes or transforms parameters of a
	 *     callable.
	 * 
	 *     For example::
	 * 
	 *        Callable[Concatenate[int, P], int]
	 * 
	 *     See PEP 612 for detailed information.
	 *     
	 */
	function Concatenate(parameters): Promise<any>
	function Concatenate$({ parameters }): Promise<any>

	/**
	 * Special typing form used to annotate the return type of a user-defined
	 *     type guard function.  ``TypeGuard`` only accepts a single type argument.
	 *     At runtime, functions marked this way should return a boolean.
	 * 
	 *     ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static
	 *     type checkers to determine a more precise type of an expression within a
	 *     program's code flow.  Usually type narrowing is done by analyzing
	 *     conditional code flow and applying the narrowing to a block of code.  The
	 *     conditional expression here is sometimes referred to as a "type guard".
	 * 
	 *     Sometimes it would be convenient to use a user-defined boolean function
	 *     as a type guard.  Such a function should use ``TypeGuard[...]`` as its
	 *     return type to alert static type checkers to this intention.
	 * 
	 *     Using  ``-> TypeGuard`` tells the static type checker that for a given
	 *     function:
	 * 
	 *     1. The return value is a boolean.
	 *     2. If the return value is ``True``, the type of its argument
	 *        is the type inside ``TypeGuard``.
	 * 
	 *        For example::
	 * 
	 *           def is_str(val: Union[str, float]):
	 *               # "isinstance" type guard
	 *               if isinstance(val, str):
	 *                   # Type of ``val`` is narrowed to ``str``
	 *                   ...
	 *               else:
	 *                   # Else, type of ``val`` is narrowed to ``float``.
	 *                   ...
	 * 
	 *     Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower
	 *     form of ``TypeA`` (it can even be a wider form) and this may lead to
	 *     type-unsafe results.  The main reason is to allow for things like
	 *     narrowing ``List[object]`` to ``List[str]`` even though the latter is not
	 *     a subtype of the former, since ``List`` is invariant.  The responsibility of
	 *     writing type-safe type guards is left to the user.
	 * 
	 *     ``TypeGuard`` also works with type variables.  For more information, see
	 *     PEP 647 (User-Defined Type Guards).
	 *     
	 */
	function TypeGuard(parameters): Promise<any>
	function TypeGuard$({ parameters }): Promise<any>

	/**
	 * Mark a protocol class as a runtime protocol.
	 * 
	 *     Such protocol can be used with isinstance() and issubclass().
	 *     Raise TypeError if applied to a non-protocol class.
	 *     This allows a simple-minded structural check very similar to
	 *     one trick ponies in collections.abc such as Iterable.
	 *     For example::
	 * 
	 *         @runtime_checkable
	 *         class Closable(Protocol):
	 *             def close(self): ...
	 * 
	 *         assert isinstance(open('/some/file'), Closable)
	 * 
	 *     Warning: this will check only the presence of the required methods,
	 *     not their type signatures!
	 *     
	 */
	function runtime_checkable(cls): Promise<any>
	function runtime_checkable$({ cls }): Promise<any>

	/**
	 * Cast a value to a type.
	 * 
	 *     This returns the value unchanged.  To the type checker this
	 *     signals that the return value has the designated type, but at
	 *     runtime we intentionally don't check anything (we want this
	 *     to be as fast as possible).
	 *     
	 */
	function cast(typ, val): Promise<any>
	function cast$({ typ, val }): Promise<any>

	/**
	 * Return type hints for an object.
	 * 
	 *     This is often the same as obj.__annotations__, but it handles
	 *     forward references encoded as string literals, adds Optional[t] if a
	 *     default value equal to None is set and recursively replaces all
	 *     'Annotated[T, ...]' with 'T' (unless 'include_extras=True').
	 * 
	 *     The argument may be a module, class, method, or function. The annotations
	 *     are returned as a dictionary. For classes, annotations include also
	 *     inherited members.
	 * 
	 *     TypeError is raised if the argument is not of a type that can contain
	 *     annotations, and an empty dictionary is returned if no annotations are
	 *     present.
	 * 
	 *     BEWARE -- the behavior of globalns and localns is counterintuitive
	 *     (unless you are familiar with how eval() and exec() work).  The
	 *     search order is locals first, then globals.
	 * 
	 *     - If no dict arguments are passed, an attempt is made to use the
	 *       globals from obj (or the respective module's globals for classes),
	 *       and these are also used as the locals.  If the object does not appear
	 *       to have globals, an empty dictionary is used.  For classes, the search
	 *       order is globals first then locals.
	 * 
	 *     - If one dict argument is passed, it is used for both globals and
	 *       locals.
	 * 
	 *     - If two dict arguments are passed, they specify globals and
	 *       locals, respectively.
	 *     
	 */
	function get_type_hints(obj, globalns?, localns?, include_extras?: boolean): Promise<any>
	function get_type_hints$({ obj, globalns, localns, include_extras }: { obj, globalns?, localns?, include_extras?}): Promise<any>

	/**
	 * Get the unsubscripted version of a type.
	 * 
	 *     This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar
	 *     and Annotated. Return None for unsupported types. Examples::
	 * 
	 *         get_origin(Literal[42]) is Literal
	 *         get_origin(int) is None
	 *         get_origin(ClassVar[int]) is ClassVar
	 *         get_origin(Generic) is Generic
	 *         get_origin(Generic[T]) is Generic
	 *         get_origin(Union[T, int]) is Union
	 *         get_origin(List[Tuple[T, T]][int]) == list
	 *         get_origin(P.args) is P
	 *     
	 */
	function get_origin(tp): Promise<any>
	function get_origin$({ tp }): Promise<any>

	/**
	 * Get type arguments with all substitutions performed.
	 * 
	 *     For unions, basic simplifications used by Union constructor are performed.
	 *     Examples::
	 *         get_args(Dict[str, int]) == (str, int)
	 *         get_args(int) == ()
	 *         get_args(Union[int, Union[T, int], str][int]) == (int, str)
	 *         get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])
	 *         get_args(Callable[[], T][int]) == ([], int)
	 *     
	 */
	function get_args(tp): Promise<any>
	function get_args$({ tp }): Promise<any>

	/**
	 * Check if an annotation is a TypedDict class
	 * 
	 *     For example::
	 *         class Film(TypedDict):
	 *             title: str
	 *             year: int
	 * 
	 *         is_typeddict(Film)  # => True
	 *         is_typeddict(Union[list, str])  # => False
	 *     
	 */
	function is_typeddict(tp): Promise<any>
	function is_typeddict$({ tp }): Promise<any>

	/**
	 * Decorator to indicate that annotations are not type hints.
	 * 
	 *     The argument must be a class or function; if it is a class, it
	 *     applies recursively to all methods and classes defined in that class
	 *     (but not to methods defined in its superclasses or subclasses).
	 * 
	 *     This mutates the function(s) or class(es) in place.
	 *     
	 */
	function no_type_check(arg): Promise<any>
	function no_type_check$({ arg }): Promise<any>

	/**
	 * Decorator to give another decorator the @no_type_check effect.
	 * 
	 *     This wraps the decorator with something that wraps the decorated
	 *     function in @no_type_check.
	 *     
	 */
	function no_type_check_decorator(decorator): Promise<any>
	function no_type_check_decorator$({ decorator }): Promise<any>

	/**
	 * Decorator for overloaded functions/methods.
	 * 
	 *     In a stub file, place two or more stub definitions for the same
	 *     function in a row, each decorated with @overload.  For example:
	 * 
	 *       @overload
	 *       def utf8(value: None) -> None: ...
	 *       @overload
	 *       def utf8(value: bytes) -> bytes: ...
	 *       @overload
	 *       def utf8(value: str) -> bytes: ...
	 * 
	 *     In a non-stub file (i.e. a regular .py file), do the same but
	 *     follow it with an implementation.  The implementation should *not*
	 *     be decorated with @overload.  For example:
	 * 
	 *       @overload
	 *       def utf8(value: None) -> None: ...
	 *       @overload
	 *       def utf8(value: bytes) -> bytes: ...
	 *       @overload
	 *       def utf8(value: str) -> bytes: ...
	 *       def utf8(value):
	 *           # implementation goes here
	 *     
	 */
	function overload(func): Promise<any>
	function overload$({ func }): Promise<any>

	/**
	 * A decorator to indicate final methods and final classes.
	 * 
	 *     Use this decorator to indicate to type checkers that the decorated
	 *     method cannot be overridden, and decorated class cannot be subclassed.
	 *     For example:
	 * 
	 *       class Base:
	 *           @final
	 *           def done(self) -> None:
	 *               ...
	 *       class Sub(Base):
	 *           def done(self) -> None:  # Error reported by type checker
	 *                 ...
	 * 
	 *       @final
	 *       class Leaf:
	 *           ...
	 *       class Other(Leaf):  # Error reported by type checker
	 *           ...
	 * 
	 *     There is no runtime checking of these properties.
	 *     
	 */
	function final(f): Promise<any>
	function final$({ f }): Promise<any>

	/**
	 * Typed version of namedtuple.
	 * 
	 *     Usage in Python versions >= 3.6::
	 * 
	 *         class Employee(NamedTuple):
	 *             name: str
	 *             id: int
	 * 
	 *     This is equivalent to::
	 * 
	 *         Employee = collections.namedtuple('Employee', ['name', 'id'])
	 * 
	 *     The resulting class has an extra __annotations__ attribute, giving a
	 *     dict that maps field names to types.  (The field names are also in
	 *     the _fields attribute, which is part of the namedtuple API.)
	 *     Alternative equivalent keyword syntax is also accepted::
	 * 
	 *         Employee = NamedTuple('Employee', name=str, id=int)
	 * 
	 *     In Python versions <= 3.5 use::
	 * 
	 *         Employee = NamedTuple('Employee', [('name', str), ('id', int)])
	 *     
	 */
	function NamedTuple(typename, fields?): Promise<any>
	function NamedTuple$({ typename, fields }: { typename, fields?}): Promise<any>

	/**
	 * A simple typed namespace. At runtime it is equivalent to a plain dict.
	 * 
	 *     TypedDict creates a dictionary type that expects all of its
	 *     instances to have a certain set of keys, where each key is
	 *     associated with a value of a consistent type. This expectation
	 *     is not checked at runtime but is only enforced by type checkers.
	 *     Usage::
	 * 
	 *         class Point2D(TypedDict):
	 *             x: int
	 *             y: int
	 *             label: str
	 * 
	 *         a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK
	 *         b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check
	 * 
	 *         assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')
	 * 
	 *     The type info can be accessed via the Point2D.__annotations__ dict, and
	 *     the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.
	 *     TypedDict supports two additional equivalent forms::
	 * 
	 *         Point2D = TypedDict('Point2D', x=int, y=int, label=str)
	 *         Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})
	 * 
	 *     By default, all keys must be present in a TypedDict. It is possible
	 *     to override this by specifying totality.
	 *     Usage::
	 * 
	 *         class point2D(TypedDict, total=False):
	 *             x: int
	 *             y: int
	 * 
	 *     This means that a point2D TypedDict can have any of the keys omitted.A type
	 *     checker is only expected to support a literal False or True as the value of
	 *     the total argument. True is the default, and makes all items defined in the
	 *     class body be required.
	 * 
	 *     The class syntax is only supported in Python 3.6+, while two other
	 *     syntax forms work for Python 2.7 and 3.2+
	 *     
	 */
	function TypedDict(typename, fields?): Promise<any>
	function TypedDict$({ typename, fields }: { typename, fields?}): Promise<any>

	/**
	 * NewType creates simple unique types with almost zero
	 *     runtime overhead. NewType(name, tp) is considered a subtype of tp
	 *     by static type checkers. At runtime, NewType(name, tp) returns
	 *     a dummy function that simply returns its argument. Usage::
	 * 
	 *         UserId = NewType('UserId', int)
	 * 
	 *         def name_by_id(user_id: UserId) -> str:
	 *             ...
	 * 
	 *         UserId('user')          # Fails type check
	 * 
	 *         name_by_id(42)          # Fails type check
	 *         name_by_id(UserId(42))  # OK
	 * 
	 *         num = UserId(5) + 1     # type: int
	 *     
	 */
	function NewType(name, tp): Promise<any>
	function NewType$({ name, tp }): Promise<any>

	/**
	 * Mixin to prohibit subclassing
	 */
	interface I_Final {
	}

	/**
	 * Mixin to indicate that object should not be copied.
	 */
	interface I_Immutable {
	}
	interface I_SpecialForm extends I_Final {
	}
	interface I_LiteralSpecialForm extends I_SpecialForm {
	}

	/**
	 * Internal wrapper to hold a forward reference.
	 */
	function ForwardRef(arg, is_argument?: boolean): Promise<IForwardRef>
	function ForwardRef$({ arg, is_argument }: { arg, is_argument?}): Promise<IForwardRef>
	interface IForwardRef extends I_Final {
	}

	/**
	 * Mixin for TypeVar-like types (TypeVar and ParamSpec).
	 */
	interface I_TypeVarLike {
	}

	/**
	 * Type variable.
	 * 
	 *     Usage::
	 * 
	 *       T = TypeVar('T')  # Can be anything
	 *       A = TypeVar('A', str, bytes)  # Must be str or bytes
	 * 
	 *     Type variables exist primarily for the benefit of static type
	 *     checkers.  They serve as the parameters for generic types as well
	 *     as for generic function definitions.  See class Generic for more
	 *     information on generic types.  Generic functions work as follows:
	 * 
	 *       def repeat(x: T, n: int) -> List[T]:
	 *           '''Return a list containing n references to x.'''
	 *           return [x]*n
	 * 
	 *       def longest(x: A, y: A) -> A:
	 *           '''Return the longest of two strings.'''
	 *           return x if len(x) >= len(y) else y
	 * 
	 *     The latter example's signature is essentially the overloading
	 *     of (str, str) -> str and (bytes, bytes) -> bytes.  Also note
	 *     that if the arguments are instances of some subclass of str,
	 *     the return type is still plain str.
	 * 
	 *     At runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.
	 * 
	 *     Type variables defined with covariant=True or contravariant=True
	 *     can be used to declare covariant or contravariant generic types.
	 *     See PEP 484 for more details. By default generic types are invariant
	 *     in all type variables.
	 * 
	 *     Type variables can be introspected. e.g.:
	 * 
	 *       T.__name__ == 'T'
	 *       T.__constraints__ == ()
	 *       T.__covariant__ == False
	 *       T.__contravariant__ = False
	 *       A.__constraints__ == (str, bytes)
	 * 
	 *     Note that only type variables defined in global scope can be pickled.
	 *     
	 */
	function TypeVar(name): Promise<ITypeVar>
	function TypeVar$({ name }): Promise<ITypeVar>
	interface ITypeVar extends I_Final, I_Immutable, I_TypeVarLike {
	}

	/**
	 * The args for a ParamSpec object.
	 * 
	 *     Given a ParamSpec object P, P.args is an instance of ParamSpecArgs.
	 * 
	 *     ParamSpecArgs objects have a reference back to their ParamSpec:
	 * 
	 *        P.args.__origin__ is P
	 * 
	 *     This type is meant for runtime introspection and has no special meaning to
	 *     static type checkers.
	 *     
	 */
	function ParamSpecArgs(origin): Promise<IParamSpecArgs>
	function ParamSpecArgs$({ origin }): Promise<IParamSpecArgs>
	interface IParamSpecArgs extends I_Final, I_Immutable {
	}

	/**
	 * The kwargs for a ParamSpec object.
	 * 
	 *     Given a ParamSpec object P, P.kwargs is an instance of ParamSpecKwargs.
	 * 
	 *     ParamSpecKwargs objects have a reference back to their ParamSpec:
	 * 
	 *        P.kwargs.__origin__ is P
	 * 
	 *     This type is meant for runtime introspection and has no special meaning to
	 *     static type checkers.
	 *     
	 */
	function ParamSpecKwargs(origin): Promise<IParamSpecKwargs>
	function ParamSpecKwargs$({ origin }): Promise<IParamSpecKwargs>
	interface IParamSpecKwargs extends I_Final, I_Immutable {
	}

	/**
	 * Parameter specification variable.
	 * 
	 *     Usage::
	 * 
	 *        P = ParamSpec('P')
	 * 
	 *     Parameter specification variables exist primarily for the benefit of static
	 *     type checkers.  They are used to forward the parameter types of one
	 *     callable to another callable, a pattern commonly found in higher order
	 *     functions and decorators.  They are only valid when used in ``Concatenate``,
	 *     or s the first argument to ``Callable``, or as parameters for user-defined
	 *     Generics.  See class Generic for more information on generic types.  An
	 *     example for annotating a decorator::
	 * 
	 *        T = TypeVar('T')
	 *        P = ParamSpec('P')
	 * 
	 *        def add_logging(f: Callable[P, T]) -> Callable[P, T]:
	 *            '''A type-safe decorator to add logging to a function.'''
	 *            def inner(*args: P.args, **kwargs: P.kwargs) -> T:
	 *                logging.info(f'{f.__name__} was called')
	 *                return f(*args, **kwargs)
	 *            return inner
	 * 
	 *        @add_logging
	 *        def add_two(x: float, y: float) -> float:
	 *            '''Add two numbers together.'''
	 *            return x + y
	 * 
	 *     Parameter specification variables defined with covariant=True or
	 *     contravariant=True can be used to declare covariant or contravariant
	 *     generic types.  These keyword arguments are valid, but their actual semantics
	 *     are yet to be decided.  See PEP 612 for details.
	 * 
	 *     Parameter specification variables can be introspected. e.g.:
	 * 
	 *        P.__name__ == 'T'
	 *        P.__bound__ == None
	 *        P.__covariant__ == False
	 *        P.__contravariant__ == False
	 * 
	 *     Note that only parameter specification variables defined in global scope can
	 *     be pickled.
	 *     
	 */
	function ParamSpec(name): Promise<IParamSpec>
	function ParamSpec$({ name }): Promise<IParamSpec>
	interface IParamSpec extends I_Final, I_Immutable, I_TypeVarLike {
		args(): Promise<any>
		args$($: {}): Promise<any>
		kwargs(): Promise<any>
		kwargs$($: {}): Promise<any>
	}

	/**
	 * The central part of internal API.
	 * 
	 *     This represents a generic version of type 'origin' with type arguments 'params'.
	 *     There are two kind of these aliases: user defined and special. The special ones
	 *     are wrappers around builtin collections and ABCs in collections.abc. These must
	 *     have 'name' always set. If 'inst' is False, then the alias can't be instantiated,
	 *     this is used by e.g. typing.List and typing.Dict.
	 *     
	 */
	interface I_BaseGenericAlias extends I_Final {
	}
	interface I_GenericAlias extends I_BaseGenericAlias {
		copy_with(params): Promise<any>
		copy_with$({ params }): Promise<any>
	}
	interface I_SpecialGenericAlias extends I_BaseGenericAlias {
		copy_with(params): Promise<any>
		copy_with$({ params }): Promise<any>
	}
	interface I_CallableGenericAlias extends I_GenericAlias {
	}
	interface I_CallableType extends I_SpecialGenericAlias {
		copy_with(params): Promise<any>
		copy_with$({ params }): Promise<any>
	}
	interface I_TupleType extends I_SpecialGenericAlias {
	}
	interface I_UnionGenericAlias extends I_GenericAlias {
		copy_with(params): Promise<any>
		copy_with$({ params }): Promise<any>
	}
	interface I_LiteralGenericAlias extends I_GenericAlias {
	}
	interface I_ConcatenateGenericAlias extends I_GenericAlias {
	}

	/**
	 * Abstract base class for generic types.
	 * 
	 *     A generic type is typically declared by inheriting from
	 *     this class parameterized with one or more type variables.
	 *     For example, a generic mapping type might be defined as::
	 * 
	 *       class Mapping(Generic[KT, VT]):
	 *           def __getitem__(self, key: KT) -> VT:
	 *               ...
	 *           # Etc.
	 * 
	 *     This class can then be used as follows::
	 * 
	 *       def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
	 *           try:
	 *               return mapping[key]
	 *           except KeyError:
	 *               return default
	 *     
	 */
	interface IGeneric {
	}

	/**
	 * Internal placeholder for () or []. Used by TupleMeta and CallableMeta
	 *     to allow empty list/tuple in specific places, without allowing them
	 *     to sneak in where prohibited.
	 *     
	 */
	interface I_TypingEmpty {
	}

	/**
	 * Internal placeholder for ... (ellipsis).
	 */
	interface I_TypingEllipsis {
	}
	interface I_ProtocolMeta {
	}

	/**
	 * Base class for protocol classes.
	 * 
	 *     Protocol classes are defined as::
	 * 
	 *         class Proto(Protocol):
	 *             def meth(self) -> int:
	 *                 ...
	 * 
	 *     Such classes are primarily used with static type checkers that recognize
	 *     structural subtyping (static duck-typing), for example::
	 * 
	 *         class C:
	 *             def meth(self) -> int:
	 *                 return 0
	 * 
	 *         def func(x: Proto) -> int:
	 *             return x.meth()
	 * 
	 *         func(C())  # Passes static type check
	 * 
	 *     See PEP 544 for details. Protocol classes decorated with
	 *     @typing.runtime_checkable act as simple-minded runtime protocols that check
	 *     only the presence of given attributes, ignoring their type signatures.
	 *     Protocol classes can be generic, they are defined as::
	 * 
	 *         class GenProto(Protocol[T]):
	 *             def meth(self) -> T:
	 *                 ...
	 *     
	 */
	interface IProtocol extends IGeneric {
	}

	/**
	 * Runtime representation of an annotated type.
	 * 
	 *     At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
	 *     with extra annotations. The alias behaves like a normal typing alias,
	 *     instantiating is the same as instantiating the underlying type, binding
	 *     it to types is also the same.
	 *     
	 */
	interface I_AnnotatedAlias extends I_GenericAlias {
		copy_with(params): Promise<any>
		copy_with$({ params }): Promise<any>
	}

	/**
	 * Add context specific metadata to a type.
	 * 
	 *     Example: Annotated[int, runtime_check.Unsigned] indicates to the
	 *     hypothetical runtime_check module that this type is an unsigned int.
	 *     Every other consumer of this type can ignore this metadata and treat
	 *     this type as int.
	 * 
	 *     The first argument to Annotated must be a valid type.
	 * 
	 *     Details:
	 * 
	 *     - It's an error to call `Annotated` with less than two arguments.
	 *     - Nested Annotated are flattened::
	 * 
	 *         Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]
	 * 
	 *     - Instantiating an annotated type is equivalent to instantiating the
	 *     underlying type::
	 * 
	 *         Annotated[C, Ann1](5) == C(5)
	 * 
	 *     - Annotated can be used as a generic type alias::
	 * 
	 *         Optimized = Annotated[T, runtime.Optimize()]
	 *         Optimized[int] == Annotated[int, runtime.Optimize()]
	 * 
	 *         OptimizedList = Annotated[List[T], runtime.Optimize()]
	 *         OptimizedList[int] == Annotated[List[int], runtime.Optimize()]
	 *     
	 */
	interface IAnnotated {
	}

	/**
	 * An ABC with one abstract method __int__.
	 */
	interface ISupportsInt extends IProtocol {
	}

	/**
	 * An ABC with one abstract method __float__.
	 */
	interface ISupportsFloat extends IProtocol {
	}

	/**
	 * An ABC with one abstract method __complex__.
	 */
	interface ISupportsComplex extends IProtocol {
	}

	/**
	 * An ABC with one abstract method __bytes__.
	 */
	interface ISupportsBytes extends IProtocol {
	}

	/**
	 * An ABC with one abstract method __index__.
	 */
	interface ISupportsIndex extends IProtocol {
	}

	/**
	 * An ABC with one abstract method __abs__ that is covariant in its return type.
	 */
	interface ISupportsAbs {
	}

	/**
	 * An ABC with one abstract method __round__ that is covariant in its return type.
	 */
	interface ISupportsRound {
	}
	interface INamedTupleMeta {
	}
	interface I_TypedDictMeta {
	}

	/**
	 * Generic base class for TextIO and BinaryIO.
	 * 
	 *     This is an abstract, generic version of the return of open().
	 * 
	 *     NOTE: This does not distinguish between the different possible
	 *     classes (text vs. binary, read vs. write vs. read/write,
	 *     append-only, unbuffered).  The TextIO and BinaryIO subclasses
	 *     below capture the distinctions between text vs. binary, which is
	 *     pervasive in the interface; however we currently do not offer a
	 *     way to track the other distinctions in the type system.
	 *     
	 */
	interface IIO {
		mode(): Promise<any>
		mode$($: {}): Promise<any>
		name(): Promise<any>
		name$($: {}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
		closed(): Promise<any>
		closed$($: {}): Promise<any>
		fileno(): Promise<any>
		fileno$($: {}): Promise<any>
		flush(): Promise<any>
		flush$($: {}): Promise<any>
		isatty(): Promise<any>
		isatty$($: {}): Promise<any>
		read(n?): Promise<any>
		read$({ n }: { n?}): Promise<any>
		readable(): Promise<any>
		readable$($: {}): Promise<any>
		readline(limit?): Promise<any>
		readline$({ limit }: { limit?}): Promise<any>
		readlines(hint?): Promise<any>
		readlines$({ hint }: { hint?}): Promise<any>
		seek(offset, whence?): Promise<any>
		seek$({ offset, whence }: { offset, whence?}): Promise<any>
		seekable(): Promise<any>
		seekable$($: {}): Promise<any>
		tell(): Promise<any>
		tell$($: {}): Promise<any>
		truncate(size?): Promise<any>
		truncate$({ size }: { size?}): Promise<any>
		writable(): Promise<any>
		writable$($: {}): Promise<any>
		write(s): Promise<any>
		write$({ s }): Promise<any>
		writelines(lines): Promise<any>
		writelines$({ lines }): Promise<any>
	}

	/**
	 * Typed version of the return of open() in binary mode.
	 */
	interface IBinaryIO {
		write(s): Promise<any>
		write$({ s }): Promise<any>
	}

	/**
	 * Typed version of the return of open() in text mode.
	 */
	interface ITextIO {
		buffer(): Promise<any>
		buffer$($: {}): Promise<any>
		encoding(): Promise<any>
		encoding$($: {}): Promise<any>
		errors(): Promise<any>
		errors$($: {}): Promise<any>
		line_buffering(): Promise<any>
		line_buffering$($: {}): Promise<any>
		newlines(): Promise<any>
		newlines$($: {}): Promise<any>
	}
	interface I_DeprecatedType {
	}

	/**
	 * Wrapper namespace for IO generic classes.
	 */
	interface Iio {
		IO
		TextIO
		BinaryIO
	}

	/**
	 * Wrapper namespace for re type aliases.
	 */
	interface Ire {
		Pattern
		Match
	}
	let EXCLUDED_ATTRIBUTES: Promise<any>
	let T: Promise<any>
	let KT: Promise<any>
	let VT: Promise<any>
	let T_co: Promise<any>
	let V_co: Promise<any>
	let VT_co: Promise<any>
	let T_contra: Promise<any>
	let CT_co: Promise<any>
	let AnyStr: Promise<any>
	let Hashable: Promise<any>
	let Awaitable: Promise<any>
	let Coroutine: Promise<any>
	let AsyncIterable: Promise<any>
	let AsyncIterator: Promise<any>
	let Iterable: Promise<any>
	let Iterator: Promise<any>
	let Reversible: Promise<any>
	let Sized: Promise<any>
	let Container: Promise<any>
	let Collection: Promise<any>
	let Callable: Promise<any>
	let AbstractSet: Promise<any>
	let MutableSet: Promise<any>
	let Mapping: Promise<any>
	let MutableMapping: Promise<any>
	let Sequence: Promise<any>
	let MutableSequence: Promise<any>
	let ByteString: Promise<any>
	let Tuple: Promise<any>
	let List: Promise<any>
	let Deque: Promise<any>
	let Set: Promise<any>
	let FrozenSet: Promise<any>
	let MappingView: Promise<any>
	let KeysView: Promise<any>
	let ItemsView: Promise<any>
	let ValuesView: Promise<any>
	let ContextManager: Promise<any>
	let AsyncContextManager: Promise<any>
	let Dict: Promise<any>
	let DefaultDict: Promise<any>
	let OrderedDict: Promise<any>
	let Counter: Promise<any>
	let ChainMap: Promise<any>
	let Generator: Promise<any>
	let AsyncGenerator: Promise<any>
	let Type: Promise<any>
	let Text: Promise<any>
	let TYPE_CHECKING: Promise<any>
}
declare module urllib {
	var _
	module error {
		var _
		function URLError(reason, filename?): Promise<IURLError>
		function URLError$({ reason, filename }: { reason, filename?}): Promise<IURLError>
		interface IURLError {
		}

		/**
		 * Raised when HTTP error occurs, but also acts like non-error return
		 */
		function HTTPError(url, code, msg, hdrs, fp): Promise<IHTTPError>
		function HTTPError$({ url, code, msg, hdrs, fp }): Promise<IHTTPError>
		interface IHTTPError extends IURLError {
			reason(): Promise<any>
			reason$($: {}): Promise<any>
			headers(): Promise<any>
			headers$($: {}): Promise<any>
			headers(headers): Promise<any>
			headers$({ headers }): Promise<any>
		}

		/**
		 * Exception raised when downloaded size does not match content-length.
		 */
		function ContentTooShortError(message, content): Promise<IContentTooShortError>
		function ContentTooShortError$({ message, content }): Promise<IContentTooShortError>
		interface IContentTooShortError extends IURLError {
		}
	}
	module parse {
		var _

		/**
		 * Clear internal performance caches. Undocumented; some tests want it.
		 */
		function clear_cache(): Promise<any>
		function clear_cache$($: {}): Promise<any>

		/**
		 * Parse a URL into 6 components:
		 *     <scheme>://<netloc>/<path>;<params>?<query>#<fragment>
		 * 
		 *     The result is a named 6-tuple with fields corresponding to the
		 *     above. It is either a ParseResult or ParseResultBytes object,
		 *     depending on the type of the url parameter.
		 * 
		 *     The username, password, hostname, and port sub-components of netloc
		 *     can also be accessed as attributes of the returned object.
		 * 
		 *     The scheme argument provides the default value of the scheme
		 *     component when no scheme is found in url.
		 * 
		 *     If allow_fragments is False, no attempt is made to separate the
		 *     fragment component from the previous component, which can be either
		 *     path or query.
		 * 
		 *     Note that % escapes are not expanded.
		 *     
		 */
		function urlparse(url, scheme?, allow_fragments?: boolean): Promise<any>
		function urlparse$({ url, scheme, allow_fragments }: { url, scheme?, allow_fragments?}): Promise<any>

		/**
		 * Parse a URL into 5 components:
		 *     <scheme>://<netloc>/<path>?<query>#<fragment>
		 * 
		 *     The result is a named 5-tuple with fields corresponding to the
		 *     above. It is either a SplitResult or SplitResultBytes object,
		 *     depending on the type of the url parameter.
		 * 
		 *     The username, password, hostname, and port sub-components of netloc
		 *     can also be accessed as attributes of the returned object.
		 * 
		 *     The scheme argument provides the default value of the scheme
		 *     component when no scheme is found in url.
		 * 
		 *     If allow_fragments is False, no attempt is made to separate the
		 *     fragment component from the previous component, which can be either
		 *     path or query.
		 * 
		 *     Note that % escapes are not expanded.
		 *     
		 */
		function urlsplit(url, scheme?, allow_fragments?: boolean): Promise<any>
		function urlsplit$({ url, scheme, allow_fragments }: { url, scheme?, allow_fragments?}): Promise<any>

		/**
		 * Put a parsed URL back together again.  This may result in a
		 *     slightly different, but equivalent URL, if the URL that was parsed
		 *     originally had redundant delimiters, e.g. a ? with an empty query
		 *     (the draft states that these are equivalent).
		 */
		function urlunparse(components): Promise<any>
		function urlunparse$({ components }): Promise<any>

		/**
		 * Combine the elements of a tuple as returned by urlsplit() into a
		 *     complete URL as a string. The data argument can be any five-item iterable.
		 *     This may result in a slightly different, but equivalent URL, if the URL that
		 *     was parsed originally had unnecessary delimiters (for example, a ? with an
		 *     empty query; the RFC states that these are equivalent).
		 */
		function urlunsplit(components): Promise<any>
		function urlunsplit$({ components }): Promise<any>

		/**
		 * Join a base URL and a possibly relative URL to form an absolute
		 *     interpretation of the latter.
		 */
		function urljoin(base, url, allow_fragments?: boolean): Promise<any>
		function urljoin$({ base, url, allow_fragments }: { base, url, allow_fragments?}): Promise<any>

		/**
		 * Removes any existing fragment from URL.
		 * 
		 *     Returns a tuple of the defragmented URL and the fragment.  If
		 *     the URL contained no fragments, the second element is the
		 *     empty string.
		 *     
		 */
		function urldefrag(url): Promise<any>
		function urldefrag$({ url }): Promise<any>

		/**
		 * unquote_to_bytes('abc%20def') -> b'abc def'.
		 */
		function unquote_to_bytes(string): Promise<any>
		function unquote_to_bytes$({ string }): Promise<any>

		/**
		 * Replace %xx escapes by their single-character equivalent. The optional
		 *     encoding and errors parameters specify how to decode percent-encoded
		 *     sequences into Unicode characters, as accepted by the bytes.decode()
		 *     method.
		 *     By default, percent-encoded sequences are decoded with UTF-8, and invalid
		 *     sequences are replaced by a placeholder character.
		 * 
		 *     unquote('abc%20def') -> 'abc def'.
		 *     
		 */
		function unquote(string, encoding?, errors?): Promise<any>
		function unquote$({ string, encoding, errors }: { string, encoding?, errors?}): Promise<any>

		/**
		 * Parse a query given as a string argument.
		 * 
		 *         Arguments:
		 * 
		 *         qs: percent-encoded query string to be parsed
		 * 
		 *         keep_blank_values: flag indicating whether blank values in
		 *             percent-encoded queries should be treated as blank strings.
		 *             A true value indicates that blanks should be retained as
		 *             blank strings.  The default false value indicates that
		 *             blank values are to be ignored and treated as if they were
		 *             not included.
		 * 
		 *         strict_parsing: flag indicating what to do with parsing errors.
		 *             If false (the default), errors are silently ignored.
		 *             If true, errors raise a ValueError exception.
		 * 
		 *         encoding and errors: specify how to decode percent-encoded sequences
		 *             into Unicode characters, as accepted by the bytes.decode() method.
		 * 
		 *         max_num_fields: int. If set, then throws a ValueError if there
		 *             are more than n fields read by parse_qsl().
		 * 
		 *         separator: str. The symbol to use for separating the query arguments.
		 *             Defaults to &.
		 * 
		 *         Returns a dictionary.
		 *     
		 */
		function parse_qs(qs, keep_blank_values?: boolean, strict_parsing?: boolean, encoding?, errors?, max_num_fields?, separator?): Promise<any>
		function parse_qs$({ qs, keep_blank_values, strict_parsing, encoding, errors, max_num_fields, separator }: { qs, keep_blank_values?, strict_parsing?, encoding?, errors?, max_num_fields?, separator?}): Promise<any>

		/**
		 * Parse a query given as a string argument.
		 * 
		 *         Arguments:
		 * 
		 *         qs: percent-encoded query string to be parsed
		 * 
		 *         keep_blank_values: flag indicating whether blank values in
		 *             percent-encoded queries should be treated as blank strings.
		 *             A true value indicates that blanks should be retained as blank
		 *             strings.  The default false value indicates that blank values
		 *             are to be ignored and treated as if they were  not included.
		 * 
		 *         strict_parsing: flag indicating what to do with parsing errors. If
		 *             false (the default), errors are silently ignored. If true,
		 *             errors raise a ValueError exception.
		 * 
		 *         encoding and errors: specify how to decode percent-encoded sequences
		 *             into Unicode characters, as accepted by the bytes.decode() method.
		 * 
		 *         max_num_fields: int. If set, then throws a ValueError
		 *             if there are more than n fields read by parse_qsl().
		 * 
		 *         separator: str. The symbol to use for separating the query arguments.
		 *             Defaults to &.
		 * 
		 *         Returns a list, as G-d intended.
		 *     
		 */
		function parse_qsl(qs, keep_blank_values?: boolean, strict_parsing?: boolean, encoding?, errors?, max_num_fields?, separator?): Promise<any>
		function parse_qsl$({ qs, keep_blank_values, strict_parsing, encoding, errors, max_num_fields, separator }: { qs, keep_blank_values?, strict_parsing?, encoding?, errors?, max_num_fields?, separator?}): Promise<any>

		/**
		 * Like unquote(), but also replace plus signs by spaces, as required for
		 *     unquoting HTML form values.
		 * 
		 *     unquote_plus('%7e/abc+def') -> '~/abc def'
		 *     
		 */
		function unquote_plus(string, encoding?, errors?): Promise<any>
		function unquote_plus$({ string, encoding, errors }: { string, encoding?, errors?}): Promise<any>

		/**
		 * quote('abc def') -> 'abc%20def'
		 * 
		 *     Each part of a URL, e.g. the path info, the query, etc., has a
		 *     different set of reserved characters that must be quoted. The
		 *     quote function offers a cautious (not minimal) way to quote a
		 *     string for most of these parts.
		 * 
		 *     RFC 3986 Uniform Resource Identifier (URI): Generic Syntax lists
		 *     the following (un)reserved characters.
		 * 
		 *     unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
		 *     reserved      = gen-delims / sub-delims
		 *     gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
		 *     sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
		 *                   / "*" / "+" / "," / ";" / "="
		 * 
		 *     Each of the reserved characters is reserved in some component of a URL,
		 *     but not necessarily in all of them.
		 * 
		 *     The quote function %-escapes all characters that are neither in the
		 *     unreserved chars ("always safe") nor the additional chars set via the
		 *     safe arg.
		 * 
		 *     The default for the safe arg is '/'. The character is reserved, but in
		 *     typical usage the quote function is being called on a path where the
		 *     existing slash characters are to be preserved.
		 * 
		 *     Python 3.7 updates from using RFC 2396 to RFC 3986 to quote URL strings.
		 *     Now, "~" is included in the set of unreserved characters.
		 * 
		 *     string and safe may be either str or bytes objects. encoding and errors
		 *     must not be specified if string is a bytes object.
		 * 
		 *     The optional encoding and errors parameters specify how to deal with
		 *     non-ASCII characters, as accepted by the str.encode method.
		 *     By default, encoding='utf-8' (characters are encoded with UTF-8), and
		 *     errors='strict' (unsupported characters raise a UnicodeEncodeError).
		 *     
		 */
		function quote(string, safe?, encoding?, errors?): Promise<any>
		function quote$({ string, safe, encoding, errors }: { string, safe?, encoding?, errors?}): Promise<any>

		/**
		 * Like quote(), but also replace ' ' with '+', as required for quoting
		 *     HTML form values. Plus signs in the original string are escaped unless
		 *     they are included in safe. It also does not have safe default to '/'.
		 *     
		 */
		function quote_plus(string, safe?, encoding?, errors?): Promise<any>
		function quote_plus$({ string, safe, encoding, errors }: { string, safe?, encoding?, errors?}): Promise<any>

		/**
		 * Like quote(), but accepts a bytes object rather than a str, and does
		 *     not perform string-to-bytes encoding.  It always returns an ASCII string.
		 *     quote_from_bytes(b'abc def?') -> 'abc%20def%3f'
		 *     
		 */
		function quote_from_bytes(bs, safe?): Promise<any>
		function quote_from_bytes$({ bs, safe }: { bs, safe?}): Promise<any>

		/**
		 * Encode a dict or sequence of two-element tuples into a URL query string.
		 * 
		 *     If any values in the query arg are sequences and doseq is true, each
		 *     sequence element is converted to a separate parameter.
		 * 
		 *     If the query arg is a sequence of two-element tuples, the order of the
		 *     parameters in the output will match the order of parameters in the
		 *     input.
		 * 
		 *     The components of a query arg may each be either a string or a bytes type.
		 * 
		 *     The safe, encoding, and errors parameters are passed down to the function
		 *     specified by quote_via (encoding and errors only if a component is a str).
		 *     
		 */
		function urlencode(query, doseq?: boolean, safe?, encoding?, errors?, quote_via?): Promise<any>
		function urlencode$({ query, doseq, safe, encoding, errors, quote_via }: { query, doseq?, safe?, encoding?, errors?, quote_via?}): Promise<any>
		function to_bytes(url): Promise<any>
		function to_bytes$({ url }): Promise<any>

		/**
		 * Transform a string like '<URL:scheme://host/path>' into 'scheme://host/path'.
		 * 
		 *     The string is returned unchanged if it's not a wrapped URL.
		 *     
		 */
		function unwrap(url): Promise<any>
		function unwrap$({ url }): Promise<any>
		function splittype(url): Promise<any>
		function splittype$({ url }): Promise<any>
		function splithost(url): Promise<any>
		function splithost$({ url }): Promise<any>
		function splituser(host): Promise<any>
		function splituser$({ host }): Promise<any>
		function splitpasswd(user): Promise<any>
		function splitpasswd$({ user }): Promise<any>
		function splitport(host): Promise<any>
		function splitport$({ host }): Promise<any>
		function splitnport(host, defport?): Promise<any>
		function splitnport$({ host, defport }: { host, defport?}): Promise<any>
		function splitquery(url): Promise<any>
		function splitquery$({ url }): Promise<any>
		function splittag(url): Promise<any>
		function splittag$({ url }): Promise<any>
		function splitattr(url): Promise<any>
		function splitattr$({ url }): Promise<any>
		function splitvalue(attr): Promise<any>
		function splitvalue$({ attr }): Promise<any>

		/**
		 * Standard approach to encoding parsed results from str to bytes
		 */
		interface I_ResultMixinStr {
			encode(encoding?, errors?): Promise<any>
			encode$({ encoding, errors }: { encoding?, errors?}): Promise<any>
		}

		/**
		 * Standard approach to decoding parsed results from bytes to str
		 */
		interface I_ResultMixinBytes {
			decode(encoding?, errors?): Promise<any>
			decode$({ encoding, errors }: { encoding?, errors?}): Promise<any>
		}

		/**
		 * Shared methods for the parsed result objects containing a netloc element
		 */
		interface I_NetlocResultMixinBase {
			username(): Promise<any>
			username$($: {}): Promise<any>
			password(): Promise<any>
			password$($: {}): Promise<any>
			hostname(): Promise<any>
			hostname$($: {}): Promise<any>
			port(): Promise<any>
			port$($: {}): Promise<any>
		}
		interface I_NetlocResultMixinStr extends I_NetlocResultMixinBase, I_ResultMixinStr {
		}
		interface I_NetlocResultMixinBytes extends I_NetlocResultMixinBase, I_ResultMixinBytes {
		}
		interface IDefragResult extends I_ResultMixinStr {
			geturl(): Promise<any>
			geturl$($: {}): Promise<any>
		}
		interface ISplitResult extends I_NetlocResultMixinStr {
			geturl(): Promise<any>
			geturl$($: {}): Promise<any>
		}
		interface IParseResult extends I_NetlocResultMixinStr {
			geturl(): Promise<any>
			geturl$($: {}): Promise<any>
		}
		interface IDefragResultBytes extends I_ResultMixinBytes {
			geturl(): Promise<any>
			geturl$($: {}): Promise<any>
		}
		interface ISplitResultBytes extends I_NetlocResultMixinBytes {
			geturl(): Promise<any>
			geturl$($: {}): Promise<any>
		}
		interface IParseResultBytes extends I_NetlocResultMixinBytes {
			geturl(): Promise<any>
			geturl$($: {}): Promise<any>
		}

		/**
		 * A mapping from bytes numbers (in range(0,256)) to strings.
		 * 
		 *     String values are percent-encoded byte values, unless the key < 128, and
		 *     in either of the specified safe set, or the always safe set.
		 *     
		 */
		interface I_Quoter {
		}
		let uses_relative: Promise<any>
		let uses_netloc: Promise<any>
		let uses_params: Promise<any>
		let non_hierarchical: Promise<any>
		let uses_query: Promise<any>
		let uses_fragment: Promise<any>
		let scheme_chars: Promise<any>
		let ResultBase: Promise<any>
	}
	module request {
		var _

		/**
		 * Open the URL url, which can be either a string or a Request object.
		 * 
		 *     *data* must be an object specifying additional data to be sent to
		 *     the server, or None if no such data is needed.  See Request for
		 *     details.
		 * 
		 *     urllib.request module uses HTTP/1.1 and includes a "Connection:close"
		 *     header in its HTTP requests.
		 * 
		 *     The optional *timeout* parameter specifies a timeout in seconds for
		 *     blocking operations like the connection attempt (if not specified, the
		 *     global default timeout setting will be used). This only works for HTTP,
		 *     HTTPS and FTP connections.
		 * 
		 *     If *context* is specified, it must be a ssl.SSLContext instance describing
		 *     the various SSL options. See HTTPSConnection for more details.
		 * 
		 *     The optional *cafile* and *capath* parameters specify a set of trusted CA
		 *     certificates for HTTPS requests. cafile should point to a single file
		 *     containing a bundle of CA certificates, whereas capath should point to a
		 *     directory of hashed certificate files. More information can be found in
		 *     ssl.SSLContext.load_verify_locations().
		 * 
		 *     The *cadefault* parameter is ignored.
		 * 
		 * 
		 *     This function always returns an object which can work as a
		 *     context manager and has the properties url, headers, and status.
		 *     See urllib.response.addinfourl for more detail on these properties.
		 * 
		 *     For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse
		 *     object slightly modified. In addition to the three new methods above, the
		 *     msg attribute contains the same information as the reason attribute ---
		 *     the reason phrase returned by the server --- instead of the response
		 *     headers as it is specified in the documentation for HTTPResponse.
		 * 
		 *     For FTP, file, and data URLs and requests explicitly handled by legacy
		 *     URLopener and FancyURLopener classes, this function returns a
		 *     urllib.response.addinfourl object.
		 * 
		 *     Note that None may be returned if no handler handles the request (though
		 *     the default installed global OpenerDirector uses UnknownHandler to ensure
		 *     this never happens).
		 * 
		 *     In addition, if proxy settings are detected (for example, when a *_proxy
		 *     environment variable like http_proxy is set), ProxyHandler is default
		 *     installed and makes sure the requests are handled through the proxy.
		 * 
		 *     
		 */
		function urlopen(url, data?, timeout?): Promise<any>
		function urlopen$({ url, data, timeout }: { url, data?, timeout?}): Promise<any>
		function install_opener(opener): Promise<any>
		function install_opener$({ opener }): Promise<any>

		/**
		 * 
		 *     Retrieve a URL into a temporary location on disk.
		 * 
		 *     Requires a URL argument. If a filename is passed, it is used as
		 *     the temporary file location. The reporthook argument should be
		 *     a callable that accepts a block number, a read size, and the
		 *     total file size of the URL target. The data argument should be
		 *     valid URL encoded data.
		 * 
		 *     If a filename is passed and the URL points to a local resource,
		 *     the result is a copy from local file to new file.
		 * 
		 *     Returns a tuple containing the path to the newly created
		 *     data file as well as the resulting HTTPMessage object.
		 *     
		 */
		function urlretrieve(url, filename?, reporthook?, data?): Promise<any>
		function urlretrieve$({ url, filename, reporthook, data }: { url, filename?, reporthook?, data?}): Promise<any>

		/**
		 * Clean up temporary files from urlretrieve calls.
		 */
		function urlcleanup(): Promise<any>
		function urlcleanup$($: {}): Promise<any>

		/**
		 * Return request-host, as defined by RFC 2965.
		 * 
		 *     Variation from RFC: returned value is lowercased, for convenient
		 *     comparison.
		 * 
		 *     
		 */
		function request_host(request): Promise<any>
		function request_host$({ request }): Promise<any>

		/**
		 * Create an opener object from a list of handlers.
		 * 
		 *     The opener will use several default handlers, including support
		 *     for HTTP, FTP and when applicable HTTPS.
		 * 
		 *     If any of the handlers passed as arguments are subclasses of the
		 *     default handlers, the default handlers will not be used.
		 *     
		 */
		function build_opener(): Promise<any>
		function build_opener$($: {}): Promise<any>

		/**
		 * Parse list of key=value strings where keys are not duplicated.
		 */
		function parse_keqv_list(l): Promise<any>
		function parse_keqv_list$({ l }): Promise<any>

		/**
		 * Parse lists as described by RFC 2068 Section 2.
		 * 
		 *     In particular, parse comma-separated lists where the elements of
		 *     the list may include quoted-strings.  A quoted-string could
		 *     contain a comma.  A non-quoted string could have quotes in the
		 *     middle.  Neither commas nor quotes count if they are escaped.
		 *     Only double-quotes count, not single-quotes.
		 *     
		 */
		function parse_http_list(s): Promise<any>
		function parse_http_list$({ s }): Promise<any>

		/**
		 * OS-specific conversion from a relative URL of the 'file' scheme
		 *         to a file system path; not recommended for general use.
		 */
		function url2pathname(pathname): Promise<any>
		function url2pathname$({ pathname }): Promise<any>

		/**
		 * OS-specific conversion from a file system path to a relative URL
		 *         of the 'file' scheme; not recommended for general use.
		 */
		function pathname2url(pathname): Promise<any>
		function pathname2url$({ pathname }): Promise<any>

		/**
		 * Return the IP address of the magic hostname 'localhost'.
		 */
		function localhost(): Promise<any>
		function localhost$($: {}): Promise<any>

		/**
		 * Return the IP addresses of the current host.
		 */
		function thishost(): Promise<any>
		function thishost$($: {}): Promise<any>

		/**
		 * Return the set of errors raised by the FTP class.
		 */
		function ftperrors(): Promise<any>
		function ftperrors$($: {}): Promise<any>

		/**
		 * Return an empty email Message object.
		 */
		function noheaders(): Promise<any>
		function noheaders$($: {}): Promise<any>

		/**
		 * Return a dictionary of scheme -> proxy server URL mappings.
		 * 
		 *     Scan the environment for variables named <scheme>_proxy;
		 *     this seems to be the standard convention.  If you need a
		 *     different way, you can pass a proxies dictionary to the
		 *     [Fancy]URLopener constructor.
		 * 
		 *     
		 */
		function getproxies_environment(): Promise<any>
		function getproxies_environment$($: {}): Promise<any>

		/**
		 * Test if proxies should not be used for a particular host.
		 * 
		 *     Checks the proxy dict for the value of no_proxy, which should
		 *     be a list of comma separated DNS suffixes, or '*' for all hosts.
		 * 
		 *     
		 */
		function proxy_bypass_environment(host, proxies?): Promise<any>
		function proxy_bypass_environment$({ host, proxies }: { host, proxies?}): Promise<any>
		function proxy_bypass_macosx_sysconf(host): Promise<any>
		function proxy_bypass_macosx_sysconf$({ host }): Promise<any>

		/**
		 * Return a dictionary of scheme -> proxy server URL mappings.
		 * 
		 *         This function uses the MacOSX framework SystemConfiguration
		 *         to fetch the proxy information.
		 *         
		 */
		function getproxies_macosx_sysconf(): Promise<any>
		function getproxies_macosx_sysconf$($: {}): Promise<any>

		/**
		 * Return True, if host should be bypassed.
		 * 
		 *         Checks proxy settings gathered from the environment, if specified,
		 *         or from the MacOSX framework SystemConfiguration.
		 * 
		 *         
		 */
		function proxy_bypass(host): Promise<any>
		function proxy_bypass$({ host }): Promise<any>
		function getproxies(): Promise<any>
		function getproxies$($: {}): Promise<any>

		/**
		 * Return a dictionary of scheme -> proxy server URL mappings.
		 * 
		 *         Win32 uses the registry to store proxies.
		 * 
		 *         
		 */
		function getproxies_registry(): Promise<any>
		function getproxies_registry$($: {}): Promise<any>

		/**
		 * Return a dictionary of scheme -> proxy server URL mappings.
		 * 
		 *         Returns settings gathered from the environment, if specified,
		 *         or the registry.
		 * 
		 *         
		 */
		function getproxies(): Promise<any>
		function getproxies$($: {}): Promise<any>
		function proxy_bypass_registry(host): Promise<any>
		function proxy_bypass_registry$({ host }): Promise<any>

		/**
		 * Return True, if host should be bypassed.
		 * 
		 *         Checks proxy settings gathered from the environment, if specified,
		 *         or the registry.
		 * 
		 *         
		 */
		function proxy_bypass(host): Promise<any>
		function proxy_bypass$({ host }): Promise<any>
		function Request(url, data?, headers?, origin_req_host?, unverifiable?: boolean, method?): Promise<IRequest>
		function Request$({ url, data, headers, origin_req_host, unverifiable, method }: { url, data?, headers?, origin_req_host?, unverifiable?, method?}): Promise<IRequest>
		interface IRequest {
			full_url(): Promise<any>
			full_url$($: {}): Promise<any>
			full_url(url): Promise<any>
			full_url$({ url }): Promise<any>
			full_url(): Promise<any>
			full_url$($: {}): Promise<any>
			data(): Promise<any>
			data$($: {}): Promise<any>
			data(data): Promise<any>
			data$({ data }): Promise<any>
			data(): Promise<any>
			data$($: {}): Promise<any>

			/**
			 * Return a string indicating the HTTP request method.
			 */
			get_method(): Promise<any>
			get_method$($: {}): Promise<any>
			get_full_url(): Promise<any>
			get_full_url$($: {}): Promise<any>
			set_proxy(host, type): Promise<any>
			set_proxy$({ host, type }): Promise<any>
			has_proxy(): Promise<any>
			has_proxy$($: {}): Promise<any>
			add_header(key, val): Promise<any>
			add_header$({ key, val }): Promise<any>
			add_unredirected_header(key, val): Promise<any>
			add_unredirected_header$({ key, val }): Promise<any>
			has_header(header_name): Promise<any>
			has_header$({ header_name }): Promise<any>
			get_header(header_name, def?): Promise<any>
			get_header$({ header_name, def }: { header_name, def?}): Promise<any>
			remove_header(header_name): Promise<any>
			remove_header$({ header_name }): Promise<any>
			header_items(): Promise<any>
			header_items$($: {}): Promise<any>
		}
		function OpenerDirector(): Promise<IOpenerDirector>
		function OpenerDirector$({ }): Promise<IOpenerDirector>
		interface IOpenerDirector {
			add_handler(handler): Promise<any>
			add_handler$({ handler }): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			open(fullurl, data?, timeout?): Promise<any>
			open$({ fullurl, data, timeout }: { fullurl, data?, timeout?}): Promise<any>
			error(proto): Promise<any>
			error$({ proto }): Promise<any>
		}
		interface IBaseHandler {
			add_parent(parent): Promise<any>
			add_parent$({ parent }): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			handler_order
		}

		/**
		 * Process HTTP error responses.
		 */
		interface IHTTPErrorProcessor extends IBaseHandler {
			http_response(request, response): Promise<any>
			http_response$({ request, response }): Promise<any>
			https_response
		}
		interface IHTTPDefaultErrorHandler extends IBaseHandler {
			http_error_default(req, fp, code, msg, hdrs): Promise<any>
			http_error_default$({ req, fp, code, msg, hdrs }): Promise<any>
		}
		interface IHTTPRedirectHandler extends IBaseHandler {

			/**
			 * Return a Request or None in response to a redirect.
			 * 
			 *         This is called by the http_error_30x methods when a
			 *         redirection response is received.  If a redirection should
			 *         take place, return a new Request to allow http_error_30x to
			 *         perform the redirect.  Otherwise, raise HTTPError if no-one
			 *         else should try to handle this url.  Return None if you can't
			 *         but another Handler might.
			 *         
			 */
			redirect_request(req, fp, code, msg, headers, newurl): Promise<any>
			redirect_request$({ req, fp, code, msg, headers, newurl }): Promise<any>
			http_error_302(req, fp, code, msg, headers): Promise<any>
			http_error_302$({ req, fp, code, msg, headers }): Promise<any>
			max_repeats
			max_redirections
			http_error_301
			http_error_303
			http_error_307
			inf_msg
		}
		function ProxyHandler(proxies?): Promise<IProxyHandler>
		function ProxyHandler$({ proxies }: { proxies?}): Promise<IProxyHandler>
		interface IProxyHandler extends IBaseHandler {
			proxy_open(req, proxy, type): Promise<any>
			proxy_open$({ req, proxy, type }): Promise<any>
		}
		function HTTPPasswordMgr(): Promise<IHTTPPasswordMgr>
		function HTTPPasswordMgr$({ }): Promise<IHTTPPasswordMgr>
		interface IHTTPPasswordMgr {
			add_password(realm, uri, user, passwd): Promise<any>
			add_password$({ realm, uri, user, passwd }): Promise<any>
			find_user_password(realm, authuri): Promise<any>
			find_user_password$({ realm, authuri }): Promise<any>

			/**
			 * Accept authority or URI and extract only the authority and path.
			 */
			reduce_uri(uri, default_port?: boolean): Promise<any>
			reduce_uri$({ uri, default_port }: { uri, default_port?}): Promise<any>

			/**
			 * Check if test is below base in a URI tree
			 * 
			 *         Both args must be URIs in reduced form.
			 *         
			 */
			is_suburi(base, test): Promise<any>
			is_suburi$({ base, test }): Promise<any>
		}
		interface IHTTPPasswordMgrWithDefaultRealm extends IHTTPPasswordMgr {
			find_user_password(realm, authuri): Promise<any>
			find_user_password$({ realm, authuri }): Promise<any>
		}
		function HTTPPasswordMgrWithPriorAuth(): Promise<IHTTPPasswordMgrWithPriorAuth>
		function HTTPPasswordMgrWithPriorAuth$({ }): Promise<IHTTPPasswordMgrWithPriorAuth>
		interface IHTTPPasswordMgrWithPriorAuth extends IHTTPPasswordMgrWithDefaultRealm {
			add_password(realm, uri, user, passwd, is_authenticated?: boolean): Promise<any>
			add_password$({ realm, uri, user, passwd, is_authenticated }: { realm, uri, user, passwd, is_authenticated?}): Promise<any>
			update_authenticated(uri, is_authenticated?: boolean): Promise<any>
			update_authenticated$({ uri, is_authenticated }: { uri, is_authenticated?}): Promise<any>
			is_authenticated(authuri): Promise<any>
			is_authenticated$({ authuri }): Promise<any>
		}
		function AbstractBasicAuthHandler(password_mgr?): Promise<IAbstractBasicAuthHandler>
		function AbstractBasicAuthHandler$({ password_mgr }: { password_mgr?}): Promise<IAbstractBasicAuthHandler>
		interface IAbstractBasicAuthHandler {
			http_error_auth_reqed(authreq, host, req, headers): Promise<any>
			http_error_auth_reqed$({ authreq, host, req, headers }): Promise<any>
			retry_http_basic_auth(host, req, realm): Promise<any>
			retry_http_basic_auth$({ host, req, realm }): Promise<any>
			http_request(req): Promise<any>
			http_request$({ req }): Promise<any>
			http_response(req, response): Promise<any>
			http_response$({ req, response }): Promise<any>
			rx
			https_request
		}
		interface IHTTPBasicAuthHandler extends IAbstractBasicAuthHandler, IBaseHandler {
			http_error_401(req, fp, code, msg, headers): Promise<any>
			http_error_401$({ req, fp, code, msg, headers }): Promise<any>
			auth_header
		}
		interface IProxyBasicAuthHandler extends IAbstractBasicAuthHandler, IBaseHandler {
			http_error_407(req, fp, code, msg, headers): Promise<any>
			http_error_407$({ req, fp, code, msg, headers }): Promise<any>
		}
		function AbstractDigestAuthHandler(passwd?): Promise<IAbstractDigestAuthHandler>
		function AbstractDigestAuthHandler$({ passwd }: { passwd?}): Promise<IAbstractDigestAuthHandler>
		interface IAbstractDigestAuthHandler {
			reset_retry_count(): Promise<any>
			reset_retry_count$($: {}): Promise<any>
			http_error_auth_reqed(auth_header, host, req, headers): Promise<any>
			http_error_auth_reqed$({ auth_header, host, req, headers }): Promise<any>
			retry_http_digest_auth(req, auth): Promise<any>
			retry_http_digest_auth$({ req, auth }): Promise<any>
			get_cnonce(nonce): Promise<any>
			get_cnonce$({ nonce }): Promise<any>
			get_authorization(req, chal): Promise<any>
			get_authorization$({ req, chal }): Promise<any>
			get_algorithm_impls(algorithm): Promise<any>
			get_algorithm_impls$({ algorithm }): Promise<any>
			get_entity_digest(data, chal): Promise<any>
			get_entity_digest$({ data, chal }): Promise<any>
		}

		/**
		 * An authentication protocol defined by RFC 2069
		 * 
		 *     Digest authentication improves on basic authentication because it
		 *     does not transmit passwords in the clear.
		 *     
		 */
		interface IHTTPDigestAuthHandler extends IBaseHandler, IAbstractDigestAuthHandler {
			http_error_401(req, fp, code, msg, headers): Promise<any>
			http_error_401$({ req, fp, code, msg, headers }): Promise<any>
		}
		interface IProxyDigestAuthHandler extends IBaseHandler, IAbstractDigestAuthHandler {
			http_error_407(req, fp, code, msg, headers): Promise<any>
			http_error_407$({ req, fp, code, msg, headers }): Promise<any>
		}
		function AbstractHTTPHandler(debuglevel?): Promise<IAbstractHTTPHandler>
		function AbstractHTTPHandler$({ debuglevel }: { debuglevel?}): Promise<IAbstractHTTPHandler>
		interface IAbstractHTTPHandler extends IBaseHandler {
			set_http_debuglevel(level): Promise<any>
			set_http_debuglevel$({ level }): Promise<any>
			do_request_(request): Promise<any>
			do_request_$({ request }): Promise<any>

			/**
			 * Return an HTTPResponse object for the request, using http_class.
			 * 
			 *         http_class must implement the HTTPConnection API from http.client.
			 *         
			 */
			do_open(http_class, req): Promise<any>
			do_open$({ http_class, req }): Promise<any>
		}
		interface IHTTPHandler extends IAbstractHTTPHandler {
			http_open(req): Promise<any>
			http_open$({ req }): Promise<any>
		}
		function HTTPSHandler(debuglevel?, context?, check_hostname?): Promise<IHTTPSHandler>
		function HTTPSHandler$({ debuglevel, context, check_hostname }: { debuglevel?, context?, check_hostname?}): Promise<IHTTPSHandler>
		interface IHTTPSHandler extends IAbstractHTTPHandler {
			https_open(req): Promise<any>
			https_open$({ req }): Promise<any>
		}
		function HTTPCookieProcessor(cookiejar?): Promise<IHTTPCookieProcessor>
		function HTTPCookieProcessor$({ cookiejar }: { cookiejar?}): Promise<IHTTPCookieProcessor>
		interface IHTTPCookieProcessor extends IBaseHandler {
			http_request(request): Promise<any>
			http_request$({ request }): Promise<any>
			http_response(request, response): Promise<any>
			http_response$({ request, response }): Promise<any>
		}
		interface IUnknownHandler extends IBaseHandler {
			unknown_open(req): Promise<any>
			unknown_open$({ req }): Promise<any>
		}
		interface IFileHandler extends IBaseHandler {
			file_open(req): Promise<any>
			file_open$({ req }): Promise<any>
			get_names(): Promise<any>
			get_names$($: {}): Promise<any>
			open_local_file(req): Promise<any>
			open_local_file$({ req }): Promise<any>
			names
		}
		interface IFTPHandler extends IBaseHandler {
			ftp_open(req): Promise<any>
			ftp_open$({ req }): Promise<any>
			connect_ftp(user, passwd, host, port, dirs, timeout): Promise<any>
			connect_ftp$({ user, passwd, host, port, dirs, timeout }): Promise<any>
		}
		function CacheFTPHandler(): Promise<ICacheFTPHandler>
		function CacheFTPHandler$({ }): Promise<ICacheFTPHandler>
		interface ICacheFTPHandler extends IFTPHandler {
			setTimeout(t): Promise<any>
			setTimeout$({ t }): Promise<any>
			setMaxConns(m): Promise<any>
			setMaxConns$({ m }): Promise<any>
			connect_ftp(user, passwd, host, port, dirs, timeout): Promise<any>
			connect_ftp$({ user, passwd, host, port, dirs, timeout }): Promise<any>
			check_cache(): Promise<any>
			check_cache$($: {}): Promise<any>
			clear_cache(): Promise<any>
			clear_cache$($: {}): Promise<any>
		}
		interface IDataHandler extends IBaseHandler {
			data_open(req): Promise<any>
			data_open$({ req }): Promise<any>
		}

		/**
		 * Class to open URLs.
		 *     This is a class rather than just a subroutine because we may need
		 *     more than one set of global protocol-specific options.
		 *     Note -- this is a base class for those who don't want the
		 *     automatic handling of errors type 302 (relocated) and 401
		 *     (authorization needed).
		 */
		function URLopener(proxies?): Promise<IURLopener>
		function URLopener$({ proxies }: { proxies?}): Promise<IURLopener>
		interface IURLopener {
			close(): Promise<any>
			close$($: {}): Promise<any>
			cleanup(): Promise<any>
			cleanup$($: {}): Promise<any>

			/**
			 * Add a header to be used by the HTTP interface only
			 *         e.g. u.addheader('Accept', 'sound/basic')
			 */
			addheader(): Promise<any>
			addheader$($: {}): Promise<any>

			/**
			 * Use URLopener().open(file) instead of open(file, 'r').
			 */
			open(fullurl, data?): Promise<any>
			open$({ fullurl, data }: { fullurl, data?}): Promise<any>

			/**
			 * Overridable interface to open unknown URL type.
			 */
			open_unknown(fullurl, data?): Promise<any>
			open_unknown$({ fullurl, data }: { fullurl, data?}): Promise<any>

			/**
			 * Overridable interface to open unknown URL type.
			 */
			open_unknown_proxy(proxy, fullurl, data?): Promise<any>
			open_unknown_proxy$({ proxy, fullurl, data }: { proxy, fullurl, data?}): Promise<any>

			/**
			 * retrieve(url) returns (filename, headers) for a local object
			 *         or (tempfilename, headers) for a remote object.
			 */
			retrieve(url, filename?, reporthook?, data?): Promise<any>
			retrieve$({ url, filename, reporthook, data }: { url, filename?, reporthook?, data?}): Promise<any>

			/**
			 * Use HTTP protocol.
			 */
			open_http(url, data?): Promise<any>
			open_http$({ url, data }: { url, data?}): Promise<any>

			/**
			 * Handle http errors.
			 * 
			 *         Derived class can override this, or provide specific handlers
			 *         named http_error_DDD where DDD is the 3-digit error code.
			 */
			http_error(url, fp, errcode, errmsg, headers, data?): Promise<any>
			http_error$({ url, fp, errcode, errmsg, headers, data }: { url, fp, errcode, errmsg, headers, data?}): Promise<any>

			/**
			 * Default error handler: close the connection and raise OSError.
			 */
			http_error_default(url, fp, errcode, errmsg, headers): Promise<any>
			http_error_default$({ url, fp, errcode, errmsg, headers }): Promise<any>

			/**
			 * Use local file or FTP depending on form of URL.
			 */
			open_file(url): Promise<any>
			open_file$({ url }): Promise<any>

			/**
			 * Use local file.
			 */
			open_local_file(url): Promise<any>
			open_local_file$({ url }): Promise<any>

			/**
			 * Use FTP protocol.
			 */
			open_ftp(url): Promise<any>
			open_ftp$({ url }): Promise<any>

			/**
			 * Use "data" URL.
			 */
			open_data(url, data?): Promise<any>
			open_data$({ url, data }: { url, data?}): Promise<any>
			version
		}

		/**
		 * Derived class with handlers for errors we can handle (perhaps).
		 */
		function FancyURLopener(): Promise<IFancyURLopener>
		function FancyURLopener$({ }): Promise<IFancyURLopener>
		interface IFancyURLopener extends IURLopener {

			/**
			 * Default error handling -- don't raise an exception.
			 */
			http_error_default(url, fp, errcode, errmsg, headers): Promise<any>
			http_error_default$({ url, fp, errcode, errmsg, headers }): Promise<any>

			/**
			 * Error 302 -- relocated (temporarily).
			 */
			http_error_302(url, fp, errcode, errmsg, headers, data?): Promise<any>
			http_error_302$({ url, fp, errcode, errmsg, headers, data }: { url, fp, errcode, errmsg, headers, data?}): Promise<any>
			redirect_internal(url, fp, errcode, errmsg, headers, data): Promise<any>
			redirect_internal$({ url, fp, errcode, errmsg, headers, data }): Promise<any>

			/**
			 * Error 301 -- also relocated (permanently).
			 */
			http_error_301(url, fp, errcode, errmsg, headers, data?): Promise<any>
			http_error_301$({ url, fp, errcode, errmsg, headers, data }: { url, fp, errcode, errmsg, headers, data?}): Promise<any>

			/**
			 * Error 303 -- also relocated (essentially identical to 302).
			 */
			http_error_303(url, fp, errcode, errmsg, headers, data?): Promise<any>
			http_error_303$({ url, fp, errcode, errmsg, headers, data }: { url, fp, errcode, errmsg, headers, data?}): Promise<any>

			/**
			 * Error 307 -- relocated, but turn POST into error.
			 */
			http_error_307(url, fp, errcode, errmsg, headers, data?): Promise<any>
			http_error_307$({ url, fp, errcode, errmsg, headers, data }: { url, fp, errcode, errmsg, headers, data?}): Promise<any>

			/**
			 * Error 401 -- authentication required.
			 *         This function supports Basic authentication only.
			 */
			http_error_401(url, fp, errcode, errmsg, headers, data?, retry?: boolean): Promise<any>
			http_error_401$({ url, fp, errcode, errmsg, headers, data, retry }: { url, fp, errcode, errmsg, headers, data?, retry?}): Promise<any>

			/**
			 * Error 407 -- proxy authentication required.
			 *         This function supports Basic authentication only.
			 */
			http_error_407(url, fp, errcode, errmsg, headers, data?, retry?: boolean): Promise<any>
			http_error_407$({ url, fp, errcode, errmsg, headers, data, retry }: { url, fp, errcode, errmsg, headers, data?, retry?}): Promise<any>
			retry_proxy_http_basic_auth(url, realm, data?): Promise<any>
			retry_proxy_http_basic_auth$({ url, realm, data }: { url, realm, data?}): Promise<any>
			retry_proxy_https_basic_auth(url, realm, data?): Promise<any>
			retry_proxy_https_basic_auth$({ url, realm, data }: { url, realm, data?}): Promise<any>
			retry_http_basic_auth(url, realm, data?): Promise<any>
			retry_http_basic_auth$({ url, realm, data }: { url, realm, data?}): Promise<any>
			retry_https_basic_auth(url, realm, data?): Promise<any>
			retry_https_basic_auth$({ url, realm, data }: { url, realm, data?}): Promise<any>
			get_user_passwd(host, realm, clear_cache?): Promise<any>
			get_user_passwd$({ host, realm, clear_cache }: { host, realm, clear_cache?}): Promise<any>

			/**
			 * Override this in a GUI environment!
			 */
			prompt_user_passwd(host, realm): Promise<any>
			prompt_user_passwd$({ host, realm }): Promise<any>
		}

		/**
		 * Class used by open_ftp() for cache of open FTP connections.
		 */
		function ftpwrapper(user, passwd, host, port, dirs, timeout?, persistent?: boolean): Promise<Iftpwrapper>
		function ftpwrapper$({ user, passwd, host, port, dirs, timeout, persistent }: { user, passwd, host, port, dirs, timeout?, persistent?}): Promise<Iftpwrapper>
		interface Iftpwrapper {
			init(): Promise<any>
			init$($: {}): Promise<any>
			retrfile(file, type): Promise<any>
			retrfile$({ file, type }): Promise<any>
			endtransfer(): Promise<any>
			endtransfer$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			file_close(): Promise<any>
			file_close$($: {}): Promise<any>
			real_close(): Promise<any>
			real_close$($: {}): Promise<any>
		}
		let MAXFTPCACHE: Promise<any>
		let ftpcache: Promise<any>
	}
	module response {
		var _

		/**
		 * Base class for addinfo and addclosehook. Is a good idea for garbage collection.
		 */
		function addbase(fp): Promise<Iaddbase>
		function addbase$({ fp }): Promise<Iaddbase>
		interface Iaddbase {
		}

		/**
		 * Class to add a close hook to an open file.
		 */
		function addclosehook(fp, closehook): Promise<Iaddclosehook>
		function addclosehook$({ fp, closehook }): Promise<Iaddclosehook>
		interface Iaddclosehook extends Iaddbase {
			close(): Promise<any>
			close$($: {}): Promise<any>
		}

		/**
		 * class to add an info() method to an open file.
		 */
		function addinfo(fp, headers): Promise<Iaddinfo>
		function addinfo$({ fp, headers }): Promise<Iaddinfo>
		interface Iaddinfo extends Iaddbase {
			info(): Promise<any>
			info$($: {}): Promise<any>
		}

		/**
		 * class to add info() and geturl() methods to an open file.
		 */
		function addinfourl(fp, headers, url, code?): Promise<Iaddinfourl>
		function addinfourl$({ fp, headers, url, code }: { fp, headers, url, code?}): Promise<Iaddinfourl>
		interface Iaddinfourl extends Iaddinfo {
			status(): Promise<any>
			status$($: {}): Promise<any>
			getcode(): Promise<any>
			getcode$($: {}): Promise<any>
			geturl(): Promise<any>
			geturl$($: {}): Promise<any>
		}
	}
	module robotparser {
		var _

		/**
		 *  This class provides a set of methods to read, parse and answer
		 *     questions about a single robots.txt file.
		 * 
		 *     
		 */
		function RobotFileParser(url?): Promise<IRobotFileParser>
		function RobotFileParser$({ url }: { url?}): Promise<IRobotFileParser>
		interface IRobotFileParser {

			/**
			 * Returns the time the robots.txt file was last fetched.
			 * 
			 *         This is useful for long-running web spiders that need to
			 *         check for new robots.txt files periodically.
			 * 
			 *         
			 */
			mtime(): Promise<any>
			mtime$($: {}): Promise<any>

			/**
			 * Sets the time the robots.txt file was last fetched to the
			 *         current time.
			 * 
			 *         
			 */
			modified(): Promise<any>
			modified$($: {}): Promise<any>

			/**
			 * Sets the URL referring to a robots.txt file.
			 */
			set_url(url): Promise<any>
			set_url$({ url }): Promise<any>

			/**
			 * Reads the robots.txt URL and feeds it to the parser.
			 */
			read(): Promise<any>
			read$($: {}): Promise<any>

			/**
			 * Parse the input lines from a robots.txt file.
			 * 
			 *         We allow that a user-agent: line is not preceded by
			 *         one or more blank lines.
			 *         
			 */
			parse(lines): Promise<any>
			parse$({ lines }): Promise<any>

			/**
			 * using the parsed robots.txt decide if useragent can fetch url
			 */
			can_fetch(useragent, url): Promise<any>
			can_fetch$({ useragent, url }): Promise<any>
			crawl_delay(useragent): Promise<any>
			crawl_delay$({ useragent }): Promise<any>
			request_rate(useragent): Promise<any>
			request_rate$({ useragent }): Promise<any>
			site_maps(): Promise<any>
			site_maps$($: {}): Promise<any>
		}

		/**
		 * A rule line is a single "Allow:" (allowance==True) or "Disallow:"
		 *        (allowance==False) followed by a path.
		 */
		function RuleLine(path, allowance): Promise<IRuleLine>
		function RuleLine$({ path, allowance }): Promise<IRuleLine>
		interface IRuleLine {
			applies_to(filename): Promise<any>
			applies_to$({ filename }): Promise<any>
		}

		/**
		 * An entry has one or more user-agents and zero or more rulelines
		 */
		function Entry(): Promise<IEntry>
		function Entry$({ }): Promise<IEntry>
		interface IEntry {

			/**
			 * check if this entry applies to the specified agent
			 */
			applies_to(useragent): Promise<any>
			applies_to$({ useragent }): Promise<any>

			/**
			 * Preconditions:
			 *         - our agent applies to this entry
			 *         - filename is URL decoded
			 */
			allowance(filename): Promise<any>
			allowance$({ filename }): Promise<any>
		}
		let RequestRate: Promise<any>
	}
}
declare module uu {
	var _

	/**
	 * Uuencode file
	 */
	function encode(in_file, out_file, name?, mode?): Promise<any>
	function encode$({ in_file, out_file, name, mode }: { in_file, out_file, name?, mode?}): Promise<any>

	/**
	 * Decode uuencoded file
	 */
	function decode(in_file, out_file?, mode?, quiet?: boolean): Promise<any>
	function decode$({ in_file, out_file, mode, quiet }: { in_file, out_file?, mode?, quiet?}): Promise<any>

	/**
	 * uuencode/uudecode main program
	 */
	function test(): Promise<any>
	function test$($: {}): Promise<any>
	interface IError {
	}
}
declare module uuid {
	var _

	/**
	 * Get the hardware address as a 48-bit positive integer.
	 * 
	 *     The first time this runs, it may launch a separate program, which could
	 *     be quite slow.  If all attempts to obtain the hardware address fail, we
	 *     choose a random 48-bit number with its eighth bit set to 1 as recommended
	 *     in RFC 4122.
	 *     
	 */
	function getnode(): Promise<any>
	function getnode$($: {}): Promise<any>

	/**
	 * Generate a UUID from a host ID, sequence number, and the current time.
	 *     If 'node' is not given, getnode() is used to obtain the hardware
	 *     address.  If 'clock_seq' is given, it is used as the sequence number;
	 *     otherwise a random 14-bit sequence number is chosen.
	 */
	function uuid1(node?, clock_seq?): Promise<any>
	function uuid1$({ node, clock_seq }: { node?, clock_seq?}): Promise<any>

	/**
	 * Generate a UUID from the MD5 hash of a namespace UUID and a name.
	 */
	function uuid3(namespace, name): Promise<any>
	function uuid3$({ namespace, name }): Promise<any>

	/**
	 * Generate a random UUID.
	 */
	function uuid4(): Promise<any>
	function uuid4$($: {}): Promise<any>

	/**
	 * Generate a UUID from the SHA-1 hash of a namespace UUID and a name.
	 */
	function uuid5(namespace, name): Promise<any>
	function uuid5$({ namespace, name }): Promise<any>
	interface ISafeUUID {
		safe
		unsafe
		unknown
	}

	/**
	 * Instances of the UUID class represent UUIDs as specified in RFC 4122.
	 *     UUID objects are immutable, hashable, and usable as dictionary keys.
	 *     Converting a UUID to a string with str() yields something in the form
	 *     '12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts
	 *     five possible forms: a similar string of hexadecimal digits, or a tuple
	 *     of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and
	 *     48-bit values respectively) as an argument named 'fields', or a string
	 *     of 16 bytes (with all the integer fields in big-endian order) as an
	 *     argument named 'bytes', or a string of 16 bytes (with the first three
	 *     fields in little-endian order) as an argument named 'bytes_le', or a
	 *     single 128-bit integer as an argument named 'int'.
	 * 
	 *     UUIDs have these read-only attributes:
	 * 
	 *         bytes       the UUID as a 16-byte string (containing the six
	 *                     integer fields in big-endian byte order)
	 * 
	 *         bytes_le    the UUID as a 16-byte string (with time_low, time_mid,
	 *                     and time_hi_version in little-endian byte order)
	 * 
	 *         fields      a tuple of the six integer fields of the UUID,
	 *                     which are also available as six individual attributes
	 *                     and two derived attributes:
	 * 
	 *             time_low                the first 32 bits of the UUID
	 *             time_mid                the next 16 bits of the UUID
	 *             time_hi_version         the next 16 bits of the UUID
	 *             clock_seq_hi_variant    the next 8 bits of the UUID
	 *             clock_seq_low           the next 8 bits of the UUID
	 *             node                    the last 48 bits of the UUID
	 * 
	 *             time                    the 60-bit timestamp
	 *             clock_seq               the 14-bit sequence number
	 * 
	 *         hex         the UUID as a 32-character hexadecimal string
	 * 
	 *         int         the UUID as a 128-bit integer
	 * 
	 *         urn         the UUID as a URN as specified in RFC 4122
	 * 
	 *         variant     the UUID variant (one of the constants RESERVED_NCS,
	 *                     RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)
	 * 
	 *         version     the UUID version number (1 through 5, meaningful only
	 *                     when the variant is RFC_4122)
	 * 
	 *         is_safe     An enum indicating whether the UUID has been generated in
	 *                     a way that is safe for multiprocessing applications, via
	 *                     uuid_generate_time_safe(3).
	 *     
	 */

	/**
	 * Create a UUID from either a string of 32 hexadecimal digits,
	 *         a string of 16 bytes as the 'bytes' argument, a string of 16 bytes
	 *         in little-endian order as the 'bytes_le' argument, a tuple of six
	 *         integers (32-bit time_low, 16-bit time_mid, 16-bit time_hi_version,
	 *         8-bit clock_seq_hi_variant, 8-bit clock_seq_low, 48-bit node) as
	 *         the 'fields' argument, or a single 128-bit integer as the 'int'
	 *         argument.  When a string of hex digits is given, curly braces,
	 *         hyphens, and a URN prefix are all optional.  For example, these
	 *         expressions all yield the same UUID:
	 * 
	 *         UUID('{12345678-1234-5678-1234-567812345678}')
	 *         UUID('12345678123456781234567812345678')
	 *         UUID('urn:uuid:12345678-1234-5678-1234-567812345678')
	 *         UUID(bytes='\x12\x34\x56\x78'*4)
	 *         UUID(bytes_le='\x78\x56\x34\x12\x34\x12\x78\x56' +
	 *                       '\x12\x34\x56\x78\x12\x34\x56\x78')
	 *         UUID(fields=(0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x567812345678))
	 *         UUID(int=0x12345678123456781234567812345678)
	 * 
	 *         Exactly one of 'hex', 'bytes', 'bytes_le', 'fields', or 'int' must
	 *         be given.  The 'version' argument is optional; if given, the resulting
	 *         UUID will have its variant and version set according to RFC 4122,
	 *         overriding the given 'hex', 'bytes', 'bytes_le', 'fields', or 'int'.
	 * 
	 *         is_safe is an enum exposed as an attribute on the instance.  It
	 *         indicates whether the UUID has been generated in a way that is safe
	 *         for multiprocessing applications, via uuid_generate_time_safe(3).
	 *         
	 */
	function UUID(hex?, bytes?, bytes_le?, fields?, int?, version?): Promise<IUUID>
	function UUID$({ hex, bytes, bytes_le, fields, int, version }: { hex?, bytes?, bytes_le?, fields?, int?, version?}): Promise<IUUID>
	interface IUUID {
		bytes(): Promise<any>
		bytes$($: {}): Promise<any>
		bytes_le(): Promise<any>
		bytes_le$($: {}): Promise<any>
		fields(): Promise<any>
		fields$($: {}): Promise<any>
		time_low(): Promise<any>
		time_low$($: {}): Promise<any>
		time_mid(): Promise<any>
		time_mid$($: {}): Promise<any>
		time_hi_version(): Promise<any>
		time_hi_version$($: {}): Promise<any>
		clock_seq_hi_variant(): Promise<any>
		clock_seq_hi_variant$($: {}): Promise<any>
		clock_seq_low(): Promise<any>
		clock_seq_low$($: {}): Promise<any>
		time(): Promise<any>
		time$($: {}): Promise<any>
		clock_seq(): Promise<any>
		clock_seq$($: {}): Promise<any>
		node(): Promise<any>
		node$($: {}): Promise<any>
		hex(): Promise<any>
		hex$($: {}): Promise<any>
		urn(): Promise<any>
		urn$($: {}): Promise<any>
		variant(): Promise<any>
		variant$($: {}): Promise<any>
		version(): Promise<any>
		version$($: {}): Promise<any>
	}
	let int_: Promise<any>
	let bytes_: Promise<any>
	let NAMESPACE_DNS: Promise<any>
	let NAMESPACE_URL: Promise<any>
	let NAMESPACE_OID: Promise<any>
	let NAMESPACE_X500: Promise<any>
}
declare module venv {
	var _

	/**
	 * Create a virtual environment in a directory.
	 */
	function create(env_dir, system_site_packages?: boolean, clear?: boolean, symlinks?: boolean, with_pip?: boolean, prompt?, upgrade_deps?: boolean): Promise<any>
	function create$({ env_dir, system_site_packages, clear, symlinks, with_pip, prompt, upgrade_deps }: { env_dir, system_site_packages?, clear?, symlinks?, with_pip?, prompt?, upgrade_deps?}): Promise<any>
	function main(args?): Promise<any>
	function main$({ args }: { args?}): Promise<any>

	/**
	 * 
	 *     This class exists to allow virtual environment creation to be
	 *     customized. The constructor parameters determine the builder's
	 *     behaviour when called upon to create a virtual environment.
	 * 
	 *     By default, the builder makes the system (global) site-packages dir
	 *     *un*available to the created environment.
	 * 
	 *     If invoked using the Python -m option, the default is to use copying
	 *     on Windows platforms but symlinks elsewhere. If instantiated some
	 *     other way, the default is to *not* use symlinks.
	 * 
	 *     :param system_site_packages: If True, the system (global) site-packages
	 *                                  dir is available to created environments.
	 *     :param clear: If True, delete the contents of the environment directory if
	 *                   it already exists, before environment creation.
	 *     :param symlinks: If True, attempt to symlink rather than copy files into
	 *                      virtual environment.
	 *     :param upgrade: If True, upgrade an existing virtual environment.
	 *     :param with_pip: If True, ensure pip is installed in the virtual
	 *                      environment
	 *     :param prompt: Alternative terminal prefix for the environment.
	 *     :param upgrade_deps: Update the base venv modules to the latest on PyPI
	 *     
	 */
	function EnvBuilder(system_site_packages?: boolean, clear?: boolean, symlinks?: boolean, upgrade?: boolean, with_pip?: boolean, prompt?, upgrade_deps?: boolean): Promise<IEnvBuilder>
	function EnvBuilder$({ system_site_packages, clear, symlinks, upgrade, with_pip, prompt, upgrade_deps }: { system_site_packages?, clear?, symlinks?, upgrade?, with_pip?, prompt?, upgrade_deps?}): Promise<IEnvBuilder>
	interface IEnvBuilder {

		/**
		 * 
		 *         Create a virtual environment in a directory.
		 * 
		 *         :param env_dir: The target directory to create an environment in.
		 * 
		 *         
		 */
		create(env_dir): Promise<any>
		create$({ env_dir }): Promise<any>
		clear_directory(path): Promise<any>
		clear_directory$({ path }): Promise<any>

		/**
		 * 
		 *         Create the directories for the environment.
		 * 
		 *         Returns a context object which holds paths in the environment,
		 *         for use by subsequent logic.
		 *         
		 */
		ensure_directories(env_dir): Promise<any>
		ensure_directories$({ env_dir }): Promise<any>

		/**
		 * 
		 *         Create a configuration file indicating where the environment's Python
		 *         was copied from, and whether the system site-packages should be made
		 *         available in the environment.
		 * 
		 *         :param context: The information for the environment creation request
		 *                         being processed.
		 *         
		 */
		create_configuration(context): Promise<any>
		create_configuration$({ context }): Promise<any>

		/**
		 * 
		 *         Set up a Python executable in the environment.
		 * 
		 *         :param context: The information for the environment creation request
		 *                         being processed.
		 *         
		 */
		setup_python(context): Promise<any>
		setup_python$({ context }): Promise<any>

		/**
		 * 
		 *         Set up scripts into the created environment from a directory.
		 * 
		 *         This method installs the default scripts into the environment
		 *         being created. You can prevent the default installation by overriding
		 *         this method if you really need to, or if you need to specify
		 *         a different location for the scripts to install. By default, the
		 *         'scripts' directory in the venv package is used as the source of
		 *         scripts to install.
		 *         
		 */
		setup_scripts(context): Promise<any>
		setup_scripts$({ context }): Promise<any>

		/**
		 * 
		 *         Hook for post-setup modification of the venv. Subclasses may install
		 *         additional packages or scripts here, add activation shell scripts, etc.
		 * 
		 *         :param context: The information for the environment creation request
		 *                         being processed.
		 *         
		 */
		post_setup(context): Promise<any>
		post_setup$({ context }): Promise<any>

		/**
		 * 
		 *         Replace variable placeholders in script text with context-specific
		 *         variables.
		 * 
		 *         Return the text passed in , but with variables replaced.
		 * 
		 *         :param text: The text in which to replace placeholder variables.
		 *         :param context: The information for the environment creation request
		 *                         being processed.
		 *         
		 */
		replace_variables(text, context): Promise<any>
		replace_variables$({ text, context }): Promise<any>

		/**
		 * 
		 *         Install scripts into the created environment from a directory.
		 * 
		 *         :param context: The information for the environment creation request
		 *                         being processed.
		 *         :param path:    Absolute pathname of a directory containing script.
		 *                         Scripts in the 'common' subdirectory of this directory,
		 *                         and those in the directory named for the platform
		 *                         being run on, are installed in the created environment.
		 *                         Placeholder variables are replaced with environment-
		 *                         specific values.
		 *         
		 */
		install_scripts(context, path): Promise<any>
		install_scripts$({ context, path }): Promise<any>
		upgrade_dependencies(context): Promise<any>
		upgrade_dependencies$({ context }): Promise<any>
	}
	let CORE_VENV_DEPS: Promise<any>
	let logger: Promise<any>
	let rc: Promise<any>
	module __main__ {
		var _
		let rc: Promise<any>
	}
}
declare module warnings {
	var _

	/**
	 * Hook to write a warning to a file; replace if you like.
	 */
	function showwarning(message, category, filename, lineno, file?, line?): Promise<any>
	function showwarning$({ message, category, filename, lineno, file, line }: { message, category, filename, lineno, file?, line?}): Promise<any>

	/**
	 * Function to format a warning the standard way.
	 */
	function formatwarning(message, category, filename, lineno, line?): Promise<any>
	function formatwarning$({ message, category, filename, lineno, line }: { message, category, filename, lineno, line?}): Promise<any>

	/**
	 * Insert an entry into the list of warnings filters (at the front).
	 * 
	 *     'action' -- one of "error", "ignore", "always", "default", "module",
	 *                 or "once"
	 *     'message' -- a regex that the warning message must match
	 *     'category' -- a class that the warning must be a subclass of
	 *     'module' -- a regex that the module name must match
	 *     'lineno' -- an integer line number, 0 matches all warnings
	 *     'append' -- if true, append to the list of filters
	 *     
	 */
	function filterwarnings(action, message?, category?, module?, lineno?, append?: boolean): Promise<any>
	function filterwarnings$({ action, message, category, module, lineno, append }: { action, message?, category?, module?, lineno?, append?}): Promise<any>

	/**
	 * Insert a simple entry into the list of warnings filters (at the front).
	 * 
	 *     A simple filter matches all modules and messages.
	 *     'action' -- one of "error", "ignore", "always", "default", "module",
	 *                 or "once"
	 *     'category' -- a class that the warning must be a subclass of
	 *     'lineno' -- an integer line number, 0 matches all warnings
	 *     'append' -- if true, append to the list of filters
	 *     
	 */
	function simplefilter(action, category?, lineno?, append?: boolean): Promise<any>
	function simplefilter$({ action, category, lineno, append }: { action, category?, lineno?, append?}): Promise<any>

	/**
	 * Clear the list of warning filters, so that no filters are active.
	 */
	function resetwarnings(): Promise<any>
	function resetwarnings$($: {}): Promise<any>

	/**
	 * Issue a warning, or maybe ignore it or raise an exception.
	 */
	function warn(message, category?, stacklevel?, source?): Promise<any>
	function warn$({ message, category, stacklevel, source }: { message, category?, stacklevel?, source?}): Promise<any>
	function warn_explicit(message, category, filename, lineno, module?, registry?, module_globals?, source?): Promise<any>
	function warn_explicit$({ message, category, filename, lineno, module, registry, module_globals, source }: { message, category, filename, lineno, module?, registry?, module_globals?, source?}): Promise<any>

	/**
	 * Exception used by option processing helpers.
	 */
	interface I_OptionError {
	}
	function WarningMessage(message, category, filename, lineno, file?, line?, source?): Promise<IWarningMessage>
	function WarningMessage$({ message, category, filename, lineno, file, line, source }: { message, category, filename, lineno, file?, line?, source?}): Promise<IWarningMessage>
	interface IWarningMessage {
	}

	/**
	 * A context manager that copies and restores the warnings filter upon
	 *     exiting the context.
	 * 
	 *     The 'record' argument specifies whether warnings should be captured by a
	 *     custom implementation of warnings.showwarning() and be appended to a list
	 *     returned by the context manager. Otherwise None is returned by the context
	 *     manager. The objects appended to the list are arguments whose attributes
	 *     mirror the arguments to showwarning().
	 * 
	 *     The 'module' argument is to specify an alternative module to the module
	 *     named 'warnings' and imported under that name. This argument is only useful
	 *     when testing the warnings module itself.
	 * 
	 *     
	 */

	/**
	 * Specify whether to record warnings and if an alternative module
	 *         should be used other than sys.modules['warnings'].
	 * 
	 *         For compatibility with Python 3.0, please consider all arguments to be
	 *         keyword-only.
	 * 
	 *         
	 */
	function catch_warnings(): Promise<Icatch_warnings>
	function catch_warnings$({ }): Promise<Icatch_warnings>
	interface Icatch_warnings {
	}
	let defaultaction: Promise<any>
	let onceregistry: Promise<any>
}
declare module wave {
	var _
	function open(f, mode?): Promise<any>
	function open$({ f, mode }: { f, mode?}): Promise<any>
	interface IError {
	}

	/**
	 * Variables used in this class:
	 * 
	 *     These variables are available to the user though appropriate
	 *     methods of this class:
	 *     _file -- the open file with methods read(), close(), and seek()
	 *               set through the __init__() method
	 *     _nchannels -- the number of audio channels
	 *               available through the getnchannels() method
	 *     _nframes -- the number of audio frames
	 *               available through the getnframes() method
	 *     _sampwidth -- the number of bytes per audio sample
	 *               available through the getsampwidth() method
	 *     _framerate -- the sampling frequency
	 *               available through the getframerate() method
	 *     _comptype -- the AIFF-C compression type ('NONE' if AIFF)
	 *               available through the getcomptype() method
	 *     _compname -- the human-readable AIFF-C compression type
	 *               available through the getcomptype() method
	 *     _soundpos -- the position in the audio stream
	 *               available through the tell() method, set through the
	 *               setpos() method
	 * 
	 *     These variables are used internally only:
	 *     _fmt_chunk_read -- 1 iff the FMT chunk has been read
	 *     _data_seek_needed -- 1 iff positioned correctly in audio
	 *               file for readframes()
	 *     _data_chunk -- instantiation of a chunk class for the DATA chunk
	 *     _framesize -- size of one frame in the file
	 *     
	 */
	function Wave_read(f): Promise<IWave_read>
	function Wave_read$({ f }): Promise<IWave_read>
	interface IWave_read {
		initfp(file): Promise<any>
		initfp$({ file }): Promise<any>
		getfp(): Promise<any>
		getfp$($: {}): Promise<any>
		rewind(): Promise<any>
		rewind$($: {}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
		tell(): Promise<any>
		tell$($: {}): Promise<any>
		getnchannels(): Promise<any>
		getnchannels$($: {}): Promise<any>
		getnframes(): Promise<any>
		getnframes$($: {}): Promise<any>
		getsampwidth(): Promise<any>
		getsampwidth$($: {}): Promise<any>
		getframerate(): Promise<any>
		getframerate$($: {}): Promise<any>
		getcomptype(): Promise<any>
		getcomptype$($: {}): Promise<any>
		getcompname(): Promise<any>
		getcompname$($: {}): Promise<any>
		getparams(): Promise<any>
		getparams$($: {}): Promise<any>
		getmarkers(): Promise<any>
		getmarkers$($: {}): Promise<any>
		getmark(id): Promise<any>
		getmark$({ id }): Promise<any>
		setpos(pos): Promise<any>
		setpos$({ pos }): Promise<any>
		readframes(nframes): Promise<any>
		readframes$({ nframes }): Promise<any>
	}

	/**
	 * Variables used in this class:
	 * 
	 *     These variables are user settable through appropriate methods
	 *     of this class:
	 *     _file -- the open file with methods write(), close(), tell(), seek()
	 *               set through the __init__() method
	 *     _comptype -- the AIFF-C compression type ('NONE' in AIFF)
	 *               set through the setcomptype() or setparams() method
	 *     _compname -- the human-readable AIFF-C compression type
	 *               set through the setcomptype() or setparams() method
	 *     _nchannels -- the number of audio channels
	 *               set through the setnchannels() or setparams() method
	 *     _sampwidth -- the number of bytes per audio sample
	 *               set through the setsampwidth() or setparams() method
	 *     _framerate -- the sampling frequency
	 *               set through the setframerate() or setparams() method
	 *     _nframes -- the number of audio frames written to the header
	 *               set through the setnframes() or setparams() method
	 * 
	 *     These variables are used internally only:
	 *     _datalength -- the size of the audio samples written to the header
	 *     _nframeswritten -- the number of frames actually written
	 *     _datawritten -- the size of the audio samples actually written
	 *     
	 */
	function Wave_write(f): Promise<IWave_write>
	function Wave_write$({ f }): Promise<IWave_write>
	interface IWave_write {
		initfp(file): Promise<any>
		initfp$({ file }): Promise<any>
		setnchannels(nchannels): Promise<any>
		setnchannels$({ nchannels }): Promise<any>
		getnchannels(): Promise<any>
		getnchannels$($: {}): Promise<any>
		setsampwidth(sampwidth): Promise<any>
		setsampwidth$({ sampwidth }): Promise<any>
		getsampwidth(): Promise<any>
		getsampwidth$($: {}): Promise<any>
		setframerate(framerate): Promise<any>
		setframerate$({ framerate }): Promise<any>
		getframerate(): Promise<any>
		getframerate$($: {}): Promise<any>
		setnframes(nframes): Promise<any>
		setnframes$({ nframes }): Promise<any>
		getnframes(): Promise<any>
		getnframes$($: {}): Promise<any>
		setcomptype(comptype, compname): Promise<any>
		setcomptype$({ comptype, compname }): Promise<any>
		getcomptype(): Promise<any>
		getcomptype$($: {}): Promise<any>
		getcompname(): Promise<any>
		getcompname$($: {}): Promise<any>
		setparams(params): Promise<any>
		setparams$({ params }): Promise<any>
		getparams(): Promise<any>
		getparams$($: {}): Promise<any>
		setmark(id, pos, name): Promise<any>
		setmark$({ id, pos, name }): Promise<any>
		getmark(id): Promise<any>
		getmark$({ id }): Promise<any>
		getmarkers(): Promise<any>
		getmarkers$($: {}): Promise<any>
		tell(): Promise<any>
		tell$($: {}): Promise<any>
		writeframesraw(data): Promise<any>
		writeframesraw$({ data }): Promise<any>
		writeframes(data): Promise<any>
		writeframes$({ data }): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}
	let WAVE_FORMAT_PCM: Promise<any>
}
declare module weakref {
	var _

	/**
	 * 
	 *     A custom `weakref.ref` subclass which simulates a weak reference to
	 *     a bound method, working around the lifetime problem of bound methods.
	 *     
	 */
	interface IWeakMethod {
	}

	/**
	 * Mapping class that references values weakly.
	 * 
	 *     Entries in the dictionary will be discarded when no strong
	 *     reference to the value exists anymore
	 *     
	 */
	function WeakValueDictionary(other?): Promise<IWeakValueDictionary>
	function WeakValueDictionary$({ other }: { other?}): Promise<IWeakValueDictionary>
	interface IWeakValueDictionary {
		copy(): Promise<any>
		copy$($: {}): Promise<any>
		get(key, def?): Promise<any>
		get$({ key, def }: { key, def?}): Promise<any>
		items(): Promise<any>
		items$($: {}): Promise<any>
		keys(): Promise<any>
		keys$($: {}): Promise<any>

		/**
		 * Return an iterator that yields the weak references to the values.
		 * 
		 *         The references are not guaranteed to be 'live' at the time
		 *         they are used, so the result of calling the references needs
		 *         to be checked before being used.  This can be used to avoid
		 *         creating references that will cause the garbage collector to
		 *         keep the values around longer than needed.
		 * 
		 *         
		 */
		itervaluerefs(): Promise<any>
		itervaluerefs$($: {}): Promise<any>
		values(): Promise<any>
		values$($: {}): Promise<any>
		popitem(): Promise<any>
		popitem$($: {}): Promise<any>
		pop(key): Promise<any>
		pop$({ key }): Promise<any>
		setdefault(key, def?): Promise<any>
		setdefault$({ key, def }: { key, def?}): Promise<any>
		update(other?): Promise<any>
		update$({ other }: { other?}): Promise<any>

		/**
		 * Return a list of weak references to the values.
		 * 
		 *         The references are not guaranteed to be 'live' at the time
		 *         they are used, so the result of calling the references needs
		 *         to be checked before being used.  This can be used to avoid
		 *         creating references that will cause the garbage collector to
		 *         keep the values around longer than needed.
		 * 
		 *         
		 */
		valuerefs(): Promise<any>
		valuerefs$($: {}): Promise<any>
	}

	/**
	 * Specialized reference that includes a key corresponding to the value.
	 * 
	 *     This is used in the WeakValueDictionary to avoid having to create
	 *     a function object for each key stored in the mapping.  A shared
	 *     callback object can use the 'key' attribute of a KeyedRef instead
	 *     of getting a reference to the key from an enclosing scope.
	 * 
	 *     
	 */
	function KeyedRef(ob, callback, key): Promise<IKeyedRef>
	function KeyedRef$({ ob, callback, key }): Promise<IKeyedRef>
	interface IKeyedRef {
	}

	/**
	 *  Mapping class that references keys weakly.
	 * 
	 *     Entries in the dictionary will be discarded when there is no
	 *     longer a strong reference to the key. This can be used to
	 *     associate additional data with an object owned by other parts of
	 *     an application without adding attributes to those objects. This
	 *     can be especially useful with objects that override attribute
	 *     accesses.
	 *     
	 */
	function WeakKeyDictionary(dict?): Promise<IWeakKeyDictionary>
	function WeakKeyDictionary$({ dict }: { dict?}): Promise<IWeakKeyDictionary>
	interface IWeakKeyDictionary {
		copy(): Promise<any>
		copy$($: {}): Promise<any>
		get(key, def?): Promise<any>
		get$({ key, def }: { key, def?}): Promise<any>
		items(): Promise<any>
		items$($: {}): Promise<any>
		keys(): Promise<any>
		keys$($: {}): Promise<any>
		values(): Promise<any>
		values$($: {}): Promise<any>

		/**
		 * Return a list of weak references to the keys.
		 * 
		 *         The references are not guaranteed to be 'live' at the time
		 *         they are used, so the result of calling the references needs
		 *         to be checked before being used.  This can be used to avoid
		 *         creating references that will cause the garbage collector to
		 *         keep the keys around longer than needed.
		 * 
		 *         
		 */
		keyrefs(): Promise<any>
		keyrefs$($: {}): Promise<any>
		popitem(): Promise<any>
		popitem$($: {}): Promise<any>
		pop(key): Promise<any>
		pop$({ key }): Promise<any>
		setdefault(key, def?): Promise<any>
		setdefault$({ key, def }: { key, def?}): Promise<any>
		update(dict?): Promise<any>
		update$({ dict }: { dict?}): Promise<any>
	}

	/**
	 * Class for finalization of weakrefable objects
	 * 
	 *     finalize(obj, func, *args, **kwargs) returns a callable finalizer
	 *     object which will be called when obj is garbage collected. The
	 *     first time the finalizer is called it evaluates func(*arg, **kwargs)
	 *     and returns the result. After this the finalizer is dead, and
	 *     calling it just returns None.
	 * 
	 *     When the program exits any remaining finalizers for which the
	 *     atexit attribute is true will be run in reverse order of creation.
	 *     By default atexit is true.
	 *     
	 */
	function finalize(obj, func): Promise<Ifinalize>
	function finalize$({ obj, func }): Promise<Ifinalize>
	interface Ifinalize {

		/**
		 * If alive then mark as dead and return (obj, func, args, kwargs);
		 *         otherwise return None
		 */
		detach(): Promise<any>
		detach$($: {}): Promise<any>

		/**
		 * If alive then return (obj, func, args, kwargs);
		 *         otherwise return None
		 */
		peek(): Promise<any>
		peek$($: {}): Promise<any>

		/**
		 * Whether finalizer is alive
		 */
		alive(): Promise<any>
		alive$($: {}): Promise<any>

		/**
		 * Whether finalizer should be called at exit
		 */
		atexit(): Promise<any>
		atexit$($: {}): Promise<any>
		atexit(value): Promise<any>
		atexit$({ value }): Promise<any>
	}
	let ProxyTypes: Promise<any>
}
declare module webbrowser {
	var _

	/**
	 * Register a browser connector.
	 */
	function register(name, klass, instance?): Promise<any>
	function register$({ name, klass, instance }: { name, klass, instance?}): Promise<any>

	/**
	 * Return a browser launcher instance appropriate for the environment.
	 */
	function get(using?): Promise<any>
	function get$({ using }: { using?}): Promise<any>

	/**
	 * Display url using the default browser.
	 * 
	 *     If possible, open url in a location determined by new.
	 *     - 0: the same browser window (the default).
	 *     - 1: a new browser window.
	 *     - 2: a new browser page ("tab").
	 *     If possible, autoraise raises the window (the default) or not.
	 *     
	 */
	function open(url, New?, autoraise?: boolean): Promise<any>
	function open$({ url, New, autoraise }: { url, New?, autoraise?}): Promise<any>

	/**
	 * Open url in a new window of the default browser.
	 * 
	 *     If not possible, then open url in the only browser window.
	 *     
	 */
	function open_new(url): Promise<any>
	function open_new$({ url }): Promise<any>

	/**
	 * Open url in a new page ("tab") of the default browser.
	 * 
	 *     If not possible, then the behavior becomes equivalent to open_new().
	 *     
	 */
	function open_new_tab(url): Promise<any>
	function open_new_tab$({ url }): Promise<any>
	function register_X_browsers(): Promise<any>
	function register_X_browsers$($: {}): Promise<any>
	function register_standard_browsers(): Promise<any>
	function register_standard_browsers$($: {}): Promise<any>
	function main(): Promise<any>
	function main$($: {}): Promise<any>
	interface IError {
	}

	/**
	 * Parent class for all browsers. Do not use directly.
	 */
	function BaseBrowser(name?): Promise<IBaseBrowser>
	function BaseBrowser$({ name }: { name?}): Promise<IBaseBrowser>
	interface IBaseBrowser {
		open(url, New?, autoraise?: boolean): Promise<any>
		open$({ url, New, autoraise }: { url, New?, autoraise?}): Promise<any>
		open_new(url): Promise<any>
		open_new$({ url }): Promise<any>
		open_new_tab(url): Promise<any>
		open_new_tab$({ url }): Promise<any>
		args
	}

	/**
	 * Class for all browsers started with a command
	 *        and without remote functionality.
	 */
	function GenericBrowser(name): Promise<IGenericBrowser>
	function GenericBrowser$({ name }): Promise<IGenericBrowser>
	interface IGenericBrowser extends IBaseBrowser {
		open(url, New?, autoraise?: boolean): Promise<any>
		open$({ url, New, autoraise }: { url, New?, autoraise?}): Promise<any>
	}

	/**
	 * Class for all browsers which are to be started in the
	 *        background.
	 */
	interface IBackgroundBrowser extends IGenericBrowser {
		open(url, New?, autoraise?: boolean): Promise<any>
		open$({ url, New, autoraise }: { url, New?, autoraise?}): Promise<any>
	}

	/**
	 * Parent class for all Unix browsers with remote functionality.
	 */
	interface IUnixBrowser extends IBaseBrowser {
		open(url, New?, autoraise?: boolean): Promise<any>
		open$({ url, New, autoraise }: { url, New?, autoraise?}): Promise<any>
		raise_opts
		background
		redirect_stdout
		remote_args
		remote_action
		remote_action_newwin
		remote_action_newtab
	}

	/**
	 * Launcher class for Mozilla browsers.
	 */
	interface IMozilla extends IUnixBrowser {
	}

	/**
	 * Launcher class for Netscape browser.
	 */
	interface INetscape extends IUnixBrowser {
	}

	/**
	 * Launcher class for Galeon/Epiphany browsers.
	 */
	interface IGaleon extends IUnixBrowser {
	}

	/**
	 * Launcher class for Google Chrome browser.
	 */
	interface IChrome extends IUnixBrowser {
	}

	/**
	 * Launcher class for Opera browser.
	 */
	interface IOpera extends IUnixBrowser {
	}

	/**
	 * Launcher class for Elinks browsers.
	 */
	interface IElinks extends IUnixBrowser {
	}

	/**
	 * Controller for the KDE File Manager (kfm, or Konqueror).
	 * 
	 *     See the output of ``kfmclient --commands``
	 *     for more information on the Konqueror remote-control interface.
	 *     
	 */
	interface IKonqueror extends IBaseBrowser {
		open(url, New?, autoraise?: boolean): Promise<any>
		open$({ url, New, autoraise }: { url, New?, autoraise?}): Promise<any>
	}
	interface IGrail extends IBaseBrowser {
		open(url, New?, autoraise?: boolean): Promise<any>
		open$({ url, New, autoraise }: { url, New?, autoraise?}): Promise<any>
	}
	interface IWindowsDefault extends IBaseBrowser {
		open(url, New?, autoraise?: boolean): Promise<any>
		open$({ url, New, autoraise }: { url, New?, autoraise?}): Promise<any>
	}

	/**
	 * Launcher class for Aqua browsers on Mac OS X
	 * 
	 *         Optionally specify a browser name on instantiation.  Note that this
	 *         will not work for Aqua browsers if the user has moved the application
	 *         package after installation.
	 * 
	 *         If no browser is specified, the default browser, as specified in the
	 *         Internet System Preferences panel, will be used.
	 *         
	 */
	function MacOSX(name): Promise<IMacOSX>
	function MacOSX$({ name }): Promise<IMacOSX>
	interface IMacOSX extends IBaseBrowser {
		open(url, New?, autoraise?: boolean): Promise<any>
		open$({ url, New, autoraise }: { url, New?, autoraise?}): Promise<any>
	}
	function MacOSXOSAScript(name): Promise<IMacOSXOSAScript>
	function MacOSXOSAScript$({ name }): Promise<IMacOSXOSAScript>
	interface IMacOSXOSAScript extends IBaseBrowser {
		open(url, New?, autoraise?: boolean): Promise<any>
		open$({ url, New, autoraise }: { url, New?, autoraise?}): Promise<any>
	}
	let Chromium: Promise<any>
}
declare module wsgiref {
	var _
	module handlers {
		var _
		function format_date_time(timestamp): Promise<any>
		function format_date_time$({ timestamp }): Promise<any>

		/**
		 * Read environment, fixing HTTP variables
		 */
		function read_environ(): Promise<any>
		function read_environ$($: {}): Promise<any>

		/**
		 * Manage the invocation of a WSGI application
		 */
		interface IBaseHandler {

			/**
			 * Invoke the application
			 */
			run(application): Promise<any>
			run$({ application }): Promise<any>

			/**
			 * Set up the environment for one request
			 */
			setup_environ(): Promise<any>
			setup_environ$($: {}): Promise<any>

			/**
			 * Send any iterable data, then close self and the iterable
			 * 
			 *         Subclasses intended for use in asynchronous servers will
			 *         want to redefine this method, such that it sets up callbacks
			 *         in the event loop to iterate over the data, and to call
			 *         'self.close()' once the response is finished.
			 *         
			 */
			finish_response(): Promise<any>
			finish_response$($: {}): Promise<any>

			/**
			 * Return the URL scheme being used
			 */
			get_scheme(): Promise<any>
			get_scheme$($: {}): Promise<any>

			/**
			 * Compute Content-Length or switch to chunked encoding if possible
			 */
			set_content_length(): Promise<any>
			set_content_length$($: {}): Promise<any>

			/**
			 * Make any necessary header changes or defaults
			 * 
			 *         Subclasses can extend this to add other defaults.
			 *         
			 */
			cleanup_headers(): Promise<any>
			cleanup_headers$($: {}): Promise<any>

			/**
			 * 'start_response()' callable as specified by PEP 3333
			 */
			start_response(status, headers, exc_info?): Promise<any>
			start_response$({ status, headers, exc_info }: { status, headers, exc_info?}): Promise<any>

			/**
			 * Transmit version/status/date/server, via self._write()
			 */
			send_preamble(): Promise<any>
			send_preamble$($: {}): Promise<any>

			/**
			 * 'write()' callable as specified by PEP 3333
			 */
			write(data): Promise<any>
			write$({ data }): Promise<any>

			/**
			 * Platform-specific file transmission
			 * 
			 *         Override this method in subclasses to support platform-specific
			 *         file transmission.  It is only called if the application's
			 *         return iterable ('self.result') is an instance of
			 *         'self.wsgi_file_wrapper'.
			 * 
			 *         This method should return a true value if it was able to actually
			 *         transmit the wrapped file-like object using a platform-specific
			 *         approach.  It should return a false value if normal iteration
			 *         should be used instead.  An exception can be raised to indicate
			 *         that transmission was attempted, but failed.
			 * 
			 *         NOTE: this method should call 'self.send_headers()' if
			 *         'self.headers_sent' is false and it is going to attempt direct
			 *         transmission of the file.
			 *         
			 */
			sendfile(): Promise<any>
			sendfile$($: {}): Promise<any>

			/**
			 * Ensure headers and content have both been sent
			 */
			finish_content(): Promise<any>
			finish_content$($: {}): Promise<any>

			/**
			 * Close the iterable (if needed) and reset all instance vars
			 * 
			 *         Subclasses may want to also drop the client connection.
			 *         
			 */
			close(): Promise<any>
			close$($: {}): Promise<any>

			/**
			 * Transmit headers to the client, via self._write()
			 */
			send_headers(): Promise<any>
			send_headers$($: {}): Promise<any>

			/**
			 * True if 'self.result' is an instance of 'self.wsgi_file_wrapper'
			 */
			result_is_file(): Promise<any>
			result_is_file$($: {}): Promise<any>

			/**
			 * True if client can accept status and headers
			 */
			client_is_modern(): Promise<any>
			client_is_modern$($: {}): Promise<any>

			/**
			 * Log the 'exc_info' tuple in the server log
			 * 
			 *         Subclasses may override to retarget the output or change its format.
			 *         
			 */
			log_exception(exc_info): Promise<any>
			log_exception$({ exc_info }): Promise<any>

			/**
			 * Log current error, and send error output to client if possible
			 */
			handle_error(): Promise<any>
			handle_error$($: {}): Promise<any>

			/**
			 * WSGI mini-app to create error output
			 * 
			 *         By default, this just uses the 'error_status', 'error_headers',
			 *         and 'error_body' attributes to generate an output page.  It can
			 *         be overridden in a subclass to dynamically generate diagnostics,
			 *         choose an appropriate message for the user's preferred language, etc.
			 * 
			 *         Note, however, that it's not recommended from a security perspective to
			 *         spit out diagnostics to any old user; ideally, you should have to do
			 *         something special to enable diagnostic output, which is why we don't
			 *         include any here!
			 *         
			 */
			error_output(environ, start_response): Promise<any>
			error_output$({ environ, start_response }): Promise<any>

			/**
			 * Override in subclass to return suitable 'wsgi.input'
			 */
			get_stdin(): Promise<any>
			get_stdin$($: {}): Promise<any>

			/**
			 * Override in subclass to return suitable 'wsgi.errors'
			 */
			get_stderr(): Promise<any>
			get_stderr$($: {}): Promise<any>

			/**
			 * Override in subclass to insert CGI variables in 'self.environ'
			 */
			add_cgi_vars(): Promise<any>
			add_cgi_vars$($: {}): Promise<any>
			wsgi_version
			wsgi_multithread
			wsgi_multiprocess
			wsgi_run_once
			origin_server
			http_version
			server_software
			os_environ
			wsgi_file_wrapper
			headers_class
			traceback_limit
			error_status
			error_headers
			error_body
			status
			result
			headers_sent
			headers
			bytes_sent
		}

		/**
		 * Handler that's just initialized with streams, environment, etc.
		 * 
		 *     This handler subclass is intended for synchronous HTTP/1.0 origin servers,
		 *     and handles sending the entire response output, given the correct inputs.
		 * 
		 *     Usage::
		 * 
		 *         handler = SimpleHandler(
		 *             inp,out,err,env, multithread=False, multiprocess=True
		 *         )
		 *         handler.run(app)
		 */
		function SimpleHandler(stdin, stdout, stderr, environ, multithread?: boolean, multiprocess?: boolean): Promise<ISimpleHandler>
		function SimpleHandler$({ stdin, stdout, stderr, environ, multithread, multiprocess }: { stdin, stdout, stderr, environ, multithread?, multiprocess?}): Promise<ISimpleHandler>
		interface ISimpleHandler extends IBaseHandler {
			get_stdin(): Promise<any>
			get_stdin$($: {}): Promise<any>
			get_stderr(): Promise<any>
			get_stderr$($: {}): Promise<any>
			add_cgi_vars(): Promise<any>
			add_cgi_vars$($: {}): Promise<any>
		}

		/**
		 * CGI-like systems using input/output/error streams and environ mapping
		 * 
		 *     Usage::
		 * 
		 *         handler = BaseCGIHandler(inp,out,err,env)
		 *         handler.run(app)
		 * 
		 *     This handler class is useful for gateway protocols like ReadyExec and
		 *     FastCGI, that have usable input/output/error streams and an environment
		 *     mapping.  It's also the base class for CGIHandler, which just uses
		 *     sys.stdin, os.environ, and so on.
		 * 
		 *     The constructor also takes keyword arguments 'multithread' and
		 *     'multiprocess' (defaulting to 'True' and 'False' respectively) to control
		 *     the configuration sent to the application.  It sets 'origin_server' to
		 *     False (to enable CGI-like output), and assumes that 'wsgi.run_once' is
		 *     False.
		 *     
		 */
		interface IBaseCGIHandler extends ISimpleHandler {
		}

		/**
		 * CGI-based invocation via sys.stdin/stdout/stderr and os.environ
		 * 
		 *     Usage::
		 * 
		 *         CGIHandler().run(app)
		 * 
		 *     The difference between this class and BaseCGIHandler is that it always
		 *     uses 'wsgi.run_once' of 'True', 'wsgi.multithread' of 'False', and
		 *     'wsgi.multiprocess' of 'True'.  It does not take any initialization
		 *     parameters, but always uses 'sys.stdin', 'os.environ', and friends.
		 * 
		 *     If you need to override any of these parameters, use BaseCGIHandler
		 *     instead.
		 *     
		 */
		function CGIHandler(): Promise<ICGIHandler>
		function CGIHandler$({ }): Promise<ICGIHandler>
		interface ICGIHandler extends IBaseCGIHandler {
		}

		/**
		 * CGI-based invocation with workaround for IIS path bug
		 * 
		 *     This handler should be used in preference to CGIHandler when deploying on
		 *     Microsoft IIS without having set the config allowPathInfo option (IIS>=7)
		 *     or metabase allowPathInfoForScriptMappings (IIS<7).
		 *     
		 */
		function IISCGIHandler(): Promise<IIISCGIHandler>
		function IISCGIHandler$({ }): Promise<IIISCGIHandler>
		interface IIISCGIHandler extends IBaseCGIHandler {
		}
	}
	module headers {
		var _

		/**
		 * Manage a collection of HTTP response headers
		 */
		function Headers(headers?): Promise<IHeaders>
		function Headers$({ headers }: { headers?}): Promise<IHeaders>
		interface IHeaders {

			/**
			 * Return a list of all the values for the named field.
			 * 
			 *         These will be sorted in the order they appeared in the original header
			 *         list or were added to this instance, and may contain duplicates.  Any
			 *         fields deleted and re-inserted are always appended to the header list.
			 *         If no fields exist with the given name, returns an empty list.
			 *         
			 */
			get_all(name): Promise<any>
			get_all$({ name }): Promise<any>

			/**
			 * Get the first header value for 'name', or return 'default'
			 */
			get(name, def?): Promise<any>
			get$({ name, def }: { name, def?}): Promise<any>

			/**
			 * Return a list of all the header field names.
			 * 
			 *         These will be sorted in the order they appeared in the original header
			 *         list, or were added to this instance, and may contain duplicates.
			 *         Any fields deleted and re-inserted are always appended to the header
			 *         list.
			 *         
			 */
			keys(): Promise<any>
			keys$($: {}): Promise<any>

			/**
			 * Return a list of all header values.
			 * 
			 *         These will be sorted in the order they appeared in the original header
			 *         list, or were added to this instance, and may contain duplicates.
			 *         Any fields deleted and re-inserted are always appended to the header
			 *         list.
			 *         
			 */
			values(): Promise<any>
			values$($: {}): Promise<any>

			/**
			 * Get all the header fields and values.
			 * 
			 *         These will be sorted in the order they were in the original header
			 *         list, or were added to this instance, and may contain duplicates.
			 *         Any fields deleted and re-inserted are always appended to the header
			 *         list.
			 *         
			 */
			items(): Promise<any>
			items$($: {}): Promise<any>

			/**
			 * Return first matching header value for 'name', or 'value'
			 * 
			 *         If there is no header named 'name', add a new header with name 'name'
			 *         and value 'value'.
			 */
			setdefault(name, value): Promise<any>
			setdefault$({ name, value }): Promise<any>

			/**
			 * Extended header setting.
			 * 
			 *         _name is the header field to add.  keyword arguments can be used to set
			 *         additional parameters for the header field, with underscores converted
			 *         to dashes.  Normally the parameter will be added as key="value" unless
			 *         value is None, in which case only the key will be added.
			 * 
			 *         Example:
			 * 
			 *         h.add_header('content-disposition', 'attachment', filename='bud.gif')
			 * 
			 *         Note that unlike the corresponding 'email.message' method, this does
			 *         *not* handle '(charset, language, value)' tuples: all values must be
			 *         strings or None.
			 *         
			 */
			add_header(_name, _value): Promise<any>
			add_header$({ _name, _value }): Promise<any>
		}
		let tspecials: Promise<any>
	}
	module simple_server {
		var _
		function demo_app(environ, start_response): Promise<any>
		function demo_app$({ environ, start_response }): Promise<any>

		/**
		 * Create a new WSGI server listening on `host` and `port` for `app`
		 */
		function make_server(host, port, app, server_class?, handler_class?): Promise<any>
		function make_server$({ host, port, app, server_class, handler_class }: { host, port, app, server_class?, handler_class?}): Promise<any>
		interface IServerHandler {
			close(): Promise<any>
			close$($: {}): Promise<any>
			server_software
		}

		/**
		 * BaseHTTPServer that implements the Python WSGI protocol
		 */
		interface IWSGIServer {

			/**
			 * Override server_bind to store the server name.
			 */
			server_bind(): Promise<any>
			server_bind$($: {}): Promise<any>
			setup_environ(): Promise<any>
			setup_environ$($: {}): Promise<any>
			get_app(): Promise<any>
			get_app$($: {}): Promise<any>
			set_app(application): Promise<any>
			set_app$({ application }): Promise<any>
			application
		}
		interface IWSGIRequestHandler {
			get_environ(): Promise<any>
			get_environ$($: {}): Promise<any>
			get_stderr(): Promise<any>
			get_stderr$($: {}): Promise<any>

			/**
			 * Handle a single HTTP request
			 */
			handle(): Promise<any>
			handle$($: {}): Promise<any>
			server_version
		}
		let sys_version: Promise<any>
		let software_version: Promise<any>
		let sa: Promise<any>
	}
	module util {
		var _

		/**
		 * Return a guess for whether 'wsgi.url_scheme' should be 'http' or 'https'
		 *     
		 */
		function guess_scheme(environ): Promise<any>
		function guess_scheme$({ environ }): Promise<any>

		/**
		 * Return the application's base URI (no PATH_INFO or QUERY_STRING)
		 */
		function application_uri(environ): Promise<any>
		function application_uri$({ environ }): Promise<any>

		/**
		 * Return the full request URI, optionally including the query string
		 */
		function request_uri(environ, include_query?: boolean): Promise<any>
		function request_uri$({ environ, include_query }: { environ, include_query?}): Promise<any>

		/**
		 * Shift a name from PATH_INFO to SCRIPT_NAME, returning it
		 * 
		 *     If there are no remaining path segments in PATH_INFO, return None.
		 *     Note: 'environ' is modified in-place; use a copy if you need to keep
		 *     the original PATH_INFO or SCRIPT_NAME.
		 * 
		 *     Note: when PATH_INFO is just a '/', this returns '' and appends a trailing
		 *     '/' to SCRIPT_NAME, even though empty path segments are normally ignored,
		 *     and SCRIPT_NAME doesn't normally end in a '/'.  This is intentional
		 *     behavior, to ensure that an application can tell the difference between
		 *     '/x' and '/x/' when traversing to objects.
		 *     
		 */
		function shift_path_info(environ): Promise<any>
		function shift_path_info$({ environ }): Promise<any>

		/**
		 * Update 'environ' with trivial defaults for testing purposes
		 * 
		 *     This adds various parameters required for WSGI, including HTTP_HOST,
		 *     SERVER_NAME, SERVER_PORT, REQUEST_METHOD, SCRIPT_NAME, PATH_INFO,
		 *     and all of the wsgi.* variables.  It only supplies default values,
		 *     and does not replace any existing settings for these variables.
		 * 
		 *     This routine is intended to make it easier for unit tests of WSGI
		 *     servers and applications to set up dummy environments.  It should *not*
		 *     be used by actual WSGI servers or applications, since the data is fake!
		 *     
		 */
		function setup_testing_defaults(environ): Promise<any>
		function setup_testing_defaults$({ environ }): Promise<any>

		/**
		 * Return true if 'header_name' is an HTTP/1.1 "Hop-by-Hop" header
		 */
		function is_hop_by_hop(header_name): Promise<any>
		function is_hop_by_hop$({ header_name }): Promise<any>

		/**
		 * Wrapper to convert file-like objects to iterables
		 */
		function FileWrapper(filelike, blksize?): Promise<IFileWrapper>
		function FileWrapper$({ filelike, blksize }: { filelike, blksize?}): Promise<IFileWrapper>
		interface IFileWrapper {
		}
	}
	module validate {
		var _
		function assert_(cond): Promise<any>
		function assert_$({ cond }): Promise<any>
		function check_string_type(value, title): Promise<any>
		function check_string_type$({ value, title }): Promise<any>

		/**
		 * 
		 *     When applied between a WSGI server and a WSGI application, this
		 *     middleware will check for WSGI compliancy on a number of levels.
		 *     This middleware does not modify the request or response in any
		 *     way, but will raise an AssertionError if anything seems off
		 *     (except for a failure to close the application iterator, which
		 *     will be printed to stderr -- there's no way to raise an exception
		 *     at that point).
		 *     
		 */
		function validator(application): Promise<any>
		function validator$({ application }): Promise<any>
		function check_environ(environ): Promise<any>
		function check_environ$({ environ }): Promise<any>
		function check_input(wsgi_input): Promise<any>
		function check_input$({ wsgi_input }): Promise<any>
		function check_errors(wsgi_errors): Promise<any>
		function check_errors$({ wsgi_errors }): Promise<any>
		function check_status(status): Promise<any>
		function check_status$({ status }): Promise<any>
		function check_headers(headers): Promise<any>
		function check_headers$({ headers }): Promise<any>
		function check_content_type(status, headers): Promise<any>
		function check_content_type$({ status, headers }): Promise<any>
		function check_exc_info(exc_info): Promise<any>
		function check_exc_info$({ exc_info }): Promise<any>
		function check_iterator(iterator): Promise<any>
		function check_iterator$({ iterator }): Promise<any>

		/**
		 * 
		 *     Raised in response to WSGI-spec-related warnings
		 *     
		 */
		interface IWSGIWarning {
		}
		function InputWrapper(wsgi_input): Promise<IInputWrapper>
		function InputWrapper$({ wsgi_input }): Promise<IInputWrapper>
		interface IInputWrapper {
			read(): Promise<any>
			read$($: {}): Promise<any>
			readline(): Promise<any>
			readline$($: {}): Promise<any>
			readlines(): Promise<any>
			readlines$($: {}): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
		}
		function ErrorWrapper(wsgi_errors): Promise<IErrorWrapper>
		function ErrorWrapper$({ wsgi_errors }): Promise<IErrorWrapper>
		interface IErrorWrapper {
			write(s): Promise<any>
			write$({ s }): Promise<any>
			flush(): Promise<any>
			flush$($: {}): Promise<any>
			writelines(seq): Promise<any>
			writelines$({ seq }): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
		}
		function WriteWrapper(wsgi_writer): Promise<IWriteWrapper>
		function WriteWrapper$({ wsgi_writer }): Promise<IWriteWrapper>
		interface IWriteWrapper {
		}
		function PartialIteratorWrapper(wsgi_iterator): Promise<IPartialIteratorWrapper>
		function PartialIteratorWrapper$({ wsgi_iterator }): Promise<IPartialIteratorWrapper>
		interface IPartialIteratorWrapper {
		}
		function IteratorWrapper(wsgi_iterator, check_start_response): Promise<IIteratorWrapper>
		function IteratorWrapper$({ wsgi_iterator, check_start_response }): Promise<IIteratorWrapper>
		interface IIteratorWrapper {
			close(): Promise<any>
			close$($: {}): Promise<any>
		}
		let header_re: Promise<any>
		let bad_header_value_re: Promise<any>
	}
}
declare module xdrlib {
	var _

	/**
	 *  Wrap any raised struct.errors in a ConversionError. 
	 */
	function raise_conversion_error(func): Promise<any>
	function raise_conversion_error$({ func }): Promise<any>

	/**
	 * Exception class for this module. Use:
	 * 
	 *     except xdrlib.Error as var:
	 *         # var has the Error instance for the exception
	 * 
	 *     Public ivars:
	 *         msg -- contains the message
	 * 
	 *     
	 */
	function Error(msg): Promise<IError>
	function Error$({ msg }): Promise<IError>
	interface IError {
	}
	interface IConversionError extends IError {
	}

	/**
	 * Pack various data representations into a buffer.
	 */
	function Packer(): Promise<IPacker>
	function Packer$({ }): Promise<IPacker>
	interface IPacker {
		reset(): Promise<any>
		reset$($: {}): Promise<any>
		get_buffer(): Promise<any>
		get_buffer$($: {}): Promise<any>
		pack_uint(x): Promise<any>
		pack_uint$({ x }): Promise<any>
		pack_int(x): Promise<any>
		pack_int$({ x }): Promise<any>
		pack_bool(x): Promise<any>
		pack_bool$({ x }): Promise<any>
		pack_uhyper(x): Promise<any>
		pack_uhyper$({ x }): Promise<any>
		pack_float(x): Promise<any>
		pack_float$({ x }): Promise<any>
		pack_double(x): Promise<any>
		pack_double$({ x }): Promise<any>
		pack_fstring(n, s): Promise<any>
		pack_fstring$({ n, s }): Promise<any>
		pack_string(s): Promise<any>
		pack_string$({ s }): Promise<any>
		pack_list(list, pack_item): Promise<any>
		pack_list$({ list, pack_item }): Promise<any>
		pack_farray(n, list, pack_item): Promise<any>
		pack_farray$({ n, list, pack_item }): Promise<any>
		pack_array(list, pack_item): Promise<any>
		pack_array$({ list, pack_item }): Promise<any>
		get_buf
		pack_enum
		pack_hyper
		pack_fopaque
		pack_opaque
		pack_bytes
	}

	/**
	 * Unpacks various data representations from the given buffer.
	 */
	function Unpacker(data): Promise<IUnpacker>
	function Unpacker$({ data }): Promise<IUnpacker>
	interface IUnpacker {
		reset(data): Promise<any>
		reset$({ data }): Promise<any>
		get_position(): Promise<any>
		get_position$($: {}): Promise<any>
		set_position(position): Promise<any>
		set_position$({ position }): Promise<any>
		get_buffer(): Promise<any>
		get_buffer$($: {}): Promise<any>
		done(): Promise<any>
		done$($: {}): Promise<any>
		unpack_uint(): Promise<any>
		unpack_uint$($: {}): Promise<any>
		unpack_int(): Promise<any>
		unpack_int$($: {}): Promise<any>
		unpack_bool(): Promise<any>
		unpack_bool$($: {}): Promise<any>
		unpack_uhyper(): Promise<any>
		unpack_uhyper$($: {}): Promise<any>
		unpack_hyper(): Promise<any>
		unpack_hyper$($: {}): Promise<any>
		unpack_float(): Promise<any>
		unpack_float$($: {}): Promise<any>
		unpack_double(): Promise<any>
		unpack_double$($: {}): Promise<any>
		unpack_fstring(n): Promise<any>
		unpack_fstring$({ n }): Promise<any>
		unpack_string(): Promise<any>
		unpack_string$($: {}): Promise<any>
		unpack_list(unpack_item): Promise<any>
		unpack_list$({ unpack_item }): Promise<any>
		unpack_farray(n, unpack_item): Promise<any>
		unpack_farray$({ n, unpack_item }): Promise<any>
		unpack_array(unpack_item): Promise<any>
		unpack_array$({ unpack_item }): Promise<any>
		unpack_enum
		unpack_fopaque
		unpack_opaque
		unpack_bytes
	}
}
declare module xml {
	var _
	module dom {
		module NodeFilter {
			var _

			/**
			 * 
			 *     This is the DOM2 NodeFilter interface. It contains only constants.
			 *     
			 */
			interface INodeFilter {
				acceptNode(node): Promise<any>
				acceptNode$({ node }): Promise<any>
				FILTER_ACCEPT
				FILTER_REJECT
				FILTER_SKIP
				SHOW_ALL
				SHOW_ELEMENT
				SHOW_ATTRIBUTE
				SHOW_TEXT
				SHOW_CDATA_SECTION
				SHOW_ENTITY_REFERENCE
				SHOW_ENTITY
				SHOW_PROCESSING_INSTRUCTION
				SHOW_COMMENT
				SHOW_DOCUMENT
				SHOW_DOCUMENT_TYPE
				SHOW_DOCUMENT_FRAGMENT
				SHOW_NOTATION
			}
		}
		var _

		/**
		 * Class giving the NodeType constants.
		 */
		interface INode {
			ELEMENT_NODE
			ATTRIBUTE_NODE
			TEXT_NODE
			CDATA_SECTION_NODE
			ENTITY_REFERENCE_NODE
			ENTITY_NODE
			PROCESSING_INSTRUCTION_NODE
			COMMENT_NODE
			DOCUMENT_NODE
			DOCUMENT_TYPE_NODE
			DOCUMENT_FRAGMENT_NODE
			NOTATION_NODE
		}

		/**
		 * Abstract base class for DOM exceptions.
		 *     Exceptions with specific codes are specializations of this class.
		 */
		function DOMException(): Promise<IDOMException>
		function DOMException$({ }): Promise<IDOMException>
		interface IDOMException {
		}
		interface IIndexSizeErr extends IDOMException {
			code
		}
		interface IDomstringSizeErr extends IDOMException {
		}
		interface IHierarchyRequestErr extends IDOMException {
		}
		interface IWrongDocumentErr extends IDOMException {
		}
		interface IInvalidCharacterErr extends IDOMException {
		}
		interface INoDataAllowedErr extends IDOMException {
		}
		interface INoModificationAllowedErr extends IDOMException {
		}
		interface INotFoundErr extends IDOMException {
		}
		interface INotSupportedErr extends IDOMException {
		}
		interface IInuseAttributeErr extends IDOMException {
		}
		interface IInvalidStateErr extends IDOMException {
		}
		interface ISyntaxErr extends IDOMException {
		}
		interface IInvalidModificationErr extends IDOMException {
		}
		interface INamespaceErr extends IDOMException {
		}
		interface IInvalidAccessErr extends IDOMException {
		}
		interface IValidationErr extends IDOMException {
		}

		/**
		 * Class giving the operation constants for UserDataHandler.handle().
		 */
		interface IUserDataHandler {
			NODE_CLONED
			NODE_IMPORTED
			NODE_DELETED
			NODE_RENAMED
		}
		let INDEX_SIZE_ERR: Promise<any>
		let DOMSTRING_SIZE_ERR: Promise<any>
		let HIERARCHY_REQUEST_ERR: Promise<any>
		let WRONG_DOCUMENT_ERR: Promise<any>
		let INVALID_CHARACTER_ERR: Promise<any>
		let NO_DATA_ALLOWED_ERR: Promise<any>
		let NO_MODIFICATION_ALLOWED_ERR: Promise<any>
		let NOT_FOUND_ERR: Promise<any>
		let NOT_SUPPORTED_ERR: Promise<any>
		let INUSE_ATTRIBUTE_ERR: Promise<any>
		let INVALID_STATE_ERR: Promise<any>
		let SYNTAX_ERR: Promise<any>
		let INVALID_MODIFICATION_ERR: Promise<any>
		let NAMESPACE_ERR: Promise<any>
		let INVALID_ACCESS_ERR: Promise<any>
		let VALIDATION_ERR: Promise<any>
		let XML_NAMESPACE: Promise<any>
		let XMLNS_NAMESPACE: Promise<any>
		let XHTML_NAMESPACE: Promise<any>
		let EMPTY_NAMESPACE: Promise<any>
		let EMPTY_PREFIX: Promise<any>
		module domreg {
			var _

			/**
			 * registerDOMImplementation(name, factory)
			 * 
			 *     Register the factory function with the name. The factory function
			 *     should return an object which implements the DOMImplementation
			 *     interface. The factory function can either return the same object,
			 *     or a new one (e.g. if that implementation supports some
			 *     customization).
			 */
			function registerDOMImplementation(name, factory): Promise<any>
			function registerDOMImplementation$({ name, factory }): Promise<any>

			/**
			 * getDOMImplementation(name = None, features = ()) -> DOM implementation.
			 * 
			 *     Return a suitable DOM implementation. The name is either
			 *     well-known, the module name of a DOM implementation, or None. If
			 *     it is not None, imports the corresponding module and returns
			 *     DOMImplementation object if the import succeeds.
			 * 
			 *     If name is not given, consider the available implementations to
			 *     find one with the required feature set. If no implementation can
			 *     be found, raise an ImportError. The features list must be a sequence
			 *     of (feature, version) pairs which are passed to hasFeature.
			 */
			function getDOMImplementation(name?, features?): Promise<any>
			function getDOMImplementation$({ name, features }: { name?, features?}): Promise<any>
			let well_known_implementations: Promise<any>
			let registered: Promise<any>
		}
		module expatbuilder {
			var _

			/**
			 * Parse a document, returning the resulting Document node.
			 * 
			 *     'file' may be either a file name or an open file object.
			 *     
			 */
			function parse(file, namespaces?: boolean): Promise<any>
			function parse$({ file, namespaces }: { file, namespaces?}): Promise<any>

			/**
			 * Parse a document from a string, returning the resulting
			 *     Document node.
			 *     
			 */
			function parseString(string, namespaces?: boolean): Promise<any>
			function parseString$({ string, namespaces }: { string, namespaces?}): Promise<any>

			/**
			 * Parse a fragment of a document, given the context from which it
			 *     was originally extracted.  context should be the parent of the
			 *     node(s) which are in the fragment.
			 * 
			 *     'file' may be either a file name or an open file object.
			 *     
			 */
			function parseFragment(file, context, namespaces?: boolean): Promise<any>
			function parseFragment$({ file, context, namespaces }: { file, context, namespaces?}): Promise<any>

			/**
			 * Parse a fragment of a document from a string, given the context
			 *     from which it was originally extracted.  context should be the
			 *     parent of the node(s) which are in the fragment.
			 *     
			 */
			function parseFragmentString(string, context, namespaces?: boolean): Promise<any>
			function parseFragmentString$({ string, context, namespaces }: { string, context, namespaces?}): Promise<any>

			/**
			 * Create a builder based on an Options object.
			 */
			function makeBuilder(options): Promise<any>
			function makeBuilder$({ options }): Promise<any>
			function ElementInfo(tagName, model?): Promise<IElementInfo>
			function ElementInfo$({ tagName, model }: { tagName, model?}): Promise<IElementInfo>
			interface IElementInfo {
				getAttributeType(aname): Promise<any>
				getAttributeType$({ aname }): Promise<any>
				getAttributeTypeNS(namespaceURI, localName): Promise<any>
				getAttributeTypeNS$({ namespaceURI, localName }): Promise<any>
				isElementContent(): Promise<any>
				isElementContent$($: {}): Promise<any>
				isEmpty(): Promise<any>
				isEmpty$($: {}): Promise<any>
				isId(aname): Promise<any>
				isId$({ aname }): Promise<any>
				isIdNS(euri, ename, auri, aname): Promise<any>
				isIdNS$({ euri, ename, auri, aname }): Promise<any>
			}

			/**
			 * Document builder that uses Expat to build a ParsedXML.DOM document
			 *     instance.
			 */
			function ExpatBuilder(options?): Promise<IExpatBuilder>
			function ExpatBuilder$({ options }: { options?}): Promise<IExpatBuilder>
			interface IExpatBuilder {

				/**
				 * Create a new parser object.
				 */
				createParser(): Promise<any>
				createParser$($: {}): Promise<any>

				/**
				 * Return the parser object, creating a new one if needed.
				 */
				getParser(): Promise<any>
				getParser$($: {}): Promise<any>

				/**
				 * Free all data structures used during DOM construction.
				 */
				reset(): Promise<any>
				reset$($: {}): Promise<any>

				/**
				 * Install the callbacks needed to build the DOM into the parser.
				 */
				install(parser): Promise<any>
				install$({ parser }): Promise<any>

				/**
				 * Parse a document from a file object, returning the document
				 *         node.
				 */
				parseFile(file): Promise<any>
				parseFile$({ file }): Promise<any>

				/**
				 * Parse a document from a string, returning the document node.
				 */
				parseString(string): Promise<any>
				parseString$({ string }): Promise<any>
				start_doctype_decl_handler(doctypeName, systemId, publicId, has_internal_subset): Promise<any>
				start_doctype_decl_handler$({ doctypeName, systemId, publicId, has_internal_subset }): Promise<any>
				end_doctype_decl_handler(): Promise<any>
				end_doctype_decl_handler$($: {}): Promise<any>
				pi_handler(target, data): Promise<any>
				pi_handler$({ target, data }): Promise<any>
				character_data_handler_cdata(data): Promise<any>
				character_data_handler_cdata$({ data }): Promise<any>
				character_data_handler(data): Promise<any>
				character_data_handler$({ data }): Promise<any>
				entity_decl_handler(entityName, is_parameter_entity, value, base, systemId, publicId, notationName): Promise<any>
				entity_decl_handler$({ entityName, is_parameter_entity, value, base, systemId, publicId, notationName }): Promise<any>
				notation_decl_handler(notationName, base, systemId, publicId): Promise<any>
				notation_decl_handler$({ notationName, base, systemId, publicId }): Promise<any>
				comment_handler(data): Promise<any>
				comment_handler$({ data }): Promise<any>
				start_cdata_section_handler(): Promise<any>
				start_cdata_section_handler$($: {}): Promise<any>
				end_cdata_section_handler(): Promise<any>
				end_cdata_section_handler$($: {}): Promise<any>
				external_entity_ref_handler(context, base, systemId, publicId): Promise<any>
				external_entity_ref_handler$({ context, base, systemId, publicId }): Promise<any>
				first_element_handler(name, attributes): Promise<any>
				first_element_handler$({ name, attributes }): Promise<any>
				start_element_handler(name, attributes): Promise<any>
				start_element_handler$({ name, attributes }): Promise<any>
				end_element_handler(name): Promise<any>
				end_element_handler$({ name }): Promise<any>
				element_decl_handler(name, model): Promise<any>
				element_decl_handler$({ name, model }): Promise<any>
				attlist_decl_handler(elem, name, type, def, required): Promise<any>
				attlist_decl_handler$({ elem, name, type, def, required }): Promise<any>
				xml_decl_handler(version, encoding, standalone): Promise<any>
				xml_decl_handler$({ version, encoding, standalone }): Promise<any>
			}

			/**
			 * Wrapper around a DOMBuilderFilter which implements the checks
			 *     to make the whatToShow filter attribute work.
			 */
			function FilterVisibilityController(filter): Promise<IFilterVisibilityController>
			function FilterVisibilityController$({ filter }): Promise<IFilterVisibilityController>
			interface IFilterVisibilityController {
				startContainer(node): Promise<any>
				startContainer$({ node }): Promise<any>
				acceptNode(node): Promise<any>
				acceptNode$({ node }): Promise<any>
			}
			function FilterCrutch(builder): Promise<IFilterCrutch>
			function FilterCrutch$({ builder }): Promise<IFilterCrutch>
			interface IFilterCrutch {
			}
			function Rejecter(builder): Promise<IRejecter>
			function Rejecter$({ builder }): Promise<IRejecter>
			interface IRejecter extends IFilterCrutch {
				start_element_handler(): Promise<any>
				start_element_handler$($: {}): Promise<any>
				end_element_handler(): Promise<any>
				end_element_handler$($: {}): Promise<any>
			}
			interface ISkipper extends IFilterCrutch {
				start_element_handler(): Promise<any>
				start_element_handler$($: {}): Promise<any>
				end_element_handler(): Promise<any>
				end_element_handler$($: {}): Promise<any>
			}

			/**
			 * Builder which constructs document fragments given XML source
			 *     text and a context node.
			 * 
			 *     The context node is expected to provide information about the
			 *     namespace declarations which are in scope at the start of the
			 *     fragment.
			 *     
			 */
			function FragmentBuilder(context, options?): Promise<IFragmentBuilder>
			function FragmentBuilder$({ context, options }: { context, options?}): Promise<IFragmentBuilder>
			interface IFragmentBuilder extends IExpatBuilder {
				reset(): Promise<any>
				reset$($: {}): Promise<any>

				/**
				 * Parse a document fragment from a file object, returning the
				 *         fragment node.
				 */
				parseFile(file): Promise<any>
				parseFile$({ file }): Promise<any>

				/**
				 * Parse a document fragment from a string, returning the
				 *         fragment node.
				 */
				parseString(string): Promise<any>
				parseString$({ string }): Promise<any>
				external_entity_ref_handler(context, base, systemId, publicId): Promise<any>
				external_entity_ref_handler$({ context, base, systemId, publicId }): Promise<any>
			}

			/**
			 * Mix-in class for builders; adds support for namespaces.
			 */
			interface INamespaces {

				/**
				 * Create a new namespace-handling parser.
				 */
				createParser(): Promise<any>
				createParser$($: {}): Promise<any>

				/**
				 * Insert the namespace-handlers onto the parser.
				 */
				install(parser): Promise<any>
				install$({ parser }): Promise<any>

				/**
				 * Push this namespace declaration on our storage.
				 */
				start_namespace_decl_handler(prefix, uri): Promise<any>
				start_namespace_decl_handler$({ prefix, uri }): Promise<any>
				start_element_handler(name, attributes): Promise<any>
				start_element_handler$({ name, attributes }): Promise<any>
			}

			/**
			 * Document builder that supports namespaces.
			 */
			interface IExpatBuilderNS extends INamespaces, IExpatBuilder {
				reset(): Promise<any>
				reset$($: {}): Promise<any>
			}

			/**
			 * Fragment builder that supports namespaces.
			 */
			interface IFragmentBuilderNS extends INamespaces, IFragmentBuilder {
				reset(): Promise<any>
				reset$($: {}): Promise<any>
			}

			/**
			 * Exception raised to short-circuit parsing in InternalSubsetExtractor.
			 */
			interface IParseEscape {
			}

			/**
			 * XML processor which can rip out the internal document type subset.
			 */
			interface IInternalSubsetExtractor extends IExpatBuilder {

				/**
				 * Return the internal subset as a string.
				 */
				getSubset(): Promise<any>
				getSubset$($: {}): Promise<any>
				parseFile(file): Promise<any>
				parseFile$({ file }): Promise<any>
				parseString(string): Promise<any>
				parseString$({ string }): Promise<any>
				install(parser): Promise<any>
				install$({ parser }): Promise<any>
				start_doctype_decl_handler(name, publicId, systemId, has_internal_subset): Promise<any>
				start_doctype_decl_handler$({ name, publicId, systemId, has_internal_subset }): Promise<any>
				end_doctype_decl_handler(): Promise<any>
				end_doctype_decl_handler$($: {}): Promise<any>
				start_element_handler(name, attrs): Promise<any>
				start_element_handler$({ name, attrs }): Promise<any>
				subset
			}
			let TEXT_NODE: Promise<any>
			let CDATA_SECTION_NODE: Promise<any>
			let DOCUMENT_NODE: Promise<any>
			let FILTER_ACCEPT: Promise<any>
			let FILTER_REJECT: Promise<any>
			let FILTER_SKIP: Promise<any>
			let FILTER_INTERRUPT: Promise<any>
			let theDOMImplementation: Promise<any>
		}
		module minicompat {
			var _
			function defproperty(klass, name, doc): Promise<any>
			function defproperty$({ klass, name, doc }): Promise<any>
			interface INodeList {
				item(index): Promise<any>
				item$({ index }): Promise<any>
				length
			}
			interface IEmptyNodeList {
				item(index): Promise<any>
				item$({ index }): Promise<any>
			}
			let StringTypes: Promise<any>
		}
		module minidom {
			var _

			/**
			 * Parse a file into a DOM by filename or file object.
			 */
			function parse(file, parser?, bufsize?): Promise<any>
			function parse$({ file, parser, bufsize }: { file, parser?, bufsize?}): Promise<any>

			/**
			 * Parse a file into a DOM from a string.
			 */
			function parseString(string, parser?): Promise<any>
			function parseString$({ string, parser }: { string, parser?}): Promise<any>
			function getDOMImplementation(features?): Promise<any>
			function getDOMImplementation$({ features }: { features?}): Promise<any>
			interface INode {
				toxml(encoding?, standalone?): Promise<any>
				toxml$({ encoding, standalone }: { encoding?, standalone?}): Promise<any>
				toprettyxml(indent?, newl?, encoding?, standalone?): Promise<any>
				toprettyxml$({ indent, newl, encoding, standalone }: { indent?, newl?, encoding?, standalone?}): Promise<any>
				hasChildNodes(): Promise<any>
				hasChildNodes$($: {}): Promise<any>
				insertBefore(newChild, refChild): Promise<any>
				insertBefore$({ newChild, refChild }): Promise<any>
				appendChild(node): Promise<any>
				appendChild$({ node }): Promise<any>
				replaceChild(newChild, oldChild): Promise<any>
				replaceChild$({ newChild, oldChild }): Promise<any>
				removeChild(oldChild): Promise<any>
				removeChild$({ oldChild }): Promise<any>
				normalize(): Promise<any>
				normalize$($: {}): Promise<any>
				cloneNode(deep): Promise<any>
				cloneNode$({ deep }): Promise<any>
				isSupported(feature, version): Promise<any>
				isSupported$({ feature, version }): Promise<any>
				isSameNode(other): Promise<any>
				isSameNode$({ other }): Promise<any>
				getInterface(feature): Promise<any>
				getInterface$({ feature }): Promise<any>
				getUserData(key): Promise<any>
				getUserData$({ key }): Promise<any>
				setUserData(key, data, handler): Promise<any>
				setUserData$({ key, data, handler }): Promise<any>
				unlink(): Promise<any>
				unlink$($: {}): Promise<any>
				namespaceURI
				parentNode
				ownerDocument
				nextSibling
				previousSibling
				prefix
			}
			function DocumentFragment(): Promise<IDocumentFragment>
			function DocumentFragment$({ }): Promise<IDocumentFragment>
			interface IDocumentFragment extends INode {
				nodeType
				nodeName
				nodeValue
				attributes
			}
			function Attr(qName, namespaceURI?, localName?, prefix?): Promise<IAttr>
			function Attr$({ qName, namespaceURI, localName, prefix }: { qName, namespaceURI?, localName?, prefix?}): Promise<IAttr>
			interface IAttr extends INode {
				unlink(): Promise<any>
				unlink$($: {}): Promise<any>
				specified
				name
				value
			}

			/**
			 * The attribute list is a transient interface to the underlying
			 *     dictionaries.  Mutations here will change the underlying element's
			 *     dictionary.
			 * 
			 *     Ordering is imposed artificially and does not reflect the order of
			 *     attributes as found in an input document.
			 *     
			 */
			function NamedNodeMap(attrs, attrsNS, ownerElement): Promise<INamedNodeMap>
			function NamedNodeMap$({ attrs, attrsNS, ownerElement }): Promise<INamedNodeMap>
			interface INamedNodeMap {
				item(index): Promise<any>
				item$({ index }): Promise<any>
				items(): Promise<any>
				items$($: {}): Promise<any>
				itemsNS(): Promise<any>
				itemsNS$($: {}): Promise<any>
				keys(): Promise<any>
				keys$($: {}): Promise<any>
				keysNS(): Promise<any>
				keysNS$($: {}): Promise<any>
				values(): Promise<any>
				values$($: {}): Promise<any>
				get(name, value?): Promise<any>
				get$({ name, value }: { name, value?}): Promise<any>
				getNamedItem(name): Promise<any>
				getNamedItem$({ name }): Promise<any>
				getNamedItemNS(namespaceURI, localName): Promise<any>
				getNamedItemNS$({ namespaceURI, localName }): Promise<any>
				removeNamedItem(name): Promise<any>
				removeNamedItem$({ name }): Promise<any>
				removeNamedItemNS(namespaceURI, localName): Promise<any>
				removeNamedItemNS$({ namespaceURI, localName }): Promise<any>
				setNamedItem(node): Promise<any>
				setNamedItem$({ node }): Promise<any>
				setNamedItemNS(node): Promise<any>
				setNamedItemNS$({ node }): Promise<any>
			}
			function TypeInfo(namespace, name): Promise<ITypeInfo>
			function TypeInfo$({ namespace, name }): Promise<ITypeInfo>
			interface ITypeInfo {
			}
			function Element(tagName, namespaceURI?, prefix?, localName?): Promise<IElement>
			function Element$({ tagName, namespaceURI, prefix, localName }: { tagName, namespaceURI?, prefix?, localName?}): Promise<IElement>
			interface IElement extends INode {
				unlink(): Promise<any>
				unlink$($: {}): Promise<any>

				/**
				 * Returns the value of the specified attribute.
				 * 
				 *         Returns the value of the element's attribute named attname as
				 *         a string. An empty string is returned if the element does not
				 *         have such an attribute. Note that an empty string may also be
				 *         returned as an explicitly given attribute value, use the
				 *         hasAttribute method to distinguish these two cases.
				 *         
				 */
				getAttribute(attname): Promise<any>
				getAttribute$({ attname }): Promise<any>
				getAttributeNS(namespaceURI, localName): Promise<any>
				getAttributeNS$({ namespaceURI, localName }): Promise<any>
				setAttribute(attname, value): Promise<any>
				setAttribute$({ attname, value }): Promise<any>
				setAttributeNS(namespaceURI, qualifiedName, value): Promise<any>
				setAttributeNS$({ namespaceURI, qualifiedName, value }): Promise<any>
				getAttributeNode(attrname): Promise<any>
				getAttributeNode$({ attrname }): Promise<any>
				getAttributeNodeNS(namespaceURI, localName): Promise<any>
				getAttributeNodeNS$({ namespaceURI, localName }): Promise<any>
				setAttributeNode(attr): Promise<any>
				setAttributeNode$({ attr }): Promise<any>
				removeAttribute(name): Promise<any>
				removeAttribute$({ name }): Promise<any>
				removeAttributeNS(namespaceURI, localName): Promise<any>
				removeAttributeNS$({ namespaceURI, localName }): Promise<any>
				removeAttributeNode(node): Promise<any>
				removeAttributeNode$({ node }): Promise<any>

				/**
				 * Checks whether the element has an attribute with the specified name.
				 * 
				 *         Returns True if the element has an attribute with the specified name.
				 *         Otherwise, returns False.
				 *         
				 */
				hasAttribute(name): Promise<any>
				hasAttribute$({ name }): Promise<any>
				hasAttributeNS(namespaceURI, localName): Promise<any>
				hasAttributeNS$({ namespaceURI, localName }): Promise<any>

				/**
				 * Returns all descendant elements with the given tag name.
				 * 
				 *         Returns the list of all descendant elements (not direct children
				 *         only) with the specified tag name.
				 *         
				 */
				getElementsByTagName(name): Promise<any>
				getElementsByTagName$({ name }): Promise<any>
				getElementsByTagNameNS(namespaceURI, localName): Promise<any>
				getElementsByTagNameNS$({ namespaceURI, localName }): Promise<any>

				/**
				 * Write an XML element to a file-like object
				 * 
				 *         Write the element to the writer object that must provide
				 *         a write method (e.g. a file or StringIO object).
				 *         
				 */
				writexml(writer, indent?, addindent?, newl?): Promise<any>
				writexml$({ writer, indent, addindent, newl }: { writer, indent?, addindent?, newl?}): Promise<any>
				hasAttributes(): Promise<any>
				hasAttributes$($: {}): Promise<any>
				setIdAttribute(name): Promise<any>
				setIdAttribute$({ name }): Promise<any>
				setIdAttributeNS(namespaceURI, localName): Promise<any>
				setIdAttributeNS$({ namespaceURI, localName }): Promise<any>
				setIdAttributeNode(idAttr): Promise<any>
				setIdAttributeNode$({ idAttr }): Promise<any>
				schemaType
				setAttributeNodeNS
				removeAttributeNodeNS
			}

			/**
			 * Mixin that makes childless-ness easy to implement and avoids
			 *     the complexity of the Node methods that deal with children.
			 *     
			 */
			interface IChildless {
				appendChild(node): Promise<any>
				appendChild$({ node }): Promise<any>
				hasChildNodes(): Promise<any>
				hasChildNodes$($: {}): Promise<any>
				insertBefore(newChild, refChild): Promise<any>
				insertBefore$({ newChild, refChild }): Promise<any>
				removeChild(oldChild): Promise<any>
				removeChild$({ oldChild }): Promise<any>
				normalize(): Promise<any>
				normalize$($: {}): Promise<any>
				replaceChild(newChild, oldChild): Promise<any>
				replaceChild$({ newChild, oldChild }): Promise<any>
				childNodes
				firstChild
				lastChild
			}
			function ProcessingInstruction(target, data): Promise<IProcessingInstruction>
			function ProcessingInstruction$({ target, data }): Promise<IProcessingInstruction>
			interface IProcessingInstruction extends IChildless, INode {
				writexml(writer, indent?, addindent?, newl?): Promise<any>
				writexml$({ writer, indent, addindent, newl }: { writer, indent?, addindent?, newl?}): Promise<any>
			}
			function CharacterData(): Promise<ICharacterData>
			function CharacterData$({ }): Promise<ICharacterData>
			interface ICharacterData extends IChildless, INode {
				substringData(offset, count): Promise<any>
				substringData$({ offset, count }): Promise<any>
				appendData(arg): Promise<any>
				appendData$({ arg }): Promise<any>
				insertData(offset, arg): Promise<any>
				insertData$({ offset, arg }): Promise<any>
				deleteData(offset, count): Promise<any>
				deleteData$({ offset, count }): Promise<any>
				replaceData(offset, count, arg): Promise<any>
				replaceData$({ offset, count, arg }): Promise<any>
				data
			}
			interface IText extends ICharacterData {
				splitText(offset): Promise<any>
				splitText$({ offset }): Promise<any>
				writexml(writer, indent?, addindent?, newl?): Promise<any>
				writexml$({ writer, indent, addindent, newl }: { writer, indent?, addindent?, newl?}): Promise<any>
				replaceWholeText(content): Promise<any>
				replaceWholeText$({ content }): Promise<any>
			}
			function Comment(data): Promise<IComment>
			function Comment$({ data }): Promise<IComment>
			interface IComment extends ICharacterData {
				writexml(writer, indent?, addindent?, newl?): Promise<any>
				writexml$({ writer, indent, addindent, newl }: { writer, indent?, addindent?, newl?}): Promise<any>
			}
			interface ICDATASection extends IText {
				writexml(writer, indent?, addindent?, newl?): Promise<any>
				writexml$({ writer, indent, addindent, newl }: { writer, indent?, addindent?, newl?}): Promise<any>
			}
			function ReadOnlySequentialNamedNodeMap(seq?): Promise<IReadOnlySequentialNamedNodeMap>
			function ReadOnlySequentialNamedNodeMap$({ seq }: { seq?}): Promise<IReadOnlySequentialNamedNodeMap>
			interface IReadOnlySequentialNamedNodeMap {
				getNamedItem(name): Promise<any>
				getNamedItem$({ name }): Promise<any>
				getNamedItemNS(namespaceURI, localName): Promise<any>
				getNamedItemNS$({ namespaceURI, localName }): Promise<any>
				item(index): Promise<any>
				item$({ index }): Promise<any>
				removeNamedItem(name): Promise<any>
				removeNamedItem$({ name }): Promise<any>
				removeNamedItemNS(namespaceURI, localName): Promise<any>
				removeNamedItemNS$({ namespaceURI, localName }): Promise<any>
				setNamedItem(node): Promise<any>
				setNamedItem$({ node }): Promise<any>
				setNamedItemNS(node): Promise<any>
				setNamedItemNS$({ node }): Promise<any>
			}

			/**
			 * Mix-in class that supports the publicId and systemId attributes.
			 */
			interface IIdentified {
			}
			function DocumentType(qualifiedName): Promise<IDocumentType>
			function DocumentType$({ qualifiedName }): Promise<IDocumentType>
			interface IDocumentType extends IIdentified, IChildless, INode {
				cloneNode(deep): Promise<any>
				cloneNode$({ deep }): Promise<any>
				writexml(writer, indent?, addindent?, newl?): Promise<any>
				writexml$({ writer, indent, addindent, newl }: { writer, indent?, addindent?, newl?}): Promise<any>
				publicId
				systemId
				internalSubset
			}
			function Entity(name, publicId, systemId, notation): Promise<IEntity>
			function Entity$({ name, publicId, systemId, notation }): Promise<IEntity>
			interface IEntity extends IIdentified, INode {
				appendChild(newChild): Promise<any>
				appendChild$({ newChild }): Promise<any>
				insertBefore(newChild, refChild): Promise<any>
				insertBefore$({ newChild, refChild }): Promise<any>
				removeChild(oldChild): Promise<any>
				removeChild$({ oldChild }): Promise<any>
				replaceChild(newChild, oldChild): Promise<any>
				replaceChild$({ newChild, oldChild }): Promise<any>
				actualEncoding
				encoding
				version
			}
			function Notation(name, publicId, systemId): Promise<INotation>
			function Notation$({ name, publicId, systemId }): Promise<INotation>
			interface INotation extends IIdentified, IChildless, INode {
			}
			interface IDOMImplementation {
				hasFeature(feature, version): Promise<any>
				hasFeature$({ feature, version }): Promise<any>
				createDocument(namespaceURI, qualifiedName, doctype): Promise<any>
				createDocument$({ namespaceURI, qualifiedName, doctype }): Promise<any>
				createDocumentType(qualifiedName, publicId, systemId): Promise<any>
				createDocumentType$({ qualifiedName, publicId, systemId }): Promise<any>
				getInterface(feature): Promise<any>
				getInterface$({ feature }): Promise<any>
			}

			/**
			 * Object that represents content-model information for an element.
			 * 
			 *     This implementation is not expected to be used in practice; DOM
			 *     builders should provide implementations which do the right thing
			 *     using information available to it.
			 * 
			 *     
			 */
			function ElementInfo(name): Promise<IElementInfo>
			function ElementInfo$({ name }): Promise<IElementInfo>
			interface IElementInfo {
				getAttributeType(aname): Promise<any>
				getAttributeType$({ aname }): Promise<any>
				getAttributeTypeNS(namespaceURI, localName): Promise<any>
				getAttributeTypeNS$({ namespaceURI, localName }): Promise<any>
				isElementContent(): Promise<any>
				isElementContent$($: {}): Promise<any>

				/**
				 * Returns true iff this element is declared to have an EMPTY
				 *         content model.
				 */
				isEmpty(): Promise<any>
				isEmpty$($: {}): Promise<any>

				/**
				 * Returns true iff the named attribute is a DTD-style ID.
				 */
				isId(aname): Promise<any>
				isId$({ aname }): Promise<any>

				/**
				 * Returns true iff the identified attribute is a DTD-style ID.
				 */
				isIdNS(namespaceURI, localName): Promise<any>
				isIdNS$({ namespaceURI, localName }): Promise<any>
			}
			function Document(): Promise<IDocument>
			function Document$({ }): Promise<IDocument>
			interface IDocument extends INode {
				appendChild(node): Promise<any>
				appendChild$({ node }): Promise<any>
				removeChild(oldChild): Promise<any>
				removeChild$({ oldChild }): Promise<any>
				unlink(): Promise<any>
				unlink$($: {}): Promise<any>
				cloneNode(deep): Promise<any>
				cloneNode$({ deep }): Promise<any>
				createDocumentFragment(): Promise<any>
				createDocumentFragment$($: {}): Promise<any>
				createElement(tagName): Promise<any>
				createElement$({ tagName }): Promise<any>
				createTextNode(data): Promise<any>
				createTextNode$({ data }): Promise<any>
				createCDATASection(data): Promise<any>
				createCDATASection$({ data }): Promise<any>
				createComment(data): Promise<any>
				createComment$({ data }): Promise<any>
				createProcessingInstruction(target, data): Promise<any>
				createProcessingInstruction$({ target, data }): Promise<any>
				createAttribute(qName): Promise<any>
				createAttribute$({ qName }): Promise<any>
				createElementNS(namespaceURI, qualifiedName): Promise<any>
				createElementNS$({ namespaceURI, qualifiedName }): Promise<any>
				createAttributeNS(namespaceURI, qualifiedName): Promise<any>
				createAttributeNS$({ namespaceURI, qualifiedName }): Promise<any>
				getElementById(id): Promise<any>
				getElementById$({ id }): Promise<any>
				getElementsByTagName(name): Promise<any>
				getElementsByTagName$({ name }): Promise<any>
				getElementsByTagNameNS(namespaceURI, localName): Promise<any>
				getElementsByTagNameNS$({ namespaceURI, localName }): Promise<any>
				isSupported(feature, version): Promise<any>
				isSupported$({ feature, version }): Promise<any>
				importNode(node, deep): Promise<any>
				importNode$({ node, deep }): Promise<any>
				writexml(writer, indent?, addindent?, newl?, encoding?, standalone?): Promise<any>
				writexml$({ writer, indent, addindent, newl, encoding, standalone }: { writer, indent?, addindent?, newl?, encoding?, standalone?}): Promise<any>
				renameNode(n, namespaceURI, name): Promise<any>
				renameNode$({ n, namespaceURI, name }): Promise<any>
				implementation
				standalone
				strictErrorChecking
				errorHandler
				documentURI
			}
			let AttributeList: Promise<any>
		}
		module pulldom {
			var _
			function parse(stream_or_string, parser?, bufsize?): Promise<any>
			function parse$({ stream_or_string, parser, bufsize }: { stream_or_string, parser?, bufsize?}): Promise<any>
			function parseString(string, parser?): Promise<any>
			function parseString$({ string, parser }: { string, parser?}): Promise<any>
			function PullDOM(documentFactory?): Promise<IPullDOM>
			function PullDOM$({ documentFactory }: { documentFactory?}): Promise<IPullDOM>
			interface IPullDOM {
				pop(): Promise<any>
				pop$($: {}): Promise<any>
				setDocumentLocator(locator): Promise<any>
				setDocumentLocator$({ locator }): Promise<any>
				startPrefixMapping(prefix, uri): Promise<any>
				startPrefixMapping$({ prefix, uri }): Promise<any>
				endPrefixMapping(prefix): Promise<any>
				endPrefixMapping$({ prefix }): Promise<any>
				startElementNS(name, tagName, attrs): Promise<any>
				startElementNS$({ name, tagName, attrs }): Promise<any>
				endElementNS(name, tagName): Promise<any>
				endElementNS$({ name, tagName }): Promise<any>
				startElement(name, attrs): Promise<any>
				startElement$({ name, attrs }): Promise<any>
				endElement(name): Promise<any>
				endElement$({ name }): Promise<any>
				comment(s): Promise<any>
				comment$({ s }): Promise<any>
				processingInstruction(target, data): Promise<any>
				processingInstruction$({ target, data }): Promise<any>
				ignorableWhitespace(chars): Promise<any>
				ignorableWhitespace$({ chars }): Promise<any>
				characters(chars): Promise<any>
				characters$({ chars }): Promise<any>
				startDocument(): Promise<any>
				startDocument$($: {}): Promise<any>
				buildDocument(uri, tagname): Promise<any>
				buildDocument$({ uri, tagname }): Promise<any>
				endDocument(): Promise<any>
				endDocument$($: {}): Promise<any>

				/**
				 * clear(): Explicitly release parsing structures
				 */
				clear(): Promise<any>
				clear$($: {}): Promise<any>
				document
			}
			interface IErrorHandler {
				warning(exception): Promise<any>
				warning$({ exception }): Promise<any>
				error(exception): Promise<any>
				error$({ exception }): Promise<any>
				fatalError(exception): Promise<any>
				fatalError$({ exception }): Promise<any>
			}
			function DOMEventStream(stream, parser, bufsize): Promise<IDOMEventStream>
			function DOMEventStream$({ stream, parser, bufsize }): Promise<IDOMEventStream>
			interface IDOMEventStream {
				reset(): Promise<any>
				reset$($: {}): Promise<any>
				expandNode(node): Promise<any>
				expandNode$({ node }): Promise<any>
				getEvent(): Promise<any>
				getEvent$($: {}): Promise<any>

				/**
				 * clear(): Explicitly release parsing objects
				 */
				clear(): Promise<any>
				clear$($: {}): Promise<any>
			}
			interface ISAX2DOM extends IPullDOM {
				startElementNS(name, tagName, attrs): Promise<any>
				startElementNS$({ name, tagName, attrs }): Promise<any>
				startElement(name, attrs): Promise<any>
				startElement$({ name, attrs }): Promise<any>
				processingInstruction(target, data): Promise<any>
				processingInstruction$({ target, data }): Promise<any>
				ignorableWhitespace(chars): Promise<any>
				ignorableWhitespace$({ chars }): Promise<any>
				characters(chars): Promise<any>
				characters$({ chars }): Promise<any>
			}
			let START_ELEMENT: Promise<any>
			let END_ELEMENT: Promise<any>
			let COMMENT: Promise<any>
			let START_DOCUMENT: Promise<any>
			let END_DOCUMENT: Promise<any>
			let PROCESSING_INSTRUCTION: Promise<any>
			let IGNORABLE_WHITESPACE: Promise<any>
			let CHARACTERS: Promise<any>
			let default_bufsize: Promise<any>
		}
		module xmlbuilder {
			var _

			/**
			 * Features object that has variables set for each DOMBuilder feature.
			 * 
			 *     The DOMBuilder class uses an instance of this class to pass settings to
			 *     the ExpatBuilder class.
			 *     
			 */
			interface IOptions {
				namespaces
				namespace_declarations
				validation
				external_parameter_entities
				external_general_entities
				external_dtd_subset
				validate_if_schema
				validate
				datatype_normalization
				create_entity_ref_nodes
				entities
				whitespace_in_element_content
				cdata_sections
				comments
				charset_overrides_xml_encoding
				infoset
				supported_mediatypes_only
				errorHandler
				filter
			}
			function DOMBuilder(): Promise<IDOMBuilder>
			function DOMBuilder$({ }): Promise<IDOMBuilder>
			interface IDOMBuilder {
				setFeature(name, state): Promise<any>
				setFeature$({ name, state }): Promise<any>
				supportsFeature(name): Promise<any>
				supportsFeature$({ name }): Promise<any>
				canSetFeature(name, state): Promise<any>
				canSetFeature$({ name, state }): Promise<any>
				getFeature(name): Promise<any>
				getFeature$({ name }): Promise<any>
				parseURI(uri): Promise<any>
				parseURI$({ uri }): Promise<any>
				parse(input): Promise<any>
				parse$({ input }): Promise<any>
				parseWithContext(input, cnode, action): Promise<any>
				parseWithContext$({ input, cnode, action }): Promise<any>
				entityResolver
				ACTION_REPLACE
				ACTION_APPEND_AS_CHILDREN
				ACTION_INSERT_AFTER
				ACTION_INSERT_BEFORE
			}
			interface IDOMEntityResolver {
				resolveEntity(publicId, systemId): Promise<any>
				resolveEntity$({ publicId, systemId }): Promise<any>
			}
			function DOMInputSource(): Promise<IDOMInputSource>
			function DOMInputSource$({ }): Promise<IDOMInputSource>
			interface IDOMInputSource {
			}

			/**
			 * Element filter which can be used to tailor construction of
			 *     a DOM instance.
			 *     
			 */
			interface IDOMBuilderFilter {
				acceptNode(element): Promise<any>
				acceptNode$({ element }): Promise<any>
				startContainer(element): Promise<any>
				startContainer$({ element }): Promise<any>
				FILTER_ACCEPT
				FILTER_REJECT
				FILTER_SKIP
				FILTER_INTERRUPT
				whatToShow
			}

			/**
			 * Mixin to create documents that conform to the load/save spec.
			 */
			interface IDocumentLS {
				abort(): Promise<any>
				abort$($: {}): Promise<any>
				load(uri): Promise<any>
				load$({ uri }): Promise<any>
				loadXML(source): Promise<any>
				loadXML$({ source }): Promise<any>
				saveXML(snode): Promise<any>
				saveXML$({ snode }): Promise<any>
				async_
			}
			interface IDOMImplementationLS {
				createDOMBuilder(mode, schemaType): Promise<any>
				createDOMBuilder$({ mode, schemaType }): Promise<any>
				createDOMWriter(): Promise<any>
				createDOMWriter$($: {}): Promise<any>
				createDOMInputSource(): Promise<any>
				createDOMInputSource$($: {}): Promise<any>
				MODE_SYNCHRONOUS
				MODE_ASYNCHRONOUS
			}
		}
	}
	module etree {
		module ElementInclude {
			var _
			function default_loader(href, parse, encoding?): Promise<any>
			function default_loader$({ href, parse, encoding }: { href, parse, encoding?}): Promise<any>
			function include(elem, loader?, base_url?, max_depth?): Promise<any>
			function include$({ elem, loader, base_url, max_depth }: { elem, loader?, base_url?, max_depth?}): Promise<any>
			interface IFatalIncludeError {
			}
			interface ILimitedRecursiveIncludeError extends IFatalIncludeError {
			}
			let XINCLUDE: Promise<any>
			let XINCLUDE_INCLUDE: Promise<any>
			let XINCLUDE_FALLBACK: Promise<any>
			let DEFAULT_MAX_INCLUSION_DEPTH: Promise<any>
		}
		module ElementPath {
			var _
			function xpath_tokenizer(pattern, namespaces?): Promise<any>
			function xpath_tokenizer$({ pattern, namespaces }: { pattern, namespaces?}): Promise<any>
			function get_parent_map(context): Promise<any>
			function get_parent_map$({ context }): Promise<any>
			function prepare_child(next, token): Promise<any>
			function prepare_child$({ next, token }): Promise<any>
			function prepare_star(next, token): Promise<any>
			function prepare_star$({ next, token }): Promise<any>
			function prepare_self(next, token): Promise<any>
			function prepare_self$({ next, token }): Promise<any>
			function prepare_descendant(next, token): Promise<any>
			function prepare_descendant$({ next, token }): Promise<any>
			function prepare_parent(next, token): Promise<any>
			function prepare_parent$({ next, token }): Promise<any>
			function prepare_predicate(next, token): Promise<any>
			function prepare_predicate$({ next, token }): Promise<any>
			function iterfind(elem, path, namespaces?): Promise<any>
			function iterfind$({ elem, path, namespaces }: { elem, path, namespaces?}): Promise<any>
			function find(elem, path, namespaces?): Promise<any>
			function find$({ elem, path, namespaces }: { elem, path, namespaces?}): Promise<any>
			function findall(elem, path, namespaces?): Promise<any>
			function findall$({ elem, path, namespaces }: { elem, path, namespaces?}): Promise<any>
			function findtext(elem, path, def?, namespaces?): Promise<any>
			function findtext$({ elem, path, def, namespaces }: { elem, path, def?, namespaces?}): Promise<any>
			interface I_SelectorContext {
				parent_map
			}
			let xpath_tokenizer_re: Promise<any>
			let ops: Promise<any>
		}
		module ElementTree {
			var _

			/**
			 * Return True if *element* appears to be an Element.
			 */
			function iselement(element): Promise<any>
			function iselement$({ element }): Promise<any>

			/**
			 * Subelement factory which creates an element instance, and appends it
			 *     to an existing parent.
			 * 
			 *     The element tag, attribute names, and attribute values can be either
			 *     bytes or Unicode strings.
			 * 
			 *     *parent* is the parent element, *tag* is the subelements name, *attrib* is
			 *     an optional directory containing element attributes, *extra* are
			 *     additional attributes given as keyword arguments.
			 * 
			 *     
			 */
			function SubElement(parent, tag, attrib?): Promise<any>
			function SubElement$({ parent, tag, attrib }: { parent, tag, attrib?}): Promise<any>

			/**
			 * Comment element factory.
			 * 
			 *     This function creates a special element which the standard serializer
			 *     serializes as an XML comment.
			 * 
			 *     *text* is a string containing the comment string.
			 * 
			 *     
			 */
			function Comment(text?): Promise<any>
			function Comment$({ text }: { text?}): Promise<any>

			/**
			 * Processing Instruction element factory.
			 * 
			 *     This function creates a special element which the standard serializer
			 *     serializes as an XML comment.
			 * 
			 *     *target* is a string containing the processing instruction, *text* is a
			 *     string containing the processing instruction contents, if any.
			 * 
			 *     
			 */
			function ProcessingInstruction(target, text?): Promise<any>
			function ProcessingInstruction$({ target, text }: { target, text?}): Promise<any>

			/**
			 * Register a namespace prefix.
			 * 
			 *     The registry is global, and any existing mapping for either the
			 *     given prefix or the namespace URI will be removed.
			 * 
			 *     *prefix* is the namespace prefix, *uri* is a namespace uri. Tags and
			 *     attributes in this namespace will be serialized with prefix if possible.
			 * 
			 *     ValueError is raised if prefix is reserved or is invalid.
			 * 
			 *     
			 */
			function register_namespace(prefix, uri): Promise<any>
			function register_namespace$({ prefix, uri }): Promise<any>

			/**
			 * Generate string representation of XML element.
			 * 
			 *     All subelements are included.  If encoding is "unicode", a string
			 *     is returned. Otherwise a bytestring is returned.
			 * 
			 *     *element* is an Element instance, *encoding* is an optional output
			 *     encoding defaulting to US-ASCII, *method* is an optional output which can
			 *     be one of "xml" (default), "html", "text" or "c14n", *default_namespace*
			 *     sets the default XML namespace (for "xmlns").
			 * 
			 *     Returns an (optionally) encoded string containing the XML data.
			 * 
			 *     
			 */
			function tostring(element, encoding?, method?): Promise<any>
			function tostring$({ element, encoding, method }: { element, encoding?, method?}): Promise<any>
			function tostringlist(element, encoding?, method?): Promise<any>
			function tostringlist$({ element, encoding, method }: { element, encoding?, method?}): Promise<any>

			/**
			 * Write element tree or element structure to sys.stdout.
			 * 
			 *     This function should be used for debugging only.
			 * 
			 *     *elem* is either an ElementTree, or a single Element.  The exact output
			 *     format is implementation dependent.  In this version, it's written as an
			 *     ordinary XML file.
			 * 
			 *     
			 */
			function dump(elem): Promise<any>
			function dump$({ elem }): Promise<any>

			/**
			 * Indent an XML document by inserting newlines and indentation space
			 *     after elements.
			 * 
			 *     *tree* is the ElementTree or Element to modify.  The (root) element
			 *     itself will not be changed, but the tail text of all elements in its
			 *     subtree will be adapted.
			 * 
			 *     *space* is the whitespace to insert for each indentation level, two
			 *     space characters by default.
			 * 
			 *     *level* is the initial indentation level. Setting this to a higher
			 *     value than 0 can be used for indenting subtrees that are more deeply
			 *     nested inside of a document.
			 *     
			 */
			function indent(tree, space?, level?): Promise<any>
			function indent$({ tree, space, level }: { tree, space?, level?}): Promise<any>

			/**
			 * Parse XML document into element tree.
			 * 
			 *     *source* is a filename or file object containing XML data,
			 *     *parser* is an optional parser instance defaulting to XMLParser.
			 * 
			 *     Return an ElementTree instance.
			 * 
			 *     
			 */
			function parse(source, parser?): Promise<any>
			function parse$({ source, parser }: { source, parser?}): Promise<any>

			/**
			 * Incrementally parse XML document into ElementTree.
			 * 
			 *     This class also reports what's going on to the user based on the
			 *     *events* it is initialized with.  The supported events are the strings
			 *     "start", "end", "start-ns" and "end-ns" (the "ns" events are used to get
			 *     detailed namespace information).  If *events* is omitted, only
			 *     "end" events are reported.
			 * 
			 *     *source* is a filename or file object containing XML data, *events* is
			 *     a list of events to report back, *parser* is an optional parser instance.
			 * 
			 *     Returns an iterator providing (event, elem) pairs.
			 * 
			 *     
			 */
			function iterparse(source, events?, parser?): Promise<any>
			function iterparse$({ source, events, parser }: { source, events?, parser?}): Promise<any>

			/**
			 * Parse XML document from string constant.
			 * 
			 *     This function can be used to embed "XML Literals" in Python code.
			 * 
			 *     *text* is a string containing XML data, *parser* is an
			 *     optional parser instance, defaulting to the standard XMLParser.
			 * 
			 *     Returns an Element instance.
			 * 
			 *     
			 */
			function XML(text, parser?): Promise<any>
			function XML$({ text, parser }: { text, parser?}): Promise<any>

			/**
			 * Parse XML document from string constant for its IDs.
			 * 
			 *     *text* is a string containing XML data, *parser* is an
			 *     optional parser instance, defaulting to the standard XMLParser.
			 * 
			 *     Returns an (Element, dict) tuple, in which the
			 *     dict maps element id:s to elements.
			 * 
			 *     
			 */
			function XMLID(text, parser?): Promise<any>
			function XMLID$({ text, parser }: { text, parser?}): Promise<any>

			/**
			 * Parse XML document from sequence of string fragments.
			 * 
			 *     *sequence* is a list of other sequence, *parser* is an optional parser
			 *     instance, defaulting to the standard XMLParser.
			 * 
			 *     Returns an Element instance.
			 * 
			 *     
			 */
			function fromstringlist(sequence, parser?): Promise<any>
			function fromstringlist$({ sequence, parser }: { sequence, parser?}): Promise<any>

			/**
			 * Convert XML to its C14N 2.0 serialised form.
			 * 
			 *     If *out* is provided, it must be a file or file-like object that receives
			 *     the serialised canonical XML output (text, not bytes) through its ``.write()``
			 *     method.  To write to a file, open it in text mode with encoding "utf-8".
			 *     If *out* is not provided, this function returns the output as text string.
			 * 
			 *     Either *xml_data* (an XML string) or *from_file* (a file path or
			 *     file-like object) must be provided as input.
			 * 
			 *     The configuration options are the same as for the ``C14NWriterTarget``.
			 *     
			 */
			function canonicalize(xml_data?): Promise<any>
			function canonicalize$({ xml_data }: { xml_data?}): Promise<any>

			/**
			 * An error when parsing an XML document.
			 * 
			 *     In addition to its exception value, a ParseError contains
			 *     two extra attributes:
			 *         'code'     - the specific exception code
			 *         'position' - the line and column of the error
			 * 
			 *     
			 */
			interface IParseError {
			}

			/**
			 * An XML element.
			 * 
			 *     This class is the reference implementation of the Element interface.
			 * 
			 *     An element's length is its number of subelements.  That means if you
			 *     want to check if an element is truly empty, you should check BOTH
			 *     its length AND its text attribute.
			 * 
			 *     The element tag, attribute names, and attribute values can be either
			 *     bytes or strings.
			 * 
			 *     *tag* is the element name.  *attrib* is an optional dictionary containing
			 *     element attributes. *extra* are additional element attributes given as
			 *     keyword arguments.
			 * 
			 *     Example form:
			 *         <tag attrib>text<child/>...</tag>tail
			 * 
			 *     
			 */
			function Element(tag, attrib?): Promise<IElement>
			function Element$({ tag, attrib }: { tag, attrib?}): Promise<IElement>
			interface IElement {

				/**
				 * Create a new element with the same type.
				 * 
				 *         *tag* is a string containing the element name.
				 *         *attrib* is a dictionary containing the element attributes.
				 * 
				 *         Do not call this method, use the SubElement factory function instead.
				 * 
				 *         
				 */
				makeelement(tag, attrib): Promise<any>
				makeelement$({ tag, attrib }): Promise<any>

				/**
				 * Return copy of current element.
				 * 
				 *         This creates a shallow copy. Subelements will be shared with the
				 *         original tree.
				 * 
				 *         
				 */
				copy(): Promise<any>
				copy$($: {}): Promise<any>

				/**
				 * Add *subelement* to the end of this element.
				 * 
				 *         The new element will appear in document order after the last existing
				 *         subelement (or directly after the text, if it's the first subelement),
				 *         but before the end tag for this element.
				 * 
				 *         
				 */
				append(subelement): Promise<any>
				append$({ subelement }): Promise<any>

				/**
				 * Append subelements from a sequence.
				 * 
				 *         *elements* is a sequence with zero or more elements.
				 * 
				 *         
				 */
				extend(elements): Promise<any>
				extend$({ elements }): Promise<any>

				/**
				 * Insert *subelement* at position *index*.
				 */
				insert(index, subelement): Promise<any>
				insert$({ index, subelement }): Promise<any>

				/**
				 * Remove matching subelement.
				 * 
				 *         Unlike the find methods, this method compares elements based on
				 *         identity, NOT ON tag value or contents.  To remove subelements by
				 *         other means, the easiest way is to use a list comprehension to
				 *         select what elements to keep, and then use slice assignment to update
				 *         the parent element.
				 * 
				 *         ValueError is raised if a matching element could not be found.
				 * 
				 *         
				 */
				remove(subelement): Promise<any>
				remove$({ subelement }): Promise<any>

				/**
				 * Find first matching element by tag name or path.
				 * 
				 *         *path* is a string having either an element tag or an XPath,
				 *         *namespaces* is an optional mapping from namespace prefix to full name.
				 * 
				 *         Return the first matching element, or None if no element was found.
				 * 
				 *         
				 */
				find(path, namespaces?): Promise<any>
				find$({ path, namespaces }: { path, namespaces?}): Promise<any>

				/**
				 * Find text for first matching element by tag name or path.
				 * 
				 *         *path* is a string having either an element tag or an XPath,
				 *         *default* is the value to return if the element was not found,
				 *         *namespaces* is an optional mapping from namespace prefix to full name.
				 * 
				 *         Return text content of first matching element, or default value if
				 *         none was found.  Note that if an element is found having no text
				 *         content, the empty string is returned.
				 * 
				 *         
				 */
				findtext(path, def?, namespaces?): Promise<any>
				findtext$({ path, def, namespaces }: { path, def?, namespaces?}): Promise<any>

				/**
				 * Find all matching subelements by tag name or path.
				 * 
				 *         *path* is a string having either an element tag or an XPath,
				 *         *namespaces* is an optional mapping from namespace prefix to full name.
				 * 
				 *         Returns list containing all matching elements in document order.
				 * 
				 *         
				 */
				findall(path, namespaces?): Promise<any>
				findall$({ path, namespaces }: { path, namespaces?}): Promise<any>

				/**
				 * Find all matching subelements by tag name or path.
				 * 
				 *         *path* is a string having either an element tag or an XPath,
				 *         *namespaces* is an optional mapping from namespace prefix to full name.
				 * 
				 *         Return an iterable yielding all matching elements in document order.
				 * 
				 *         
				 */
				iterfind(path, namespaces?): Promise<any>
				iterfind$({ path, namespaces }: { path, namespaces?}): Promise<any>

				/**
				 * Reset element.
				 * 
				 *         This function removes all subelements, clears all attributes, and sets
				 *         the text and tail attributes to None.
				 * 
				 *         
				 */
				clear(): Promise<any>
				clear$($: {}): Promise<any>

				/**
				 * Get element attribute.
				 * 
				 *         Equivalent to attrib.get, but some implementations may handle this a
				 *         bit more efficiently.  *key* is what attribute to look for, and
				 *         *default* is what to return if the attribute was not found.
				 * 
				 *         Returns a string containing the attribute value, or the default if
				 *         attribute was not found.
				 * 
				 *         
				 */
				get(key, def?): Promise<any>
				get$({ key, def }: { key, def?}): Promise<any>

				/**
				 * Set element attribute.
				 * 
				 *         Equivalent to attrib[key] = value, but some implementations may handle
				 *         this a bit more efficiently.  *key* is what attribute to set, and
				 *         *value* is the attribute value to set it to.
				 * 
				 *         
				 */
				set(key, value): Promise<any>
				set$({ key, value }): Promise<any>

				/**
				 * Get list of attribute names.
				 * 
				 *         Names are returned in an arbitrary order, just like an ordinary
				 *         Python dict.  Equivalent to attrib.keys()
				 * 
				 *         
				 */
				keys(): Promise<any>
				keys$($: {}): Promise<any>

				/**
				 * Get element attributes as a sequence.
				 * 
				 *         The attributes are returned in arbitrary order.  Equivalent to
				 *         attrib.items().
				 * 
				 *         Return a list of (name, value) tuples.
				 * 
				 *         
				 */
				items(): Promise<any>
				items$($: {}): Promise<any>

				/**
				 * Create tree iterator.
				 * 
				 *         The iterator loops over the element and all subelements in document
				 *         order, returning all elements with a matching tag.
				 * 
				 *         If the tree structure is modified during iteration, new or removed
				 *         elements may or may not be included.  To get a stable set, use the
				 *         list() function on the iterator, and loop over the resulting list.
				 * 
				 *         *tag* is what tags to look for (default is to return all elements)
				 * 
				 *         Return an iterator containing all the matching elements.
				 * 
				 *         
				 */
				iter(tag?): Promise<any>
				iter$({ tag }: { tag?}): Promise<any>

				/**
				 * Create text iterator.
				 * 
				 *         The iterator loops over the element and all subelements in document
				 *         order, returning all inner text.
				 * 
				 *         
				 */
				itertext(): Promise<any>
				itertext$($: {}): Promise<any>
				tag
				attrib
				text
				tail
			}

			/**
			 * Qualified name wrapper.
			 * 
			 *     This class can be used to wrap a QName attribute value in order to get
			 *     proper namespace handing on output.
			 * 
			 *     *text_or_uri* is a string containing the QName value either in the form
			 *     {uri}local, or if the tag argument is given, the URI part of a QName.
			 * 
			 *     *tag* is an optional argument which if given, will make the first
			 *     argument (text_or_uri) be interpreted as a URI, and this argument (tag)
			 *     be interpreted as a local name.
			 * 
			 *     
			 */
			function QName(text_or_uri, tag?): Promise<IQName>
			function QName$({ text_or_uri, tag }: { text_or_uri, tag?}): Promise<IQName>
			interface IQName {
			}

			/**
			 * An XML element hierarchy.
			 * 
			 *     This class also provides support for serialization to and from
			 *     standard XML.
			 * 
			 *     *element* is an optional root element node,
			 *     *file* is an optional file handle or file name of an XML file whose
			 *     contents will be used to initialize the tree with.
			 * 
			 *     
			 */
			function ElementTree(element?, file?): Promise<IElementTree>
			function ElementTree$({ element, file }: { element?, file?}): Promise<IElementTree>
			interface IElementTree {

				/**
				 * Return root element of this tree.
				 */
				getroot(): Promise<any>
				getroot$($: {}): Promise<any>

				/**
				 * Load external XML document into element tree.
				 * 
				 *         *source* is a file name or file object, *parser* is an optional parser
				 *         instance that defaults to XMLParser.
				 * 
				 *         ParseError is raised if the parser fails to parse the document.
				 * 
				 *         Returns the root element of the given source document.
				 * 
				 *         
				 */
				parse(source, parser?): Promise<any>
				parse$({ source, parser }: { source, parser?}): Promise<any>

				/**
				 * Create and return tree iterator for the root element.
				 * 
				 *         The iterator loops over all elements in this tree, in document order.
				 * 
				 *         *tag* is a string with the tag name to iterate over
				 *         (default is to return all elements).
				 * 
				 *         
				 */
				iter(tag?): Promise<any>
				iter$({ tag }: { tag?}): Promise<any>

				/**
				 * Find first matching element by tag name or path.
				 * 
				 *         Same as getroot().find(path), which is Element.find()
				 * 
				 *         *path* is a string having either an element tag or an XPath,
				 *         *namespaces* is an optional mapping from namespace prefix to full name.
				 * 
				 *         Return the first matching element, or None if no element was found.
				 * 
				 *         
				 */
				find(path, namespaces?): Promise<any>
				find$({ path, namespaces }: { path, namespaces?}): Promise<any>

				/**
				 * Find first matching element by tag name or path.
				 * 
				 *         Same as getroot().findtext(path),  which is Element.findtext()
				 * 
				 *         *path* is a string having either an element tag or an XPath,
				 *         *namespaces* is an optional mapping from namespace prefix to full name.
				 * 
				 *         Return the first matching element, or None if no element was found.
				 * 
				 *         
				 */
				findtext(path, def?, namespaces?): Promise<any>
				findtext$({ path, def, namespaces }: { path, def?, namespaces?}): Promise<any>

				/**
				 * Find all matching subelements by tag name or path.
				 * 
				 *         Same as getroot().findall(path), which is Element.findall().
				 * 
				 *         *path* is a string having either an element tag or an XPath,
				 *         *namespaces* is an optional mapping from namespace prefix to full name.
				 * 
				 *         Return list containing all matching elements in document order.
				 * 
				 *         
				 */
				findall(path, namespaces?): Promise<any>
				findall$({ path, namespaces }: { path, namespaces?}): Promise<any>

				/**
				 * Find all matching subelements by tag name or path.
				 * 
				 *         Same as getroot().iterfind(path), which is element.iterfind()
				 * 
				 *         *path* is a string having either an element tag or an XPath,
				 *         *namespaces* is an optional mapping from namespace prefix to full name.
				 * 
				 *         Return an iterable yielding all matching elements in document order.
				 * 
				 *         
				 */
				iterfind(path, namespaces?): Promise<any>
				iterfind$({ path, namespaces }: { path, namespaces?}): Promise<any>

				/**
				 * Write element tree to a file as XML.
				 * 
				 *         Arguments:
				 *           *file_or_filename* -- file name or a file object opened for writing
				 * 
				 *           *encoding* -- the output encoding (default: US-ASCII)
				 * 
				 *           *xml_declaration* -- bool indicating if an XML declaration should be
				 *                                added to the output. If None, an XML declaration
				 *                                is added if encoding IS NOT either of:
				 *                                US-ASCII, UTF-8, or Unicode
				 * 
				 *           *default_namespace* -- sets the default XML namespace (for "xmlns")
				 * 
				 *           *method* -- either "xml" (default), "html, "text", or "c14n"
				 * 
				 *           *short_empty_elements* -- controls the formatting of elements
				 *                                     that contain no content. If True (default)
				 *                                     they are emitted as a single self-closed
				 *                                     tag, otherwise they are emitted as a pair
				 *                                     of start/end tags
				 * 
				 *         
				 */
				write(file_or_filename, encoding?, xml_declaration?, default_namespace?, method?): Promise<any>
				write$({ file_or_filename, encoding, xml_declaration, default_namespace, method }: { file_or_filename, encoding?, xml_declaration?, default_namespace?, method?}): Promise<any>
				write_c14n(file): Promise<any>
				write_c14n$({ file }): Promise<any>
			}

			/**
			 * An auxiliary stream accumulating into a list reference.
			 */
			interface I_ListDataStream {
				writable(): Promise<any>
				writable$($: {}): Promise<any>
				seekable(): Promise<any>
				seekable$($: {}): Promise<any>
				write(b): Promise<any>
				write$({ b }): Promise<any>
				tell(): Promise<any>
				tell$($: {}): Promise<any>
			}
			function XMLPullParser(events?): Promise<IXMLPullParser>
			function XMLPullParser$({ events }: { events?}): Promise<IXMLPullParser>
			interface IXMLPullParser {

				/**
				 * Feed encoded data to parser.
				 */
				feed(data): Promise<any>
				feed$({ data }): Promise<any>

				/**
				 * Finish feeding data to parser.
				 * 
				 *         Unlike XMLParser, does not return the root element. Use
				 *         read_events() to consume elements from XMLPullParser.
				 *         
				 */
				close(): Promise<any>
				close$($: {}): Promise<any>

				/**
				 * Return an iterator over currently available (event, elem) pairs.
				 * 
				 *         Events are consumed from the internal event queue as they are
				 *         retrieved from the iterator.
				 *         
				 */
				read_events(): Promise<any>
				read_events$($: {}): Promise<any>
			}

			/**
			 * Generic element structure builder.
			 * 
			 *     This builder converts a sequence of start, data, and end method
			 *     calls to a well-formed element structure.
			 * 
			 *     You can use this class to build an element structure using a custom XML
			 *     parser, or a parser for some other XML-like format.
			 * 
			 *     *element_factory* is an optional element factory which is called
			 *     to create new Element instances, as necessary.
			 * 
			 *     *comment_factory* is a factory to create comments to be used instead of
			 *     the standard factory.  If *insert_comments* is false (the default),
			 *     comments will not be inserted into the tree.
			 * 
			 *     *pi_factory* is a factory to create processing instructions to be used
			 *     instead of the standard factory.  If *insert_pis* is false (the default),
			 *     processing instructions will not be inserted into the tree.
			 *     
			 */
			function TreeBuilder(element_factory?): Promise<ITreeBuilder>
			function TreeBuilder$({ element_factory }: { element_factory?}): Promise<ITreeBuilder>
			interface ITreeBuilder {

				/**
				 * Flush builder buffers and return toplevel document Element.
				 */
				close(): Promise<any>
				close$($: {}): Promise<any>

				/**
				 * Add text to current element.
				 */
				data(data): Promise<any>
				data$({ data }): Promise<any>

				/**
				 * Open new element and return it.
				 * 
				 *         *tag* is the element name, *attrs* is a dict containing element
				 *         attributes.
				 * 
				 *         
				 */
				start(tag, attrs): Promise<any>
				start$({ tag, attrs }): Promise<any>

				/**
				 * Close and return current Element.
				 * 
				 *         *tag* is the element name.
				 * 
				 *         
				 */
				end(tag): Promise<any>
				end$({ tag }): Promise<any>

				/**
				 * Create a comment using the comment_factory.
				 * 
				 *         *text* is the text of the comment.
				 *         
				 */
				comment(text): Promise<any>
				comment$({ text }): Promise<any>

				/**
				 * Create a processing instruction using the pi_factory.
				 * 
				 *         *target* is the target name of the processing instruction.
				 *         *text* is the data of the processing instruction, or ''.
				 *         
				 */
				pi(target, text?): Promise<any>
				pi$({ target, text }: { target, text?}): Promise<any>
			}

			/**
			 * Element structure builder for XML source data based on the expat parser.
			 * 
			 *     *target* is an optional target object which defaults to an instance of the
			 *     standard TreeBuilder class, *encoding* is an optional encoding string
			 *     which if given, overrides the encoding specified in the XML file:
			 *     http://www.iana.org/assignments/character-sets
			 * 
			 *     
			 */
			function XMLParser(): Promise<IXMLParser>
			function XMLParser$({ }): Promise<IXMLParser>
			interface IXMLParser {

				/**
				 * Feed encoded data to parser.
				 */
				feed(data): Promise<any>
				feed$({ data }): Promise<any>

				/**
				 * Finish feeding data to parser and return element structure.
				 */
				close(): Promise<any>
				close$($: {}): Promise<any>
			}

			/**
			 * 
			 *     Canonicalization writer target for the XMLParser.
			 * 
			 *     Serialises parse events to XML C14N 2.0.
			 * 
			 *     The *write* function is used for writing out the resulting data stream
			 *     as text (not bytes).  To write to a file, open it in text mode with encoding
			 *     "utf-8" and pass its ``.write`` method.
			 * 
			 *     Configuration options:
			 * 
			 *     - *with_comments*: set to true to include comments
			 *     - *strip_text*: set to true to strip whitespace before and after text content
			 *     - *rewrite_prefixes*: set to true to replace namespace prefixes by "n{number}"
			 *     - *qname_aware_tags*: a set of qname aware tag names in which prefixes
			 *                           should be replaced in text content
			 *     - *qname_aware_attrs*: a set of qname aware attribute names in which prefixes
			 *                            should be replaced in text content
			 *     - *exclude_attrs*: a set of attribute names that should not be serialised
			 *     - *exclude_tags*: a set of tag names that should not be serialised
			 *     
			 */
			function C14NWriterTarget(write): Promise<IC14NWriterTarget>
			function C14NWriterTarget$({ write }): Promise<IC14NWriterTarget>
			interface IC14NWriterTarget {
				data(data): Promise<any>
				data$({ data }): Promise<any>
				start_ns(prefix, uri): Promise<any>
				start_ns$({ prefix, uri }): Promise<any>
				start(tag, attrs): Promise<any>
				start$({ tag, attrs }): Promise<any>
				end(tag): Promise<any>
				end$({ tag }): Promise<any>
				comment(text): Promise<any>
				comment$({ text }): Promise<any>
				pi(target, data): Promise<any>
				pi$({ target, data }): Promise<any>
			}
			let VERSION: Promise<any>
			let PI: Promise<any>
			let HTML_EMPTY: Promise<any>
			let fromstring: Promise<any>
		}
		var _
		module cElementTree {
			var _
		}
	}
	module parsers {
		var _
		module expat {
			var _
		}
	}
	module sax {
		var _
		function parse(source, handler, errorHandler?): Promise<any>
		function parse$({ source, handler, errorHandler }: { source, handler, errorHandler?}): Promise<any>
		function parseString(string, handler, errorHandler?): Promise<any>
		function parseString$({ string, handler, errorHandler }: { string, handler, errorHandler?}): Promise<any>

		/**
		 * Creates and returns a SAX parser.
		 * 
		 *     Creates the first parser it is able to instantiate of the ones
		 *     given in the iterable created by chaining parser_list and
		 *     default_parser_list.  The iterables must contain the names of Python
		 *     modules containing both a SAX parser and a create_parser function.
		 */
		function make_parser(parser_list?): Promise<any>
		function make_parser$({ parser_list }: { parser_list?}): Promise<any>
		let default_parser_list: Promise<any>
		module _exceptions {
			var _

			/**
			 * Encapsulate an XML error or warning. This class can contain
			 *     basic error or warning information from either the XML parser or
			 *     the application: you can subclass it to provide additional
			 *     functionality, or to add localization. Note that although you will
			 *     receive a SAXException as the argument to the handlers in the
			 *     ErrorHandler interface, you are not actually required to raise
			 *     the exception; instead, you can simply read the information in
			 *     it.
			 */

			/**
			 * Creates an exception. The message is required, but the exception
			 *         is optional.
			 */
			function SAXException(msg, exception?): Promise<ISAXException>
			function SAXException$({ msg, exception }: { msg, exception?}): Promise<ISAXException>
			interface ISAXException {

				/**
				 * Return a message for this exception.
				 */
				getMessage(): Promise<any>
				getMessage$($: {}): Promise<any>

				/**
				 * Return the embedded exception, or None if there was none.
				 */
				getException(): Promise<any>
				getException$($: {}): Promise<any>
			}

			/**
			 * Encapsulate an XML parse error or warning.
			 * 
			 *     This exception will include information for locating the error in
			 *     the original XML document. Note that although the application will
			 *     receive a SAXParseException as the argument to the handlers in the
			 *     ErrorHandler interface, the application is not actually required
			 *     to raise the exception; instead, it can simply read the
			 *     information in it and take a different action.
			 * 
			 *     Since this exception is a subclass of SAXException, it inherits
			 *     the ability to wrap another exception.
			 */

			/**
			 * Creates the exception. The exception parameter is allowed to be None.
			 */
			function SAXParseException(msg, exception, locator): Promise<ISAXParseException>
			function SAXParseException$({ msg, exception, locator }): Promise<ISAXParseException>
			interface ISAXParseException extends ISAXException {

				/**
				 * The column number of the end of the text where the exception
				 *         occurred.
				 */
				getColumnNumber(): Promise<any>
				getColumnNumber$($: {}): Promise<any>

				/**
				 * The line number of the end of the text where the exception occurred.
				 */
				getLineNumber(): Promise<any>
				getLineNumber$($: {}): Promise<any>

				/**
				 * Get the public identifier of the entity where the exception occurred.
				 */
				getPublicId(): Promise<any>
				getPublicId$($: {}): Promise<any>

				/**
				 * Get the system identifier of the entity where the exception occurred.
				 */
				getSystemId(): Promise<any>
				getSystemId$($: {}): Promise<any>
			}

			/**
			 * Exception class for an unrecognized identifier.
			 * 
			 *     An XMLReader will raise this exception when it is confronted with an
			 *     unrecognized feature or property. SAX applications and extensions may
			 *     use this class for similar purposes.
			 */
			interface ISAXNotRecognizedException extends ISAXException {
			}

			/**
			 * Exception class for an unsupported operation.
			 * 
			 *     An XMLReader will raise this exception when a service it cannot
			 *     perform is requested (specifically setting a state or value). SAX
			 *     applications and extensions may use this class for similar
			 *     purposes.
			 */
			interface ISAXNotSupportedException extends ISAXException {
			}

			/**
			 * Exception class for a missing driver.
			 * 
			 *     An XMLReader module (driver) should raise this exception when it
			 *     is first imported, e.g. when a support module cannot be imported.
			 *     It also may be raised during parsing, e.g. if executing an external
			 *     program is not permitted.
			 */
			interface ISAXReaderNotAvailable extends ISAXNotSupportedException {
			}
		}
		module expatreader {
			var _
			function create_parser(): Promise<any>
			function create_parser$($: {}): Promise<any>
			interface I_ClosedParser {
			}

			/**
			 * Locator for use with the ExpatParser class.
			 * 
			 *     This uses a weak reference to the parser object to avoid creating
			 *     a circular reference between the parser and the content handler.
			 *     
			 */
			function ExpatLocator(parser): Promise<IExpatLocator>
			function ExpatLocator$({ parser }): Promise<IExpatLocator>
			interface IExpatLocator {
				getColumnNumber(): Promise<any>
				getColumnNumber$($: {}): Promise<any>
				getLineNumber(): Promise<any>
				getLineNumber$($: {}): Promise<any>
				getPublicId(): Promise<any>
				getPublicId$($: {}): Promise<any>
				getSystemId(): Promise<any>
				getSystemId$($: {}): Promise<any>
			}

			/**
			 * SAX driver for the pyexpat C module.
			 */
			function ExpatParser(namespaceHandling?, bufsize?): Promise<IExpatParser>
			function ExpatParser$({ namespaceHandling, bufsize }: { namespaceHandling?, bufsize?}): Promise<IExpatParser>
			interface IExpatParser {

				/**
				 * Parse an XML document from a URL or an InputSource.
				 */
				parse(source): Promise<any>
				parse$({ source }): Promise<any>
				prepareParser(source): Promise<any>
				prepareParser$({ source }): Promise<any>
				setContentHandler(handler): Promise<any>
				setContentHandler$({ handler }): Promise<any>
				getFeature(name): Promise<any>
				getFeature$({ name }): Promise<any>
				setFeature(name, state): Promise<any>
				setFeature$({ name, state }): Promise<any>
				getProperty(name): Promise<any>
				getProperty$({ name }): Promise<any>
				setProperty(name, value): Promise<any>
				setProperty$({ name, value }): Promise<any>
				feed(data, isFinal?: boolean): Promise<any>
				feed$({ data, isFinal }: { data, isFinal?}): Promise<any>
				close(): Promise<any>
				close$($: {}): Promise<any>
				reset(): Promise<any>
				reset$($: {}): Promise<any>
				getColumnNumber(): Promise<any>
				getColumnNumber$($: {}): Promise<any>
				getLineNumber(): Promise<any>
				getLineNumber$($: {}): Promise<any>
				getPublicId(): Promise<any>
				getPublicId$($: {}): Promise<any>
				getSystemId(): Promise<any>
				getSystemId$($: {}): Promise<any>
				start_element(name, attrs): Promise<any>
				start_element$({ name, attrs }): Promise<any>
				end_element(name): Promise<any>
				end_element$({ name }): Promise<any>
				start_element_ns(name, attrs): Promise<any>
				start_element_ns$({ name, attrs }): Promise<any>
				end_element_ns(name): Promise<any>
				end_element_ns$({ name }): Promise<any>
				processing_instruction(target, data): Promise<any>
				processing_instruction$({ target, data }): Promise<any>
				character_data(data): Promise<any>
				character_data$({ data }): Promise<any>
				start_namespace_decl(prefix, uri): Promise<any>
				start_namespace_decl$({ prefix, uri }): Promise<any>
				end_namespace_decl(prefix): Promise<any>
				end_namespace_decl$({ prefix }): Promise<any>
				start_doctype_decl(name, sysid, pubid, has_internal_subset): Promise<any>
				start_doctype_decl$({ name, sysid, pubid, has_internal_subset }): Promise<any>
				unparsed_entity_decl(name, base, sysid, pubid, notation_name): Promise<any>
				unparsed_entity_decl$({ name, base, sysid, pubid, notation_name }): Promise<any>
				notation_decl(name, base, sysid, pubid): Promise<any>
				notation_decl$({ name, base, sysid, pubid }): Promise<any>
				external_entity_ref(context, base, sysid, pubid): Promise<any>
				external_entity_ref$({ context, base, sysid, pubid }): Promise<any>
				skipped_entity_handler(name, is_pe): Promise<any>
				skipped_entity_handler$({ name, is_pe }): Promise<any>
			}
			let version: Promise<any>
			let AttributesImpl: Promise<any>
			let AttributesNSImpl: Promise<any>
			let p: Promise<any>
		}
		module handler {
			var _

			/**
			 * Basic interface for SAX error handlers.
			 * 
			 *     If you create an object that implements this interface, then
			 *     register the object with your XMLReader, the parser will call the
			 *     methods in your object to report all warnings and errors. There
			 *     are three levels of errors available: warnings, (possibly)
			 *     recoverable errors, and unrecoverable errors. All methods take a
			 *     SAXParseException as the only parameter.
			 */
			interface IErrorHandler {

				/**
				 * Handle a recoverable error.
				 */
				error(exception): Promise<any>
				error$({ exception }): Promise<any>

				/**
				 * Handle a non-recoverable error.
				 */
				fatalError(exception): Promise<any>
				fatalError$({ exception }): Promise<any>

				/**
				 * Handle a warning.
				 */
				warning(exception): Promise<any>
				warning$({ exception }): Promise<any>
			}

			/**
			 * Interface for receiving logical document content events.
			 * 
			 *     This is the main callback interface in SAX, and the one most
			 *     important to applications. The order of events in this interface
			 *     mirrors the order of the information in the document.
			 */
			function ContentHandler(): Promise<IContentHandler>
			function ContentHandler$({ }): Promise<IContentHandler>
			interface IContentHandler {

				/**
				 * Called by the parser to give the application a locator for
				 *         locating the origin of document events.
				 * 
				 *         SAX parsers are strongly encouraged (though not absolutely
				 *         required) to supply a locator: if it does so, it must supply
				 *         the locator to the application by invoking this method before
				 *         invoking any of the other methods in the DocumentHandler
				 *         interface.
				 * 
				 *         The locator allows the application to determine the end
				 *         position of any document-related event, even if the parser is
				 *         not reporting an error. Typically, the application will use
				 *         this information for reporting its own errors (such as
				 *         character content that does not match an application's
				 *         business rules). The information returned by the locator is
				 *         probably not sufficient for use with a search engine.
				 * 
				 *         Note that the locator will return correct information only
				 *         during the invocation of the events in this interface. The
				 *         application should not attempt to use it at any other time.
				 */
				setDocumentLocator(locator): Promise<any>
				setDocumentLocator$({ locator }): Promise<any>

				/**
				 * Receive notification of the beginning of a document.
				 * 
				 *         The SAX parser will invoke this method only once, before any
				 *         other methods in this interface or in DTDHandler (except for
				 *         setDocumentLocator).
				 */
				startDocument(): Promise<any>
				startDocument$($: {}): Promise<any>

				/**
				 * Receive notification of the end of a document.
				 * 
				 *         The SAX parser will invoke this method only once, and it will
				 *         be the last method invoked during the parse. The parser shall
				 *         not invoke this method until it has either abandoned parsing
				 *         (because of an unrecoverable error) or reached the end of
				 *         input.
				 */
				endDocument(): Promise<any>
				endDocument$($: {}): Promise<any>

				/**
				 * Begin the scope of a prefix-URI Namespace mapping.
				 * 
				 *         The information from this event is not necessary for normal
				 *         Namespace processing: the SAX XML reader will automatically
				 *         replace prefixes for element and attribute names when the
				 *         http://xml.org/sax/features/namespaces feature is true (the
				 *         default).
				 * 
				 *         There are cases, however, when applications need to use
				 *         prefixes in character data or in attribute values, where they
				 *         cannot safely be expanded automatically; the
				 *         start/endPrefixMapping event supplies the information to the
				 *         application to expand prefixes in those contexts itself, if
				 *         necessary.
				 * 
				 *         Note that start/endPrefixMapping events are not guaranteed to
				 *         be properly nested relative to each-other: all
				 *         startPrefixMapping events will occur before the corresponding
				 *         startElement event, and all endPrefixMapping events will occur
				 *         after the corresponding endElement event, but their order is
				 *         not guaranteed.
				 */
				startPrefixMapping(prefix, uri): Promise<any>
				startPrefixMapping$({ prefix, uri }): Promise<any>

				/**
				 * End the scope of a prefix-URI mapping.
				 * 
				 *         See startPrefixMapping for details. This event will always
				 *         occur after the corresponding endElement event, but the order
				 *         of endPrefixMapping events is not otherwise guaranteed.
				 */
				endPrefixMapping(prefix): Promise<any>
				endPrefixMapping$({ prefix }): Promise<any>

				/**
				 * Signals the start of an element in non-namespace mode.
				 * 
				 *         The name parameter contains the raw XML 1.0 name of the
				 *         element type as a string and the attrs parameter holds an
				 *         instance of the Attributes class containing the attributes of
				 *         the element.
				 */
				startElement(name, attrs): Promise<any>
				startElement$({ name, attrs }): Promise<any>

				/**
				 * Signals the end of an element in non-namespace mode.
				 * 
				 *         The name parameter contains the name of the element type, just
				 *         as with the startElement event.
				 */
				endElement(name): Promise<any>
				endElement$({ name }): Promise<any>

				/**
				 * Signals the start of an element in namespace mode.
				 * 
				 *         The name parameter contains the name of the element type as a
				 *         (uri, localname) tuple, the qname parameter the raw XML 1.0
				 *         name used in the source document, and the attrs parameter
				 *         holds an instance of the Attributes class containing the
				 *         attributes of the element.
				 * 
				 *         The uri part of the name tuple is None for elements which have
				 *         no namespace.
				 */
				startElementNS(name, qname, attrs): Promise<any>
				startElementNS$({ name, qname, attrs }): Promise<any>

				/**
				 * Signals the end of an element in namespace mode.
				 * 
				 *         The name parameter contains the name of the element type, just
				 *         as with the startElementNS event.
				 */
				endElementNS(name, qname): Promise<any>
				endElementNS$({ name, qname }): Promise<any>

				/**
				 * Receive notification of character data.
				 * 
				 *         The Parser will call this method to report each chunk of
				 *         character data. SAX parsers may return all contiguous
				 *         character data in a single chunk, or they may split it into
				 *         several chunks; however, all of the characters in any single
				 *         event must come from the same external entity so that the
				 *         Locator provides useful information.
				 */
				characters(content): Promise<any>
				characters$({ content }): Promise<any>

				/**
				 * Receive notification of ignorable whitespace in element content.
				 * 
				 *         Validating Parsers must use this method to report each chunk
				 *         of ignorable whitespace (see the W3C XML 1.0 recommendation,
				 *         section 2.10): non-validating parsers may also use this method
				 *         if they are capable of parsing and using content models.
				 * 
				 *         SAX parsers may return all contiguous whitespace in a single
				 *         chunk, or they may split it into several chunks; however, all
				 *         of the characters in any single event must come from the same
				 *         external entity, so that the Locator provides useful
				 *         information.
				 */
				ignorableWhitespace(whitespace): Promise<any>
				ignorableWhitespace$({ whitespace }): Promise<any>

				/**
				 * Receive notification of a processing instruction.
				 * 
				 *         The Parser will invoke this method once for each processing
				 *         instruction found: note that processing instructions may occur
				 *         before or after the main document element.
				 * 
				 *         A SAX parser should never report an XML declaration (XML 1.0,
				 *         section 2.8) or a text declaration (XML 1.0, section 4.3.1)
				 *         using this method.
				 */
				processingInstruction(target, data): Promise<any>
				processingInstruction$({ target, data }): Promise<any>

				/**
				 * Receive notification of a skipped entity.
				 * 
				 *         The Parser will invoke this method once for each entity
				 *         skipped. Non-validating processors may skip entities if they
				 *         have not seen the declarations (because, for example, the
				 *         entity was declared in an external DTD subset). All processors
				 *         may skip external entities, depending on the values of the
				 *         http://xml.org/sax/features/external-general-entities and the
				 *         http://xml.org/sax/features/external-parameter-entities
				 *         properties.
				 */
				skippedEntity(name): Promise<any>
				skippedEntity$({ name }): Promise<any>
			}

			/**
			 * Handle DTD events.
			 * 
			 *     This interface specifies only those DTD events required for basic
			 *     parsing (unparsed entities and attributes).
			 */
			interface IDTDHandler {

				/**
				 * Handle a notation declaration event.
				 */
				notationDecl(name, publicId, systemId): Promise<any>
				notationDecl$({ name, publicId, systemId }): Promise<any>

				/**
				 * Handle an unparsed entity declaration event.
				 */
				unparsedEntityDecl(name, publicId, systemId, ndata): Promise<any>
				unparsedEntityDecl$({ name, publicId, systemId, ndata }): Promise<any>
			}

			/**
			 * Basic interface for resolving entities. If you create an object
			 *     implementing this interface, then register the object with your
			 *     Parser, the parser will call the method in your object to
			 *     resolve all external entities. Note that DefaultHandler implements
			 *     this interface with the default behaviour.
			 */
			interface IEntityResolver {

				/**
				 * Resolve the system identifier of an entity and return either
				 *         the system identifier to read from as a string, or an InputSource
				 *         to read from.
				 */
				resolveEntity(publicId, systemId): Promise<any>
				resolveEntity$({ publicId, systemId }): Promise<any>
			}

			/**
			 * Optional SAX2 handler for lexical events.
			 * 
			 *     This handler is used to obtain lexical information about an XML
			 *     document, that is, information about how the document was encoded
			 *     (as opposed to what it contains, which is reported to the
			 *     ContentHandler), such as comments and CDATA marked section
			 *     boundaries.
			 * 
			 *     To set the LexicalHandler of an XMLReader, use the setProperty
			 *     method with the property identifier
			 *     'http://xml.org/sax/properties/lexical-handler'.
			 */
			interface ILexicalHandler {

				/**
				 * Reports a comment anywhere in the document (including the
				 *         DTD and outside the document element).
				 * 
				 *         content is a string that holds the contents of the comment.
				 */
				comment(content): Promise<any>
				comment$({ content }): Promise<any>

				/**
				 * Report the start of the DTD declarations, if the document
				 *         has an associated DTD.
				 * 
				 *         A startEntity event will be reported before declaration events
				 *         from the external DTD subset are reported, and this can be
				 *         used to infer from which subset DTD declarations derive.
				 * 
				 *         name is the name of the document element type, public_id the
				 *         public identifier of the DTD (or None if none were supplied)
				 *         and system_id the system identfier of the external subset (or
				 *         None if none were supplied).
				 */
				startDTD(name, public_id, system_id): Promise<any>
				startDTD$({ name, public_id, system_id }): Promise<any>

				/**
				 * Signals the end of DTD declarations.
				 */
				endDTD(): Promise<any>
				endDTD$($: {}): Promise<any>

				/**
				 * Reports the beginning of a CDATA marked section.
				 * 
				 *         The contents of the CDATA marked section will be reported
				 *         through the characters event.
				 */
				startCDATA(): Promise<any>
				startCDATA$($: {}): Promise<any>

				/**
				 * Reports the end of a CDATA marked section.
				 */
				endCDATA(): Promise<any>
				endCDATA$($: {}): Promise<any>
			}
			let version: Promise<any>
			let feature_namespaces: Promise<any>
			let feature_namespace_prefixes: Promise<any>
			let feature_string_interning: Promise<any>
			let feature_validation: Promise<any>
			let feature_external_ges: Promise<any>
			let feature_external_pes: Promise<any>
			let all_features: Promise<any>
			let property_lexical_handler: Promise<any>
			let property_declaration_handler: Promise<any>
			let property_dom_node: Promise<any>
			let property_xml_string: Promise<any>
			let property_encoding: Promise<any>
			let property_interning_dict: Promise<any>
			let all_properties: Promise<any>
		}
		module saxutils {
			var _

			/**
			 * Escape &, <, and > in a string of data.
			 * 
			 *     You can escape other strings of data by passing a dictionary as
			 *     the optional entities parameter.  The keys and values must all be
			 *     strings; each key will be replaced with its corresponding value.
			 *     
			 */
			function escape(data, entities?): Promise<any>
			function escape$({ data, entities }: { data, entities?}): Promise<any>

			/**
			 * Unescape &amp;, &lt;, and &gt; in a string of data.
			 * 
			 *     You can unescape other strings of data by passing a dictionary as
			 *     the optional entities parameter.  The keys and values must all be
			 *     strings; each key will be replaced with its corresponding value.
			 *     
			 */
			function unescape(data, entities?): Promise<any>
			function unescape$({ data, entities }: { data, entities?}): Promise<any>

			/**
			 * Escape and quote an attribute value.
			 * 
			 *     Escape &, <, and > in a string of data, then quote it for use as
			 *     an attribute value.  The " character will be escaped as well, if
			 *     necessary.
			 * 
			 *     You can escape other strings of data by passing a dictionary as
			 *     the optional entities parameter.  The keys and values must all be
			 *     strings; each key will be replaced with its corresponding value.
			 *     
			 */
			function quoteattr(data, entities?): Promise<any>
			function quoteattr$({ data, entities }: { data, entities?}): Promise<any>

			/**
			 * This function takes an InputSource and an optional base URL and
			 *     returns a fully resolved InputSource object ready for reading.
			 */
			function prepare_input_source(source, base?): Promise<any>
			function prepare_input_source$({ source, base }: { source, base?}): Promise<any>
			function XMLGenerator(out?, encoding?, short_empty_elements?: boolean): Promise<IXMLGenerator>
			function XMLGenerator$({ out, encoding, short_empty_elements }: { out?, encoding?, short_empty_elements?}): Promise<IXMLGenerator>
			interface IXMLGenerator {
				startDocument(): Promise<any>
				startDocument$($: {}): Promise<any>
				endDocument(): Promise<any>
				endDocument$($: {}): Promise<any>
				startPrefixMapping(prefix, uri): Promise<any>
				startPrefixMapping$({ prefix, uri }): Promise<any>
				endPrefixMapping(prefix): Promise<any>
				endPrefixMapping$({ prefix }): Promise<any>
				startElement(name, attrs): Promise<any>
				startElement$({ name, attrs }): Promise<any>
				endElement(name): Promise<any>
				endElement$({ name }): Promise<any>
				startElementNS(name, qname, attrs): Promise<any>
				startElementNS$({ name, qname, attrs }): Promise<any>
				endElementNS(name, qname): Promise<any>
				endElementNS$({ name, qname }): Promise<any>
				characters(content): Promise<any>
				characters$({ content }): Promise<any>
				ignorableWhitespace(content): Promise<any>
				ignorableWhitespace$({ content }): Promise<any>
				processingInstruction(target, data): Promise<any>
				processingInstruction$({ target, data }): Promise<any>
			}

			/**
			 * This class is designed to sit between an XMLReader and the
			 *     client application's event handlers.  By default, it does nothing
			 *     but pass requests up to the reader and events on to the handlers
			 *     unmodified, but subclasses can override specific methods to modify
			 *     the event stream or the configuration requests as they pass
			 *     through.
			 */
			function XMLFilterBase(parent?): Promise<IXMLFilterBase>
			function XMLFilterBase$({ parent }: { parent?}): Promise<IXMLFilterBase>
			interface IXMLFilterBase {
				error(exception): Promise<any>
				error$({ exception }): Promise<any>
				fatalError(exception): Promise<any>
				fatalError$({ exception }): Promise<any>
				warning(exception): Promise<any>
				warning$({ exception }): Promise<any>
				setDocumentLocator(locator): Promise<any>
				setDocumentLocator$({ locator }): Promise<any>
				startDocument(): Promise<any>
				startDocument$($: {}): Promise<any>
				endDocument(): Promise<any>
				endDocument$($: {}): Promise<any>
				startPrefixMapping(prefix, uri): Promise<any>
				startPrefixMapping$({ prefix, uri }): Promise<any>
				endPrefixMapping(prefix): Promise<any>
				endPrefixMapping$({ prefix }): Promise<any>
				startElement(name, attrs): Promise<any>
				startElement$({ name, attrs }): Promise<any>
				endElement(name): Promise<any>
				endElement$({ name }): Promise<any>
				startElementNS(name, qname, attrs): Promise<any>
				startElementNS$({ name, qname, attrs }): Promise<any>
				endElementNS(name, qname): Promise<any>
				endElementNS$({ name, qname }): Promise<any>
				characters(content): Promise<any>
				characters$({ content }): Promise<any>
				ignorableWhitespace(chars): Promise<any>
				ignorableWhitespace$({ chars }): Promise<any>
				processingInstruction(target, data): Promise<any>
				processingInstruction$({ target, data }): Promise<any>
				skippedEntity(name): Promise<any>
				skippedEntity$({ name }): Promise<any>
				notationDecl(name, publicId, systemId): Promise<any>
				notationDecl$({ name, publicId, systemId }): Promise<any>
				unparsedEntityDecl(name, publicId, systemId, ndata): Promise<any>
				unparsedEntityDecl$({ name, publicId, systemId, ndata }): Promise<any>
				resolveEntity(publicId, systemId): Promise<any>
				resolveEntity$({ publicId, systemId }): Promise<any>
				parse(source): Promise<any>
				parse$({ source }): Promise<any>
				setLocale(locale): Promise<any>
				setLocale$({ locale }): Promise<any>
				getFeature(name): Promise<any>
				getFeature$({ name }): Promise<any>
				setFeature(name, state): Promise<any>
				setFeature$({ name, state }): Promise<any>
				getProperty(name): Promise<any>
				getProperty$({ name }): Promise<any>
				setProperty(name, value): Promise<any>
				setProperty$({ name, value }): Promise<any>
				getParent(): Promise<any>
				getParent$($: {}): Promise<any>
				setParent(parent): Promise<any>
				setParent$({ parent }): Promise<any>
			}
		}
		module xmlreader {
			var _

			/**
			 * Interface for reading an XML document using callbacks.
			 * 
			 *     XMLReader is the interface that an XML parser's SAX2 driver must
			 *     implement. This interface allows an application to set and query
			 *     features and properties in the parser, to register event handlers
			 *     for document processing, and to initiate a document parse.
			 * 
			 *     All SAX interfaces are assumed to be synchronous: the parse
			 *     methods must not return until parsing is complete, and readers
			 *     must wait for an event-handler callback to return before reporting
			 *     the next event.
			 */
			function XMLReader(): Promise<IXMLReader>
			function XMLReader$({ }): Promise<IXMLReader>
			interface IXMLReader {

				/**
				 * Parse an XML document from a system identifier or an InputSource.
				 */
				parse(source): Promise<any>
				parse$({ source }): Promise<any>

				/**
				 * Returns the current ContentHandler.
				 */
				getContentHandler(): Promise<any>
				getContentHandler$($: {}): Promise<any>

				/**
				 * Registers a new object to receive document content events.
				 */
				setContentHandler(handler): Promise<any>
				setContentHandler$({ handler }): Promise<any>

				/**
				 * Returns the current DTD handler.
				 */
				getDTDHandler(): Promise<any>
				getDTDHandler$($: {}): Promise<any>

				/**
				 * Register an object to receive basic DTD-related events.
				 */
				setDTDHandler(handler): Promise<any>
				setDTDHandler$({ handler }): Promise<any>

				/**
				 * Returns the current EntityResolver.
				 */
				getEntityResolver(): Promise<any>
				getEntityResolver$($: {}): Promise<any>

				/**
				 * Register an object to resolve external entities.
				 */
				setEntityResolver(resolver): Promise<any>
				setEntityResolver$({ resolver }): Promise<any>

				/**
				 * Returns the current ErrorHandler.
				 */
				getErrorHandler(): Promise<any>
				getErrorHandler$($: {}): Promise<any>

				/**
				 * Register an object to receive error-message events.
				 */
				setErrorHandler(handler): Promise<any>
				setErrorHandler$({ handler }): Promise<any>

				/**
				 * Allow an application to set the locale for errors and warnings.
				 * 
				 *         SAX parsers are not required to provide localization for errors
				 *         and warnings; if they cannot support the requested locale,
				 *         however, they must raise a SAX exception. Applications may
				 *         request a locale change in the middle of a parse.
				 */
				setLocale(locale): Promise<any>
				setLocale$({ locale }): Promise<any>

				/**
				 * Looks up and returns the state of a SAX2 feature.
				 */
				getFeature(name): Promise<any>
				getFeature$({ name }): Promise<any>

				/**
				 * Sets the state of a SAX2 feature.
				 */
				setFeature(name, state): Promise<any>
				setFeature$({ name, state }): Promise<any>

				/**
				 * Looks up and returns the value of a SAX2 property.
				 */
				getProperty(name): Promise<any>
				getProperty$({ name }): Promise<any>

				/**
				 * Sets the value of a SAX2 property.
				 */
				setProperty(name, value): Promise<any>
				setProperty$({ name, value }): Promise<any>
			}

			/**
			 * This interface adds three extra methods to the XMLReader
			 *     interface that allow XML parsers to support incremental
			 *     parsing. Support for this interface is optional, since not all
			 *     underlying XML parsers support this functionality.
			 * 
			 *     When the parser is instantiated it is ready to begin accepting
			 *     data from the feed method immediately. After parsing has been
			 *     finished with a call to close the reset method must be called to
			 *     make the parser ready to accept new data, either from feed or
			 *     using the parse method.
			 * 
			 *     Note that these methods must _not_ be called during parsing, that
			 *     is, after parse has been called and before it returns.
			 * 
			 *     By default, the class also implements the parse method of the XMLReader
			 *     interface using the feed, close and reset methods of the
			 *     IncrementalParser interface as a convenience to SAX 2.0 driver
			 *     writers.
			 */
			function IncrementalParser(bufsize?): Promise<IIncrementalParser>
			function IncrementalParser$({ bufsize }: { bufsize?}): Promise<IIncrementalParser>
			interface IIncrementalParser extends IXMLReader {
				parse(source): Promise<any>
				parse$({ source }): Promise<any>

				/**
				 * This method gives the raw XML data in the data parameter to
				 *         the parser and makes it parse the data, emitting the
				 *         corresponding events. It is allowed for XML constructs to be
				 *         split across several calls to feed.
				 * 
				 *         feed may raise SAXException.
				 */
				feed(data): Promise<any>
				feed$({ data }): Promise<any>

				/**
				 * This method is called by the parse implementation to allow
				 *         the SAX 2.0 driver to prepare itself for parsing.
				 */
				prepareParser(source): Promise<any>
				prepareParser$({ source }): Promise<any>

				/**
				 * This method is called when the entire XML document has been
				 *         passed to the parser through the feed method, to notify the
				 *         parser that there are no more data. This allows the parser to
				 *         do the final checks on the document and empty the internal
				 *         data buffer.
				 * 
				 *         The parser will not be ready to parse another document until
				 *         the reset method has been called.
				 * 
				 *         close may raise SAXException.
				 */
				close(): Promise<any>
				close$($: {}): Promise<any>

				/**
				 * This method is called after close has been called to reset
				 *         the parser so that it is ready to parse new documents. The
				 *         results of calling parse or feed after close without calling
				 *         reset are undefined.
				 */
				reset(): Promise<any>
				reset$($: {}): Promise<any>
			}

			/**
			 * Interface for associating a SAX event with a document
			 *     location. A locator object will return valid results only during
			 *     calls to DocumentHandler methods; at any other time, the
			 *     results are unpredictable.
			 */
			interface ILocator {

				/**
				 * Return the column number where the current event ends.
				 */
				getColumnNumber(): Promise<any>
				getColumnNumber$($: {}): Promise<any>

				/**
				 * Return the line number where the current event ends.
				 */
				getLineNumber(): Promise<any>
				getLineNumber$($: {}): Promise<any>

				/**
				 * Return the public identifier for the current event.
				 */
				getPublicId(): Promise<any>
				getPublicId$($: {}): Promise<any>

				/**
				 * Return the system identifier for the current event.
				 */
				getSystemId(): Promise<any>
				getSystemId$($: {}): Promise<any>
			}

			/**
			 * Encapsulation of the information needed by the XMLReader to
			 *     read entities.
			 * 
			 *     This class may include information about the public identifier,
			 *     system identifier, byte stream (possibly with character encoding
			 *     information) and/or the character stream of an entity.
			 * 
			 *     Applications will create objects of this class for use in the
			 *     XMLReader.parse method and for returning from
			 *     EntityResolver.resolveEntity.
			 * 
			 *     An InputSource belongs to the application, the XMLReader is not
			 *     allowed to modify InputSource objects passed to it from the
			 *     application, although it may make copies and modify those.
			 */
			function InputSource(system_id?): Promise<IInputSource>
			function InputSource$({ system_id }: { system_id?}): Promise<IInputSource>
			interface IInputSource {

				/**
				 * Sets the public identifier of this InputSource.
				 */
				setPublicId(public_id): Promise<any>
				setPublicId$({ public_id }): Promise<any>

				/**
				 * Returns the public identifier of this InputSource.
				 */
				getPublicId(): Promise<any>
				getPublicId$($: {}): Promise<any>

				/**
				 * Sets the system identifier of this InputSource.
				 */
				setSystemId(system_id): Promise<any>
				setSystemId$({ system_id }): Promise<any>

				/**
				 * Returns the system identifier of this InputSource.
				 */
				getSystemId(): Promise<any>
				getSystemId$($: {}): Promise<any>

				/**
				 * Sets the character encoding of this InputSource.
				 * 
				 *         The encoding must be a string acceptable for an XML encoding
				 *         declaration (see section 4.3.3 of the XML recommendation).
				 * 
				 *         The encoding attribute of the InputSource is ignored if the
				 *         InputSource also contains a character stream.
				 */
				setEncoding(encoding): Promise<any>
				setEncoding$({ encoding }): Promise<any>

				/**
				 * Get the character encoding of this InputSource.
				 */
				getEncoding(): Promise<any>
				getEncoding$($: {}): Promise<any>

				/**
				 * Set the byte stream (a Python file-like object which does
				 *         not perform byte-to-character conversion) for this input
				 *         source.
				 * 
				 *         The SAX parser will ignore this if there is also a character
				 *         stream specified, but it will use a byte stream in preference
				 *         to opening a URI connection itself.
				 * 
				 *         If the application knows the character encoding of the byte
				 *         stream, it should set it with the setEncoding method.
				 */
				setByteStream(bytefile): Promise<any>
				setByteStream$({ bytefile }): Promise<any>

				/**
				 * Get the byte stream for this input source.
				 * 
				 *         The getEncoding method will return the character encoding for
				 *         this byte stream, or None if unknown.
				 */
				getByteStream(): Promise<any>
				getByteStream$($: {}): Promise<any>

				/**
				 * Set the character stream for this input source. (The stream
				 *         must be a Python 2.0 Unicode-wrapped file-like that performs
				 *         conversion to Unicode strings.)
				 * 
				 *         If there is a character stream specified, the SAX parser will
				 *         ignore any byte stream and will not attempt to open a URI
				 *         connection to the system identifier.
				 */
				setCharacterStream(charfile): Promise<any>
				setCharacterStream$({ charfile }): Promise<any>

				/**
				 * Get the character stream for this input source.
				 */
				getCharacterStream(): Promise<any>
				getCharacterStream$($: {}): Promise<any>
			}

			/**
			 * Non-NS-aware implementation.
			 * 
			 *         attrs should be of the form {name : value}.
			 */
			function AttributesImpl(attrs): Promise<IAttributesImpl>
			function AttributesImpl$({ attrs }): Promise<IAttributesImpl>
			interface IAttributesImpl {
				getLength(): Promise<any>
				getLength$($: {}): Promise<any>
				getType(name): Promise<any>
				getType$({ name }): Promise<any>
				getValue(name): Promise<any>
				getValue$({ name }): Promise<any>
				getValueByQName(name): Promise<any>
				getValueByQName$({ name }): Promise<any>
				getNameByQName(name): Promise<any>
				getNameByQName$({ name }): Promise<any>
				getQNameByName(name): Promise<any>
				getQNameByName$({ name }): Promise<any>
				getNames(): Promise<any>
				getNames$($: {}): Promise<any>
				getQNames(): Promise<any>
				getQNames$($: {}): Promise<any>
				keys(): Promise<any>
				keys$($: {}): Promise<any>
				get(name, alternative?): Promise<any>
				get$({ name, alternative }: { name, alternative?}): Promise<any>
				copy(): Promise<any>
				copy$($: {}): Promise<any>
				items(): Promise<any>
				items$($: {}): Promise<any>
				values(): Promise<any>
				values$($: {}): Promise<any>
			}

			/**
			 * NS-aware implementation.
			 * 
			 *         attrs should be of the form {(ns_uri, lname): value, ...}.
			 *         qnames of the form {(ns_uri, lname): qname, ...}.
			 */
			function AttributesNSImpl(attrs, qnames): Promise<IAttributesNSImpl>
			function AttributesNSImpl$({ attrs, qnames }): Promise<IAttributesNSImpl>
			interface IAttributesNSImpl extends IAttributesImpl {
				getValueByQName(name): Promise<any>
				getValueByQName$({ name }): Promise<any>
				getNameByQName(name): Promise<any>
				getNameByQName$({ name }): Promise<any>
				getQNameByName(name): Promise<any>
				getQNameByName$({ name }): Promise<any>
				getQNames(): Promise<any>
				getQNames$($: {}): Promise<any>
				copy(): Promise<any>
				copy$($: {}): Promise<any>
			}
		}
	}
}
declare module xmlrpc {
	var _
	module client {
		var _
		function escape(s): Promise<any>
		function escape$({ s }): Promise<any>

		/**
		 * getparser() -> parser, unmarshaller
		 * 
		 *     Create an instance of the fastest available parser, and attach it
		 *     to an unmarshalling object.  Return both objects.
		 *     
		 */
		function getparser(use_datetime?: boolean, use_builtin_types?: boolean): Promise<any>
		function getparser$({ use_datetime, use_builtin_types }: { use_datetime?, use_builtin_types?}): Promise<any>

		/**
		 * data [,options] -> marshalled data
		 * 
		 *     Convert an argument tuple or a Fault instance to an XML-RPC
		 *     request (or response, if the methodresponse option is used).
		 * 
		 *     In addition to the data object, the following options can be given
		 *     as keyword arguments:
		 * 
		 *         methodname: the method name for a methodCall packet
		 * 
		 *         methodresponse: true to create a methodResponse packet.
		 *         If this option is used with a tuple, the tuple must be
		 *         a singleton (i.e. it can contain only one element).
		 * 
		 *         encoding: the packet encoding (default is UTF-8)
		 * 
		 *     All byte strings in the data structure are assumed to use the
		 *     packet encoding.  Unicode strings are automatically converted,
		 *     where necessary.
		 *     
		 */
		function dumps(params, methodname?, methodresponse?, encoding?, allow_none?: boolean): Promise<any>
		function dumps$({ params, methodname, methodresponse, encoding, allow_none }: { params, methodname?, methodresponse?, encoding?, allow_none?}): Promise<any>

		/**
		 * data -> unmarshalled data, method name
		 * 
		 *     Convert an XML-RPC packet to unmarshalled data plus a method
		 *     name (None if not present).
		 * 
		 *     If the XML-RPC packet represents a fault condition, this function
		 *     raises a Fault exception.
		 *     
		 */
		function loads(data, use_datetime?: boolean, use_builtin_types?: boolean): Promise<any>
		function loads$({ data, use_datetime, use_builtin_types }: { data, use_datetime?, use_builtin_types?}): Promise<any>

		/**
		 * data -> gzip encoded data
		 * 
		 *     Encode data using the gzip content encoding as described in RFC 1952
		 *     
		 */
		function gzip_encode(data): Promise<any>
		function gzip_encode$({ data }): Promise<any>

		/**
		 * gzip encoded data -> unencoded data
		 * 
		 *     Decode data using the gzip content encoding as described in RFC 1952
		 *     
		 */
		function gzip_decode(data, max_decode?): Promise<any>
		function gzip_decode$({ data, max_decode }: { data, max_decode?}): Promise<any>

		/**
		 * Base class for client errors.
		 */
		interface IError {
		}

		/**
		 * Indicates an HTTP protocol error.
		 */
		function ProtocolError(url, errcode, errmsg, headers): Promise<IProtocolError>
		function ProtocolError$({ url, errcode, errmsg, headers }): Promise<IProtocolError>
		interface IProtocolError extends IError {
		}

		/**
		 * Indicates a broken response package.
		 */
		interface IResponseError extends IError {
		}

		/**
		 * Indicates an XML-RPC fault package.
		 */
		function Fault(faultCode, faultString): Promise<IFault>
		function Fault$({ faultCode, faultString }): Promise<IFault>
		interface IFault extends IError {
		}

		/**
		 * DateTime wrapper for an ISO 8601 string or time tuple or
		 *     localtime integer value to generate 'dateTime.iso8601' XML-RPC
		 *     value.
		 *     
		 */
		function DateTime(value?): Promise<IDateTime>
		function DateTime$({ value }: { value?}): Promise<IDateTime>
		interface IDateTime {
			make_comparable(other): Promise<any>
			make_comparable$({ other }): Promise<any>
			timetuple(): Promise<any>
			timetuple$($: {}): Promise<any>
			decode(data): Promise<any>
			decode$({ data }): Promise<any>
			encode(out): Promise<any>
			encode$({ out }): Promise<any>
		}

		/**
		 * Wrapper for binary data.
		 */
		function Binary(data?): Promise<IBinary>
		function Binary$({ data }: { data?}): Promise<IBinary>
		interface IBinary {
			decode(data): Promise<any>
			decode$({ data }): Promise<any>
			encode(out): Promise<any>
			encode$({ out }): Promise<any>
		}
		function ExpatParser(target): Promise<IExpatParser>
		function ExpatParser$({ target }): Promise<IExpatParser>
		interface IExpatParser {
			feed(data): Promise<any>
			feed$({ data }): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
		}

		/**
		 * Generate an XML-RPC params chunk from a Python data structure.
		 * 
		 *     Create a Marshaller instance for each set of parameters, and use
		 *     the "dumps" method to convert your data (represented as a tuple)
		 *     to an XML-RPC params chunk.  To write a fault response, pass a
		 *     Fault instance instead.  You may prefer to use the "dumps" module
		 *     function for this purpose.
		 *     
		 */
		function Marshaller(encoding?, allow_none?: boolean): Promise<IMarshaller>
		function Marshaller$({ encoding, allow_none }: { encoding?, allow_none?}): Promise<IMarshaller>
		interface IMarshaller {
			dumps(values): Promise<any>
			dumps$({ values }): Promise<any>
			dump_nil(value, write): Promise<any>
			dump_nil$({ value, write }): Promise<any>
			dump_bool(value, write): Promise<any>
			dump_bool$({ value, write }): Promise<any>
			dump_long(value, write): Promise<any>
			dump_long$({ value, write }): Promise<any>
			dump_double(value, write): Promise<any>
			dump_double$({ value, write }): Promise<any>
			dump_unicode(value, write, escape?): Promise<any>
			dump_unicode$({ value, write, escape }: { value, write, escape?}): Promise<any>
			dump_bytes(value, write): Promise<any>
			dump_bytes$({ value, write }): Promise<any>
			dump_array(value, write): Promise<any>
			dump_array$({ value, write }): Promise<any>
			dump_struct(value, write, escape?): Promise<any>
			dump_struct$({ value, write, escape }: { value, write, escape?}): Promise<any>
			dump_datetime(value, write): Promise<any>
			dump_datetime$({ value, write }): Promise<any>
			dump_instance(value, write): Promise<any>
			dump_instance$({ value, write }): Promise<any>
			dispatch
			dump_int
		}

		/**
		 * Unmarshal an XML-RPC response, based on incoming XML event
		 *     messages (start, data, end).  Call close() to get the resulting
		 *     data structure.
		 * 
		 *     Note that this reader is fairly tolerant, and gladly accepts bogus
		 *     XML-RPC data without complaining (but not bogus XML).
		 *     
		 */
		function Unmarshaller(use_datetime?: boolean, use_builtin_types?: boolean): Promise<IUnmarshaller>
		function Unmarshaller$({ use_datetime, use_builtin_types }: { use_datetime?, use_builtin_types?}): Promise<IUnmarshaller>
		interface IUnmarshaller {
			close(): Promise<any>
			close$($: {}): Promise<any>
			getmethodname(): Promise<any>
			getmethodname$($: {}): Promise<any>
			xml(encoding, standalone): Promise<any>
			xml$({ encoding, standalone }): Promise<any>
			start(tag, attrs): Promise<any>
			start$({ tag, attrs }): Promise<any>
			data(text): Promise<any>
			data$({ text }): Promise<any>
			end(tag): Promise<any>
			end$({ tag }): Promise<any>
			end_dispatch(tag, data): Promise<any>
			end_dispatch$({ tag, data }): Promise<any>
			end_nil(data): Promise<any>
			end_nil$({ data }): Promise<any>
			end_boolean(data): Promise<any>
			end_boolean$({ data }): Promise<any>
			end_int(data): Promise<any>
			end_int$({ data }): Promise<any>
			end_double(data): Promise<any>
			end_double$({ data }): Promise<any>
			end_bigdecimal(data): Promise<any>
			end_bigdecimal$({ data }): Promise<any>
			end_string(data): Promise<any>
			end_string$({ data }): Promise<any>
			end_array(data): Promise<any>
			end_array$({ data }): Promise<any>
			end_struct(data): Promise<any>
			end_struct$({ data }): Promise<any>
			end_base64(data): Promise<any>
			end_base64$({ data }): Promise<any>
			end_dateTime(data): Promise<any>
			end_dateTime$({ data }): Promise<any>
			end_value(data): Promise<any>
			end_value$({ data }): Promise<any>
			end_params(data): Promise<any>
			end_params$({ data }): Promise<any>
			end_fault(data): Promise<any>
			end_fault$({ data }): Promise<any>
			end_methodName(data): Promise<any>
			end_methodName$({ data }): Promise<any>
		}
		interface I_MultiCallMethod {
		}

		/**
		 * Iterates over the results of a multicall. Exceptions are
		 *     raised in response to xmlrpc faults.
		 */
		function MultiCallIterator(results): Promise<IMultiCallIterator>
		function MultiCallIterator$({ results }): Promise<IMultiCallIterator>
		interface IMultiCallIterator {
		}

		/**
		 * server -> an object used to boxcar method calls
		 * 
		 *     server should be a ServerProxy object.
		 * 
		 *     Methods can be added to the MultiCall using normal
		 *     method call syntax e.g.:
		 * 
		 *     multicall = MultiCall(server_proxy)
		 *     multicall.add(2,3)
		 *     multicall.get_address("Guido")
		 * 
		 *     To execute the multicall, call the MultiCall object e.g.:
		 * 
		 *     add_result, address = multicall()
		 *     
		 */
		function MultiCall(server): Promise<IMultiCall>
		function MultiCall$({ server }): Promise<IMultiCall>
		interface IMultiCall {
		}

		/**
		 * a file-like object to decode a response encoded with the gzip
		 *     method, as described in RFC 1952.
		 *     
		 */
		function GzipDecodedResponse(response): Promise<IGzipDecodedResponse>
		function GzipDecodedResponse$({ response }): Promise<IGzipDecodedResponse>
		interface IGzipDecodedResponse {
			close(): Promise<any>
			close$($: {}): Promise<any>
		}
		interface I_Method {
		}

		/**
		 * Handles an HTTP transaction to an XML-RPC server.
		 */
		function Transport(use_datetime?: boolean, use_builtin_types?: boolean): Promise<ITransport>
		function Transport$({ use_datetime, use_builtin_types }: { use_datetime?, use_builtin_types?}): Promise<ITransport>
		interface ITransport {
			request(host, handler, request_body, verbose?: boolean): Promise<any>
			request$({ host, handler, request_body, verbose }: { host, handler, request_body, verbose?}): Promise<any>
			single_request(host, handler, request_body, verbose?: boolean): Promise<any>
			single_request$({ host, handler, request_body, verbose }: { host, handler, request_body, verbose?}): Promise<any>
			getparser(): Promise<any>
			getparser$($: {}): Promise<any>
			get_host_info(host): Promise<any>
			get_host_info$({ host }): Promise<any>
			make_connection(host): Promise<any>
			make_connection$({ host }): Promise<any>
			close(): Promise<any>
			close$($: {}): Promise<any>
			send_request(host, handler, request_body, debug): Promise<any>
			send_request$({ host, handler, request_body, debug }): Promise<any>
			send_headers(connection, headers): Promise<any>
			send_headers$({ connection, headers }): Promise<any>
			send_content(connection, request_body): Promise<any>
			send_content$({ connection, request_body }): Promise<any>
			parse_response(response): Promise<any>
			parse_response$({ response }): Promise<any>
			user_agent
			accept_gzip_encoding
			encode_threshold
		}

		/**
		 * Handles an HTTPS transaction to an XML-RPC server.
		 */
		function SafeTransport(use_datetime?: boolean, use_builtin_types?: boolean): Promise<ISafeTransport>
		function SafeTransport$({ use_datetime, use_builtin_types }: { use_datetime?, use_builtin_types?}): Promise<ISafeTransport>
		interface ISafeTransport extends ITransport {
			make_connection(host): Promise<any>
			make_connection$({ host }): Promise<any>
		}

		/**
		 * uri [,options] -> a logical connection to an XML-RPC server
		 * 
		 *     uri is the connection point on the server, given as
		 *     scheme://host/target.
		 * 
		 *     The standard implementation always supports the "http" scheme.  If
		 *     SSL socket support is available (Python 2.0), it also supports
		 *     "https".
		 * 
		 *     If the target part and the slash preceding it are both omitted,
		 *     "/RPC2" is assumed.
		 * 
		 *     The following options can be given as keyword arguments:
		 * 
		 *         transport: a transport factory
		 *         encoding: the request encoding (default is UTF-8)
		 * 
		 *     All 8-bit strings passed to the server proxy are assumed to use
		 *     the given encoding.
		 *     
		 */
		function ServerProxy(uri, transport?, encoding?, verbose?: boolean, allow_none?: boolean, use_datetime?: boolean, use_builtin_types?: boolean): Promise<IServerProxy>
		function ServerProxy$({ uri, transport, encoding, verbose, allow_none, use_datetime, use_builtin_types }: { uri, transport?, encoding?, verbose?, allow_none?, use_datetime?, use_builtin_types?}): Promise<IServerProxy>
		interface IServerProxy {
		}
		let MAXINT: Promise<any>
		let MININT: Promise<any>
		let PARSE_ERROR: Promise<any>
		let SERVER_ERROR: Promise<any>
		let APPLICATION_ERROR: Promise<any>
		let SYSTEM_ERROR: Promise<any>
		let TRANSPORT_ERROR: Promise<any>
		let NOT_WELLFORMED_ERROR: Promise<any>
		let UNSUPPORTED_ENCODING: Promise<any>
		let INVALID_ENCODING_CHAR: Promise<any>
		let INVALID_XMLRPC: Promise<any>
		let METHOD_NOT_FOUND: Promise<any>
		let INVALID_METHOD_PARAMS: Promise<any>
		let INTERNAL_ERROR: Promise<any>
		let boolean: Promise<any>
		let Boolean: Promise<any>
		let WRAPPERS: Promise<any>
		let FastMarshaller: Promise<any>
		let FastParser: Promise<any>
		let FastUnmarshaller: Promise<any>
		let Server: Promise<any>
		let server: Promise<any>
		let multi: Promise<any>
	}
	module server {
		var _

		/**
		 * resolve_dotted_attribute(a, 'b.c.d') => a.b.c.d
		 * 
		 *     Resolves a dotted attribute name to an object.  Raises
		 *     an AttributeError if any attribute in the chain starts with a '_'.
		 * 
		 *     If the optional allow_dotted_names argument is false, dots are not
		 *     supported and this function operates similar to getattr(obj, attr).
		 *     
		 */
		function resolve_dotted_attribute(obj, attr, allow_dotted_names?: boolean): Promise<any>
		function resolve_dotted_attribute$({ obj, attr, allow_dotted_names }: { obj, attr, allow_dotted_names?}): Promise<any>

		/**
		 * Returns a list of attribute strings, found in the specified
		 *     object, which represent callable attributes
		 */
		function list_public_methods(obj): Promise<any>
		function list_public_methods$({ obj }): Promise<any>

		/**
		 * Mix-in class that dispatches XML-RPC requests.
		 * 
		 *     This class is used to register XML-RPC method handlers
		 *     and then to dispatch them. This class doesn't need to be
		 *     instanced directly when used by SimpleXMLRPCServer but it
		 *     can be instanced when used by the MultiPathXMLRPCServer
		 *     
		 */
		function SimpleXMLRPCDispatcher(allow_none?: boolean, encoding?, use_builtin_types?: boolean): Promise<ISimpleXMLRPCDispatcher>
		function SimpleXMLRPCDispatcher$({ allow_none, encoding, use_builtin_types }: { allow_none?, encoding?, use_builtin_types?}): Promise<ISimpleXMLRPCDispatcher>
		interface ISimpleXMLRPCDispatcher {

			/**
			 * Registers an instance to respond to XML-RPC requests.
			 * 
			 *         Only one instance can be installed at a time.
			 * 
			 *         If the registered instance has a _dispatch method then that
			 *         method will be called with the name of the XML-RPC method and
			 *         its parameters as a tuple
			 *         e.g. instance._dispatch('add',(2,3))
			 * 
			 *         If the registered instance does not have a _dispatch method
			 *         then the instance will be searched to find a matching method
			 *         and, if found, will be called. Methods beginning with an '_'
			 *         are considered private and will not be called by
			 *         SimpleXMLRPCServer.
			 * 
			 *         If a registered function matches an XML-RPC request, then it
			 *         will be called instead of the registered instance.
			 * 
			 *         If the optional allow_dotted_names argument is true and the
			 *         instance does not have a _dispatch method, method names
			 *         containing dots are supported and resolved, as long as none of
			 *         the name segments start with an '_'.
			 * 
			 *             *** SECURITY WARNING: ***
			 * 
			 *             Enabling the allow_dotted_names options allows intruders
			 *             to access your module's global variables and may allow
			 *             intruders to execute arbitrary code on your machine.  Only
			 *             use this option on a secure, closed network.
			 * 
			 *         
			 */
			register_instance(instance, allow_dotted_names?: boolean): Promise<any>
			register_instance$({ instance, allow_dotted_names }: { instance, allow_dotted_names?}): Promise<any>

			/**
			 * Registers a function to respond to XML-RPC requests.
			 * 
			 *         The optional name argument can be used to set a Unicode name
			 *         for the function.
			 *         
			 */
			register_function(func?, name?): Promise<any>
			register_function$({ func, name }: { func?, name?}): Promise<any>

			/**
			 * Registers the XML-RPC introspection methods in the system
			 *         namespace.
			 * 
			 *         see http://xmlrpc.usefulinc.com/doc/reserved.html
			 *         
			 */
			register_introspection_functions(): Promise<any>
			register_introspection_functions$($: {}): Promise<any>

			/**
			 * Registers the XML-RPC multicall method in the system
			 *         namespace.
			 * 
			 *         see http://www.xmlrpc.com/discuss/msgReader$1208
			 */
			register_multicall_functions(): Promise<any>
			register_multicall_functions$($: {}): Promise<any>

			/**
			 * system.listMethods() => ['add', 'subtract', 'multiple']
			 * 
			 *         Returns a list of the methods supported by the server.
			 */
			system_listMethods(): Promise<any>
			system_listMethods$($: {}): Promise<any>

			/**
			 * system.methodSignature('add') => [double, int, int]
			 * 
			 *         Returns a list describing the signature of the method. In the
			 *         above example, the add method takes two integers as arguments
			 *         and returns a double result.
			 * 
			 *         This server does NOT support system.methodSignature.
			 */
			system_methodSignature(method_name): Promise<any>
			system_methodSignature$({ method_name }): Promise<any>

			/**
			 * system.methodHelp('add') => "Adds two integers together"
			 * 
			 *         Returns a string containing documentation for the specified method.
			 */
			system_methodHelp(method_name): Promise<any>
			system_methodHelp$({ method_name }): Promise<any>

			/**
			 * system.multicall([{'methodName': 'add', 'params': [2, 2]}, ...]) => [[4], ...]
			 * 
			 *         Allows the caller to package multiple XML-RPC calls into a single
			 *         request.
			 * 
			 *         See http://www.xmlrpc.com/discuss/msgReader$1208
			 *         
			 */
			system_multicall(call_list): Promise<any>
			system_multicall$({ call_list }): Promise<any>
		}

		/**
		 * Simple XML-RPC request handler class.
		 * 
		 *     Handles all HTTP POST requests and attempts to decode them as
		 *     XML-RPC requests.
		 *     
		 */
		interface ISimpleXMLRPCRequestHandler {
			accept_encodings(): Promise<any>
			accept_encodings$($: {}): Promise<any>
			is_rpc_path_valid(): Promise<any>
			is_rpc_path_valid$($: {}): Promise<any>

			/**
			 * Handles the HTTP POST request.
			 * 
			 *         Attempts to interpret all HTTP POST requests as XML-RPC calls,
			 *         which are forwarded to the server's _dispatch method for handling.
			 *         
			 */
			do_POST(): Promise<any>
			do_POST$($: {}): Promise<any>
			decode_request_content(data): Promise<any>
			decode_request_content$({ data }): Promise<any>
			report_404(): Promise<any>
			report_404$($: {}): Promise<any>

			/**
			 * Selectively log an accepted request.
			 */
			log_request(code?, size?): Promise<any>
			log_request$({ code, size }: { code?, size?}): Promise<any>
			rpc_paths
			encode_threshold
			wbufsize
			disable_nagle_algorithm
			aepattern
		}

		/**
		 * Simple XML-RPC server.
		 * 
		 *     Simple XML-RPC server that allows functions and a single instance
		 *     to be installed to handle requests. The default implementation
		 *     attempts to dispatch XML-RPC calls to the functions or instance
		 *     installed in the server. Override the _dispatch method inherited
		 *     from SimpleXMLRPCDispatcher to change this behavior.
		 *     
		 */
		function SimpleXMLRPCServer(addr, requestHandler?, logRequests?: boolean, allow_none?: boolean, encoding?, bind_and_activate?: boolean, use_builtin_types?: boolean): Promise<ISimpleXMLRPCServer>
		function SimpleXMLRPCServer$({ addr, requestHandler, logRequests, allow_none, encoding, bind_and_activate, use_builtin_types }: { addr, requestHandler?, logRequests?, allow_none?, encoding?, bind_and_activate?, use_builtin_types?}): Promise<ISimpleXMLRPCServer>
		interface ISimpleXMLRPCServer extends ISimpleXMLRPCDispatcher {
			allow_reuse_address
		}

		/**
		 * Multipath XML-RPC Server
		 *     This specialization of SimpleXMLRPCServer allows the user to create
		 *     multiple Dispatcher instances and assign them to different
		 *     HTTP request paths.  This makes it possible to run two or more
		 *     'virtual XML-RPC servers' at the same port.
		 *     Make sure that the requestHandler accepts the paths in question.
		 *     
		 */
		function MultiPathXMLRPCServer(addr, requestHandler?, logRequests?: boolean, allow_none?: boolean, encoding?, bind_and_activate?: boolean, use_builtin_types?: boolean): Promise<IMultiPathXMLRPCServer>
		function MultiPathXMLRPCServer$({ addr, requestHandler, logRequests, allow_none, encoding, bind_and_activate, use_builtin_types }: { addr, requestHandler?, logRequests?, allow_none?, encoding?, bind_and_activate?, use_builtin_types?}): Promise<IMultiPathXMLRPCServer>
		interface IMultiPathXMLRPCServer extends ISimpleXMLRPCServer {
			add_dispatcher(path, dispatcher): Promise<any>
			add_dispatcher$({ path, dispatcher }): Promise<any>
			get_dispatcher(path): Promise<any>
			get_dispatcher$({ path }): Promise<any>
		}

		/**
		 * Simple handler for XML-RPC data passed through CGI.
		 */
		function CGIXMLRPCRequestHandler(allow_none?: boolean, encoding?, use_builtin_types?: boolean): Promise<ICGIXMLRPCRequestHandler>
		function CGIXMLRPCRequestHandler$({ allow_none, encoding, use_builtin_types }: { allow_none?, encoding?, use_builtin_types?}): Promise<ICGIXMLRPCRequestHandler>
		interface ICGIXMLRPCRequestHandler extends ISimpleXMLRPCDispatcher {

			/**
			 * Handle a single XML-RPC request
			 */
			handle_xmlrpc(request_text): Promise<any>
			handle_xmlrpc$({ request_text }): Promise<any>

			/**
			 * Handle a single HTTP GET request.
			 * 
			 *         Default implementation indicates an error because
			 *         XML-RPC uses the POST method.
			 *         
			 */
			handle_get(): Promise<any>
			handle_get$($: {}): Promise<any>

			/**
			 * Handle a single XML-RPC request passed through a CGI post method.
			 * 
			 *         If no XML data is given then it is read from stdin. The resulting
			 *         XML-RPC response is printed to stdout along with the correct HTTP
			 *         headers.
			 *         
			 */
			handle_request(request_text?): Promise<any>
			handle_request$({ request_text }: { request_text?}): Promise<any>
		}

		/**
		 * Class used to generate pydoc HTML document for a server
		 */
		interface IServerHTMLDoc {

			/**
			 * Mark up some plain text, given a context of symbols to look for.
			 *         Each context dictionary maps object names to anchor names.
			 */
			markup(text, escape?, funcs?, classes?, methods?): Promise<any>
			markup$({ text, escape, funcs, classes, methods }: { text, escape?, funcs?, classes?, methods?}): Promise<any>

			/**
			 * Produce HTML documentation for a function or method object.
			 */
			docroutine(object, name, mod?, funcs?, classes?, methods?, cl?): Promise<any>
			docroutine$({ object, name, mod, funcs, classes, methods, cl }: { object, name, mod?, funcs?, classes?, methods?, cl?}): Promise<any>

			/**
			 * Produce HTML documentation for an XML-RPC server.
			 */
			docserver(server_name, package_documentation, methods): Promise<any>
			docserver$({ server_name, package_documentation, methods }): Promise<any>
		}

		/**
		 * Generates documentation for an XML-RPC server.
		 * 
		 *     This class is designed as mix-in and should not
		 *     be constructed directly.
		 *     
		 */
		function XMLRPCDocGenerator(): Promise<IXMLRPCDocGenerator>
		function XMLRPCDocGenerator$({ }): Promise<IXMLRPCDocGenerator>
		interface IXMLRPCDocGenerator {

			/**
			 * Set the HTML title of the generated server documentation
			 */
			set_server_title(server_title): Promise<any>
			set_server_title$({ server_title }): Promise<any>

			/**
			 * Set the name of the generated HTML server documentation
			 */
			set_server_name(server_name): Promise<any>
			set_server_name$({ server_name }): Promise<any>

			/**
			 * Set the documentation string for the entire server.
			 */
			set_server_documentation(server_documentation): Promise<any>
			set_server_documentation$({ server_documentation }): Promise<any>

			/**
			 * generate_html_documentation() => html documentation for the server
			 * 
			 *         Generates HTML documentation for the server using introspection for
			 *         installed functions and instances that do not implement the
			 *         _dispatch method. Alternatively, instances can choose to implement
			 *         the _get_method_argstring(method_name) method to provide the
			 *         argument string used in the documentation and the
			 *         _methodHelp(method_name) method to provide the help text used
			 *         in the documentation.
			 */
			generate_html_documentation(): Promise<any>
			generate_html_documentation$($: {}): Promise<any>
		}

		/**
		 * XML-RPC and documentation request handler class.
		 * 
		 *     Handles all HTTP POST requests and attempts to decode them as
		 *     XML-RPC requests.
		 * 
		 *     Handles all HTTP GET requests and interprets them as requests
		 *     for documentation.
		 *     
		 */
		interface IDocXMLRPCRequestHandler extends ISimpleXMLRPCRequestHandler {

			/**
			 * Handles the HTTP GET request.
			 * 
			 *         Interpret all HTTP GET requests as requests for server
			 *         documentation.
			 *         
			 */
			do_GET(): Promise<any>
			do_GET$($: {}): Promise<any>
		}

		/**
		 * XML-RPC and HTML documentation server.
		 * 
		 *     Adds the ability to serve server documentation to the capabilities
		 *     of SimpleXMLRPCServer.
		 *     
		 */
		function DocXMLRPCServer(addr, requestHandler?, logRequests?: boolean, allow_none?: boolean, encoding?, bind_and_activate?: boolean, use_builtin_types?: boolean): Promise<IDocXMLRPCServer>
		function DocXMLRPCServer$({ addr, requestHandler, logRequests, allow_none, encoding, bind_and_activate, use_builtin_types }: { addr, requestHandler?, logRequests?, allow_none?, encoding?, bind_and_activate?, use_builtin_types?}): Promise<IDocXMLRPCServer>
		interface IDocXMLRPCServer extends ISimpleXMLRPCServer, IXMLRPCDocGenerator {
		}

		/**
		 * Handler for XML-RPC data and documentation requests passed through
		 *     CGI
		 */
		function DocCGIXMLRPCRequestHandler(): Promise<IDocCGIXMLRPCRequestHandler>
		function DocCGIXMLRPCRequestHandler$({ }): Promise<IDocCGIXMLRPCRequestHandler>
		interface IDocCGIXMLRPCRequestHandler extends ICGIXMLRPCRequestHandler, IXMLRPCDocGenerator {

			/**
			 * Handles the HTTP GET request.
			 * 
			 *         Interpret all HTTP GET requests as requests for server
			 *         documentation.
			 *         
			 */
			handle_get(): Promise<any>
			handle_get$($: {}): Promise<any>
		}
		interface IExampleService {
			getData(): Promise<any>
			getData$($: {}): Promise<any>
		}
	}
}
declare module zipapp {
	var _

	/**
	 * Create an application archive from SOURCE.
	 * 
	 *     The SOURCE can be the name of a directory, or a filename or a file-like
	 *     object referring to an existing archive.
	 * 
	 *     The content of SOURCE is packed into an application archive in TARGET,
	 *     which can be a filename or a file-like object.  If SOURCE is a directory,
	 *     TARGET can be omitted and will default to the name of SOURCE with .pyz
	 *     appended.
	 * 
	 *     The created application archive will have a shebang line specifying
	 *     that it should run with INTERPRETER (there will be no shebang line if
	 *     INTERPRETER is None), and a __main__.py which runs MAIN (if MAIN is
	 *     not specified, an existing __main__.py will be used).  It is an error
	 *     to specify MAIN for anything other than a directory source with no
	 *     __main__.py, and it is an error to omit MAIN if the directory has no
	 *     __main__.py.
	 *     
	 */
	function create_archive(source, target?, interpreter?, main?, filter?, compressed?: boolean): Promise<any>
	function create_archive$({ source, target, interpreter, main, filter, compressed }: { source, target?, interpreter?, main?, filter?, compressed?}): Promise<any>
	function get_interpreter(archive): Promise<any>
	function get_interpreter$({ archive }): Promise<any>

	/**
	 * Run the zipapp command line interface.
	 * 
	 *     The ARGS parameter lets you specify the argument list directly.
	 *     Omitting ARGS (or setting it to None) works as for argparse, using
	 *     sys.argv[1:] as the argument list.
	 *     
	 */
	function main(args?): Promise<any>
	function main$({ args }: { args?}): Promise<any>
	interface IZipAppError {
	}
	let MAIN_TEMPLATE: Promise<any>
	let shebang_encoding: Promise<any>
}
declare module zipfile {
	var _

	/**
	 * Quickly see if a file is a ZIP file by checking the magic number.
	 * 
	 *     The filename argument may be a file or file-like object too.
	 *     
	 */
	function is_zipfile(filename): Promise<any>
	function is_zipfile$({ filename }): Promise<any>
	function main(args?): Promise<any>
	function main$({ args }: { args?}): Promise<any>
	interface IBadZipFile {
	}

	/**
	 * 
	 *     Raised when writing a zipfile, the zipfile requires ZIP64 extensions
	 *     and those extensions are disabled.
	 *     
	 */
	interface ILargeZipFile {
	}

	/**
	 * Class with attributes describing each file in the ZIP archive.
	 */
	function ZipInfo(filename?, date_time?): Promise<IZipInfo>
	function ZipInfo$({ filename, date_time }: { filename?, date_time?}): Promise<IZipInfo>
	interface IZipInfo {

		/**
		 * Return the per-file header as a bytes object.
		 */
		FileHeader(zip64?): Promise<any>
		FileHeader$({ zip64 }: { zip64?}): Promise<any>

		/**
		 * Construct an appropriate ZipInfo for a file on the filesystem.
		 * 
		 *         filename should be the path to a file or directory on the filesystem.
		 * 
		 *         arcname is the name which it will have within the archive (by default,
		 *         this will be the same as filename, but without a drive letter and with
		 *         leading path separators removed).
		 *         
		 */
		from_file(filename, arcname?): Promise<any>
		from_file$({ filename, arcname }: { filename, arcname?}): Promise<any>

		/**
		 * Return True if this archive member is a directory.
		 */
		is_dir(): Promise<any>
		is_dir$($: {}): Promise<any>
	}
	function LZMACompressor(): Promise<ILZMACompressor>
	function LZMACompressor$({ }): Promise<ILZMACompressor>
	interface ILZMACompressor {
		compress(data): Promise<any>
		compress$({ data }): Promise<any>
		flush(): Promise<any>
		flush$($: {}): Promise<any>
	}
	function LZMADecompressor(): Promise<ILZMADecompressor>
	function LZMADecompressor$({ }): Promise<ILZMADecompressor>
	interface ILZMADecompressor {
		decompress(data): Promise<any>
		decompress$({ data }): Promise<any>
	}
	interface I_SharedFile {
		seek(offset, whence?): Promise<any>
		seek$({ offset, whence }: { offset, whence?}): Promise<any>
		read(n?): Promise<any>
		read$({ n }: { n?}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}
	interface I_Tellable {
		write(data): Promise<any>
		write$({ data }): Promise<any>
		tell(): Promise<any>
		tell$($: {}): Promise<any>
		flush(): Promise<any>
		flush$($: {}): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 * File-like object for reading an archive member.
	 *        Is returned by ZipFile.open().
	 *     
	 */
	function ZipExtFile(fileobj, mode, zipinfo, pwd?, close_fileobj?: boolean): Promise<IZipExtFile>
	function ZipExtFile$({ fileobj, mode, zipinfo, pwd, close_fileobj }: { fileobj, mode, zipinfo, pwd?, close_fileobj?}): Promise<IZipExtFile>
	interface IZipExtFile {

		/**
		 * Read and return a line from the stream.
		 * 
		 *         If limit is specified, at most limit bytes will be read.
		 *         
		 */
		readline(limit?): Promise<any>
		readline$({ limit }: { limit?}): Promise<any>

		/**
		 * Returns buffered bytes without advancing the position.
		 */
		peek(n?): Promise<any>
		peek$({ n }: { n?}): Promise<any>
		readable(): Promise<any>
		readable$($: {}): Promise<any>

		/**
		 * Read and return up to n bytes.
		 *         If the argument is omitted, None, or negative, data is read and returned until EOF is reached.
		 *         
		 */
		read(n?): Promise<any>
		read$({ n }: { n?}): Promise<any>

		/**
		 * Read up to n bytes with at most one read() system call.
		 */
		read1(n): Promise<any>
		read1$({ n }): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
		seekable(): Promise<any>
		seekable$($: {}): Promise<any>
		seek(offset, whence?): Promise<any>
		seek$({ offset, whence }: { offset, whence?}): Promise<any>
		tell(): Promise<any>
		tell$($: {}): Promise<any>
		MAX_N
		MIN_READ_SIZE
		MAX_SEEK_READ
	}
	interface I_ZipWriteFile {
		writable(): Promise<any>
		writable$($: {}): Promise<any>
		write(data): Promise<any>
		write$({ data }): Promise<any>
		close(): Promise<any>
		close$($: {}): Promise<any>
	}

	/**
	 *  Class with methods to open, read, write, close, list zip files.
	 * 
	 *     z = ZipFile(file, mode="r", compression=ZIP_STORED, allowZip64=True,
	 *                 compresslevel=None)
	 * 
	 *     file: Either the path to the file, or a file-like object.
	 *           If it is a path, the file will be opened and closed by ZipFile.
	 *     mode: The mode can be either read 'r', write 'w', exclusive create 'x',
	 *           or append 'a'.
	 *     compression: ZIP_STORED (no compression), ZIP_DEFLATED (requires zlib),
	 *                  ZIP_BZIP2 (requires bz2) or ZIP_LZMA (requires lzma).
	 *     allowZip64: if True ZipFile will create files with ZIP64 extensions when
	 *                 needed, otherwise it will raise an exception when this would
	 *                 be necessary.
	 *     compresslevel: None (default for the given compression type) or an integer
	 *                    specifying the level to pass to the compressor.
	 *                    When using ZIP_STORED or ZIP_LZMA this keyword has no effect.
	 *                    When using ZIP_DEFLATED integers 0 through 9 are accepted.
	 *                    When using ZIP_BZIP2 integers 1 through 9 are accepted.
	 * 
	 *     
	 */

	/**
	 * Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
	 *         or append 'a'.
	 */
	function ZipFile(file, mode?, compression?, allowZip64?: boolean, compresslevel?): Promise<IZipFile>
	function ZipFile$({ file, mode, compression, allowZip64, compresslevel }: { file, mode?, compression?, allowZip64?, compresslevel?}): Promise<IZipFile>
	interface IZipFile {

		/**
		 * Return a list of file names in the archive.
		 */
		namelist(): Promise<any>
		namelist$($: {}): Promise<any>

		/**
		 * Return a list of class ZipInfo instances for files in the
		 *         archive.
		 */
		infolist(): Promise<any>
		infolist$($: {}): Promise<any>

		/**
		 * Print a table of contents for the zip file.
		 */
		printdir(file?): Promise<any>
		printdir$({ file }: { file?}): Promise<any>

		/**
		 * Read all the files and check the CRC.
		 */
		testzip(): Promise<any>
		testzip$($: {}): Promise<any>

		/**
		 * Return the instance of ZipInfo given 'name'.
		 */
		getinfo(name): Promise<any>
		getinfo$({ name }): Promise<any>

		/**
		 * Set default password for encrypted files.
		 */
		setpassword(pwd): Promise<any>
		setpassword$({ pwd }): Promise<any>

		/**
		 * The comment text associated with the ZIP file.
		 */
		comment(): Promise<any>
		comment$($: {}): Promise<any>
		comment(comment): Promise<any>
		comment$({ comment }): Promise<any>

		/**
		 * Return file bytes for name.
		 */
		read(name, pwd?): Promise<any>
		read$({ name, pwd }: { name, pwd?}): Promise<any>

		/**
		 * Return file-like object for 'name'.
		 * 
		 *         name is a string for the file name within the ZIP file, or a ZipInfo
		 *         object.
		 * 
		 *         mode should be 'r' to read a file already in the ZIP file, or 'w' to
		 *         write to a file newly added to the archive.
		 * 
		 *         pwd is the password to decrypt files (only used for reading).
		 * 
		 *         When writing, if the file size is not known in advance but may exceed
		 *         2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large
		 *         files.  If the size is known in advance, it is best to pass a ZipInfo
		 *         instance for name, with zinfo.file_size set.
		 *         
		 */
		open(name, mode?, pwd?): Promise<any>
		open$({ name, mode, pwd }: { name, mode?, pwd?}): Promise<any>

		/**
		 * Extract a member from the archive to the current working directory,
		 *            using its full name. Its file information is extracted as accurately
		 *            as possible. `member' may be a filename or a ZipInfo object. You can
		 *            specify a different directory using `path'.
		 *         
		 */
		extract(member, path?, pwd?): Promise<any>
		extract$({ member, path, pwd }: { member, path?, pwd?}): Promise<any>

		/**
		 * Extract all members from the archive to the current working
		 *            directory. `path' specifies a different directory to extract to.
		 *            `members' is optional and must be a subset of the list returned
		 *            by namelist().
		 *         
		 */
		extractall(path?, members?, pwd?): Promise<any>
		extractall$({ path, members, pwd }: { path?, members?, pwd?}): Promise<any>

		/**
		 * Put the bytes from filename into the archive under the name
		 *         arcname.
		 */
		write(filename, arcname?, compress_type?, compresslevel?): Promise<any>
		write$({ filename, arcname, compress_type, compresslevel }: { filename, arcname?, compress_type?, compresslevel?}): Promise<any>

		/**
		 * Write a file into the archive.  The contents is 'data', which
		 *         may be either a 'str' or a 'bytes' instance; if it is a 'str',
		 *         it is encoded as UTF-8 first.
		 *         'zinfo_or_arcname' is either a ZipInfo instance or
		 *         the name of the file in the archive.
		 */
		writestr(zinfo_or_arcname, data, compress_type?, compresslevel?): Promise<any>
		writestr$({ zinfo_or_arcname, data, compress_type, compresslevel }: { zinfo_or_arcname, data, compress_type?, compresslevel?}): Promise<any>

		/**
		 * Close the file, and for mode 'w', 'x' and 'a' write the ending
		 *         records.
		 */
		close(): Promise<any>
		close$($: {}): Promise<any>
		fp
	}

	/**
	 * Class to create ZIP archives with Python library files and packages.
	 */
	function PyZipFile(file, mode?, compression?, allowZip64?: boolean, optimize?): Promise<IPyZipFile>
	function PyZipFile$({ file, mode, compression, allowZip64, optimize }: { file, mode?, compression?, allowZip64?, optimize?}): Promise<IPyZipFile>
	interface IPyZipFile extends IZipFile {

		/**
		 * Add all files from "pathname" to the ZIP archive.
		 * 
		 *         If pathname is a package directory, search the directory and
		 *         all package subdirectories recursively for all *.py and enter
		 *         the modules into the archive.  If pathname is a plain
		 *         directory, listdir *.py and enter all modules.  Else, pathname
		 *         must be a Python *.py file and the module will be put into the
		 *         archive.  Added modules are always module.pyc.
		 *         This method will compile the module.py into module.pyc if
		 *         necessary.
		 *         If filterfunc(pathname) is given, it is called with every argument.
		 *         When it is False, the file or directory is skipped.
		 *         
		 */
		writepy(pathname, basename?, filterfunc?): Promise<any>
		writepy$({ pathname, basename, filterfunc }: { pathname, basename?, filterfunc?}): Promise<any>
	}

	/**
	 * 
	 *     A ZipFile subclass that ensures that implied directories
	 *     are always included in the namelist.
	 *     
	 */
	interface ICompleteDirs extends IZipFile {
		namelist(): Promise<any>
		namelist$($: {}): Promise<any>

		/**
		 * 
		 *         If the name represents a directory, return that name
		 *         as a directory (with the trailing slash).
		 *         
		 */
		resolve_dir(name): Promise<any>
		resolve_dir$({ name }): Promise<any>

		/**
		 * 
		 *         Given a source (filename or zipfile), return an
		 *         appropriate CompleteDirs subclass.
		 *         
		 */
		make(source): Promise<any>
		make$({ source }): Promise<any>
	}

	/**
	 * 
	 *     ZipFile subclass to ensure implicit
	 *     dirs exist and are resolved rapidly.
	 *     
	 */
	interface IFastLookup extends ICompleteDirs {
		namelist(): Promise<any>
		namelist$($: {}): Promise<any>
	}

	/**
	 * 
	 *     A pathlib-compatible interface for zip files.
	 * 
	 *     Consider a zip file with this structure::
	 * 
	 *         .
	 *          a.txt
	 *          b
	 *              c.txt
	 *              d
	 *                  e.txt
	 * 
	 *     >>> data = io.BytesIO()
	 *     >>> zf = ZipFile(data, 'w')
	 *     >>> zf.writestr('a.txt', 'content of a')
	 *     >>> zf.writestr('b/c.txt', 'content of c')
	 *     >>> zf.writestr('b/d/e.txt', 'content of e')
	 *     >>> zf.filename = 'mem/abcde.zip'
	 * 
	 *     Path accepts the zipfile object itself or a filename
	 * 
	 *     >>> root = Path(zf)
	 * 
	 *     From there, several path operations are available.
	 * 
	 *     Directory iteration (including the zip file itself):
	 * 
	 *     >>> a, b = root.iterdir()
	 *     >>> a
	 *     Path('mem/abcde.zip', 'a.txt')
	 *     >>> b
	 *     Path('mem/abcde.zip', 'b/')
	 * 
	 *     name property:
	 * 
	 *     >>> b.name
	 *     'b'
	 * 
	 *     join with divide operator:
	 * 
	 *     >>> c = b / 'c.txt'
	 *     >>> c
	 *     Path('mem/abcde.zip', 'b/c.txt')
	 *     >>> c.name
	 *     'c.txt'
	 * 
	 *     Read text:
	 * 
	 *     >>> c.read_text()
	 *     'content of c'
	 * 
	 *     existence:
	 * 
	 *     >>> c.exists()
	 *     True
	 *     >>> (b / 'missing.txt').exists()
	 *     False
	 * 
	 *     Coercion to string:
	 * 
	 *     >>> import os
	 *     >>> str(c).replace(os.sep, posixpath.sep)
	 *     'mem/abcde.zip/b/c.txt'
	 * 
	 *     At the root, ``name``, ``filename``, and ``parent``
	 *     resolve to the zipfile. Note these attributes are not
	 *     valid and will raise a ``ValueError`` if the zipfile
	 *     has no filename.
	 * 
	 *     >>> root.name
	 *     'abcde.zip'
	 *     >>> str(root.filename).replace(os.sep, posixpath.sep)
	 *     'mem/abcde.zip'
	 *     >>> str(root.parent)
	 *     'mem'
	 *     
	 */

	/**
	 * 
	 *         Construct a Path from a ZipFile or filename.
	 * 
	 *         Note: When the source is an existing ZipFile object,
	 *         its type (__class__) will be mutated to a
	 *         specialized type. If the caller wishes to retain the
	 *         original type, the caller should either create a
	 *         separate ZipFile object or pass a filename.
	 *         
	 */
	function Path(root, at?): Promise<IPath>
	function Path$({ root, at }: { root, at?}): Promise<IPath>
	interface IPath {

		/**
		 * 
		 *         Open this entry as text or binary following the semantics
		 *         of ``pathlib.Path.open()`` by passing arguments through
		 *         to io.TextIOWrapper().
		 *         
		 */
		open(mode?): Promise<any>
		open$({ mode }: { mode?}): Promise<any>
		name(): Promise<any>
		name$($: {}): Promise<any>
		suffix(): Promise<any>
		suffix$($: {}): Promise<any>
		suffixes(): Promise<any>
		suffixes$($: {}): Promise<any>
		stem(): Promise<any>
		stem$($: {}): Promise<any>
		filename(): Promise<any>
		filename$($: {}): Promise<any>
		read_text(): Promise<any>
		read_text$($: {}): Promise<any>
		read_bytes(): Promise<any>
		read_bytes$($: {}): Promise<any>
		is_dir(): Promise<any>
		is_dir$($: {}): Promise<any>
		is_file(): Promise<any>
		is_file$($: {}): Promise<any>
		exists(): Promise<any>
		exists$($: {}): Promise<any>
		iterdir(): Promise<any>
		iterdir$($: {}): Promise<any>
		joinpath(): Promise<any>
		joinpath$($: {}): Promise<any>
		parent(): Promise<any>
		parent$($: {}): Promise<any>
	}
	let crc32: Promise<any>
	let error: Promise<any>
	let BadZipfile: Promise<any>
	let ZIP64_LIMIT: Promise<any>
	let ZIP_FILECOUNT_LIMIT: Promise<any>
	let ZIP_MAX_COMMENT: Promise<any>
	let ZIP_STORED: Promise<any>
	let ZIP_DEFLATED: Promise<any>
	let ZIP_BZIP2: Promise<any>
	let ZIP_LZMA: Promise<any>
	let DEFAULT_VERSION: Promise<any>
	let ZIP64_VERSION: Promise<any>
	let BZIP2_VERSION: Promise<any>
	let LZMA_VERSION: Promise<any>
	let MAX_EXTRACT_VERSION: Promise<any>
	let structEndArchive: Promise<any>
	let stringEndArchive: Promise<any>
	let sizeEndCentDir: Promise<any>
	let structCentralDir: Promise<any>
	let stringCentralDir: Promise<any>
	let sizeCentralDir: Promise<any>
	let structFileHeader: Promise<any>
	let stringFileHeader: Promise<any>
	let sizeFileHeader: Promise<any>
	let structEndArchive64Locator: Promise<any>
	let stringEndArchive64Locator: Promise<any>
	let sizeEndCentDir64Locator: Promise<any>
	let structEndArchive64: Promise<any>
	let stringEndArchive64: Promise<any>
	let sizeEndCentDir64: Promise<any>
	let compressor_names: Promise<any>
}
declare module zipimport {
	var _
	interface IZipImportError {
	}

	/**
	 * zipimporter(archivepath) -> zipimporter object
	 * 
	 *     Create a new zipimporter instance. 'archivepath' must be a path to
	 *     a zipfile, or to a specific path inside a zipfile. For example, it can be
	 *     '/tmp/myimport.zip', or '/tmp/myimport.zip/mydirectory', if mydirectory is a
	 *     valid directory inside the archive.
	 * 
	 *     'ZipImportError is raised if 'archivepath' doesn't point to a valid Zip
	 *     archive.
	 * 
	 *     The 'archive' attribute of zipimporter objects contains the name of the
	 *     zipfile targeted.
	 *     
	 */
	function zipimporter(path): Promise<Izipimporter>
	function zipimporter$({ path }): Promise<Izipimporter>
	interface Izipimporter {

		/**
		 * find_loader(fullname, path=None) -> self, str or None.
		 * 
		 *         Search for a module specified by 'fullname'. 'fullname' must be the
		 *         fully qualified (dotted) module name. It returns the zipimporter
		 *         instance itself if the module was found, a string containing the
		 *         full path name if it's possibly a portion of a namespace package,
		 *         or None otherwise. The optional 'path' argument is ignored -- it's
		 *         there for compatibility with the importer protocol.
		 * 
		 *         Deprecated since Python 3.10. Use find_spec() instead.
		 *         
		 */
		find_loader(fullname, path?): Promise<any>
		find_loader$({ fullname, path }: { fullname, path?}): Promise<any>

		/**
		 * find_module(fullname, path=None) -> self or None.
		 * 
		 *         Search for a module specified by 'fullname'. 'fullname' must be the
		 *         fully qualified (dotted) module name. It returns the zipimporter
		 *         instance itself if the module was found, or None if it wasn't.
		 *         The optional 'path' argument is ignored -- it's there for compatibility
		 *         with the importer protocol.
		 * 
		 *         Deprecated since Python 3.10. Use find_spec() instead.
		 *         
		 */
		find_module(fullname, path?): Promise<any>
		find_module$({ fullname, path }: { fullname, path?}): Promise<any>

		/**
		 * Create a ModuleSpec for the specified module.
		 * 
		 *         Returns None if the module cannot be found.
		 *         
		 */
		find_spec(fullname, target?): Promise<any>
		find_spec$({ fullname, target }: { fullname, target?}): Promise<any>

		/**
		 * get_code(fullname) -> code object.
		 * 
		 *         Return the code object for the specified module. Raise ZipImportError
		 *         if the module couldn't be imported.
		 *         
		 */
		get_code(fullname): Promise<any>
		get_code$({ fullname }): Promise<any>

		/**
		 * get_data(pathname) -> string with file data.
		 * 
		 *         Return the data associated with 'pathname'. Raise OSError if
		 *         the file wasn't found.
		 *         
		 */
		get_data(pathname): Promise<any>
		get_data$({ pathname }): Promise<any>

		/**
		 * get_filename(fullname) -> filename string.
		 * 
		 *         Return the filename for the specified module or raise ZipImportError
		 *         if it couldn't be imported.
		 *         
		 */
		get_filename(fullname): Promise<any>
		get_filename$({ fullname }): Promise<any>

		/**
		 * get_source(fullname) -> source string.
		 * 
		 *         Return the source code for the specified module. Raise ZipImportError
		 *         if the module couldn't be found, return None if the archive does
		 *         contain the module, but has no source for it.
		 *         
		 */
		get_source(fullname): Promise<any>
		get_source$({ fullname }): Promise<any>

		/**
		 * is_package(fullname) -> bool.
		 * 
		 *         Return True if the module specified by fullname is a package.
		 *         Raise ZipImportError if the module couldn't be found.
		 *         
		 */
		is_package(fullname): Promise<any>
		is_package$({ fullname }): Promise<any>

		/**
		 * load_module(fullname) -> module.
		 * 
		 *         Load the module specified by 'fullname'. 'fullname' must be the
		 *         fully qualified (dotted) module name. It returns the imported
		 *         module, or raises ZipImportError if it could not be imported.
		 * 
		 *         Deprecated since Python 3.10. Use exec_module() instead.
		 *         
		 */
		load_module(fullname): Promise<any>
		load_module$({ fullname }): Promise<any>

		/**
		 * Return the ResourceReader for a package in a zip file.
		 * 
		 *         If 'fullname' is a package within the zip file, return the
		 *         'ResourceReader' object for the package.  Otherwise return None.
		 *         
		 */
		get_resource_reader(fullname): Promise<any>
		get_resource_reader$({ fullname }): Promise<any>

		/**
		 * Reload the file data of the archive path.
		 */
		invalidate_caches(): Promise<any>
		invalidate_caches$($: {}): Promise<any>
	}
	let path_sep: Promise<any>
	let alt_path_sep: Promise<any>
	let END_CENTRAL_DIR_SIZE: Promise<any>
	let STRING_END_ARCHIVE: Promise<any>
	let MAX_COMMENT_LEN: Promise<any>
	let cp437_table: Promise<any>
}
declare module zoneinfo {
	var _
	let reset_tzpath: Promise<any>
	let available_timezones: Promise<any>
	let InvalidTZPathWarning: Promise<any>
	module _common {
		var _
		function load_tzdata(key): Promise<any>
		function load_tzdata$({ key }): Promise<any>
		function load_data(fobj): Promise<any>
		function load_data$({ fobj }): Promise<any>
		interface I_TZifHeader {
			from_file(stream): Promise<any>
			from_file$({ stream }): Promise<any>
		}

		/**
		 * Exception raised when a ZoneInfo key is not found.
		 */
		interface IZoneInfoNotFoundError {
		}
	}
	module _tzpath {
		var _
		function reset_tzpath(to?): Promise<any>
		function reset_tzpath$({ to }: { to?}): Promise<any>

		/**
		 * Retrieve the path to a TZif file from a key.
		 */
		function find_tzfile(key): Promise<any>
		function find_tzfile$({ key }): Promise<any>

		/**
		 * Returns a set containing all available time zones.
		 * 
		 *     .. caution::
		 * 
		 *         This may attempt to open a large number of files, since the best way to
		 *         determine if a given file on the time zone search path is to open it
		 *         and check for the "magic string" at the beginning.
		 *     
		 */
		function available_timezones(): Promise<any>
		function available_timezones$($: {}): Promise<any>

		/**
		 * Warning raised if an invalid path is specified in PYTHONTZPATH.
		 */
		interface IInvalidTZPathWarning {
		}
		let TZPATH: Promise<any>
	}
	module _zoneinfo {
		var _
		interface IZoneInfo {
			no_cache(key): Promise<any>
			no_cache$({ key }): Promise<any>
			from_file(fobj, key?): Promise<any>
			from_file$({ fobj, key }: { fobj, key?}): Promise<any>
			clear_cache(): Promise<any>
			clear_cache$($: {}): Promise<any>
			key(): Promise<any>
			key$($: {}): Promise<any>
			utcoffset(dt): Promise<any>
			utcoffset$({ dt }): Promise<any>
			dst(dt): Promise<any>
			dst$({ dt }): Promise<any>
			tzname(dt): Promise<any>
			tzname$({ dt }): Promise<any>

			/**
			 * Convert from datetime in UTC to datetime in local time
			 */
			fromutc(dt): Promise<any>
			fromutc$({ dt }): Promise<any>
		}
		interface I_ttinfo {
		}
		interface I_TZStr {
			transitions(year): Promise<any>
			transitions$({ year }): Promise<any>
		}
		interface I_DayOffset {
			year_to_epoch(year): Promise<any>
			year_to_epoch$({ year }): Promise<any>
		}
		interface I_CalendarOffset {

			/**
			 * Calculates the datetime of the occurrence from the year
			 */
			year_to_epoch(year): Promise<any>
			year_to_epoch$({ year }): Promise<any>
		}
		let EPOCH: Promise<any>
		let EPOCHORDINAL: Promise<any>
	}
}
type PyObjectType<T> =
	T extends "abc" ? typeof abc :
	T extends "aifc" ? typeof aifc :
	T extends "antigravity" ? typeof antigravity :
	T extends "argparse" ? typeof argparse :
	T extends "ast" ? typeof ast :
	T extends "asynchat" ? typeof asynchat :
	T extends "asyncio.base_events" ? typeof asyncio.base_events :
	T extends "asyncio.base_futures" ? typeof asyncio.base_futures :
	T extends "asyncio.base_subprocess" ? typeof asyncio.base_subprocess :
	T extends "asyncio.base_tasks" ? typeof asyncio.base_tasks :
	T extends "asyncio.constants" ? typeof asyncio.constants :
	T extends "asyncio.coroutines" ? typeof asyncio.coroutines :
	T extends "asyncio.events" ? typeof asyncio.events :
	T extends "asyncio.exceptions" ? typeof asyncio.exceptions :
	T extends "asyncio.format_helpers" ? typeof asyncio.format_helpers :
	T extends "asyncio.futures" ? typeof asyncio.futures :
	T extends "asyncio.locks" ? typeof asyncio.locks :
	T extends "asyncio.log" ? typeof asyncio.log :
	T extends "asyncio.mixins" ? typeof asyncio.mixins :
	T extends "asyncio.proactor_events" ? typeof asyncio.proactor_events :
	T extends "asyncio.protocols" ? typeof asyncio.protocols :
	T extends "asyncio.queues" ? typeof asyncio.queues :
	T extends "asyncio.runners" ? typeof asyncio.runners :
	T extends "asyncio.selector_events" ? typeof asyncio.selector_events :
	T extends "asyncio.sslproto" ? typeof asyncio.sslproto :
	T extends "asyncio.staggered" ? typeof asyncio.staggered :
	T extends "asyncio.streams" ? typeof asyncio.streams :
	T extends "asyncio.subprocess" ? typeof asyncio.subprocess :
	T extends "asyncio.tasks" ? typeof asyncio.tasks :
	T extends "asyncio.threads" ? typeof asyncio.threads :
	T extends "asyncio.transports" ? typeof asyncio.transports :
	T extends "asyncio.trsock" ? typeof asyncio.trsock :
	T extends "asyncio.unix_events" ? typeof asyncio.unix_events :
	T extends "asyncio.windows_events" ? typeof asyncio.windows_events :
	T extends "asyncio.windows_utils" ? typeof asyncio.windows_utils :
	T extends "asyncore" ? typeof asyncore :
	T extends "base64" ? typeof base64 :
	T extends "bdb" ? typeof bdb :
	T extends "binhex" ? typeof binhex :
	T extends "bisect" ? typeof bisect :
	T extends "bz2" ? typeof bz2 :
	T extends "cProfile" ? typeof cProfile :
	T extends "calendar" ? typeof calendar :
	T extends "cgi" ? typeof cgi :
	T extends "cgitb" ? typeof cgitb :
	T extends "chunk" ? typeof chunk :
	T extends "cmd" ? typeof cmd :
	T extends "code" ? typeof code :
	T extends "codecs" ? typeof codecs :
	T extends "codeop" ? typeof codeop :
	T extends "collections.abc" ? typeof collections.abc :
	T extends "colorsys" ? typeof colorsys :
	T extends "compileall" ? typeof compileall :
	T extends "concurrent.futures._base" ? typeof concurrent.futures._base :
	T extends "concurrent.futures.process" ? typeof concurrent.futures.process :
	T extends "concurrent.futures.thread" ? typeof concurrent.futures.thread :
	T extends "configparser" ? typeof configparser :
	T extends "contextlib" ? typeof contextlib :
	T extends "contextvars" ? typeof contextvars :
	T extends "copy" ? typeof copy :
	T extends "copyreg" ? typeof copyreg :
	T extends "crypt" ? typeof crypt :
	T extends "csv" ? typeof csv :
	T extends "ctypes._aix" ? typeof ctypes._aix :
	T extends "ctypes._endian" ? typeof ctypes._endian :
	T extends "ctypes.macholib.dyld" ? typeof ctypes.macholib.dyld :
	T extends "ctypes.macholib.dylib" ? typeof ctypes.macholib.dylib :
	T extends "ctypes.macholib.framework" ? typeof ctypes.macholib.framework :
	T extends "ctypes.util" ? typeof ctypes.util :
	T extends "ctypes.wintypes" ? typeof ctypes.wintypes :
	T extends "curses.ascii" ? typeof curses.ascii :
	T extends "curses.has_key" ? typeof curses.has_key :
	T extends "curses.panel" ? typeof curses.panel :
	T extends "curses.textpad" ? typeof curses.textpad :
	T extends "dataclasses" ? typeof dataclasses :
	T extends "datetime" ? typeof datetime :
	T extends "dbm.dumb" ? typeof dbm.dumb :
	T extends "dbm.gnu" ? typeof dbm.gnu :
	T extends "dbm.ndbm" ? typeof dbm.ndbm :
	T extends "decimal" ? typeof decimal :
	T extends "difflib" ? typeof difflib :
	T extends "dis" ? typeof dis :
	T extends "distutils._msvccompiler" ? typeof distutils._msvccompiler :
	T extends "distutils.archive_util" ? typeof distutils.archive_util :
	T extends "distutils.bcppcompiler" ? typeof distutils.bcppcompiler :
	T extends "distutils.ccompiler" ? typeof distutils.ccompiler :
	T extends "distutils.cmd" ? typeof distutils.cmd :
	T extends "distutils.command.bdist" ? typeof distutils.command.bdist :
	T extends "distutils.command.bdist_dumb" ? typeof distutils.command.bdist_dumb :
	T extends "distutils.command.bdist_msi" ? typeof distutils.command.bdist_msi :
	T extends "distutils.command.bdist_rpm" ? typeof distutils.command.bdist_rpm :
	T extends "distutils.command.build" ? typeof distutils.command.build :
	T extends "distutils.command.build_clib" ? typeof distutils.command.build_clib :
	T extends "distutils.command.build_ext" ? typeof distutils.command.build_ext :
	T extends "distutils.command.build_py" ? typeof distutils.command.build_py :
	T extends "distutils.command.build_scripts" ? typeof distutils.command.build_scripts :
	T extends "distutils.command.check" ? typeof distutils.command.check :
	T extends "distutils.command.clean" ? typeof distutils.command.clean :
	T extends "distutils.command.config" ? typeof distutils.command.config :
	T extends "distutils.command.install" ? typeof distutils.command.install :
	T extends "distutils.command.install_data" ? typeof distutils.command.install_data :
	T extends "distutils.command.install_egg_info" ? typeof distutils.command.install_egg_info :
	T extends "distutils.command.install_headers" ? typeof distutils.command.install_headers :
	T extends "distutils.command.install_lib" ? typeof distutils.command.install_lib :
	T extends "distutils.command.install_scripts" ? typeof distutils.command.install_scripts :
	T extends "distutils.command.register" ? typeof distutils.command.register :
	T extends "distutils.command.sdist" ? typeof distutils.command.sdist :
	T extends "distutils.command.upload" ? typeof distutils.command.upload :
	T extends "distutils.config" ? typeof distutils.config :
	T extends "distutils.core" ? typeof distutils.core :
	T extends "distutils.cygwinccompiler" ? typeof distutils.cygwinccompiler :
	T extends "distutils.debug" ? typeof distutils.debug :
	T extends "distutils.dep_util" ? typeof distutils.dep_util :
	T extends "distutils.dir_util" ? typeof distutils.dir_util :
	T extends "distutils.dist" ? typeof distutils.dist :
	T extends "distutils.errors" ? typeof distutils.errors :
	T extends "distutils.extension" ? typeof distutils.extension :
	T extends "distutils.fancy_getopt" ? typeof distutils.fancy_getopt :
	T extends "distutils.file_util" ? typeof distutils.file_util :
	T extends "distutils.filelist" ? typeof distutils.filelist :
	T extends "distutils.log" ? typeof distutils.log :
	T extends "distutils.msvc9compiler" ? typeof distutils.msvc9compiler :
	T extends "distutils.msvccompiler" ? typeof distutils.msvccompiler :
	T extends "distutils.spawn" ? typeof distutils.spawn :
	T extends "distutils.sysconfig" ? typeof distutils.sysconfig :
	T extends "distutils.text_file" ? typeof distutils.text_file :
	T extends "distutils.unixccompiler" ? typeof distutils.unixccompiler :
	T extends "distutils.util" ? typeof distutils.util :
	T extends "distutils.version" ? typeof distutils.version :
	T extends "distutils.versionpredicate" ? typeof distutils.versionpredicate :
	T extends "email._encoded_words" ? typeof email._encoded_words :
	T extends "email._header_value_parser" ? typeof email._header_value_parser :
	T extends "email._parseaddr" ? typeof email._parseaddr :
	T extends "email._policybase" ? typeof email._policybase :
	T extends "email.base64mime" ? typeof email.base64mime :
	T extends "email.charset" ? typeof email.charset :
	T extends "email.contentmanager" ? typeof email.contentmanager :
	T extends "email.encoders" ? typeof email.encoders :
	T extends "email.errors" ? typeof email.errors :
	T extends "email.feedparser" ? typeof email.feedparser :
	T extends "email.generator" ? typeof email.generator :
	T extends "email.header" ? typeof email.header :
	T extends "email.headerregistry" ? typeof email.headerregistry :
	T extends "email.iterators" ? typeof email.iterators :
	T extends "email.message" ? typeof email.message :
	T extends "email.mime.application" ? typeof email.mime.application :
	T extends "email.mime.audio" ? typeof email.mime.audio :
	T extends "email.mime.base" ? typeof email.mime.base :
	T extends "email.mime.image" ? typeof email.mime.image :
	T extends "email.mime.message" ? typeof email.mime.message :
	T extends "email.mime.multipart" ? typeof email.mime.multipart :
	T extends "email.mime.nonmultipart" ? typeof email.mime.nonmultipart :
	T extends "email.mime.text" ? typeof email.mime.text :
	T extends "email.parser" ? typeof email.parser :
	T extends "email.policy" ? typeof email.policy :
	T extends "email.quoprimime" ? typeof email.quoprimime :
	T extends "email.utils" ? typeof email.utils :
	T extends "encodings.aliases" ? typeof encodings.aliases :
	T extends "encodings.ascii" ? typeof encodings.ascii :
	T extends "encodings.base64_codec" ? typeof encodings.base64_codec :
	T extends "encodings.big5" ? typeof encodings.big5 :
	T extends "encodings.big5hkscs" ? typeof encodings.big5hkscs :
	T extends "encodings.bz2_codec" ? typeof encodings.bz2_codec :
	T extends "encodings.charmap" ? typeof encodings.charmap :
	T extends "encodings.cp037" ? typeof encodings.cp037 :
	T extends "encodings.cp1006" ? typeof encodings.cp1006 :
	T extends "encodings.cp1026" ? typeof encodings.cp1026 :
	T extends "encodings.cp1125" ? typeof encodings.cp1125 :
	T extends "encodings.cp1140" ? typeof encodings.cp1140 :
	T extends "encodings.cp1250" ? typeof encodings.cp1250 :
	T extends "encodings.cp1251" ? typeof encodings.cp1251 :
	T extends "encodings.cp1252" ? typeof encodings.cp1252 :
	T extends "encodings.cp1253" ? typeof encodings.cp1253 :
	T extends "encodings.cp1254" ? typeof encodings.cp1254 :
	T extends "encodings.cp1255" ? typeof encodings.cp1255 :
	T extends "encodings.cp1256" ? typeof encodings.cp1256 :
	T extends "encodings.cp1257" ? typeof encodings.cp1257 :
	T extends "encodings.cp1258" ? typeof encodings.cp1258 :
	T extends "encodings.cp273" ? typeof encodings.cp273 :
	T extends "encodings.cp424" ? typeof encodings.cp424 :
	T extends "encodings.cp437" ? typeof encodings.cp437 :
	T extends "encodings.cp500" ? typeof encodings.cp500 :
	T extends "encodings.cp720" ? typeof encodings.cp720 :
	T extends "encodings.cp737" ? typeof encodings.cp737 :
	T extends "encodings.cp775" ? typeof encodings.cp775 :
	T extends "encodings.cp850" ? typeof encodings.cp850 :
	T extends "encodings.cp852" ? typeof encodings.cp852 :
	T extends "encodings.cp855" ? typeof encodings.cp855 :
	T extends "encodings.cp856" ? typeof encodings.cp856 :
	T extends "encodings.cp857" ? typeof encodings.cp857 :
	T extends "encodings.cp858" ? typeof encodings.cp858 :
	T extends "encodings.cp860" ? typeof encodings.cp860 :
	T extends "encodings.cp861" ? typeof encodings.cp861 :
	T extends "encodings.cp862" ? typeof encodings.cp862 :
	T extends "encodings.cp863" ? typeof encodings.cp863 :
	T extends "encodings.cp864" ? typeof encodings.cp864 :
	T extends "encodings.cp865" ? typeof encodings.cp865 :
	T extends "encodings.cp866" ? typeof encodings.cp866 :
	T extends "encodings.cp869" ? typeof encodings.cp869 :
	T extends "encodings.cp874" ? typeof encodings.cp874 :
	T extends "encodings.cp875" ? typeof encodings.cp875 :
	T extends "encodings.cp932" ? typeof encodings.cp932 :
	T extends "encodings.cp949" ? typeof encodings.cp949 :
	T extends "encodings.cp950" ? typeof encodings.cp950 :
	T extends "encodings.euc_jis_2004" ? typeof encodings.euc_jis_2004 :
	T extends "encodings.euc_jisx0213" ? typeof encodings.euc_jisx0213 :
	T extends "encodings.euc_jp" ? typeof encodings.euc_jp :
	T extends "encodings.euc_kr" ? typeof encodings.euc_kr :
	T extends "encodings.gb18030" ? typeof encodings.gb18030 :
	T extends "encodings.gb2312" ? typeof encodings.gb2312 :
	T extends "encodings.gbk" ? typeof encodings.gbk :
	T extends "encodings.hex_codec" ? typeof encodings.hex_codec :
	T extends "encodings.hp_roman8" ? typeof encodings.hp_roman8 :
	T extends "encodings.hz" ? typeof encodings.hz :
	T extends "encodings.idna" ? typeof encodings.idna :
	T extends "encodings.iso2022_jp" ? typeof encodings.iso2022_jp :
	T extends "encodings.iso2022_jp_1" ? typeof encodings.iso2022_jp_1 :
	T extends "encodings.iso2022_jp_2" ? typeof encodings.iso2022_jp_2 :
	T extends "encodings.iso2022_jp_2004" ? typeof encodings.iso2022_jp_2004 :
	T extends "encodings.iso2022_jp_3" ? typeof encodings.iso2022_jp_3 :
	T extends "encodings.iso2022_jp_ext" ? typeof encodings.iso2022_jp_ext :
	T extends "encodings.iso2022_kr" ? typeof encodings.iso2022_kr :
	T extends "encodings.iso8859_1" ? typeof encodings.iso8859_1 :
	T extends "encodings.iso8859_10" ? typeof encodings.iso8859_10 :
	T extends "encodings.iso8859_11" ? typeof encodings.iso8859_11 :
	T extends "encodings.iso8859_13" ? typeof encodings.iso8859_13 :
	T extends "encodings.iso8859_14" ? typeof encodings.iso8859_14 :
	T extends "encodings.iso8859_15" ? typeof encodings.iso8859_15 :
	T extends "encodings.iso8859_16" ? typeof encodings.iso8859_16 :
	T extends "encodings.iso8859_2" ? typeof encodings.iso8859_2 :
	T extends "encodings.iso8859_3" ? typeof encodings.iso8859_3 :
	T extends "encodings.iso8859_4" ? typeof encodings.iso8859_4 :
	T extends "encodings.iso8859_5" ? typeof encodings.iso8859_5 :
	T extends "encodings.iso8859_6" ? typeof encodings.iso8859_6 :
	T extends "encodings.iso8859_7" ? typeof encodings.iso8859_7 :
	T extends "encodings.iso8859_8" ? typeof encodings.iso8859_8 :
	T extends "encodings.iso8859_9" ? typeof encodings.iso8859_9 :
	T extends "encodings.johab" ? typeof encodings.johab :
	T extends "encodings.koi8_r" ? typeof encodings.koi8_r :
	T extends "encodings.koi8_t" ? typeof encodings.koi8_t :
	T extends "encodings.koi8_u" ? typeof encodings.koi8_u :
	T extends "encodings.kz1048" ? typeof encodings.kz1048 :
	T extends "encodings.latin_1" ? typeof encodings.latin_1 :
	T extends "encodings.mac_arabic" ? typeof encodings.mac_arabic :
	T extends "encodings.mac_croatian" ? typeof encodings.mac_croatian :
	T extends "encodings.mac_cyrillic" ? typeof encodings.mac_cyrillic :
	T extends "encodings.mac_farsi" ? typeof encodings.mac_farsi :
	T extends "encodings.mac_greek" ? typeof encodings.mac_greek :
	T extends "encodings.mac_iceland" ? typeof encodings.mac_iceland :
	T extends "encodings.mac_latin2" ? typeof encodings.mac_latin2 :
	T extends "encodings.mac_roman" ? typeof encodings.mac_roman :
	T extends "encodings.mac_romanian" ? typeof encodings.mac_romanian :
	T extends "encodings.mac_turkish" ? typeof encodings.mac_turkish :
	T extends "encodings.mbcs" ? typeof encodings.mbcs :
	T extends "encodings.oem" ? typeof encodings.oem :
	T extends "encodings.palmos" ? typeof encodings.palmos :
	T extends "encodings.ptcp154" ? typeof encodings.ptcp154 :
	T extends "encodings.punycode" ? typeof encodings.punycode :
	T extends "encodings.quopri_codec" ? typeof encodings.quopri_codec :
	T extends "encodings.raw_unicode_escape" ? typeof encodings.raw_unicode_escape :
	T extends "encodings.rot_13" ? typeof encodings.rot_13 :
	T extends "encodings.shift_jis" ? typeof encodings.shift_jis :
	T extends "encodings.shift_jis_2004" ? typeof encodings.shift_jis_2004 :
	T extends "encodings.shift_jisx0213" ? typeof encodings.shift_jisx0213 :
	T extends "encodings.tis_620" ? typeof encodings.tis_620 :
	T extends "encodings.undefined" ? typeof encodings.undefined :
	T extends "encodings.unicode_escape" ? typeof encodings.unicode_escape :
	T extends "encodings.utf_16" ? typeof encodings.utf_16 :
	T extends "encodings.utf_16_be" ? typeof encodings.utf_16_be :
	T extends "encodings.utf_16_le" ? typeof encodings.utf_16_le :
	T extends "encodings.utf_32" ? typeof encodings.utf_32 :
	T extends "encodings.utf_32_be" ? typeof encodings.utf_32_be :
	T extends "encodings.utf_32_le" ? typeof encodings.utf_32_le :
	T extends "encodings.utf_7" ? typeof encodings.utf_7 :
	T extends "encodings.utf_8" ? typeof encodings.utf_8 :
	T extends "encodings.utf_8_sig" ? typeof encodings.utf_8_sig :
	T extends "encodings.uu_codec" ? typeof encodings.uu_codec :
	T extends "encodings.zlib_codec" ? typeof encodings.zlib_codec :
	T extends "ensurepip._uninstall" ? typeof ensurepip._uninstall :
	T extends "enum" ? typeof enum :
	T extends "filecmp" ? typeof filecmp :
	T extends "fileinput" ? typeof fileinput :
	T extends "fnmatch" ? typeof fnmatch :
	T extends "fractions" ? typeof fractions :
	T extends "ftplib" ? typeof ftplib :
	T extends "functools" ? typeof functools :
	T extends "genericpath" ? typeof genericpath :
	T extends "getopt" ? typeof getopt :
	T extends "getpass" ? typeof getpass :
	T extends "gettext" ? typeof gettext :
	T extends "glob" ? typeof glob :
	T extends "graphlib" ? typeof graphlib :
	T extends "gzip" ? typeof gzip :
	T extends "hashlib" ? typeof hashlib :
	T extends "heapq" ? typeof heapq :
	T extends "hmac" ? typeof hmac :
	T extends "html.entities" ? typeof html.entities :
	T extends "html.parser" ? typeof html.parser :
	T extends "http.client" ? typeof http.client :
	T extends "http.cookiejar" ? typeof http.cookiejar :
	T extends "http.cookies" ? typeof http.cookies :
	T extends "http.server" ? typeof http.server :
	T extends "idlelib.autocomplete" ? typeof idlelib.autocomplete :
	T extends "idlelib.autocomplete_w" ? typeof idlelib.autocomplete_w :
	T extends "idlelib.autoexpand" ? typeof idlelib.autoexpand :
	T extends "idlelib.browser" ? typeof idlelib.browser :
	T extends "idlelib.calltip" ? typeof idlelib.calltip :
	T extends "idlelib.calltip_w" ? typeof idlelib.calltip_w :
	T extends "idlelib.codecontext" ? typeof idlelib.codecontext :
	T extends "idlelib.colorizer" ? typeof idlelib.colorizer :
	T extends "idlelib.config" ? typeof idlelib.config :
	T extends "idlelib.config_key" ? typeof idlelib.config_key :
	T extends "idlelib.configdialog" ? typeof idlelib.configdialog :
	T extends "idlelib.debugger" ? typeof idlelib.debugger :
	T extends "idlelib.debugger_r" ? typeof idlelib.debugger_r :
	T extends "idlelib.debugobj" ? typeof idlelib.debugobj :
	T extends "idlelib.debugobj_r" ? typeof idlelib.debugobj_r :
	T extends "idlelib.delegator" ? typeof idlelib.delegator :
	T extends "idlelib.dynoption" ? typeof idlelib.dynoption :
	T extends "idlelib.editor" ? typeof idlelib.editor :
	T extends "idlelib.filelist" ? typeof idlelib.filelist :
	T extends "idlelib.format" ? typeof idlelib.format :
	T extends "idlelib.grep" ? typeof idlelib.grep :
	T extends "idlelib.help" ? typeof idlelib.help :
	T extends "idlelib.help_about" ? typeof idlelib.help_about :
	T extends "idlelib.history" ? typeof idlelib.history :
	T extends "idlelib.hyperparser" ? typeof idlelib.hyperparser :
	T extends "idlelib.idle" ? typeof idlelib.idle :
	T extends "idlelib.iomenu" ? typeof idlelib.iomenu :
	T extends "idlelib.macosx" ? typeof idlelib.macosx :
	T extends "idlelib.mainmenu" ? typeof idlelib.mainmenu :
	T extends "idlelib.multicall" ? typeof idlelib.multicall :
	T extends "idlelib.outwin" ? typeof idlelib.outwin :
	T extends "idlelib.parenmatch" ? typeof idlelib.parenmatch :
	T extends "idlelib.pathbrowser" ? typeof idlelib.pathbrowser :
	T extends "idlelib.percolator" ? typeof idlelib.percolator :
	T extends "idlelib.pyparse" ? typeof idlelib.pyparse :
	T extends "idlelib.pyshell" ? typeof idlelib.pyshell :
	T extends "idlelib.query" ? typeof idlelib.query :
	T extends "idlelib.redirector" ? typeof idlelib.redirector :
	T extends "idlelib.replace" ? typeof idlelib.replace :
	T extends "idlelib.rpc" ? typeof idlelib.rpc :
	T extends "idlelib.run" ? typeof idlelib.run :
	T extends "idlelib.runscript" ? typeof idlelib.runscript :
	T extends "idlelib.scrolledlist" ? typeof idlelib.scrolledlist :
	T extends "idlelib.search" ? typeof idlelib.search :
	T extends "idlelib.searchbase" ? typeof idlelib.searchbase :
	T extends "idlelib.searchengine" ? typeof idlelib.searchengine :
	T extends "idlelib.sidebar" ? typeof idlelib.sidebar :
	T extends "idlelib.squeezer" ? typeof idlelib.squeezer :
	T extends "idlelib.stackviewer" ? typeof idlelib.stackviewer :
	T extends "idlelib.statusbar" ? typeof idlelib.statusbar :
	T extends "idlelib.textview" ? typeof idlelib.textview :
	T extends "idlelib.tooltip" ? typeof idlelib.tooltip :
	T extends "idlelib.tree" ? typeof idlelib.tree :
	T extends "idlelib.undo" ? typeof idlelib.undo :
	T extends "idlelib.window" ? typeof idlelib.window :
	T extends "idlelib.zoomheight" ? typeof idlelib.zoomheight :
	T extends "idlelib.zzdummy" ? typeof idlelib.zzdummy :
	T extends "imaplib" ? typeof imaplib :
	T extends "imghdr" ? typeof imghdr :
	T extends "imp" ? typeof imp :
	T extends "importlib._abc" ? typeof importlib._abc :
	T extends "importlib._adapters" ? typeof importlib._adapters :
	T extends "importlib._bootstrap" ? typeof importlib._bootstrap :
	T extends "importlib._bootstrap_external" ? typeof importlib._bootstrap_external :
	T extends "importlib._common" ? typeof importlib._common :
	T extends "importlib.abc" ? typeof importlib.abc :
	T extends "importlib.machinery" ? typeof importlib.machinery :
	T extends "importlib.metadata._adapters" ? typeof importlib.metadata._adapters :
	T extends "importlib.metadata._collections" ? typeof importlib.metadata._collections :
	T extends "importlib.metadata._functools" ? typeof importlib.metadata._functools :
	T extends "importlib.metadata._itertools" ? typeof importlib.metadata._itertools :
	T extends "importlib.metadata._meta" ? typeof importlib.metadata._meta :
	T extends "importlib.metadata._text" ? typeof importlib.metadata._text :
	T extends "importlib.readers" ? typeof importlib.readers :
	T extends "importlib.resources" ? typeof importlib.resources :
	T extends "importlib.util" ? typeof importlib.util :
	T extends "inspect" ? typeof inspect :
	T extends "io" ? typeof io :
	T extends "ipaddress" ? typeof ipaddress :
	T extends "json.decoder" ? typeof json.decoder :
	T extends "json.encoder" ? typeof json.encoder :
	T extends "json.scanner" ? typeof json.scanner :
	T extends "json.tool" ? typeof json.tool :
	T extends "keyword" ? typeof keyword :
	T extends "lib2to3.btm_matcher" ? typeof lib2to3.btm_matcher :
	T extends "lib2to3.btm_utils" ? typeof lib2to3.btm_utils :
	T extends "lib2to3.fixer_base" ? typeof lib2to3.fixer_base :
	T extends "lib2to3.fixer_util" ? typeof lib2to3.fixer_util :
	T extends "lib2to3.fixes.fix_apply" ? typeof lib2to3.fixes.fix_apply :
	T extends "lib2to3.fixes.fix_asserts" ? typeof lib2to3.fixes.fix_asserts :
	T extends "lib2to3.fixes.fix_basestring" ? typeof lib2to3.fixes.fix_basestring :
	T extends "lib2to3.fixes.fix_buffer" ? typeof lib2to3.fixes.fix_buffer :
	T extends "lib2to3.fixes.fix_dict" ? typeof lib2to3.fixes.fix_dict :
	T extends "lib2to3.fixes.fix_except" ? typeof lib2to3.fixes.fix_except :
	T extends "lib2to3.fixes.fix_exec" ? typeof lib2to3.fixes.fix_exec :
	T extends "lib2to3.fixes.fix_execfile" ? typeof lib2to3.fixes.fix_execfile :
	T extends "lib2to3.fixes.fix_exitfunc" ? typeof lib2to3.fixes.fix_exitfunc :
	T extends "lib2to3.fixes.fix_filter" ? typeof lib2to3.fixes.fix_filter :
	T extends "lib2to3.fixes.fix_funcattrs" ? typeof lib2to3.fixes.fix_funcattrs :
	T extends "lib2to3.fixes.fix_future" ? typeof lib2to3.fixes.fix_future :
	T extends "lib2to3.fixes.fix_getcwdu" ? typeof lib2to3.fixes.fix_getcwdu :
	T extends "lib2to3.fixes.fix_has_key" ? typeof lib2to3.fixes.fix_has_key :
	T extends "lib2to3.fixes.fix_idioms" ? typeof lib2to3.fixes.fix_idioms :
	T extends "lib2to3.fixes.fix_import" ? typeof lib2to3.fixes.fix_import :
	T extends "lib2to3.fixes.fix_imports" ? typeof lib2to3.fixes.fix_imports :
	T extends "lib2to3.fixes.fix_imports2" ? typeof lib2to3.fixes.fix_imports2 :
	T extends "lib2to3.fixes.fix_input" ? typeof lib2to3.fixes.fix_input :
	T extends "lib2to3.fixes.fix_intern" ? typeof lib2to3.fixes.fix_intern :
	T extends "lib2to3.fixes.fix_isinstance" ? typeof lib2to3.fixes.fix_isinstance :
	T extends "lib2to3.fixes.fix_itertools" ? typeof lib2to3.fixes.fix_itertools :
	T extends "lib2to3.fixes.fix_itertools_imports" ? typeof lib2to3.fixes.fix_itertools_imports :
	T extends "lib2to3.fixes.fix_long" ? typeof lib2to3.fixes.fix_long :
	T extends "lib2to3.fixes.fix_map" ? typeof lib2to3.fixes.fix_map :
	T extends "lib2to3.fixes.fix_metaclass" ? typeof lib2to3.fixes.fix_metaclass :
	T extends "lib2to3.fixes.fix_methodattrs" ? typeof lib2to3.fixes.fix_methodattrs :
	T extends "lib2to3.fixes.fix_ne" ? typeof lib2to3.fixes.fix_ne :
	T extends "lib2to3.fixes.fix_next" ? typeof lib2to3.fixes.fix_next :
	T extends "lib2to3.fixes.fix_nonzero" ? typeof lib2to3.fixes.fix_nonzero :
	T extends "lib2to3.fixes.fix_numliterals" ? typeof lib2to3.fixes.fix_numliterals :
	T extends "lib2to3.fixes.fix_operator" ? typeof lib2to3.fixes.fix_operator :
	T extends "lib2to3.fixes.fix_paren" ? typeof lib2to3.fixes.fix_paren :
	T extends "lib2to3.fixes.fix_print" ? typeof lib2to3.fixes.fix_print :
	T extends "lib2to3.fixes.fix_raise" ? typeof lib2to3.fixes.fix_raise :
	T extends "lib2to3.fixes.fix_raw_input" ? typeof lib2to3.fixes.fix_raw_input :
	T extends "lib2to3.fixes.fix_reduce" ? typeof lib2to3.fixes.fix_reduce :
	T extends "lib2to3.fixes.fix_reload" ? typeof lib2to3.fixes.fix_reload :
	T extends "lib2to3.fixes.fix_renames" ? typeof lib2to3.fixes.fix_renames :
	T extends "lib2to3.fixes.fix_repr" ? typeof lib2to3.fixes.fix_repr :
	T extends "lib2to3.fixes.fix_set_literal" ? typeof lib2to3.fixes.fix_set_literal :
	T extends "lib2to3.fixes.fix_standarderror" ? typeof lib2to3.fixes.fix_standarderror :
	T extends "lib2to3.fixes.fix_sys_exc" ? typeof lib2to3.fixes.fix_sys_exc :
	T extends "lib2to3.fixes.fix_throw" ? typeof lib2to3.fixes.fix_throw :
	T extends "lib2to3.fixes.fix_tuple_params" ? typeof lib2to3.fixes.fix_tuple_params :
	T extends "lib2to3.fixes.fix_types" ? typeof lib2to3.fixes.fix_types :
	T extends "lib2to3.fixes.fix_unicode" ? typeof lib2to3.fixes.fix_unicode :
	T extends "lib2to3.fixes.fix_urllib" ? typeof lib2to3.fixes.fix_urllib :
	T extends "lib2to3.fixes.fix_ws_comma" ? typeof lib2to3.fixes.fix_ws_comma :
	T extends "lib2to3.fixes.fix_xrange" ? typeof lib2to3.fixes.fix_xrange :
	T extends "lib2to3.fixes.fix_xreadlines" ? typeof lib2to3.fixes.fix_xreadlines :
	T extends "lib2to3.fixes.fix_zip" ? typeof lib2to3.fixes.fix_zip :
	T extends "lib2to3.main" ? typeof lib2to3.main :
	T extends "lib2to3.patcomp" ? typeof lib2to3.patcomp :
	T extends "lib2to3.pgen2.conv" ? typeof lib2to3.pgen2.conv :
	T extends "lib2to3.pgen2.driver" ? typeof lib2to3.pgen2.driver :
	T extends "lib2to3.pgen2.grammar" ? typeof lib2to3.pgen2.grammar :
	T extends "lib2to3.pgen2.literals" ? typeof lib2to3.pgen2.literals :
	T extends "lib2to3.pgen2.parse" ? typeof lib2to3.pgen2.parse :
	T extends "lib2to3.pgen2.pgen" ? typeof lib2to3.pgen2.pgen :
	T extends "lib2to3.pgen2.token" ? typeof lib2to3.pgen2.token :
	T extends "lib2to3.pgen2.tokenize" ? typeof lib2to3.pgen2.tokenize :
	T extends "lib2to3.pygram" ? typeof lib2to3.pygram :
	T extends "lib2to3.pytree" ? typeof lib2to3.pytree :
	T extends "lib2to3.refactor" ? typeof lib2to3.refactor :
	T extends "linecache" ? typeof linecache :
	T extends "locale" ? typeof locale :
	T extends "logging.config" ? typeof logging.config :
	T extends "logging.handlers" ? typeof logging.handlers :
	T extends "lzma" ? typeof lzma :
	T extends "mailbox" ? typeof mailbox :
	T extends "mailcap" ? typeof mailcap :
	T extends "mimetypes" ? typeof mimetypes :
	T extends "modulefinder" ? typeof modulefinder :
	T extends "msilib.schema" ? typeof msilib.schema :
	T extends "msilib.sequence" ? typeof msilib.sequence :
	T extends "msilib.text" ? typeof msilib.text :
	T extends "multiprocessing.connection" ? typeof multiprocessing.connection :
	T extends "multiprocessing.context" ? typeof multiprocessing.context :
	T extends "multiprocessing.dummy.connection" ? typeof multiprocessing.dummy.connection :
	T extends "multiprocessing.forkserver" ? typeof multiprocessing.forkserver :
	T extends "multiprocessing.heap" ? typeof multiprocessing.heap :
	T extends "multiprocessing.managers" ? typeof multiprocessing.managers :
	T extends "multiprocessing.pool" ? typeof multiprocessing.pool :
	T extends "multiprocessing.popen_fork" ? typeof multiprocessing.popen_fork :
	T extends "multiprocessing.popen_forkserver" ? typeof multiprocessing.popen_forkserver :
	T extends "multiprocessing.popen_spawn_posix" ? typeof multiprocessing.popen_spawn_posix :
	T extends "multiprocessing.popen_spawn_win32" ? typeof multiprocessing.popen_spawn_win32 :
	T extends "multiprocessing.process" ? typeof multiprocessing.process :
	T extends "multiprocessing.queues" ? typeof multiprocessing.queues :
	T extends "multiprocessing.reduction" ? typeof multiprocessing.reduction :
	T extends "multiprocessing.resource_sharer" ? typeof multiprocessing.resource_sharer :
	T extends "multiprocessing.resource_tracker" ? typeof multiprocessing.resource_tracker :
	T extends "multiprocessing.shared_memory" ? typeof multiprocessing.shared_memory :
	T extends "multiprocessing.sharedctypes" ? typeof multiprocessing.sharedctypes :
	T extends "multiprocessing.spawn" ? typeof multiprocessing.spawn :
	T extends "multiprocessing.synchronize" ? typeof multiprocessing.synchronize :
	T extends "multiprocessing.util" ? typeof multiprocessing.util :
	T extends "netrc" ? typeof netrc :
	T extends "nntplib" ? typeof nntplib :
	T extends "ntpath" ? typeof ntpath :
	T extends "nturl2path" ? typeof nturl2path :
	T extends "numbers" ? typeof numbers :
	T extends "opcode" ? typeof opcode :
	T extends "operator" ? typeof operator :
	T extends "optparse" ? typeof optparse :
	T extends "os" ? typeof os :
	T extends "pathlib" ? typeof pathlib :
	T extends "pdb" ? typeof pdb :
	T extends "pickle" ? typeof pickle :
	T extends "pickletools" ? typeof pickletools :
	T extends "pipes" ? typeof pipes :
	T extends "pkgutil" ? typeof pkgutil :
	T extends "platform" ? typeof platform :
	T extends "plistlib" ? typeof plistlib :
	T extends "poplib" ? typeof poplib :
	T extends "posixpath" ? typeof posixpath :
	T extends "pprint" ? typeof pprint :
	T extends "profile" ? typeof profile :
	T extends "pstats" ? typeof pstats :
	T extends "pty" ? typeof pty :
	T extends "py_compile" ? typeof py_compile :
	T extends "pyclbr" ? typeof pyclbr :
	T extends "pydoc" ? typeof pydoc :
	T extends "pydoc_data.topics" ? typeof pydoc_data.topics :
	T extends "queue" ? typeof queue :
	T extends "quopri" ? typeof quopri :
	T extends "random" ? typeof random :
	T extends "re" ? typeof re :
	T extends "reprlib" ? typeof reprlib :
	T extends "rlcompleter" ? typeof rlcompleter :
	T extends "runpy" ? typeof runpy :
	T extends "sched" ? typeof sched :
	T extends "secrets" ? typeof secrets :
	T extends "selectors" ? typeof selectors :
	T extends "shelve" ? typeof shelve :
	T extends "shlex" ? typeof shlex :
	T extends "shutil" ? typeof shutil :
	T extends "signal" ? typeof signal :
	T extends "site" ? typeof site :
	T extends "smtpd" ? typeof smtpd :
	T extends "smtplib" ? typeof smtplib :
	T extends "sndhdr" ? typeof sndhdr :
	T extends "socket" ? typeof socket :
	T extends "socketserver" ? typeof socketserver :
	T extends "sqlite3.dbapi2" ? typeof sqlite3.dbapi2 :
	T extends "sqlite3.dump" ? typeof sqlite3.dump :
	T extends "sre_compile" ? typeof sre_compile :
	T extends "sre_constants" ? typeof sre_constants :
	T extends "sre_parse" ? typeof sre_parse :
	T extends "ssl" ? typeof ssl :
	T extends "stat" ? typeof stat :
	T extends "statistics" ? typeof statistics :
	T extends "string" ? typeof string :
	T extends "stringprep" ? typeof stringprep :
	T extends "struct" ? typeof struct :
	T extends "subprocess" ? typeof subprocess :
	T extends "sunau" ? typeof sunau :
	T extends "symtable" ? typeof symtable :
	T extends "sysconfig" ? typeof sysconfig :
	T extends "tabnanny" ? typeof tabnanny :
	T extends "tarfile" ? typeof tarfile :
	T extends "telnetlib" ? typeof telnetlib :
	T extends "tempfile" ? typeof tempfile :
	T extends "textwrap" ? typeof textwrap :
	T extends "this" ? typeof this :
	T extends "threading" ? typeof threading :
	T extends "timeit" ? typeof timeit :
	T extends "tkinter.colorchooser" ? typeof tkinter.colorchooser :
	T extends "tkinter.commondialog" ? typeof tkinter.commondialog :
	T extends "tkinter.constants" ? typeof tkinter.constants :
	T extends "tkinter.dialog" ? typeof tkinter.dialog :
	T extends "tkinter.dnd" ? typeof tkinter.dnd :
	T extends "tkinter.filedialog" ? typeof tkinter.filedialog :
	T extends "tkinter.font" ? typeof tkinter.font :
	T extends "tkinter.messagebox" ? typeof tkinter.messagebox :
	T extends "tkinter.scrolledtext" ? typeof tkinter.scrolledtext :
	T extends "tkinter.simpledialog" ? typeof tkinter.simpledialog :
	T extends "tkinter.tix" ? typeof tkinter.tix :
	T extends "tkinter.ttk" ? typeof tkinter.ttk :
	T extends "token" ? typeof token :
	T extends "tokenize" ? typeof tokenize :
	T extends "trace" ? typeof trace :
	T extends "traceback" ? typeof traceback :
	T extends "tracemalloc" ? typeof tracemalloc :
	T extends "tty" ? typeof tty :
	T extends "turtle" ? typeof turtle :
	T extends "turtledemo.bytedesign" ? typeof turtledemo.bytedesign :
	T extends "turtledemo.chaos" ? typeof turtledemo.chaos :
	T extends "turtledemo.clock" ? typeof turtledemo.clock :
	T extends "turtledemo.colormixer" ? typeof turtledemo.colormixer :
	T extends "turtledemo.forest" ? typeof turtledemo.forest :
	T extends "turtledemo.fractalcurves" ? typeof turtledemo.fractalcurves :
	T extends "turtledemo.lindenmayer" ? typeof turtledemo.lindenmayer :
	T extends "turtledemo.minimal_hanoi" ? typeof turtledemo.minimal_hanoi :
	T extends "turtledemo.nim" ? typeof turtledemo.nim :
	T extends "turtledemo.paint" ? typeof turtledemo.paint :
	T extends "turtledemo.peace" ? typeof turtledemo.peace :
	T extends "turtledemo.penrose" ? typeof turtledemo.penrose :
	T extends "turtledemo.planet_and_moon" ? typeof turtledemo.planet_and_moon :
	T extends "turtledemo.rosette" ? typeof turtledemo.rosette :
	T extends "turtledemo.round_dance" ? typeof turtledemo.round_dance :
	T extends "turtledemo.sorting_animate" ? typeof turtledemo.sorting_animate :
	T extends "turtledemo.tree" ? typeof turtledemo.tree :
	T extends "turtledemo.two_canvases" ? typeof turtledemo.two_canvases :
	T extends "turtledemo.yinyang" ? typeof turtledemo.yinyang :
	T extends "types" ? typeof types :
	T extends "typing" ? typeof typing :
	T extends "urllib.error" ? typeof urllib.error :
	T extends "urllib.parse" ? typeof urllib.parse :
	T extends "urllib.request" ? typeof urllib.request :
	T extends "urllib.response" ? typeof urllib.response :
	T extends "urllib.robotparser" ? typeof urllib.robotparser :
	T extends "uu" ? typeof uu :
	T extends "uuid" ? typeof uuid :
	T extends "warnings" ? typeof warnings :
	T extends "wave" ? typeof wave :
	T extends "weakref" ? typeof weakref :
	T extends "webbrowser" ? typeof webbrowser :
	T extends "wsgiref.handlers" ? typeof wsgiref.handlers :
	T extends "wsgiref.headers" ? typeof wsgiref.headers :
	T extends "wsgiref.simple_server" ? typeof wsgiref.simple_server :
	T extends "wsgiref.util" ? typeof wsgiref.util :
	T extends "wsgiref.validate" ? typeof wsgiref.validate :
	T extends "xdrlib" ? typeof xdrlib :
	T extends "xml.dom.NodeFilter" ? typeof xml.dom.NodeFilter :
	T extends "xml.dom.domreg" ? typeof xml.dom.domreg :
	T extends "xml.dom.expatbuilder" ? typeof xml.dom.expatbuilder :
	T extends "xml.dom.minicompat" ? typeof xml.dom.minicompat :
	T extends "xml.dom.minidom" ? typeof xml.dom.minidom :
	T extends "xml.dom.pulldom" ? typeof xml.dom.pulldom :
	T extends "xml.dom.xmlbuilder" ? typeof xml.dom.xmlbuilder :
	T extends "xml.etree.ElementInclude" ? typeof xml.etree.ElementInclude :
	T extends "xml.etree.ElementPath" ? typeof xml.etree.ElementPath :
	T extends "xml.etree.ElementTree" ? typeof xml.etree.ElementTree :
	T extends "xml.etree.cElementTree" ? typeof xml.etree.cElementTree :
	T extends "xml.parsers.expat" ? typeof xml.parsers.expat :
	T extends "xml.sax._exceptions" ? typeof xml.sax._exceptions :
	T extends "xml.sax.expatreader" ? typeof xml.sax.expatreader :
	T extends "xml.sax.handler" ? typeof xml.sax.handler :
	T extends "xml.sax.saxutils" ? typeof xml.sax.saxutils :
	T extends "xml.sax.xmlreader" ? typeof xml.sax.xmlreader :
	T extends "xmlrpc.client" ? typeof xmlrpc.client :
	T extends "xmlrpc.server" ? typeof xmlrpc.server :
	T extends "zipapp" ? typeof zipapp :
	T extends "zipfile" ? typeof zipfile :
	T extends "zipimport" ? typeof zipimport :
	T extends "zoneinfo._common" ? typeof zoneinfo._common :
	T extends "zoneinfo._tzpath" ? typeof zoneinfo._tzpath :
	T extends "zoneinfo._zoneinfo" ? typeof zoneinfo._zoneinfo :
	T extends "asyncio" ? typeof asyncio :
	T extends "ctypes" ? typeof ctypes :
	T extends "dbm" ? typeof dbm :
	T extends "ensurepip" ? typeof ensurepip :
	T extends "json" ? typeof json :
	T extends "logging" ? typeof logging :
	T extends "sqlite3" ? typeof sqlite3 :
	T extends "tkinter" ? typeof tkinter : object;
type PyTypeName =
	"abc" | "aifc" | "antigravity" | "argparse" | "ast" | "asynchat" | "asyncio.base_events" | "asyncio.base_futures" | "asyncio.base_subprocess" | "asyncio.base_tasks" | "asyncio.constants" | "asyncio.coroutines" | "asyncio.events" | "asyncio.exceptions" | "asyncio.format_helpers" | "asyncio.futures" | "asyncio.locks" | "asyncio.log" | "asyncio.mixins" | "asyncio.proactor_events" | "asyncio.protocols" | "asyncio.queues" | "asyncio.runners" | "asyncio.selector_events" | "asyncio.sslproto" | "asyncio.staggered" | "asyncio.streams" | "asyncio.subprocess" | "asyncio.tasks" | "asyncio.threads" | "asyncio.transports" | "asyncio.trsock" | "asyncio.unix_events" | "asyncio.windows_events" | "asyncio.windows_utils" | "asyncore" | "base64" | "bdb" | "binhex" | "bisect" | "bz2" | "cProfile" | "calendar" | "cgi" | "cgitb" | "chunk" | "cmd" | "code" | "codecs" | "codeop" | "collections.abc" | "colorsys" | "compileall" | "concurrent.futures._base" | "concurrent.futures.process" | "concurrent.futures.thread" | "configparser" | "contextlib" | "contextvars" | "copy" | "copyreg" | "crypt" | "csv" | "ctypes._aix" | "ctypes._endian" | "ctypes.macholib.dyld" | "ctypes.macholib.dylib" | "ctypes.macholib.framework" | "ctypes.util" | "ctypes.wintypes" | "curses.ascii" | "curses.has_key" | "curses.panel" | "curses.textpad" | "dataclasses" | "datetime" | "dbm.dumb" | "dbm.gnu" | "dbm.ndbm" | "decimal" | "difflib" | "dis" | "distutils._msvccompiler" | "distutils.archive_util" | "distutils.bcppcompiler" | "distutils.ccompiler" | "distutils.cmd" | "distutils.command.bdist" | "distutils.command.bdist_dumb" | "distutils.command.bdist_msi" | "distutils.command.bdist_rpm" | "distutils.command.build" | "distutils.command.build_clib" | "distutils.command.build_ext" | "distutils.command.build_py" | "distutils.command.build_scripts" | "distutils.command.check" | "distutils.command.clean" | "distutils.command.config" | "distutils.command.install" | "distutils.command.install_data" | "distutils.command.install_egg_info" | "distutils.command.install_headers" | "distutils.command.install_lib" | "distutils.command.install_scripts" | "distutils.command.register" | "distutils.command.sdist" | "distutils.command.upload" | "distutils.config" | "distutils.core" | "distutils.cygwinccompiler" | "distutils.debug" | "distutils.dep_util" | "distutils.dir_util" | "distutils.dist" | "distutils.errors" | "distutils.extension" | "distutils.fancy_getopt" | "distutils.file_util" | "distutils.filelist" | "distutils.log" | "distutils.msvc9compiler" | "distutils.msvccompiler" | "distutils.spawn" | "distutils.sysconfig" | "distutils.text_file" | "distutils.unixccompiler" | "distutils.util" | "distutils.version" | "distutils.versionpredicate" | "email._encoded_words" | "email._header_value_parser" | "email._parseaddr" | "email._policybase" | "email.base64mime" | "email.charset" | "email.contentmanager" | "email.encoders" | "email.errors" | "email.feedparser" | "email.generator" | "email.header" | "email.headerregistry" | "email.iterators" | "email.message" | "email.mime.application" | "email.mime.audio" | "email.mime.base" | "email.mime.image" | "email.mime.message" | "email.mime.multipart" | "email.mime.nonmultipart" | "email.mime.text" | "email.parser" | "email.policy" | "email.quoprimime" | "email.utils" | "encodings.aliases" | "encodings.ascii" | "encodings.base64_codec" | "encodings.big5" | "encodings.big5hkscs" | "encodings.bz2_codec" | "encodings.charmap" | "encodings.cp037" | "encodings.cp1006" | "encodings.cp1026" | "encodings.cp1125" | "encodings.cp1140" | "encodings.cp1250" | "encodings.cp1251" | "encodings.cp1252" | "encodings.cp1253" | "encodings.cp1254" | "encodings.cp1255" | "encodings.cp1256" | "encodings.cp1257" | "encodings.cp1258" | "encodings.cp273" | "encodings.cp424" | "encodings.cp437" | "encodings.cp500" | "encodings.cp720" | "encodings.cp737" | "encodings.cp775" | "encodings.cp850" | "encodings.cp852" | "encodings.cp855" | "encodings.cp856" | "encodings.cp857" | "encodings.cp858" | "encodings.cp860" | "encodings.cp861" | "encodings.cp862" | "encodings.cp863" | "encodings.cp864" | "encodings.cp865" | "encodings.cp866" | "encodings.cp869" | "encodings.cp874" | "encodings.cp875" | "encodings.cp932" | "encodings.cp949" | "encodings.cp950" | "encodings.euc_jis_2004" | "encodings.euc_jisx0213" | "encodings.euc_jp" | "encodings.euc_kr" | "encodings.gb18030" | "encodings.gb2312" | "encodings.gbk" | "encodings.hex_codec" | "encodings.hp_roman8" | "encodings.hz" | "encodings.idna" | "encodings.iso2022_jp" | "encodings.iso2022_jp_1" | "encodings.iso2022_jp_2" | "encodings.iso2022_jp_2004" | "encodings.iso2022_jp_3" | "encodings.iso2022_jp_ext" | "encodings.iso2022_kr" | "encodings.iso8859_1" | "encodings.iso8859_10" | "encodings.iso8859_11" | "encodings.iso8859_13" | "encodings.iso8859_14" | "encodings.iso8859_15" | "encodings.iso8859_16" | "encodings.iso8859_2" | "encodings.iso8859_3" | "encodings.iso8859_4" | "encodings.iso8859_5" | "encodings.iso8859_6" | "encodings.iso8859_7" | "encodings.iso8859_8" | "encodings.iso8859_9" | "encodings.johab" | "encodings.koi8_r" | "encodings.koi8_t" | "encodings.koi8_u" | "encodings.kz1048" | "encodings.latin_1" | "encodings.mac_arabic" | "encodings.mac_croatian" | "encodings.mac_cyrillic" | "encodings.mac_farsi" | "encodings.mac_greek" | "encodings.mac_iceland" | "encodings.mac_latin2" | "encodings.mac_roman" | "encodings.mac_romanian" | "encodings.mac_turkish" | "encodings.mbcs" | "encodings.oem" | "encodings.palmos" | "encodings.ptcp154" | "encodings.punycode" | "encodings.quopri_codec" | "encodings.raw_unicode_escape" | "encodings.rot_13" | "encodings.shift_jis" | "encodings.shift_jis_2004" | "encodings.shift_jisx0213" | "encodings.tis_620" | "encodings.undefined" | "encodings.unicode_escape" | "encodings.utf_16" | "encodings.utf_16_be" | "encodings.utf_16_le" | "encodings.utf_32" | "encodings.utf_32_be" | "encodings.utf_32_le" | "encodings.utf_7" | "encodings.utf_8" | "encodings.utf_8_sig" | "encodings.uu_codec" | "encodings.zlib_codec" | "ensurepip._uninstall" | "enum" | "filecmp" | "fileinput" | "fnmatch" | "fractions" | "ftplib" | "functools" | "genericpath" | "getopt" | "getpass" | "gettext" | "glob" | "graphlib" | "gzip" | "hashlib" | "heapq" | "hmac" | "html.entities" | "html.parser" | "http.client" | "http.cookiejar" | "http.cookies" | "http.server" | "idlelib.autocomplete" | "idlelib.autocomplete_w" | "idlelib.autoexpand" | "idlelib.browser" | "idlelib.calltip" | "idlelib.calltip_w" | "idlelib.codecontext" | "idlelib.colorizer" | "idlelib.config" | "idlelib.config_key" | "idlelib.configdialog" | "idlelib.debugger" | "idlelib.debugger_r" | "idlelib.debugobj" | "idlelib.debugobj_r" | "idlelib.delegator" | "idlelib.dynoption" | "idlelib.editor" | "idlelib.filelist" | "idlelib.format" | "idlelib.grep" | "idlelib.help" | "idlelib.help_about" | "idlelib.history" | "idlelib.hyperparser" | "idlelib.idle" | "idlelib.iomenu" | "idlelib.macosx" | "idlelib.mainmenu" | "idlelib.multicall" | "idlelib.outwin" | "idlelib.parenmatch" | "idlelib.pathbrowser" | "idlelib.percolator" | "idlelib.pyparse" | "idlelib.pyshell" | "idlelib.query" | "idlelib.redirector" | "idlelib.replace" | "idlelib.rpc" | "idlelib.run" | "idlelib.runscript" | "idlelib.scrolledlist" | "idlelib.search" | "idlelib.searchbase" | "idlelib.searchengine" | "idlelib.sidebar" | "idlelib.squeezer" | "idlelib.stackviewer" | "idlelib.statusbar" | "idlelib.textview" | "idlelib.tooltip" | "idlelib.tree" | "idlelib.undo" | "idlelib.window" | "idlelib.zoomheight" | "idlelib.zzdummy" | "imaplib" | "imghdr" | "imp" | "importlib._abc" | "importlib._adapters" | "importlib._bootstrap" | "importlib._bootstrap_external" | "importlib._common" | "importlib.abc" | "importlib.machinery" | "importlib.metadata._adapters" | "importlib.metadata._collections" | "importlib.metadata._functools" | "importlib.metadata._itertools" | "importlib.metadata._meta" | "importlib.metadata._text" | "importlib.readers" | "importlib.resources" | "importlib.util" | "inspect" | "io" | "ipaddress" | "json.decoder" | "json.encoder" | "json.scanner" | "json.tool" | "keyword" | "lib2to3.btm_matcher" | "lib2to3.btm_utils" | "lib2to3.fixer_base" | "lib2to3.fixer_util" | "lib2to3.fixes.fix_apply" | "lib2to3.fixes.fix_asserts" | "lib2to3.fixes.fix_basestring" | "lib2to3.fixes.fix_buffer" | "lib2to3.fixes.fix_dict" | "lib2to3.fixes.fix_except" | "lib2to3.fixes.fix_exec" | "lib2to3.fixes.fix_execfile" | "lib2to3.fixes.fix_exitfunc" | "lib2to3.fixes.fix_filter" | "lib2to3.fixes.fix_funcattrs" | "lib2to3.fixes.fix_future" | "lib2to3.fixes.fix_getcwdu" | "lib2to3.fixes.fix_has_key" | "lib2to3.fixes.fix_idioms" | "lib2to3.fixes.fix_import" | "lib2to3.fixes.fix_imports" | "lib2to3.fixes.fix_imports2" | "lib2to3.fixes.fix_input" | "lib2to3.fixes.fix_intern" | "lib2to3.fixes.fix_isinstance" | "lib2to3.fixes.fix_itertools" | "lib2to3.fixes.fix_itertools_imports" | "lib2to3.fixes.fix_long" | "lib2to3.fixes.fix_map" | "lib2to3.fixes.fix_metaclass" | "lib2to3.fixes.fix_methodattrs" | "lib2to3.fixes.fix_ne" | "lib2to3.fixes.fix_next" | "lib2to3.fixes.fix_nonzero" | "lib2to3.fixes.fix_numliterals" | "lib2to3.fixes.fix_operator" | "lib2to3.fixes.fix_paren" | "lib2to3.fixes.fix_print" | "lib2to3.fixes.fix_raise" | "lib2to3.fixes.fix_raw_input" | "lib2to3.fixes.fix_reduce" | "lib2to3.fixes.fix_reload" | "lib2to3.fixes.fix_renames" | "lib2to3.fixes.fix_repr" | "lib2to3.fixes.fix_set_literal" | "lib2to3.fixes.fix_standarderror" | "lib2to3.fixes.fix_sys_exc" | "lib2to3.fixes.fix_throw" | "lib2to3.fixes.fix_tuple_params" | "lib2to3.fixes.fix_types" | "lib2to3.fixes.fix_unicode" | "lib2to3.fixes.fix_urllib" | "lib2to3.fixes.fix_ws_comma" | "lib2to3.fixes.fix_xrange" | "lib2to3.fixes.fix_xreadlines" | "lib2to3.fixes.fix_zip" | "lib2to3.main" | "lib2to3.patcomp" | "lib2to3.pgen2.conv" | "lib2to3.pgen2.driver" | "lib2to3.pgen2.grammar" | "lib2to3.pgen2.literals" | "lib2to3.pgen2.parse" | "lib2to3.pgen2.pgen" | "lib2to3.pgen2.token" | "lib2to3.pgen2.tokenize" | "lib2to3.pygram" | "lib2to3.pytree" | "lib2to3.refactor" | "linecache" | "locale" | "logging.config" | "logging.handlers" | "lzma" | "mailbox" | "mailcap" | "mimetypes" | "modulefinder" | "msilib.schema" | "msilib.sequence" | "msilib.text" | "multiprocessing.connection" | "multiprocessing.context" | "multiprocessing.dummy.connection" | "multiprocessing.forkserver" | "multiprocessing.heap" | "multiprocessing.managers" | "multiprocessing.pool" | "multiprocessing.popen_fork" | "multiprocessing.popen_forkserver" | "multiprocessing.popen_spawn_posix" | "multiprocessing.popen_spawn_win32" | "multiprocessing.process" | "multiprocessing.queues" | "multiprocessing.reduction" | "multiprocessing.resource_sharer" | "multiprocessing.resource_tracker" | "multiprocessing.shared_memory" | "multiprocessing.sharedctypes" | "multiprocessing.spawn" | "multiprocessing.synchronize" | "multiprocessing.util" | "netrc" | "nntplib" | "ntpath" | "nturl2path" | "numbers" | "opcode" | "operator" | "optparse" | "os" | "pathlib" | "pdb" | "pickle" | "pickletools" | "pipes" | "pkgutil" | "platform" | "plistlib" | "poplib" | "posixpath" | "pprint" | "profile" | "pstats" | "pty" | "py_compile" | "pyclbr" | "pydoc" | "pydoc_data.topics" | "queue" | "quopri" | "random" | "re" | "reprlib" | "rlcompleter" | "runpy" | "sched" | "secrets" | "selectors" | "shelve" | "shlex" | "shutil" | "signal" | "site" | "smtpd" | "smtplib" | "sndhdr" | "socket" | "socketserver" | "sqlite3.dbapi2" | "sqlite3.dump" | "sre_compile" | "sre_constants" | "sre_parse" | "ssl" | "stat" | "statistics" | "string" | "stringprep" | "struct" | "subprocess" | "sunau" | "symtable" | "sysconfig" | "tabnanny" | "tarfile" | "telnetlib" | "tempfile" | "textwrap" | "this" | "threading" | "timeit" | "tkinter.colorchooser" | "tkinter.commondialog" | "tkinter.constants" | "tkinter.dialog" | "tkinter.dnd" | "tkinter.filedialog" | "tkinter.font" | "tkinter.messagebox" | "tkinter.scrolledtext" | "tkinter.simpledialog" | "tkinter.tix" | "tkinter.ttk" | "token" | "tokenize" | "trace" | "traceback" | "tracemalloc" | "tty" | "turtle" | "turtledemo.bytedesign" | "turtledemo.chaos" | "turtledemo.clock" | "turtledemo.colormixer" | "turtledemo.forest" | "turtledemo.fractalcurves" | "turtledemo.lindenmayer" | "turtledemo.minimal_hanoi" | "turtledemo.nim" | "turtledemo.paint" | "turtledemo.peace" | "turtledemo.penrose" | "turtledemo.planet_and_moon" | "turtledemo.rosette" | "turtledemo.round_dance" | "turtledemo.sorting_animate" | "turtledemo.tree" | "turtledemo.two_canvases" | "turtledemo.yinyang" | "types" | "typing" | "urllib.error" | "urllib.parse" | "urllib.request" | "urllib.response" | "urllib.robotparser" | "uu" | "uuid" | "warnings" | "wave" | "weakref" | "webbrowser" | "wsgiref.handlers" | "wsgiref.headers" | "wsgiref.simple_server" | "wsgiref.util" | "wsgiref.validate" | "xdrlib" | "xml.dom.NodeFilter" | "xml.dom.domreg" | "xml.dom.expatbuilder" | "xml.dom.minicompat" | "xml.dom.minidom" | "xml.dom.pulldom" | "xml.dom.xmlbuilder" | "xml.etree.ElementInclude" | "xml.etree.ElementPath" | "xml.etree.ElementTree" | "xml.etree.cElementTree" | "xml.parsers.expat" | "xml.sax._exceptions" | "xml.sax.expatreader" | "xml.sax.handler" | "xml.sax.saxutils" | "xml.sax.xmlreader" | "xmlrpc.client" | "xmlrpc.server" | "zipapp" | "zipfile" | "zipimport" | "zoneinfo._common" | "zoneinfo._tzpath" | "zoneinfo._zoneinfo" | "asyncio" | "ctypes" | "dbm" | "ensurepip" | "json" | "logging" | "sqlite3" | "tkinter";